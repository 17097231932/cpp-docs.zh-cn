---
title: 1.3 执行模型
ms.date: 11/04/2016
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
ms.openlocfilehash: 291bf71159cc681916d19649cfa12298d0929cc3
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/31/2018
ms.locfileid: "50491567"
---
# <a name="13-execution-model"></a>1.3 执行模型

OpenMP 利用并行执行的派生-联结模式。 尽管此 fork-join 模型可用于解决各种问题，但它一定程度上为基于数组的大型应用程序量身定制。 OpenMP 旨在将正确地同时按执行并行程序 （多个执行线程和完整的 OpenMP 支持库） 的支持计划并作为顺序化程序 （忽略指令和简单的 OpenMP 存根库）。 但是，它可能并允许开发程序无法正常使用时按顺序执行。 此外，不同程度的并行度可能会导致不同的数值结果由于中的数值操作关联的更改。 例如，串行添加减少可能有不同的模式的并行缩减比添加关联。 这些不同的关联可能会更改浮点加法的结果。

使用 OpenMP C/c + + API 编写的程序开始执行名为作为单个线程执行*主线程*。 在遇到第一个并行构造之前，主线程执行串行区域中。 在 OpenMP C/c + + API 中，**并行**指令构成并行构造。 当遇到并行构造时，主线程创建的线程，团队和主机成为主团队。 团队中的每个线程并行区域，除了工作共享构造的动态范围中执行的语句。 必须按相同顺序中，团队中的所有线程遇到工作共享构造和相关联的结构化块中的语句执行的一个或多个线程。 关卡末尾而无需的工作共享构造的隐式`nowait`子句执行由团队中的所有线程。

如果一个线程修改共享的对象，它会在其自己的执行环境，不仅在程序中的其他线程的影响。 修改保证可完成，从一个其他线程，在下一步的序列点的角度 （如定义的基本语言），仅当对象被声明为易失性。 否则，修改就可保证完成后第一次修改线程，然后 （或并发） 其他线程，会遇到**刷新**（隐式或显式） 指定的对象的指令。 请注意，当**刷新**隐含其他 OpenMP 指令的指令没有足够权限来确保所需顺序的负面影响，它是程序员的责任，以提供附加的显式**刷新**指令。

完成后的并行构造，团队中的线程同步在隐式的障碍，并仅在主线程继续执行。 可以在单一程序指定任意数量的并行构造。 因此，程序可能会创建分支并加入期间执行的很多时间。

OpenMP C/c + + API 使程序员可以使用并行构造中从调用的函数中的指令。 指令不会出现在并行构造的词法范围中，但可能处于的动态范围内被称为*孤立*指令。 孤立的指令使程序员能够根据程序的主要部分与并行执行仅极少量的更改到顺序的程序。 使用此功能，用户可以在程序调用关系树的顶部级别的并行构造的代码和指令用于控制在任何调用的函数中执行。

未同步的调用 C 和 c + + 输出写入到同一文件的函数可能会导致的输出在其中写入由不同的线程的数据显示在具有不确定性的顺序。 同样，输入从同一个文件中读取的函数的未同步的调用可能会读取具有不确定性的顺序中的数据。 未同步的使用的 I/O，以便每个线程访问不同的文件，将生成与 I/O 函数的串行执行相同的结果。