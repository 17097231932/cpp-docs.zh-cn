---
title: ARM64 ABI 约定概述
ms.date: 03/27/2019
ms.openlocfilehash: 2695ba69c642b2100ec041d1f85debb4ad7041c8
ms.sourcegitcommit: 06fc71a46e3c4f6202a1c0bc604aa40611f50d36
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/27/2019
ms.locfileid: "58508853"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 约定概述

基本应用程序二进制接口 (ABI) 为 Windows 编译时和运行在 64 位模式下 （ARMv8 或更高版本的体系结构），在多数情况下，为 ARM 处理器上遵循 ARM 的标准 AArch64 EABI。 本文重点介绍的一些关键的假设和从 EABI 中记录了哪些更改。 32 位 ABI 有关的信息，请参阅[概述的 ARM ABI 约定](overview-of-arm-abi-conventions.md)。 有关标准 ARM EABI 的详细信息，请参阅[应用程序二进制接口 (ABI) 的 ARM 体系结构](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html)（外部链接）。

## <a name="definitions"></a>定义

随着 64 位支持，ARM 定义多个词：

- **AArch32** – 旧的 32 位指令集体系结构 (ISA) 由 ARM，包括 Thumb 模式下执行。
- **AArch64** – 新的 64 位指令集体系结构 (ISA) 由 ARM 定义。
- **ARMv7** –"第 7 个代"的规范 ARM 硬件，只包括对 AArch32 的支持。 此版本的 ARM 硬件是第一个版本 Windows 的 ARM 支持。
- **ARMv8** –"第 8 个代"的规范包括支持 AArch32 和 AArch64 的 ARM 硬件。

Windows 还使用这些术语：

- **ARM** – 指的是 32 位 ARM 体系结构 (AArch32) 有时称为 WoA (在 ARM 上 Windows)。
- **ARM32** – 相同 ARM，上述; 为清楚起见本文档中使用。
- **ARM64** – 指的是 64 位 ARM 体系结构 (AArch64)。 WoA64 没有此类的内容。

最后，如果为数据类型的引用，引用 ARM 中的以下定义：

- **短矢量**– 直接在单指令多数据，向量的元素的 8 个字节或 16 个字节的价值可表示的数据类型。 它是其大小，8 个字节或 16 个字节，其中每个元素可以是 1、 2、 4 或 8 个字节对齐。
- **HFA （同构浮点聚合）** – 2 到 4 完全相同的浮点型成员，数据类型为是浮动或加倍。
- **HVA （同构的短矢量聚合）** – 2 到 4 相同的短矢量成员的数据类型。

## <a name="base-requirements"></a>基本要求

上 ARMv8 运行或在任何时候都更高版本的体系结构，前提是 Windows 的 ARM64 版本。 同时浮点和 NEON 支持都假定为会在硬件中提供。

ARMv8 规范允许 AArch32 应用程序的完全支持。 但是，没有计划支持 ARM64 版本的 Windows 上的现有 ARM32 应用程序。 （即，没有计划的 WOW64）。 此支持都受重新评估以后，但它是当前的工作假设。

ARMv8 规范 AArch32 和 AArch64 介绍新的可选加密和 CRC 帮助程序操作码。 对它们的支持是当前可选的但建议这样做。 若要充分利用这些操作代码，应用应首先使运行时检查其存在。

## <a name="endianness"></a>字节排序方式

作为与 ARM32 版本的 Windows，ARM64 Windows 上执行在 little-endian 模式下。 切换字节排序方式很难实现，而内核模式下支持 AArch64，在不是更轻松地强制执行。

## <a name="alignment"></a>对齐方式

在 ARM64 上运行的 Windows 使 CPU 硬件来以透明方式处理未对齐的访问。 从 AArch32 提高了，这种支持现在还适用于所有整数访问 （包括多个单词访问） 以及浮点访问。

但是，对未缓存 （设备） 内存访问仍必须始终对齐。 如果代码可能无法读取或写入未对齐的数据从非缓存的内存，则必须确保以一致的所有访问。

## <a name="integer-registers"></a>整数寄存器

AArch64 体系结构支持 32 整数寄存器：

| 寄存器 | 是否易失？ | 角色 |
| - | - | - |
| x0 | 易失的 | 参数/从头开始注册 1、 结果寄存器 |
| x1-x7 | 易失的 | 参数/从头开始注册 2-8 |
| x8-x15 | 易失的 | 临时寄存器 |
| x16-x17 | 易失的 | 内部过程调用临时寄存器 |
| x18 | 非易失性的 | 平台注册： 在内核模式下，指向 KPCR 当前处理器;在用户模式下，指向 TEB |
| x19-x28 | 非易失性的 | 临时寄存器 |
| x29/fp | 非易失性的 | 帧指针 |
| x30/lr | 非易失性的 | 链接寄存器 |

作为完整的 64 位值 （通过 x0 x30) 或 32 位值 （通过 w0 w30)，可以访问每个注册。 32 位操作零扩展其结果最多 64 位。

请参阅使用参数寄存器中传递部分了解详细信息的参数。

与 AArch32，不同的程序计数器 (PC) 和堆栈指针 (SP) 不是索引的寄存器。 这些限制是在可以访问它们的方式。 此外请注意，没有任何 x31 注册。 编码的用于特殊用途。

帧指针 (x29) 都需要与快速审核堆栈 ETW 和其他服务使用的兼容性。 它必须指向上一个 {x29，x 30} 对在堆栈上的。

## <a name="floating-pointsimd-registers"></a>浮点 point/SIMD 寄存器

AArch64 体系结构还支持 32 point 浮点/SIMD 寄存器，总结如下：

| 寄存器 | 是否易失？ | 角色 |
| - | - | - |
| v0 | 易失的 | 参数/从头开始注册 1、 结果寄存器 |
| v1-v7 | 易失的 | 参数/从头开始注册 2-8 |
| v8-v15 | 非易失性的 | 从头开始注册 （仅的低 64 位均为非易失性） |
| v16-v31 | 易失的 | 临时寄存器 |

每个注册可能会作为一个完整的 128 位值 （通过 v0 v31 或 q0 q31） 进行访问。 它可能会作为 64 位值 （通过 d0-d31) 作为 32 位值 （通过 s0-s31) 作为 16 位值 （通过 h0-h31)，或访问作为 8 位值 （通过 b0 b31)。 访问小于 128 位只能访问完整的 128 位寄存器的低位。 它们保留剩余的位保持不变，除非另行指定。 （AArch64 是不同于 AArch32，其中的较小的寄存器已打包在较大的寄存器之上。）

浮点控制寄存器 (FPCR) 中各种的位域上有某些要求：

| Bits | 含义 | 是否易失？ | 角色 |
| - | - | - | - |
| 26 | AHP | 非易失性 | 备选半精度控制。 |
| 25 | DN | 非易失性 | 默认 NaN 模式控制。 |
| 24 | FZ | 非易失性的 | 刷新零模式控制。 |
| 23-22 | RMode | 非易失性的 | 舍入模式控制。 |
| 15,12-8 | IDE/IXE/etc | 非易失性 | 异常捕获启用位，必须始终为 0。 |

## <a name="system-registers"></a>系统寄存器

如 AArch32，AArch64 规范提供了三个系统控制"的线程 ID"寄存器：

| 寄存器 | 角色 |
| - | - |
| TPIDR_EL0 | 保留。 |
| TPIDRRO_EL0 | 包含当前处理器的 CPU 数。 |
| TPIDR_EL1 | 指向当前处理器的 KPCR 结构。 |

## <a name="floating-point-exceptions"></a>浮点异常

为 IEEE 浮点异常的支持取决于您在 AArch64 的系统上。 有关处理器有硬件浮点异常的变体，Windows 内核以无提示方式将捕获的异常和隐式禁用 FPCR 寄存器中。 此陷阱可确保在处理器变量之间的规范化的行为。 否则，如果没有异常支持的平台上开发的代码可能会发现本身支持的平台上运行时执行意外的异常。

## <a name="parameter-passing"></a>参数传递

对于非可变参数函数，Windows ABI 将遵循由 ARM 传递的参数所指定的规则。 这些规则是直接从过程调用标准摘录 AArch64 体系结构：

### <a name="stage-a--initialization"></a>阶段 A-初始化

自变量处理开始之前，一次完成此阶段。

1. 下一步常规用途注册数 (NGRN) 设置为零。

1. 下一步单指令多数据和浮点注册数 (NSRN) 设置为零。

1. 下一个堆叠自变量地址 (NSAA) 设置为当前的堆栈指针值 (SP)。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>阶段 B-预填充和扩展的参数

对于每个自变量列表中，应用以下列表中的第一个匹配规则。 如果不使用任何规则匹配，参数保持不变。

1. 其大小不能由调用方和被调用方静态确定的复合类型的参数类型时，将参数复制到内存和自变量替换为指向该副本的指针。 （C/c + + 中不存在此类类型，但它们存在于其他语言或语言扩展中）。

1. 如果自变量类型是 HFA 或有关 HVA，则使用此参数未修改。

1. 大于 16 个字节的复合类型的参数类型时，然后将参数复制到由调用方分配的内存和自变量替换为指向该副本的指针。

1. 如果自变量类型是复合类型，然后自变量的大小舍入为最接近的 8 个字节的倍数。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>阶段 C-自变量分配给寄存器和堆栈

对于列表中的每个参数，直到已分配参数又应用以下规则。 如果自变量分配给寄存器，在寄存器中的任何未使用的位具有未指定的值。 如果自变量分配到堆栈槽，任何未使用的填充字节具有未指定的值。

1. 如果参数是半-、 单、 双精度或四核精度浮点或短矢量类型和 NSRN 小于 8，则自变量分配到寄存器 v 的最低有效位\[NSRN]。 NSRN 就会递增 1。 现在已分配参数。

1. 如果参数为 HFA 或有关 HVA，并且有足够的未分配的 SIMD 和浮点寄存器 （NSRN + 数成员 ≤ 8），该参数将分配到单指令多数据和浮点寄存器，每个成员的 HFA 或 HVA 一个寄存器中。 NSRN 加使用的寄存器的数量。 现在已分配参数。

1. 如果 HFA 或有关 HVA 自变量，然后 NSRN 设置为 8，和自变量的大小向上舍入到最接近的 8 个字节的倍数。

1. 如果参数为 HFA、 有关 HVA、 四核精度浮点或短向量类型，则 NSAA 将向上舍入到较大的 8 或参数的类型的自然对齐方式。

1. 如果参数为半或单精度浮点类型，则会将自变量的大小设置为 8 个字节。 效果如同自变量具有已复制到 64 位寄存器的最低有效位，并使用未指定值填充剩余的位。

1. 如果参数为 HFA，有关 HVA 后, 半部分-，单、 双-或四精度浮点或短矢量类型，然后自变量将复制到内存中的调整后的 nsaa 处。 NSAA 按参数的大小递增。 现在已分配参数。

1. 如果参数为整型或指针类型、 自变量的大小小于或等于 8 个字节，并且 NGRN 为小于 8，将参数复制到 x 中的最低有效位\[NGRN]。 NGRN 就会递增 1。 现在已分配参数。

1. 如果自变量具有 16 的对齐方式，然后 NGRN 舍入为下一个偶数。

1. 如果参数是一种整型类型、 自变量的大小等于 16，而 NGRN 是小于 7，将参数复制到 x\[NGRN] 和 x\[NGRN + 1]。 x\[NGRN] 应包含较低寻址的双字的自变量的内存表示形式。 NGRN 加两个。 现在已分配参数。

1. 如果参数为复合类型，并且自变量的双字中的大小都不能超过 8 减去 NGRN，则自变量复制到连续的通用寄存器，开始 x\[NGRN]。 将实参传递，就好像有已加载到寄存器从双字对齐地址，从内存加载连续寄存器 LDR 说明了相应规则。 寄存器的任何未使用部分的内容是未指定此标准。 NGRN 加使用的寄存器的数量。 现在已分配参数。

1. NGRN 设置为 8。

1. NSAA 向上舍入到较大的 8 或参数的类型的自然对齐方式。

1. 如果参数为复合类型，则会将参数复制到内存中的调整后的 nsaa 处。 NSAA 按参数的大小递增。 现在已分配参数。

1. 如果自变量的大小小于 8 个字节，然后将自变量的大小设置为 8 个字节。 效果是像参数已复制到 64 位寄存器的最低有效位且未指定值以填充剩余的位。

1. 自变量复制到内存中的调整后的 nsaa 处。 NSAA 按参数的大小递增。 现在已分配参数。

### <a name="addendum-variadic-functions"></a>附录：可变参数函数

采用可变数量的参数的函数的处理方式不同于更高版本，按如下所示：

1. 所有复合字符将被视为相似;HFAs hva 的任何特殊处理。

1. 不使用单指令多数据和浮点寄存器。

实际上，它是堆栈的以下规则 C.12–C.15 分配虚部堆栈，其中第一个 64 个字节被加载到 x0-x7，通常情况下放置任何剩余的 stack 参数的参数相同。

## <a name="return-values"></a>返回值

X0 中返回整数值。

浮点值 s0/d0/v0 根据形式返回。

返回值类型的处理方式不同，具体取决于是否具有特定属性。

类型是给出"C"返回样式如果它们是聚合的 C + + 14 标准定义。 那是

- 它们有没有用户提供的构造函数、 没有私有或受保护的非静态数据成员、 基类和没有虚函数
- 它们具有普通复制构造函数，并
- 它们具有普通析构函数。

所有其他类型都有"c + +"的返回样式。

### <a name="c-return-style"></a>C 返回样式

小于或等于 8 个字节 x0 中返回的类型。

小于或等于 16 个字节 x0 和 x1，与包含较低序位 8 个字节的 x0 中返回的类型。

对于大于 16 个字节的类型，调用方应保留足够的大小和对齐方式为保存结果的内存块。 内存块的地址应作为附加参数传递给 x8 中的函数。 被调用方可能会在该子例程执行期间修改任意点处的结果内存块。 被调用方不需要保留 x8 中存储的值。

### <a name="c-return-style"></a>C + + 返回样式

调用方应保留足够的大小和对齐方式为保存结果的内存块。 内存块的地址应该传递作为附加参数赋值给 x0 或 x1 函数如果 $这传入 x0。 被调用方可能会在该子例程执行期间修改任意点处的结果内存块。 被调用方返回 x0 中的内存块的地址。

## <a name="stack"></a>堆栈

以下利 ARM ABI，堆栈必须保持为 16 字节对齐在所有时间。 AArch64 包含 SP 不是 16 字节对齐并完成 SP 相对负载或应用商店时，生成堆栈对齐错误的硬件功能。 在任何时候启用此功能在运行 Windows。

分配 4k 或多个值得堆栈的函数必须确保按顺序访问时的最后一页之前每个页。 此操作可确保没有代码可以"跳过"Windows 用于展开堆栈的受保护页。 通常涉及通过`__chkstk`帮助器，具有将按 16 个 in x15 划分的总堆栈分配的自定义调用约定。

## <a name="red-zone"></a>红色区域

立即在当前的堆栈指针下方的 16 字节区域是保留供分析和动态修补方案。 此区域允许小心地生成的代码要插入它存储在两个寄存器 [sp，# 16] 并临时将其用于任意目的。 Windows 内核保证，如果异常或中断用户和内核模式执行不会覆盖这些 16 个字节。

## <a name="kernel-stack"></a>内核堆栈

在 Windows 中的默认内核模式堆栈是六页 (24 k)。 在内核模式下应特别小心于带大堆栈缓冲区的函数。 适时中断可能随着小空余空间，并创建的堆栈 panic bug 检查。

## <a name="stack-walking"></a>堆栈审核

Windows 中的代码编译的启用帧指针 ([/Oy-](reference/oy-frame-pointer-omission.md)) 以实现快速审核堆栈。 通常情况下，x29 (fp) 指向链是 {fp，lr} 中的下一个链接对，指示堆栈和返回地址上的上一帧指针。 若要启用帧指针，以便改进分析和跟踪，建议使用第三方代码。

## <a name="exception-unwinding"></a>异常展开

在处理异常时展开被辅助通过使用展开代码。 展开代码是存储在.xdata 部分中的可执行文件的字节序列。 这样可以在准备备份到调用方的堆栈帧中撤消函数序言的效果，它们会以抽象的方式，描述序言和尾声的操作。 展开代码的详细信息，请参阅[ARM64 异常处理](arm64-exception-handling.md)。

ARM EABI 还指定使用的异常展开模式展开代码。 但是，因为提供的规范是不足，无法在 Windows，必须处理函数序言或尾声中间的 PC 的情况下展开。

动态生成的代码应通过的动态函数表所述`RtlAddFunctionTable`以及关联函数，以便生成的代码可以参与异常处理。

## <a name="cycle-counter"></a>时钟周期计数器

支持循环计数器所需的所有 ARMv8 Cpu 注册 Windows 配置为在任何异常级别，包括用户模式下可读的 64 位寄存器。 它可以通过特殊 PMCCNTR_EL0 访问程序集代码中使用 MSR 操作码的注册或`_ReadStatusReg`C/c + + 代码中内部函数。

时钟周期计数器此处是一个真循环计数器，不时钟。 计数频率会因处理器的频率。 如果您认为您必须知道的时钟周期计数器的频率，则不应使用循环计数器。 相反，你想要测量时钟时间，应使用`QueryPerformanceCounter`。

## <a name="see-also"></a>请参阅

[Visual C++ ARM 迁移的常见问题](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 异常处理](arm64-exception-handling.md)
