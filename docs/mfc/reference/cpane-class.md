---
title: CPane Class
ms.date: 11/04/2016
f1_keywords:
- CPane
- AFXPANE/CPane
- AFXPANE/CPane::AdjustSizeImmediate
- AFXPANE/CPane::AllocElements
- AFXPANE/CPane::AllowShowOnPaneMenu
- AFXPANE/CPane::CalcAvailableSize
- AFXPANE/CPane::CalcInsideRect
- AFXPANE/CPane::CalcRecentDockedRect
- AFXPANE/CPane::CalcSize
- AFXPANE/CPane::CanBeDocked
- AFXPANE/CPane::CanBeTabbedDocument
- AFXPANE/CPane::ConvertToTabbedDocument
- AFXPANE/CPane::CopyState
- AFXPANE/CPane::Create
- AFXPANE/CPane::CreateDefaultMiniframe
- AFXPANE/CPane::CreateEx
- AFXPANE/CPane::DockByMouse
- AFXPANE/CPane::DockPane
- AFXPANE/CPane::DockPaneStandard
- AFXPANE/CPane::DockToFrameWindow
- AFXPANE/CPane::DoesAllowSiblingBars
- AFXPANE/CPane::FloatPane
- AFXPANE/CPane::GetAvailableExpandSize
- AFXPANE/CPane::GetAvailableStretchSize
- AFXPANE/CPane::GetBorders
- AFXPANE/CPane::GetClientHotSpot
- AFXPANE/CPane::GetDockSiteRow
- AFXPANE/CPane::GetExclusiveRowMode
- AFXPANE/CPane::GetHotSpot
- AFXPANE/CPane::GetMinSize
- AFXPANE/CPane::GetPaneName
- AFXPANE/CPane::GetVirtualRect
- AFXPANE/CPane::IsChangeState
- AFXPANE/CPane::IsDragMode
- AFXPANE/CPane::IsInFloatingMultiPaneFrameWnd
- AFXPANE/CPane::IsLeftOf
- AFXPANE/CPane::IsResizable
- AFXPANE/CPane::IsTabbed
- AFXPANE/CPane::LoadState
- AFXPANE/CPane::MoveByAlignment
- AFXPANE/CPane::MovePane
- AFXPANE/CPane::OnAfterChangeParent
- AFXPANE/CPane::OnBeforeChangeParent
- AFXPANE/CPane::OnPressCloseButton
- AFXPANE/CPane::OnShowControlBarMenu
- AFXPANE/CPane::RecalcLayout
- AFXPANE/CPane::SaveState
- AFXPANE/CPane::SetActiveInGroup
- AFXPANE/CPane::SetBorders
- AFXPANE/CPane::SetClientHotSpot
- AFXPANE/CPane::SetDockState
- AFXPANE/CPane::SetExclusiveRowMode
- AFXPANE/CPane::SetMiniFrameRTC
- AFXPANE/CPane::SetMinSize
- AFXPANE/CPane::SetVirtualRect
- AFXPANE/CPane::StretchPaneDeferWndPos
- AFXPANE/CPane::ToggleAutoHide
- AFXPANE/CPane::UndockPane
- AFXPANE/CPane::UpdateVirtualRect
- AFXPANE/CPane::OnAfterDock
- AFXPANE/CPane::OnAfterFloat
- AFXPANE/CPane::OnBeforeDock
- AFXPANE/CPane::OnBeforeFloat
- AFXPANE/CPane::m_bHandleMinSize
- AFXPANE/CPane::m_recentDockInfo
helpviewer_keywords:
- CPane [MFC], AdjustSizeImmediate
- CPane [MFC], AllocElements
- CPane [MFC], AllowShowOnPaneMenu
- CPane [MFC], CalcAvailableSize
- CPane [MFC], CalcInsideRect
- CPane [MFC], CalcRecentDockedRect
- CPane [MFC], CalcSize
- CPane [MFC], CanBeDocked
- CPane [MFC], CanBeTabbedDocument
- CPane [MFC], ConvertToTabbedDocument
- CPane [MFC], CopyState
- CPane [MFC], Create
- CPane [MFC], CreateDefaultMiniframe
- CPane [MFC], CreateEx
- CPane [MFC], DockByMouse
- CPane [MFC], DockPane
- CPane [MFC], DockPaneStandard
- CPane [MFC], DockToFrameWindow
- CPane [MFC], DoesAllowSiblingBars
- CPane [MFC], FloatPane
- CPane [MFC], GetAvailableExpandSize
- CPane [MFC], GetAvailableStretchSize
- CPane [MFC], GetBorders
- CPane [MFC], GetClientHotSpot
- CPane [MFC], GetDockSiteRow
- CPane [MFC], GetExclusiveRowMode
- CPane [MFC], GetHotSpot
- CPane [MFC], GetMinSize
- CPane [MFC], GetPaneName
- CPane [MFC], GetVirtualRect
- CPane [MFC], IsChangeState
- CPane [MFC], IsDragMode
- CPane [MFC], IsInFloatingMultiPaneFrameWnd
- CPane [MFC], IsLeftOf
- CPane [MFC], IsResizable
- CPane [MFC], IsTabbed
- CPane [MFC], LoadState
- CPane [MFC], MoveByAlignment
- CPane [MFC], MovePane
- CPane [MFC], OnAfterChangeParent
- CPane [MFC], OnBeforeChangeParent
- CPane [MFC], OnPressCloseButton
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], RecalcLayout
- CPane [MFC], SaveState
- CPane [MFC], SetActiveInGroup
- CPane [MFC], SetBorders
- CPane [MFC], SetClientHotSpot
- CPane [MFC], SetDockState
- CPane [MFC], SetExclusiveRowMode
- CPane [MFC], SetMiniFrameRTC
- CPane [MFC], SetMinSize
- CPane [MFC], SetVirtualRect
- CPane [MFC], StretchPaneDeferWndPos
- CPane [MFC], ToggleAutoHide
- CPane [MFC], UndockPane
- CPane [MFC], UpdateVirtualRect
- CPane [MFC], OnAfterDock
- CPane [MFC], OnAfterFloat
- CPane [MFC], OnBeforeDock
- CPane [MFC], OnBeforeFloat
- CPane [MFC], m_bHandleMinSize
- CPane [MFC], m_recentDockInfo
ms.assetid: 5c651a64-3c79-4d94-9676-45f6402a6bc5
ms.openlocfilehash: b660d181aada8abeb61b397fb30b097897e74f65
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/04/2019
ms.locfileid: "57326772"
---
# <a name="cpane-class"></a>CPane Class

`CPane`类是一个增强的功能[CControlBar 类](../../mfc/reference/ccontrolbar-class.md)。 如果要升级现有 MFC 项目，替换出现的所有`CControlBar`与`CPane`。

## <a name="syntax"></a>语法

```
class CPane : public CBasePane
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|`CPane::~CPane`|析构函数。|

### <a name="public-methods"></a>公共方法

|名称|描述|
|----------|-----------------|
|[CPane::AdjustSizeImmediate](#adjustsizeimmediate)|立即重新计算窗格的布局。|
|[CPane::AllocElements](#allocelements)|分配存储供内部使用。|
|[CPane::AllowShowOnPaneMenu](#allowshowonpanemenu)|指定是否在窗格列出的应用程序的窗格的运行时生成列表中。|
|[CPane::CalcAvailableSize](#calcavailablesize)|计算大小中指定的矩形与当前窗口矩形之间的差异。|
|[CPane::CalcInsideRect](#calcinsiderect)|计算内部的窗格中，并考虑边框和控制手柄的矩形。|
|[CPane::CalcRecentDockedRect](#calcrecentdockedrect)|计算最近停靠的矩形。|
|[CPane::CalcSize](#calcsize)|计算窗格的大小。|
|[CPane::CanBeDocked](#canbedocked)|确定是否可以在指定的基窗格停靠窗格。|
|[CPane::CanBeTabbedDocument](#canbetabbeddocument)|确定是否可将窗格转换选项卡式文档。|
|[CPane::ConvertToTabbedDocument](#converttotabbeddocument)|将选项卡式文档转换为可停靠窗格。|
|[CPane::CopyState](#copystate)|将复制一个窗格的状态。 (重写[CBasePane::CopyState](../../mfc/reference/cbasepane-class.md#copystate)。)|
|[CPane::Create](#create)|创建控件条，并将其附加到`CPane`对象。|
|[CPane::CreateDefaultMiniframe](#createdefaultminiframe)|创建浮动窗格的微型框架窗口。|
|[CPane::CreateEx](#createex)|创建控件条，并将其附加到`CPane`对象。|
|`CPane::CreateObject`|由框架用于创建此类类型的动态实例。|
|[CPane::DockByMouse](#dockbymouse)|将窗格停靠使用鼠标停靠方法。|
|[CPane::DockPane](#dockpane)|将浮动窗格停靠到基窗格。|
|[CPane::DockPaneStandard](#dockpanestandard)|将窗格停靠使用大纲 （标准） 停靠。|
|[CPane::DockToFrameWindow](#docktoframewindow)|将可停靠窗格停靠到的帧。 （重写 `CBasePane::DockToFrameWindow`。）|
|[CPane::DoesAllowSiblingBars](#doesallowsiblingbars)|指示是否可以停靠在当前窗格的停靠位置的同一行的另一个窗格。|
|[CPane::FloatPane](#floatpane)|浮动窗格。|
|[CPane::GetAvailableExpandSize](#getavailableexpandsize)|返回的以像素为单位，该窗格可以展开。|
|[CPane::GetAvailableStretchSize](#getavailablestretchsize)|返回的以像素为单位，该窗格可以收缩。|
|[CPane::GetBorders](#getborders)|返回窗格的边框的宽度。|
|[CPane::GetClientHotSpot](#getclienthotspot)|返回*热点*窗格。|
|[CPane::GetDockSiteRow](#getdocksiterow)|返回在其中停靠窗格的停靠行。|
|[CPane::GetExclusiveRowMode](#getexclusiverowmode)|确定窗格是否在排他行模式下。|
|[CPane::GetHotSpot](#gethotspot)|返回存储在基础的热点`CMFCDragFrameImpl`对象。|
|[CPane::GetMinSize](#getminsize)|检索的最小允许大小的窗格。|
|[CPane::GetPaneName](#getpanename)|检索在窗格的标题。|
|`CPane::GetResizeStep`|内部使用。|
|`CPane::GetThisClass`|由框架用于获取一个指向[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)与此类类型相关联的对象。|
|[CPane::GetVirtualRect](#getvirtualrect)|检索*虚拟矩形*的窗格。|
|[CPane::IsChangeState](#ischangestate)|在窗格中，如移动，此方法分析的位置相对于其他窗格，请在窗格的行和微型框架窗口停靠，并返回相应的 AFX_CS_STATUS 值。|
|[CPane::IsDragMode](#isdragmode)|指定是否正被拖动窗格。|
|[CPane::IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定窗格是否在多窗格框架窗口中。 （重写 `CBasePane::IsInFloatingMultiPaneFrameWnd`。）|
|[CPane::IsLeftOf](#isleftof)|确定的 （或更高版本） 是否保持为窗格中指定的矩形。|
|[CPane::IsResizable](#isresizable)|确定是否可以调整窗格的大小。 (重写[cbasepane:: Isresizable](../../mfc/reference/cbasepane-class.md#isresizable)。)|
|[CPane::IsTabbed](#istabbed)|确定是否已插入窗格的选项卡式窗口选项卡控件中。 (重写[CBasePane::IsTabbed](../../mfc/reference/cbasepane-class.md#istabbed)。)|
|[CPane::LoadState](#loadstate)|从注册表加载窗格的状态。 (重写[CBasePane::LoadState](../../mfc/reference/cbasepane-class.md#loadstate)。)|
|[CPane::MoveByAlignment](#movebyalignment)|将窗格的虚拟矩形移动指定的量。|
|[CPane::MovePane](#movepane)|将窗格移动到指定的矩形。|
|[CPane::OnAfterChangeParent](#onafterchangeparent)|一个窗格的父级发生更改时由框架调用。|
|[CPane::OnBeforeChangeParent](#onbeforechangeparent)|在窗格的父即将更改时由框架调用。|
|[CPane::OnPressCloseButton](#onpressclosebutton)|在用户选择上窗格的标题的关闭按钮时由框架调用。|
|`CPane::OnProcessDblClk`|内部使用。|
|[CPane::OnShowControlBarMenu](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|[CPane::OnShowControlBarMenu](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|`CPane::PrepareToDock`|内部使用。|
|[CPane::RecalcLayout](#recalclayout)|重新计算在窗格的布局信息。 (重写[CBasePane::RecalcLayout](../../mfc/reference/cbasepane-class.md#recalclayout)。)|
|[CPane::SaveState](#savestate)|将窗格的状态保存到注册表。 (重写[CBasePane::SaveState](../../mfc/reference/cbasepane-class.md#savestate)。)|
|[CPane::SetActiveInGroup](#setactiveingroup)|标记为活动状态的窗格。|
|[CPane::SetBorders](#setborders)|设置窗格的边框值。|
|[CPane::SetClientHotSpot](#setclienthotspot)|设置作用点窗格。|
|[CPane::SetDockState](#setdockstate)|还原停靠窗格的状态信息。|
|[CPane::SetExclusiveRowMode](#setexclusiverowmode)|启用或禁用的排他行模式。|
|[CPane::SetMiniFrameRTC](#setminiframertc)|设置默认微型框架窗口的运行时类信息。|
|[CPane::SetMinSize](#setminsize)|设置的最小允许大小的窗格。|
|[CPane::SetVirtualRect](#setvirtualrect)|集*虚拟矩形*的窗格。|
|[CPane::StretchPaneDeferWndPos](#stretchpanedeferwndpos)|拉伸垂直或水平停靠样式基于的窗格。|
|[CPane::ToggleAutoHide](#toggleautohide)|切换自动隐藏模式。|
|[CPane::UndockPane](#undockpane)|从停靠站点、 默认滑块或当前停靠位置的微型框架窗口删除窗格。 (重写[CBasePane::UndockPane](../../mfc/reference/cbasepane-class.md#undockpane)。)|
|[CPane::UpdateVirtualRect](#updatevirtualrect)|更新的虚拟矩形。|

### <a name="protected-methods"></a>受保护的方法

|名称|描述|
|----------|-----------------|
|[CPane::OnAfterDock](#onafterdock)|已停靠窗格时，由框架调用。|
|[CPane::OnAfterFloat](#onafterfloat)|浮动窗格时，由框架调用。|
|[CPane::OnBeforeDock](#onbeforedock)|要停靠窗格时，由框架调用。|
|[CPane::OnBeforeFloat](#onbeforefloat)|要浮动窗格时，由框架调用。|

### <a name="data-members"></a>数据成员

|name|描述|
|----------|-----------------|
|[CPane::m_bHandleMinSize](#m_bhandleminsize)|启用窗格的最小大小一致的处理。|
|[CPane::m_recentDockInfo](#m_recentdockinfo)|包含新的停靠信息。|

## <a name="remarks"></a>备注

通常情况下，`CPane`不直接实例化对象。 如果你需要一个具有停靠功能窗格，派生从对象[CDockablePane](../../mfc/reference/cdockablepane-class.md)。 如果您需要工具栏功能，派生从对象[CMFCToolBar](../../mfc/reference/cmfctoolbar-class.md)。

从类派生时`CPane`，它可以在停靠[CDockSite](../../mfc/reference/cdocksite-class.md)和其可以浮动在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

[CPane](../../mfc/reference/cpane-class.md)

## <a name="requirements"></a>要求

**标头：** afxPane.h

##  <a name="adjustsizeimmediate"></a>  CPane::AdjustSizeImmediate

立即重新计算窗格的布局。

```
virtual void AdjustSizeImmediate(BOOL bRecalcLayout = TRUE);
```

### <a name="parameters"></a>参数

*bRecalcLayout*<br/>
[in]为 TRUE，则会自动重新计算窗格; 的布局否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法时动态更改窗格的布局。 例如，你可能想要隐藏或显示工具栏按钮时调用此方法。

##  <a name="allocelements"></a>  CPane::AllocElements

分配存储供内部使用。

```
BOOL AllocElements(
    int nElements,
    int cbElement);
```

### <a name="parameters"></a>参数

*nElements*<br/>
[in]要为其分配存储空间的元素数。

*cbElement*<br/>
[in]以字节为单位，元素的大小。

### <a name="return-value"></a>返回值

如果内存分配失败; 则为 FALSE否则，则为 TRUE。

##  <a name="allowshowonpanemenu"></a>  CPane::AllowShowOnPaneMenu

指定是否在窗格列出的应用程序的窗格的运行时生成列表中。

```
virtual BOOL AllowShowOnPaneMenu() const;
```

### <a name="return-value"></a>返回值

如果窗格会显示在列表; 则为 TRUE否则为 FALSE。 基实现始终返回 TRUE。

### <a name="remarks"></a>备注

应用程序向导生成的应用程序包含菜单选项，其中列出了它所包含的窗格。 此方法确定是否在列表中显示的窗格。

##  <a name="calcavailablesize"></a>  CPane::CalcAvailableSize

计算大小中指定的矩形与当前窗口矩形之间的差异。

```
virtual CSize CalcAvailableSize(CRect rectRequired);
```

### <a name="parameters"></a>参数

*rectRequired*<br/>
[in]所需的矩形。

### <a name="return-value"></a>返回值

宽度和高度之间的区别*rectRequired*和当前窗口矩形。

##  <a name="calcinsiderect"></a>  CPane::CalcInsideRect

计算内部的窗格中，包括边框和控制手柄的矩形。

```
void CalcInsideRect(
    CRect& rect,
    BOOL bHorz) const;
```

### <a name="parameters"></a>参数

*rect*<br/>
[out]包含的大小和工作区的窗格中的偏移量。

*bHorz*<br/>
[in]窗格将采用水平方向; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

在必须重新计算一个窗格的布局时，由框架调用此方法。 *Rect*参数填充的大小和工作区的窗格中的偏移量。 这包括其边框和控制手柄。

##  <a name="calcrecentdockedrect"></a>  CPane::CalcRecentDockedRect

计算最近停靠的矩形。

```
void CalcRecentDockedRect();
```

### <a name="remarks"></a>备注

此方法会更新[cpane:: M_recentdockinfo](#m_recentdockinfo)。

##  <a name="calcsize"></a>  CPane::CalcSize

计算窗格的大小。

```
virtual CSize CalcSize(BOOL bVertDock);
```

### <a name="parameters"></a>参数

*bVertDock*<br/>
[in]如果窗格停靠垂直 FALSE，否则，则为 TRUE。

### <a name="return-value"></a>返回值

此方法的默认实现返回的大小为 （0，0）。

### <a name="remarks"></a>备注

派生的类应重写此方法。

##  <a name="canbedocked"></a>  CPane::CanBeDocked

确定是否可在指定的基窗格停靠窗格。

```
virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[in]指定此窗格将停靠的窗格。

### <a name="return-value"></a>返回值

如果此窗格可以停靠在指定的停靠窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法通常称为框架以确定是否可将一个窗格停靠在指定的停靠窗格。 若要确定是否可以停靠窗格，该方法的计算结果窗格中的当前启用停靠对齐方式。

启用通过调用停靠到框架窗口的各个方面[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)。

##  <a name="canbetabbeddocument"></a>  CPane::CanBeTabbedDocument

确定是否窗格可以转换为选项卡式文档。

```
virtual BOOL CanBeTabbedDocument() const;
```

### <a name="return-value"></a>返回值

如果窗格可以转换为选项卡式文档，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

重写此方法在派生类中的，并返回 FALSE，如果你想要防止一个窗格，从要转换为选项卡式文档。 选项卡式的文档不会在窗口位置菜单中列出。

##  <a name="converttotabbeddocument"></a>  CPane::ConvertToTabbedDocument

将选项卡式文档转换为可停靠窗格。

```
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```

### <a name="parameters"></a>参数

*bActiveTabOnly*<br/>
[in]不用于`CPane::ConvertToTabbedDocument`。

### <a name="remarks"></a>备注

仅可停靠窗格可以转换为选项卡式文档。 有关信息，请参阅[CDockablePane::ConvertToTabbedDocument](../../mfc/reference/cdockablepane-class.md#converttotabbeddocument)。

##  <a name="copystate"></a>  CPane::CopyState

将复制一个窗格的状态。

```
virtual void CopyState(CPane* pOrgBar);
```

### <a name="parameters"></a>参数

*pOrgBar*<br/>
[in]指向一个窗格的指针。

### <a name="remarks"></a>备注

此方法将复制的状态*pOrgBar*到当前的窗格。

##  <a name="create"></a>  Cpane:: Create

创建控件条，并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*lpszClassName*<br/>
[in]指定的 Windows 类的名称。

*dwStyle*<br/>
[in]指定的窗口样式特性。 有关详细信息，请参阅[的窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*rect*<br/>
[in]指定的初始大小和位置*pParentWnd*窗口中的，在工作区坐标。

*pParentWnd*<br/>
[in、 out]指定此窗格的父窗口。

*nID*<br/>
[in]指定在窗格的 ID。

*dwControlBarStyle*<br/>
[in]指定窗格中的样式。 有关详细信息，请参阅[cbasepane:: Createex](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in、 out]指定创建上下文的窗格。

### <a name="return-value"></a>返回值

如果窗格已创建成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法创建一个 Windows 窗格，并将其附加到`CPane`对象。

如果显式未初始化[cpane:: M_recentdockinfo](#m_recentdockinfo)在调用之前`Create`，该参数*rect*将用作浮动或停靠窗格时的矩形。

##  <a name="createdefaultminiframe"></a>  CPane::CreateDefaultMiniframe

创建浮动窗格的微型框架窗口。

```
virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);
```

### <a name="parameters"></a>参数

*rectInitial*<br/>
[in]指定的初始大小和位置，在屏幕坐标中的微型框架窗口创建。

### <a name="return-value"></a>返回值

新创建的微型框架窗口中。

### <a name="remarks"></a>备注

由框架创建微型框架窗口浮动窗格时调用此方法。 微型框架窗口可以为类型[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)类型或类型[CMultiPaneFrameWnd](../../mfc/reference/cmultipaneframewnd-class.md)。 如果窗格具有 AFX_CBRS_FLOAT_MULTI 样式，将创建一个多微型框架窗口。

微型框架窗口的运行时类信息存储在`CPane::m_pMiniFrameRTC`成员。 在派生的类可用于设置此成员，如果你决定创建自定义的微型框架窗口。

##  <a name="createex"></a>  Cpane:: Createex

创建控件条，并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*dwStyleEx*<br/>
[in]指定扩展的窗口样式特性。 有关详细信息，请参阅[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

*lpszClassName*<br/>
[in]指定的 Windows 类的名称。

*dwStyle*<br/>
[in]指定窗口的样式特性。 有关详细信息，请参阅[的窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*rect*<br/>
[in]指定的初始大小和位置*pParentWnd*窗口中的，在工作区坐标。

*pParentWnd*<br/>
[in、 out]指定此窗格的父窗口。

*nID*<br/>
[in]指定在窗格的 ID。

*dwControlBarStyle*<br/>
[in]指定窗格中的样式。 有关详细信息，请参阅[cbasepane:: Createex](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in、 out]指定在窗格的创建上下文。

### <a name="return-value"></a>返回值

如果窗格已创建成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法创建一个 Windows 窗格，并将其附加到`CPane`对象。

如果显式未初始化[cpane:: M_recentdockinfo](#m_recentdockinfo)在调用之前`CreateEx`，该参数*rect*将用作浮动或停靠窗格时的矩形。

##  <a name="dockbymouse"></a>  CPane::DockByMouse

通过使用鼠标将停靠窗格。

```
virtual BOOL DockByMouse(CBasePane* pDockBar);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[in]指定要将此窗格停靠到基本窗格。

### <a name="return-value"></a>返回值

如果已成功，则停靠窗格，则返回 TRUE否则为 FALSE。

##  <a name="dockpane"></a>  CPane::DockPane

将浮动窗格停靠到基窗格。

```
virtual BOOL DockPane(
    CBasePane* pDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[in、 out]指定的基窗格停靠到此窗格。

*lpRect*<br/>
[in]此窗格的停靠位置的基窗格上指定的矩形。

*dockMethod*<br/>
[in]指定要使用的扩展方法。 可用选项如下所示：

|选项|描述|
|------------|-----------------|
|DM_UNKNOWN|未知停靠方法时，框架将使用此选项。 在窗格不会存储其最新的浮动位置。 此选项还可用于以编程方式将窗格停靠时不需要存储的最新的浮动位置。|
|DM_MOUSE|内部使用。|
|DM_DBL_CLICK|双击控制手柄时使用此选项。 在其最新的停靠位置重新定位窗格。 如果窗格取消停靠，通过双击，窗格器重定位到其最新的浮动位置处。|
|DM_SHOW|此选项可用于以编程方式停靠窗格。 窗格中将存储其最新的浮动位置。|
|DM_RECT|在窗格停靠在由指定的区域*lpRect*。|
|DM_STANDARD|时使用此选项，框架绘制轮廓框架作为窗格中，在移动时。|

### <a name="return-value"></a>返回值

如果已成功，则停靠窗格，则返回 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法将窗格停靠到由指定的基窗格*pDockBar*参数。 你必须先启用通过调用停靠[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)。

##  <a name="dockpanestandard"></a>  CPane::DockPaneStandard

将窗格停靠使用大纲 （标准） 停靠。

```
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```

### <a name="parameters"></a>参数

*bWasDocked*<br/>
[in]如果成功停靠窗格; 则为 TRUE否则为 FALSE。

### <a name="return-value"></a>返回值

此方法始终返回**这**指针。

### <a name="remarks"></a>备注

此方法仅用于派生自的窗格[CDockablePane 类](../../mfc/reference/cdockablepane-class.md)。 有关详细信息，请参阅[CDockablePane::DockPaneStandard](../../mfc/reference/cdockablepane-class.md#dockpanestandard)。

##  <a name="docktoframewindow"></a>  CPane::DockToFrameWindow

将可停靠窗格停靠到的帧。

```
virtual BOOL DockToFrameWindow(
    DWORD dwAlignment,
    LPCRECT lpRect = NULL,
    DWORD dwDockFlags = DT_DOCK_LAST,
    CBasePane* pRelativeBar = NULL,
    int nRelativeIndex = -1,
    BOOL bOuterEdge = FALSE);
```

### <a name="parameters"></a>参数

*dwAlignment*<br/>
[in]你想要停靠的窗格为与父框架中的方。

*lpRect*<br/>
[in]指定的大小。

*dwDockFlags*<br/>
[in]忽略。

*pRelativeBar*<br/>
[in]忽略。

*nRelativeIndex*<br/>
[in]忽略。

*bOuterEdge*<br/>
[in]如果 TRUE 和有是侧所指定的其他可停靠窗格*dwAlignment*外其他窗格，, 停靠窗格更接近于父框架的边缘。 如果为 FALSE，在窗格停靠在更靠近客户端区域的中心。

### <a name="return-value"></a>返回值

如果窗格分隔符，则为 FALSE ( [CPaneDivider 类](../../mfc/reference/cpanedivider-class.md)) 不能创建; 否则为 TRUE。

### <a name="remarks"></a>备注

##  <a name="doesallowsiblingbars"></a>  CPane::DoesAllowSiblingBars

指示是否可以停靠在当前窗格的停靠位置的同一行的另一个窗格。

```
virtual BOOL DoesAllowSiblingBars() const;
```

### <a name="return-value"></a>返回值

如果此窗格可以停靠到另一个窗格与本身; 位于同一行上则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

可以启用或禁用此行为通过调用[CPane::SetExclusiveRowMode](#setexclusiverowmode)。

默认情况下，工具栏具有禁用的排他行模式，菜单栏中的已启用的排他行模式。

##  <a name="floatpane"></a>  CPane::FloatPane

浮动窗格。

```
virtual BOOL FloatPane(
    CRect rectFloat,
    AFX_DOCK_METHOD dockMethod = DM_UNKNOWN,
    bool bShow = true);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
[in]在屏幕坐标定位时它浮动窗格中指定位置。

*dockMethod*<br/>
[in]指定要使用时浮动窗格的停靠方法。 有关可能的值的列表，请参阅[CPane::DockPane](#dockpane)。

*bShow*<br/>
[in]为 TRUE，则显示窗格中时浮动;否则为 FALSE。

### <a name="return-value"></a>返回值

如果已成功浮动窗格或不能浮动窗格中，因为 TRUE [CBasePane::CanFloat](../../mfc/reference/cbasepane-class.md#canfloat)返回 FALSE; 否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法以浮动窗格中由指定的位置*rectFloat*参数。 此方法自动创建父微型框架窗口的窗格。

##  <a name="getavailableexpandsize"></a>  CPane::GetAvailableExpandSize

返回的以像素为单位，该窗格可以展开。

```
virtual int GetAvailableExpandSize() const;
```

### <a name="return-value"></a>返回值

如果窗格时水平停靠，返回值是可用的宽度;否则，返回值是可用的高度。

### <a name="remarks"></a>备注

##  <a name="getavailablestretchsize"></a>  CPane::GetAvailableStretchSize

返回的以像素为单位，该窗格可以收缩。

```
virtual int GetAvailableStretchSize() const;
```

### <a name="return-value"></a>返回值

量 （以像素为单位，该窗格可以收缩）。 如果窗格时水平停靠，此数量是可用的宽度;否则，它是可用的高度。

### <a name="remarks"></a>备注

可用延伸大小减去计算得出的最小允许大小为窗格 ( [CPane::GetMinSize](#getminsize)) 中的当前大小 ( [CWnd::GetWindowRect](../../mfc/reference/cwnd-class.md#getwindowrect))。

##  <a name="getborders"></a>  CPane::GetBorders

返回窗格的边框的宽度。

```
CRect GetBorders() const;
```

### <a name="return-value"></a>返回值

一个[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含的当前宽度，以像素为单位，每个边的窗格。 例如，值`left`的成员`CRect`对象是左边框的宽度。

### <a name="remarks"></a>备注

若要设置边框的大小，请调用[CPane::SetBorders](#setborders)。

##  <a name="getclienthotspot"></a>  CPane::GetClientHotSpot

返回*热点*窗格。

```
CPoint GetClientHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*热点*是在用户选择并按住以移动该窗格的窗格上的点。 作用点用于当窗格从停靠位置移动都进行流畅的动画。

##  <a name="getdocksiterow"></a>  CPane::GetDockSiteRow

返回停靠行 ( [CDockingPanesRow 类](../../mfc/reference/cdockingpanesrow-class.md)) 在停靠窗格。

```
CDockingPanesRow* GetDockSiteRow() const;
```

### <a name="return-value"></a>返回值

一个`CDockingPanesRow`*，它指向在其中停靠窗格，停靠行或 NULL 如果未停靠窗格。

##  <a name="getexclusiverowmode"></a>  CPane::GetExclusiveRowMode

确定在窗格是否在排他行模式下。

```
virtual BOOL GetExclusiveRowMode() const;
```

### <a name="return-value"></a>返回值

如果窗格在排他行模式，则为，TRUE否则为 FALSE。

### <a name="remarks"></a>备注

有关排他行模式的详细信息，请参阅[CPane::SetExclusiveRowMode](#setexclusiverowmode)。

##  <a name="gethotspot"></a>  CPane::GetHotSpot

返回存储在基础的热点`CMFCDragFrameImpl`对象。

```
CPoint GetHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

`CPane`类包含`CMFCDragFrameImpl`对象， `m_dragFrameImpl`，即负责绘制显示当用户在标准停靠模式下移动一个窗格的矩形。 作用点用于绘制矩形相对于当前的鼠标位置，用户在将移动窗格。

##  <a name="getminsize"></a>  CPane::GetMinSize

检索的最小允许大小的窗格。

```
virtual void GetMinSize(CSize& size) const;
```

### <a name="parameters"></a>参数

*size*<br/>
[out]一个`CSize`对象填充的最小允许大小。

### <a name="remarks"></a>备注

##  <a name="getpanename"></a>  CPane::GetPaneName

检索在窗格的标题。

```
virtual void GetPaneName(CString& strName) const;
```

### <a name="parameters"></a>参数

*strName*<br/>
[out]一个`CString`对象填充的标题名称。

### <a name="remarks"></a>备注

当窗格处于停靠状态还是浮动窗格标题显示的标题区域中。 如果窗格选项卡式组的一部分，是在选项卡区域中显示标题。 如果窗格在自动隐藏模式下，标题会显示在`CMFCAutoHideButton`。

##  <a name="getvirtualrect"></a>  CPane::GetVirtualRect

检索*虚拟矩形*的窗格。

```
void GetVirtualRect(CRect& rectVirtual) const;
```

### <a name="parameters"></a>参数

*rectVirtual*<br/>
[out]一个`CRect`虚拟矩形填充的对象。

### <a name="remarks"></a>备注

移动后一个窗格，框架将存储在虚拟矩形的窗格中的原始位置。 该框架可以使用的虚拟矩形还原窗格中的原始位置。

不要调用除非要以编程方式移动窗格相关的虚拟矩形的方法。

##  <a name="ischangestate"></a>  CPane::IsChangeState

在窗格中，如移动，此方法分析其位置相对于其他窗格中，行和微型框架窗口停靠，并返回相应的 AFX_CS_STATUS 值。

```
virtual AFX_CS_STATUS IsChangeState(
    int nOffset,
    CBasePane** ppTargetBar) const;
```

### <a name="parameters"></a>参数

*nOffset*<br/>
[in]指定停靠的敏感度。 例如，一个窗格，其中内移动*nOffset*将停靠停靠行中的像素为单位。

*ppTargetBar*<br/>
[in]方法返回时， *ppTargetBar*包含指向到应停靠当前窗格中，该对象的指针或 NULL，如果不停靠应发生。

### <a name="return-value"></a>返回值

以下 AFX_CS_STATUS 值之一：

|“值”|描述|
|-----------|-----------------|
|CS_NOTHING|窗格并不是停靠站点附近。 该框架将窗格未停靠。|
|CS_DOCK_IMMEDIATELY|在窗格中，通过停靠站点，并且 DT_IMMEDIATE 样式已启用。 该框架将立即停靠窗格。|
|CS_DELAY_DOCK|在窗格是另一个停靠窗格或主框架边缘的停靠站点。 在用户释放移动时，框架将停靠窗格。|
|CS_DELAY_DOCK_TO_TAB|在窗格是使窗格停靠在选项卡式窗口停靠站点。 通过另一个停靠窗格的标题或选项卡式窗格的选项卡区域窗格时，将发生这种情况。 在用户释放移动时，框架将停靠窗格。|

##  <a name="isdragmode"></a>  CPane::IsDragMode

指定是否要移动的窗格。

```
virtual BOOL IsDragMode() const;
```

### <a name="return-value"></a>返回值

如果要移动窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

##  <a name="isinfloatingmultipaneframewnd"></a>  CPane::IsInFloatingMultiPaneFrameWnd

指定窗格是否在多窗格框架窗口中 ( [CMultiPaneFrameWnd 类](../../mfc/reference/cmultipaneframewnd-class.md))。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>返回值

在窗格的多窗格框架窗口; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

仅可停靠窗格可以浮动在多窗格框架窗口中。 因此，`CPane::IsInFloatingMultiPaneFrameWnd`始终返回 FALSE。

##  <a name="isleftof"></a>  CPane::IsLeftOf

确定的 （或更高版本） 是否保持为窗格中指定的矩形。

```
bool IsLeftOf(
    CRect rect,
    bool bWindowRect = true) const;
```

### <a name="parameters"></a>参数

*rect*<br/>
[in]一个`CRect`用于比较的对象。

*bWindowRect*<br/>
[in]如果为 TRUE， *rect*包含屏幕坐标; 如果为 FALSE，则假定*rect*假定包含客户端坐标。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

如果窗格时水平停靠，此方法将检查是否保持为其位置的*rect*。 否则，此方法检查位置是否高于*rect*。

##  <a name="isresizable"></a>  CPane::IsResizable

指定是否可以在窗格的大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>返回值

在窗格中，可调整大小; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

基本`CPane`对象不能调整大小。

到停靠管理器使用可调整大小的标志来确定窗格布局。 非可调整大小的窗格是始终位于父框架的外边缘。

非可调整大小的窗格不能驻留在停靠容器。

##  <a name="istabbed"></a>  CPane::IsTabbed

确定是否已在窗格插入选项卡控件的选项卡式窗口。

```
virtual BOOL IsTabbed() const;
```

### <a name="return-value"></a>返回值

如果窗格选项卡式; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

选项卡式的状态处理单独从浮动、 停靠，并自动隐藏状态。

##  <a name="loadstate"></a>  CPane::LoadState

从注册表加载窗格的状态。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpszProfileName*<br/>
[in]配置文件名称。

*nIndex*<br/>
[in]配置文件的索引。

*uiID*<br/>
[in]窗格 id。

### <a name="return-value"></a>返回值

如果窗格状态加载成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

框架调用此方法以从注册表加载窗格状态。 通过保存要加载的其他信息的派生类中重写此[CPane::SaveState](#savestate)。

当重写此方法时，还调用基方法，并返回 FALSE 的基方法返回 FALSE。

##  <a name="m_bhandleminsize"></a>  CPane::m_bHandleMinSize

允许最小窗格大小一致的处理。

```
AFX_IMPORT_DATA static BOOL m_bHandleMinSize;
```

### <a name="remarks"></a>备注

如果在应用程序中的一个或多个停靠窗格重写`GetMinSize`，或如果你的应用程序调用`SetMinSize`，你可能想要将此静态成员设置为 TRUE，以使框架可以一致地处理如何调整大小窗格。

如果此值设置为 TRUE，将剪切不拉伸的所有窗格应如下其最小大小减小其大小。 由于框架窗格大小调整用于使用窗口区域，不要更改为停靠窗格，如果此值设置为 TRUE 的窗口区域的大小。

##  <a name="m_recentdockinfo"></a>  CPane::m_recentDockInfo

包含新的停靠信息。

```
CRecentDockSiteInfo m_recentDockInfo;
```

### <a name="remarks"></a>备注

框架将在窗格的最新停靠状态信息存储在此成员。

##  <a name="movebyalignment"></a>  CPane::MoveByAlignment

将窗格的虚拟矩形移动指定的量。

```
BOOL MoveByAlignment(
    DWORD dwAlignment,
    int nOffset);
```

### <a name="parameters"></a>参数

*dwAlignment*<br/>
[in]指定窗格对齐方式。

*nOffset*<br/>
[in]量 （以像素为单位，要移动的窗格和虚拟的矩形）。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*dwAlignment*可以是任何以下值：

|值|描述|
|-----------|-----------------|
|CBRS_ALIGN_TOP|使窗格停靠到框架窗口的工作区的顶部。|
|CBRS_ALIGN_BOTTOM|使窗格停靠到框架窗口的工作区的底部。|
|CBRS_ALIGN_LEFT|使左侧和右侧的框架窗口的客户端区域停靠窗格。|
|CBRS_ALIGN_RIGHT|使框架窗口的客户端区域的右侧停靠的窗格。|
|CBRS_ALIGN_ANY|使窗格停靠到框架窗口的工作区的任何一侧。|

如果*dwAlignment*包含 CBRS_ALIGN_LEFT 或 CBRS_ALIGN_RIGHT 标志，在窗格和虚拟矩形移动水平; 否则为如果*dwAlignment*包含 CBRS_ALIGN_TOP 或 CBRS_ALIGN垂直移动位居标志、 窗格和虚拟的矩形。

##  <a name="movepane"></a>  CPane::MovePane

将窗格移动到指定的矩形。

```
virtual CSize MovePane(
    CRect rectNew,
    BOOL bForceMove,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*rectNew*<br/>
[in]指定新矩形的窗格。

*bForceMove*<br/>
[in]如果为 TRUE，此方法将忽略允许的最小窗格大小 ( [CPane::GetMinSize](#getminsize)); 否则为如果有必要，以确保它至少是最小允许大小调整窗格。

*hdwp*<br/>
[in]不使用。

### <a name="return-value"></a>返回值

一个`CSize`对象，其中包含新的和旧矩形的宽度和高度差异 (旧矩形- *rectNew*)。

### <a name="remarks"></a>备注

此方法仅用于可停靠窗格。

##  <a name="onafterchangeparent"></a>  CPane::OnAfterChangeParent

一个窗格的父级发生更改时由框架调用。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>参数

*pWndOldParent*<br/>
[in、 out]该窗格的上一个父窗口。

### <a name="remarks"></a>备注

当窗格的父由于停靠或浮动的操作而发生更改时，由框架调用此方法。

##  <a name="onafterdock"></a>  CPane::OnAfterDock

已停靠窗格时，由框架调用。

```
virtual void OnAfterDock(
    CBasePane* pBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pBar*<br/>
[in]未使用此参数。

*lpRect*<br/>
[in]未使用此参数。

*dockMethod*<br/>
[in]未使用此参数。

##  <a name="onafterfloat"></a>  CPane::OnAfterFloat

后一个窗格浮动，由框架调用。

```
virtual void OnAfterFloat();
```

### <a name="remarks"></a>备注

如果你想要一个窗格浮动后执行任何处理，可以重写此方法在派生类中。

##  <a name="onbeforechangeparent"></a>  CPane::OnBeforeChangeParent

在窗格的父即将更改时由框架调用。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*pWndNewParent*<br/>
[in、 out]指定新的父窗口。

*bDelay*<br/>
[in]为 TRUE，则延迟的全局停靠布局调整;否则为 FALSE。

### <a name="remarks"></a>备注

由框架调用此方法，当窗格的父级是要更改，因为正在窗格停靠或浮动。

默认情况下，在窗格是停靠的窗格中注销通过调用`CDockSite::RemovePane`。

##  <a name="onbeforedock"></a>  CPane::OnBeforeDock

要停靠窗格时，由框架调用。

```
virtual BOOL OnBeforeDock(
    CBasePane** ppDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*ppDockBar*<br/>
[in、 out]指定此窗格停靠到窗格。

*lpRect*<br/>
[in]指定停靠的矩形。

*dockMethod*<br/>
[in]指定的扩展方法。

### <a name="return-value"></a>返回值

如果可以停靠窗格，则为 TRUE。 如果该函数将返回 FALSE，将中止停靠的操作。

### <a name="remarks"></a>备注

要停靠窗格时，由框架调用此方法。 如果你想要执行任何处理之前最后停靠窗格，可以重写此方法在派生类中。

##  <a name="onbeforefloat"></a>  CPane::OnBeforeFloat

当窗格时有关为浮点数，由框架调用。

```
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
[in]当处于浮动状态时指定的位置和窗格的大小。

*dockMethod*<br/>
[in]指定在窗格的停靠方法。

### <a name="return-value"></a>返回值

如果可以浮动窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

当窗格时有关为浮点数，由框架调用此方法。 如果你想要执行任何处理之前最后浮动窗格，可以重写此方法在派生类中。

##  <a name="onpressclosebutton"></a>  CPane::OnPressCloseButton

在用户在窗格的标题上按关闭按钮时由框架调用。

```
virtual void OnPressCloseButton();
```

### <a name="remarks"></a>备注

由框架调用此方法，当用户按下**关闭**上窗格的标题按钮。 若要接收通知有关**关闭**事件，可以重写此方法在派生类中的。

##  <a name="onshowcontrolbarmenu"></a>  CPane::OnShowControlBarMenu

当即将显示特殊窗格菜单时由框架调用。

```
virtual BOOL OnShowControlBarMenu(CPoint point);
```

### <a name="parameters"></a>参数

*point*<br/>
[in]指定菜单位置。

### <a name="return-value"></a>返回值

如果可以显示菜单; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

菜单包含多个项，您可以指定该窗格的行为，即：**浮动**，**停靠**，**自动隐藏**，并且**隐藏**。 可以通过调用来启用此菜单中的所有窗格[CDockingManager::EnableDockSiteMenu](../../mfc/reference/cdockingmanager-class.md#enabledocksitemenu)。

##  <a name="recalclayout"></a>  CPane::RecalcLayout

重新计算在窗格的布局信息。

```
virtual void RecalcLayout();
```

### <a name="remarks"></a>备注

如果停靠窗格中，此方法将更新通过其大小设置为窗格中的当前大小的窗格中的虚拟矩形。

如果窗格浮动的此方法将通知父微型框架可调整大小的窗格为最小化帧的大小。 框架将确保最小化框架至少是允许在窗格的大小的最小 ( [CPane::GetMinSize](#getminsize)) 和调整微型框架，如有必要。

##  <a name="savestate"></a>  CPane::SaveState

将窗格的状态保存到注册表。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpszProfileName*<br/>
[in]配置文件名称。

*nIndex*<br/>
[in]配置文件的索引。

*uiID*<br/>
[in]窗格 id。

### <a name="return-value"></a>返回值

如果成功，则保存状态，则返回 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

它将窗格的状态保存到注册表时，框架将调用此方法。 重写`SaveState`在派生类来存储的其他信息。

当重写此方法时，还调用基方法，并返回 FALSE 的基方法返回 FALSE。

##  <a name="setactiveingroup"></a>  CPane::SetActiveInGroup

标记为活动状态的窗格。

```
virtual void SetActiveInGroup(BOOL bActive);
```

### <a name="parameters"></a>参数

*bActive*<br/>
[in]一个布尔值，指定是否在窗格标记为活动状态。

### <a name="remarks"></a>备注

当显示可停靠窗格或选择自动隐藏按钮时，相应的自动隐藏窗格标记为活动。

与窗格关联的自动隐藏按钮的外观取决于两个因素。 如果窗格处于活动状态，并且`static BOOL CMFCAutoHideButton::m_bOverlappingTabs`为 TRUE，则框架显示自动隐藏按钮图标和标签。 对于处于非活动状态的窗格中，框架将显示仅自动隐藏图标。

如果`CMFCAutoHideButton::m_bOverlappingTabs`为 FALSE，或如果窗格不在组中，框架将关联的自动隐藏按钮显示为图标和标签。

##  <a name="setborders"></a>  CPane::SetBorders

设置窗格的边框值。

```
void SetBorders(
    int cxLeft = 0,
    int cyTop = 0,
    int cxRight = 0,
    int cyBottom = 0);

void SetBorders(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*cxLeft*<br/>
[in]指定以像素为单位，窗格的左边框的宽度。

*cyTop*<br/>
[in]指定以像素为单位，窗格的上边框的宽度。

*cxRight*<br/>
[in]指定以像素为单位，窗格的右边框的宽度。

*cyBottom*<br/>
[in]指定以像素为单位，窗格的下边框的宽度。

*lpRect*<br/>
[in]一个[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含以像素为单位，每个窗格的边框的宽度。

### <a name="remarks"></a>备注

调用此函数可设置窗格的边框的大小。

##  <a name="setclienthotspot"></a>  CPane::SetClientHotSpot

集*热点*窗格。

```
void SetClientHotSpot(const CPoint& ptNew);
```

### <a name="parameters"></a>参数

*ptNew*<br/>
[in]一个`CPoint`对象，它指定新的作用点。

### <a name="remarks"></a>备注

*热点*是在用户选择并按住以移动该窗格的窗格上的点。 作用点用于从停靠位置拖动窗格时流畅的动画。

##  <a name="setdockstate"></a>  CPane::SetDockState

还原停靠窗格的状态信息。

```
virtual void SetDockState(CDockingManager* pDockManager);
```

### <a name="parameters"></a>参数

*pDockManager*<br/>
[in]指向主框架窗口到停靠管理器。

### <a name="remarks"></a>备注

若要还原在窗格停靠的最近状态信息的框架调用此方法。 一个窗格，将存储在最近的停靠状态信息[cpane:: M_recentdockinfo](#m_recentdockinfo)。 有关详细信息，请参阅[CRecentDockSiteInfo 类](../../mfc/reference/crecentdocksiteinfo-class.md)。

此外可以调用此方法以设置停靠状态，当您从外部源加载窗格的信息。

##  <a name="setexclusiverowmode"></a>  CPane::SetExclusiveRowMode

启用或禁用的排他行模式。

```
virtual void SetExclusiveRowMode(BOOL bExclusive = TRUE);
```

### <a name="parameters"></a>参数

*bExclusive*<br/>
[in]如果启用了排他行模式，则为否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法来启用或禁用排他行模式。 排他行模式下一个窗格时，它不能与任何其他工具栏共享同一行。

默认情况下，所有工具栏都具有禁用的排他行模式，菜单栏中的已启用的排他行模式。

##  <a name="setminsize"></a>  CPane::SetMinSize

设置的最小允许大小的窗格。

```
void SetMinSize(const CSize& size);
```

### <a name="parameters"></a>参数

*size*<br/>
[in]一个`CSize`对象，其中包含的最小允许大小的窗格。

### <a name="remarks"></a>备注

##  <a name="setvirtualrect"></a>  CPane::SetVirtualRect

集*虚拟矩形*的窗格。

```
void SetVirtualRect(
    const CRect& rect,
    BOOL bMapToParent = TRUE);
```

### <a name="parameters"></a>参数

*rect*<br/>
[in]一个`CRect`对象，它指定要设置的虚拟矩形。

*bMapToParent*<br/>
[in]如果指定为 TRUE *rect*包含相对于父窗口的点。

### <a name="remarks"></a>备注

一个*虚拟矩形*时它将被移动，将存储一个窗格的原始位置。 框架可以使用的虚拟矩形还原到原始位置。

不要调用除非要以编程方式移动窗格相关的虚拟矩形的方法。

##  <a name="setminiframertc"></a>  CPane::SetMiniFrameRTC

设置默认微型框架窗口的运行时类信息。

```
void SetMiniFrameRTC(CRuntimeClass* pClass);
```

### <a name="parameters"></a>参数

*pClass*<br/>
[in、 out]指定微型框架窗口的运行时类信息。

### <a name="remarks"></a>备注

浮动窗格中，将被放[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md) （最小化框架） 窗口。 可以提供自定义`CPaneFrameWnd`的派生类将成为时使用[cpane:: Createdefaultminiframe](#createdefaultminiframe)调用。

##  <a name="stretchpanedeferwndpos"></a>  CPane::StretchPaneDeferWndPos

拉伸垂直或水平停靠样式基于的窗格。

```
virtual int StretchPaneDeferWndPos(
    int nStretchSize,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*nStretchSize*<br/>
[in]量 （以像素为单位，拉伸窗格）。 使用负值收缩窗格。

*hdwp*<br/>
[in]不使用。

### <a name="return-value"></a>返回值

实际的量，以像素为单位，在窗格已延伸。

### <a name="remarks"></a>备注

如果有必要，此方法修改*nStretchSize*以确保在窗格不会超过大小限制。 这些限制获取通过调用[CPane::GetAvailableStretchSize](#getavailablestretchsize)并[CPane::GetAvailableExpandSize](#getavailableexpandsize)。

##  <a name="toggleautohide"></a>  CPane::ToggleAutoHide

切换自动隐藏模式。

```
virtual void ToggleAutoHide();
```

### <a name="remarks"></a>备注

调用此方法以切换到自动隐藏模式。 若要切换到自动隐藏模式，必须向主框架窗口停靠窗格。

##  <a name="undockpane"></a>  CPane::UndockPane

从停靠站点、 默认滑块或当前停靠位置的微型框架窗口删除窗格。

```
virtual void UndockPane(BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*bDelay*<br/>
[in]如果为 FALSE，框架将调用[cbasepane:: Adjustdockinglayout](../../mfc/reference/cbasepane-class.md#adjustdockinglayout)调整停靠布局。

### <a name="remarks"></a>备注

使用此方法以编程方式取消停靠窗格。

##  <a name="updatevirtualrect"></a>  CPane::UpdateVirtualRect

更新的虚拟矩形。

```
void UpdateVirtualRect();
void UpdateVirtualRect(CPoint ptOffset);
  void UpdateVirtualRect(CSize sizeNew);
```

### <a name="parameters"></a>参数

*ptOffset*<br/>
[in]一个`CPoint`对象，它指定按其轮换窗格中的偏移量。

*sizeNew*<br/>
[in]一个`CSize`对象，它指定窗格中的新大小。

### <a name="remarks"></a>备注

第一个重载使用当前位置和窗格的大小设置的虚拟矩形。

第二个重载右移指定的量的虚拟矩形*ptOffset*。

第三个重载使用当前窗格和由指定的大小的位置设置的虚拟矩形*大小*。

## <a name="see-also"></a>请参阅

[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CBasePane 类](../../mfc/reference/cbasepane-class.md)
