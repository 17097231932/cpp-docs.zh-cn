---
title: 2.4.1 for 构造 |Microsoft 文档
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 27d2cbce-786b-4819-91d3-d55b2cc57a5e
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: d5165c21f0bf6f2b9757550208d5e8e26a2bd3b1
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2018
---
# <a name="241-for-construct"></a>2.4.1 for 构造
**为**指令标识了指定的关联的循环迭代将并行执行的迭代工作共享构造。 迭代**为**循环分布在团队执行的并行构造，它将绑定中已存在的线程。 语法**为**构造是，如下所示：  
  
```  
#pragma omp for [clause[[,] clause] ... ] new-linefor-loop  
```  
  
 子句是以下项之一：  
  
 **private(** *variable-list* **)**  
  
 **firstprivate(** *variable-list* **)**  
  
 **lastprivate(** *variable-list* **)**  
  
 **减少 (** *运算符* **:** *变量的列表 * * *)**  
  
 **排序**  
  
 **计划 (** *类型*[，*使用 chunk_size*]**)**  
  
 **nowait**  
  
 **为**指令在相应的结构上放置限制**为**循环。 具体而言，相应**为**循环必须具有规范的形状：  
  
 **有关 (** *init expr* **;***var 逻辑操作 b*;*incr-expr * * *)**  
  
 *init expr*  
 以下项之一：  
  
 *var* = *lb*  
  
 *整数类型 var* = *lb*  
  
 *incr expr*  
 以下项之一：  
  
 ++*Var*  
  
 *var* ++  
  
 -- *Var*  
  
 *var* --  
  
 *var* += *incr*  
  
 *var* -= *incr*  
  
 *var* = *var* + *incr*  
  
 *var* = *incr* + *var*  
  
 *var* = *var* - *incr*  
  
 *var*  
 一个有符号的整数的变量。 如果此变量将否则共享，它隐式设为专用的持续时间内**为**。   此变量不能修改主体中**为**语句。 除非指定变量**lastprivate**，其值后循环是不确定的。  
  
 *逻辑操作*  
 以下项之一：  
  
 <  
  
 \<=  
  
 >  
  
 \>=  
  
 *lb*， *b*，和*incr*  
 循环固定的整数表达式。 没有在这些表达式的计算期间同步。 因此，任何计算的方面的副作用产生不确定的结果。  
  
 请注意，该规范的窗体允许的循环迭代将计算在进入循环数。 使用中的类型的值执行此计算*var*之后整型提升。 特别地，如果值*b* - *lb* + *incr*不能表示在于类型，结果是不确定的。 此外，如果*逻辑操作*是 < 或\<然后 = *incr expr*必须导致*var*循环的每个迭代上增加。   如果*逻辑操作*是 > 或 > 然后 = *incr expr*必须导致*var*以减少循环的每个迭代上。  
  
 **计划**子句指定如何迭代**为**循环划分的团队的线程。 程序的正确性必须不依赖于哪个线程执行的特定迭代。 值*使用 chunk_size*，如果指定，必须用正值是循环固定的整数表达式。 没有在此表达式的计算期间同步。 因此，任何计算的方面的副作用产生不确定的结果。 计划*类型*可以是以下之一：  
  
 表 2-1**计划**子句*类型*值  
  
|||  
|-|-|  
|静态|当**计划 (静态的***使用 chunk_size * * *)** 迭代划分为区块的指定大小的指定*使用 chunk_size*。 消息块以静态方式分配给线程号顺序以轮循机制方式团队中的线程。 如果没有*使用 chunk_size*指定，则迭代空间划分为区块与分配给每个线程的一个块区的大小，大致相等的。|  
|dynamic|当**计划 (动态的***使用 chunk_size * * *)** 迭代划分为区块，每个包含的一系列的指定*使用 chunk_size*迭代。 每个区块分配给正在等待分配的线程。 线程执行的迭代区块，然后等待其下一步的分配，直到没有块保持可以被指定。 请注意，要分配的最后一个块区可能具有较小数目的迭代。 如果没有*使用 chunk_size*指定，则它默认为 1。|  
|引导式|当**计划 (有作为指导，** *使用 chunk_size * * *)** 指定，则迭代分配给递减大小的小区块中的线程。 线程在完成时的迭代其已分配的块，它是动态分配另一个区块，直到未保留任何。 有关*使用 chunk_size*的每个块区大小为 1，是大约的未分配的线程数的一半的迭代数。 这些大小减少大约指数级增长至 1。 有关*使用 chunk_size*值*k*大于 1，大小大约减少指数级增长到*k*，只不过最后一个区块可能具有少于*k*迭代。 如果没有*使用 chunk_size*指定，则它默认为 1。|  
|Runtime — 运行时|当**schedule （runtime)** 指定，则有关计划被推迟到运行时的决策。 计划*类型*和通过设置环境变量，可以在运行时选择各区块大小**OMP_SCHEDULE**。 如果未设置此环境变量，生成的计划是实现定义的。 当**schedule （runtime)** 指定，则*使用 chunk_size*不能指定。|  
  
 在没有显式定义**计划**子句，则默认**计划**是实现定义的。  
  
 OpenMP 兼容的程序不应依赖于正确的执行的特定计划。 程序不应依赖于计划*类型*精确符合上面提供的说明，因为它是可以具有相同的计划的实现中的变体*类型*跨不同的编译器。 描述可用来选择适合于特定的情况的计划。  
  
 **排序**子句必须存在时**排序**指令将绑定到**为**构造。  
  
 在末尾没有隐式屏障**为**构造，除非**nowait**指定子句。  
  
 限制到**为**指令如下所示：  
  
-   **为**循环必须是结构化的块中，并且，此外，其执行不都必须通过终止**中断**语句。  
  
-   循环的值控制的表达式**为**与关联的循环**为**指令必须是相同的组中的所有线程。  
  
-   **为**循环迭代变量必须具有带符号的整数类型。  
  
-   只有一个**计划**子句可以出现在**为**指令。  
  
-   只有一个**排序**子句可以出现在**为**指令。  
  
-   只有一个**nowait**子句可以出现在**为**指令。  
  
-   它是未指定的如果或任何一侧频率效果内*使用 chunk_size*， *lb*， *b*，或*incr*表达式发生。  
  
-   值*使用 chunk_size*表达式必须是相同的组中的所有线程。  
  
## <a name="cross-references"></a>交叉引用：  
  
-   **私有**， **firstprivate**， **lastprivate**，和**缩减**子句，请参阅[部分 2.7.2](../../parallel/openmp/2-7-2-data-sharing-attribute-clauses.md)第 25 页上。  
  
-   **OMP_SCHEDULE**环境变量，请参阅[第 4.1 节](../../parallel/openmp/4-1-omp-schedule.md)第 48 页。  
  
-   **排序**构造，请参阅[部分 2.6.6](../../parallel/openmp/2-6-6-ordered-construct.md)页 22 上。  
  
-   [附录 D](../../parallel/openmp/d-using-the-schedule-clause.md)，页上 93，提供了有关使用计划子句的详细信息。