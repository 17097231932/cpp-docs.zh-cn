---
description: 了解有关以下内容的详细信息：编译器错误 C2600 到 C2699
title: 编译器错误 C2600 - C2699
ms.date: 04/21/2019
f1_keywords:
- C2604
- C2606
- C2607
- C2608
- C2609
- C2610
- C2615
- C2618
- C2620
- C2621
- C2622
- C2623
- C2625
- C2629
- C2631
- C2639
- C2641
- C2642
- C2643
- C2644
- C2684
- C2685
- C2686
- C2697
helpviewer_keywords:
- C2604
- C2606
- C2607
- C2608
- C2609
- C2610
- C2615
- C2618
- C2620
- C2621
- C2622
- C2623
- C2625
- C2629
- C2631
- C2639
- C2641
- C2642
- C2643
- C2644
- C2684
- C2685
- C2686
- C2697
ms.assetid: 73c6319f-cbea-4a2f-913b-90dc1af61f64
ms.openlocfilehash: 6baced0b735d48cb00e316850b87a42cf301a878
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238838"
---
# <a name="compiler-errors-c2600-through-c2699"></a>编译器错误 C2600 - C2699

文档的本节中的文章介绍了编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|错误|消息|
|-----------|-------------|
|[编译器错误 C2600](compiler-error-c2600.md)|"*function*"：不能定义编译器生成的特殊成员函数 (必须先在类中声明) |
|[编译器错误 C2601](compiler-error-c2601.md)|"*function*"：本地函数定义是非法的|
|[编译器错误 C2602](compiler-error-c2602.md)|"*class*：：*identifier*" 不是 "*class*" 基类的成员|
|[编译器错误 C2603](compiler-error-c2603.md)|"*function*"：函数中有构造函数/析构函数的块范围静态对象太多|
|编译器错误 C2604|"*identifier*"：无法实现多个接口方法|
|[编译器错误 C2605](compiler-error-c2605.md)|"*identifier*"：此方法是在托管的/WinRT 类中保留的|
|编译器错误 C2606|"*class1*"：无法重新实现 "*member*"，因为它继承自运行时基 "*class2*"|
|编译器错误 C2607|静态断言失败|
|编译器错误 C2608|已过时。|
|编译器错误 C2609|已过时。|
|编译器错误 C2610|"*class*：：*member*"：不是可默认的特殊成员函数|
|[编译器错误 C2611](compiler-error-c2611.md)|"*token*"：非法后面的 "~" (所需的标识符) |
|[编译器错误 C2612](compiler-error-c2612.md)|基/成员初始值设定项列表中的后缀 "*character*" 非法|
|[编译器错误 C2613](compiler-error-c2613.md)|基类列表中的后缀 "*character*" 非法|
|[编译器错误 C2614](compiler-error-c2614.md)|"*class*"：非法的成员初始化： "*identifier*" 不是基或成员|
|编译器错误 C2615|已过时。|
|[编译器错误 C2616](compiler-error-c2616.md)|"*转换*"：无法将非 lvalue "*type1*" 隐式转换为不是常量的 "*type2*"|
|[编译器错误 C2617](compiler-error-c2617.md)|"*function*"：返回语句不一致|
|编译器错误 C2618|已过时。|
|[编译器错误 C2619](compiler-error-c2619.md)|"*identifier*"：匿名结构/联合中不允许使用静态数据成员|
|编译器错误 C2620|已过时。|
|编译器错误 C2621|已过时。|
|编译器错误 C2622|已过时。|
|编译器错误 C2623|已过时。|
|[编译器错误 C2624](compiler-error-c2624.md)|"*scope*：：*type*"：局部类不能用于声明 "extern" 变量|
|编译器错误 C2625|"*identifier*"：非法的联合成员;类型 "*type*" 是引用类型|
|[编译器错误 C2626](compiler-error-c2626.md)|"*identifier*"：匿名结构/联合中不允许使用私有/受保护的数据成员|
|[编译器错误 C2627](compiler-error-c2627.md)|"*function*"：匿名联合中不允许使用成员函数|
|[编译器错误 C2628](compiler-error-c2628.md)|"*type1*" 后跟 "*type2*" 是非法的 (您是否忘记了 ";"？) |
|编译器错误 C2629|"*identifier*"：匿名结构/联合不能声明嵌套类型|
|[编译器错误 C2630](compiler-error-c2630.md)|"*symbol*" 在应是逗号分隔列表的内容中找到|
|编译器错误 C2631|"*identifier*"：别名模板中不能定义类或枚举|
|[编译器错误 C2632](compiler-error-c2632.md)|"*type1*" 后跟 "*type2*" 是非法的|
|[编译器错误 C2633](compiler-error-c2633.md)|"*identifier*"： "inline" 是构造函数的唯一合法存储类|
|[编译器错误 C2634](compiler-error-c2634.md)|"*class*：：*member*"：指向引用成员的指针是非法的|
|[编译器错误 C2635](compiler-error-c2635.md)|无法将 "*type1* \* " 转换为 "*type2* \* "; 暗含了从虚拟基类的转换|
|[编译器错误 C2636](compiler-error-c2636.md)|"*identifier*"：指向引用成员的指针是非法的|
|[编译器错误 C2637](compiler-error-c2637.md)|"*identifier*"：不能修改指向数据成员的指针|
|[编译器错误 C2638](compiler-error-c2638.md)|"*identifier*"： __based 修饰符在指向成员的指针上非法|
|编译器错误 C2639|已过时。|
|[编译器错误 C2640](compiler-error-c2640.md)|"*identifier*"： __based 修饰符在引用上非法|
|编译器错误 C2641|已过时。|
|编译器错误 C2642|已过时。|
|编译器错误 C2643|已过时。|
|编译器错误 C2644|已过时。|
|[编译器错误 C2645](compiler-error-c2645.md)|指向成员的指针没有限定名 (找到 "：： *" ) |
|[编译器错误 C2646](compiler-error-c2646.md)|全局或命名空间范围内的匿名结构/联合必须声明为静态|
|[编译器错误 C2647](compiler-error-c2647.md)|"*operator*"：无法取消引用 "*type2*" 上的 "*type1*"|
|[编译器错误 C2648](compiler-error-c2648.md)|"*identifier*"：将成员用作默认参数需要静态成员|
|[编译器错误 C2649](compiler-error-c2649.md)|"*identifier*"：不是 "class/struct/union"|
|[编译器错误 C2650](compiler-error-c2650.md)|"*operator*"：不能是虚函数|
|[编译器错误 C2651](compiler-error-c2651.md)|"*type*"： "：：" 的左边必须是类、结构或联合|
|[编译器错误 C2652](compiler-error-c2652.md)|"*identifier*"：非法的复制构造函数：第一个参数不能是 "*type*"|
|[编译器错误 C2653](compiler-error-c2653.md)|"*identifier*"：不是类或命名空间名称|
|[编译器错误 C2654](compiler-error-c2654.md)|"*identifier*"：尝试访问成员函数的外部成员|
|[编译器错误 C2655](compiler-error-c2655.md)|"*identifier*"：当前范围内的定义或重新声明非法|
|[编译器错误 C2656](compiler-error-c2656.md)|"*function*"：函数不能作为位域|
|[编译器错误 C2657](compiler-error-c2657.md)|在语句的开始找到 "*class*：:*" (是否忘记指定类型？ ) |
|[编译器错误 C2658](compiler-error-c2658.md)|"*identifier*"：匿名结构/联合中的重定义|
|[编译器错误 C2659](compiler-error-c2659.md)|"*operator*"：作为左操作数的函数|
|[编译器错误 C2660](compiler-error-c2660.md)|"*function*"：函数不采用 *number* 参数|
|[编译器错误 C2661](compiler-error-c2661.md)|"*function*"：没有重载函数使用 *数字* 参数|
|[编译器错误 C2662](compiler-error-c2662.md)|"*function*"：不能将 "this" 指针从 "*type1*" 转换为 "*type2*"|
|[编译器错误 C2663](compiler-error-c2663.md)|"*function*"： *数字* 重载没有 "this" 指针的合法转换|
|[编译器错误 C2664](compiler-error-c2664.md)|"*function*"：无法将自变量 *数* 从 "*type1*" 转换为 "*type2*"|
|[编译器错误 C2665](compiler-error-c2665.md)|"*function*"：任何一个 *数字* 重载都无法转换所有参数类型|
|[编译器错误 C2666](compiler-error-c2666.md)|"*function*"： *数字* 重载具有相似的转换|
|[编译器错误 C2667](compiler-error-c2667.md)|"*function*"：所有 *数字* 重载都没有最佳转换|
|[编译器错误 C2668](compiler-error-c2668.md)|"*function*"：对重载函数的调用不明确|
|[编译器错误 C2669](compiler-error-c2669.md)|匿名联合中不允许使用成员函数|
|[编译器错误 C2670](compiler-error-c2670.md)|"*function*"：函数模板不能从类型 "*type*" 转换参数 *号*|
|[编译器错误 C2671](compiler-error-c2671.md)|"*function*"：静态成员函数没有 "this" 指针|
|[编译器错误 C2672](compiler-error-c2672.md)|"*function*"：未找到匹配的重载函数|
|[编译器错误 C2673](compiler-error-c2673.md)|"*function*"：全局函数没有 "this" 指针|
|[编译器错误 C2674](compiler-error-c2674.md)|此上下文中不允许泛型声明|
|[编译器错误 C2675](compiler-error-c2675.md)|一元 "*operator*"： "*type*" 不定义此运算符或对预定义运算符可接受的类型的转换|
|[编译器错误 C2676](compiler-error-c2676.md)|二元 "*operator*"： "*type*" 不定义此运算符或对预定义运算符可接受的类型的转换|
|[编译器错误 C2677](compiler-error-c2677.md)|二进制 "*operator*"：找不到使用类型 "*type*" 的全局运算符 (或没有可接受的转换) |
|[编译器错误 C2678](compiler-error-c2678.md)|二进制 "*operator*"：没有找到接受 "*type* (" 类型的左操作数的运算符，或者没有可接受的转换) |
|[编译器错误 C2679](compiler-error-c2679.md)|二进制 "*operator*"：找不到接受 "*type*" 类型的右操作数的运算符， (或没有可接受的转换) |
|[编译器错误 C2680](compiler-error-c2680.md)|"*type*"：*转换* 的目标类型无效|
|[编译器错误 C2681](compiler-error-c2681.md)|"*type*"： *cast* 的表达式类型无效|
|[编译器错误 C2682](compiler-error-c2682.md)|不能使用 "*cast*" 从 "*type1*" 转换为 "*type2*"|
|[编译器错误 C2683](compiler-error-c2683.md)|"*cast*"： "*type*" 不是多态类型|
|编译器错误 C2684|"*声明符*"：托管或 WinRT 类中不支持删除的和默认的函数|
|编译器错误 C2685|"*声明符*"：显式限制说明符不支持删除的和默认的函数|
|编译器错误 C2686|不能重载具有相同参数类型的静态和非静态成员函数|
|[编译器错误 C2687](compiler-error-c2687.md)|"*type*"：异常声明不能为 "void"，也不能表示不完整类型或指向不完整类型的指针或引用|
|[编译器错误 C2688](compiler-error-c2688.md)|"*type*：：*member*"：对 varargs 函数不支持具有多个或虚拟继承的协变返回|
|[编译器错误 C2689](compiler-error-c2689.md)|"*function*"：不能在局部类中定义友元函数|
|[编译器错误 C2690](compiler-error-c2690.md)|"*operator*"：不能对托管/WinRT 数组执行指针算法|
|[编译器错误 C2691](compiler-error-c2691.md)|"*type*"：托管的/WinRT 数组不能有此元素类型|
|[编译器错误 C2692](compiler-error-c2692.md)|"*function*"： C 编译器中的完全原型函数需要 "/clr" 选项|
|[编译器错误 C2693](compiler-error-c2693.md)|"*operator*"：对托管/WinRT 数组引用的比较非法|
|[编译器错误 C2694](compiler-error-c2694.md)|"*override_function*"：重写虚函数的限制性异常规范比基类虚成员函数 "*base_function*" 少|
|[编译器错误 C2695](compiler-error-c2695.md)|"*override_function*"：重写虚函数不同于 "*base_function*" 的调用约定|
|[编译器错误 C2696](compiler-error-c2696.md)|无法创建托管/WinRT 类型 "*type*" 的临时对象|
|编译器错误 C2697|已过时。|
|[编译器错误 C2698](compiler-error-c2698.md)|"*declaration1*" 的 using 声明不能与 "*declaration2*" 的现有 using 声明共存|

## <a name="see-also"></a>请参阅

[C/c + + 编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器错误 C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
