---
title: "Visual c + + ARM 迁移的常见问题 |Microsoft 文档"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
caps.latest.revision: "12"
author: corob-msft
ms.author: corob
manager: ghogen
ms.openlocfilehash: 458272a769fd1ce2076b6d80f5b3977a7c2ea7b5
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/24/2017
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 迁移的常见问题

在 x86 或 x64 体系结构上比，相同的 Visual c + + 源代码可能会产生不同的结果，在 ARM 体系结构。  
  
## <a name="sources-of-migration-issues"></a>源的迁移问题  

将代码从 x86 或 x64 体系结构迁移到 ARM 体系结构时可能遇到的许多问题相关可能调用未定义的实现定义的或未指定行为的源代码构造。  
  
*未定义的行为*  
C + + 标准不定义，并由具有不合理结果的操作导致的行为-例如，将浮点值转换为无符号整数，或使用的位置的数值为负或超过的数量来移位值与其提升的类型中的位。  
  
*实现定义的行为*  
C + + 标准要求编译器供应商联系，以定义和文档的行为。 即使这样做因此可能不能移植，程序可以安全地依赖于实现定义的行为。 实现定义的行为的示例包括内置数据类型和其对齐需求的大小。 实现定义的行为可能会影响运算的一个示例访问变量自变量列表。  
  
*未指定的行为*  
C + + 标准离开有意非确定性的行为。 尽管行为被视为非确定性，但未指定的行为的特定调用由编译器实现决定。 但是，编译器供应商以预先确定的结果或保证可比较的调用之间保持行为一致，不要求，并且没有文档，不要求。 未指定的行为的一个示例是中的子表达式的顺序 — 其中包括函数调用的参数-进行评估。  
  
其他迁移问题可以被归因于 ARM 和 x86 或 x64 体系结构以不同的方式与标准 c + + 交互之间的硬件差异。 例如，x86 和 x64 体系结构的强内存模型使`volatile`-限定已用于促进某些类型在过去的线程间通信的某些其他属性的变量。 但 ARM 体系结构的弱内存模型不支持使用时，也不 c + + 标准要求它。  
  
> [!IMPORTANT]
>  尽管`volatile`提升可用于 x86 和 x64，这些附加属性上实现线程间通信的有限的形式某些属性不能满足需求，以实现线程间的通信通常。 C + + 标准建议通过改为使用适当的同步基元来实现此类通信。  
  
不同的平台可能以不同的方式表达这些类型的行为，因为移植平台之间的软件可能很困难并且容易出错如果它依赖于特定平台的行为。 尽管许多这些类型的行为可以观察到，且可能会出现稳定，依赖于它们是至少不可移植的因此在未定义的或未指定行为的情况下，也是错误的。 即使在此文档中引用的行为，不能依靠和编译器或 CPU 实现，可以在将来更改。  
  
## <a name="example-migration-issues"></a>示例的迁移问题  

此文档的其余部分介绍如何这些 c + + 语言元素不同的行为会产生不同的平台上的不同结果。  
  
### <a name="conversion-of-floating-point-to-unsigned-integer"></a>为无符号整数的浮点转换  

在 ARM 体系结构，为 32 位整数的浮点值的转换会使更饱满到最近的浮点值是否可以表示整数的范围之外，可以表示整数的值。 X86 和 x64 体系结构中，转换将环绕如果整数是无符号整数，或如果签名整数设置为介于-2147483648。 这些体系结构的任何直接支持浮点值的转换为较小的整数类型;相反，为 32 位，执行的转换，结果被截断为较小的大小。  
  
对于 ARM 体系结构，饱和度和截断的组合意味着，转换为无符号类型正确会使更饱满较小的无符号的类型会使更饱满的 32 位整数，但生成的值大于一个截断的结果较小的类型可以表示但太小，以便使饱和完整的 32 位整数。 转换还会使更饱满正确 32 位有符号整数，但饱和，有符号整数的截断导致产生积极饱和值-1 和 0 表示产生负面饱和值。 为较小的带符号整数的转换会产生不可预知的截断的结果。  
  
X86 和 x64 体系结构无符号的整数转换环绕行为和在溢出时，以及截断，有符号的整数转换为显式求值的组合使结果对于大多数将它们是否不可预测太大。  
  
在处理 NaN （非数字） 转换为整数类型的方式也有差异这些平台。 在 ARM，NaN 将转换为 0x00000000;在 x86 和 x64 上，它将转换为 0x80000000。  
  
如果你知道将该值转换为整数类型的范围内，浮点转换可以仅依赖于中。  
  
### <a name="shift-operator---behavior"></a>移位运算符 (<\< >>) 行为  

在 ARM 体系结构上, 一个值可以要移动鼠标左键或右键最多 255 位模式开始重复之前。 X86 和 x64 体系结构模式将重复在每个多为 32 个除非模式的源是 64 位变量，例如：在这种情况下，在每个在 x64 和 x86，采用软件实现则上的 256 的每个倍数的 64 个的多个重复该模式。 例如，具有 32 位置向左移动 1 的值的 32 位变量，ARM 上的结果是 0、 在 x86 上的结果为 1，和 x64 上结果也是 1。 但是，如果值的源是 64 位变量，然后在所有三个平台上的结果为 4294967296，并且值不"环绕"直到它已在 x64 或 ARM 上的 256 位置和 x86 上移动 64 位置。  
  
由于超过的源类型中的位数的移位运算的结果是不确定，编译器不需要在所有情况下具有一致的行为。 例如，如果在 shift 两个操作数在编译时已知，编译器可能： 使用内部例程 precompute 移位的结果，然后替换代替移位运算的结果优化程序。 如果位移量太大，或负，内部例程的结果可能不同于相同的 shift 表达式的结果由 CPU 执行。  
  
### <a name="variable-arguments-varargs-behavior"></a>变量自变量 (varargs) 行为  

在 ARM 体系结构，从变量自变量列表在堆栈传递的参数将受到对齐方式。 例如，在 64 位边界上对齐 64 位参数。 在 x86 和 x64 上，在堆栈传递的参数不受对齐方式和包紧密。 这种差异可能会导致所示的可变参数函数`printf`读取用作 ARM 上的填充如果预期的布局的变量自变量列表不匹配完全匹配，即使它可能在 x86 上运行的某些值子集的内存地址或 x64 体系结构。 请看以下示例：  
  
```C  
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.  
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.  
// on ARM the calling convention will align the 64-bit value and the code will print a random value  
printf("%d\n", 1LL);     
```  
  
在这种情况下，通过确保使用正确的格式规范，从而修复 bug 以便被视为自变量的对齐方式。 此代码是正确的：  
  
```C  
// CORRECT: use %I64d for 64-bit integers  
printf("%I64d\n", 1LL);  
```  
  
### <a name="argument-evaluation-order"></a>自变量计算顺序  

因为 ARM、 x86，和 x64 处理器差别，因此，就可以提供不同的要求编译器实现中，而且还需要不同的优化机会。 以及其他因素，如调用约定和优化的设置，因此，编译器可能会计算上不同的体系结构或其他因素的更改时不同的顺序的函数自变量。 这可能导致的应用程序依赖于特定评估顺序，若要更改意外行为。  
  
当函数自变量产生副作用，影响在同一调用函数的其他参数，则会发生这种错误。 通常这种类型的依赖项是轻松避免，但它有时变得模糊不清通过依赖关系很难识别，或通过运算符重载。 请考虑此代码示例：  
  
```cpp  
handle memory_handle;  
  
memory_handle->acquire(*p);  
```  
  
这将显示定义完善，但是，如果`->`和`*`是重载的运算符，则此代码转换成类似于此：  
  
```cpp  
Handle::acquire(operator->(memory_handle), operator*(p));  
```  
  
如果没有之间的依赖项和`operator->(memory_handle)`和`operator*(p)`，代码可能依赖于特定评估顺序，即使原始代码如下所示不存在可能依赖。  
  
### <a name="volatile-keyword-default-behavior"></a>可变关键字默认行为  

Microsoft c + + 编译器支持的两个不同的解释`volatile`可以通过使用编译器开关指定的存储限定符。 **/Volatile: ms**开关用于选择 Microsoft 扩展可变语义，它能够保证强排序，因为已为 x86 和 x64 上 Microsoft 编译器的传统情况由于对强内存模型体系结构。 **/Volatile:iso**开关用于选择的严格 c + + 标准可变语义不能保证强排序。  
  
默认值是 ARM 体系结构， **/volatile:iso**由于 ARM 处理器具有弱排序内存模型，而且因为 ARM 软件不依赖于的扩展语义的旧**/volatile: ms**并且通常没有与执行的软件。 但是，它是仍有时方便或甚至需要编译 ARM 程序以使用扩展的语义。 例如，它可能过于昂贵，若要移植程序能够使用 ISO c + + 语义，或者驱动程序软件可能需要遵守的传统的语义，才能正常工作。 在这些情况下，你可以使用**/volatile: ms**交换机; 但是，要重新创建在 ARM 目标上的传统可变语义，编译器必须将插入解决每个读取或写入的内存屏障`volatile`变量以强制实施强排序，这可以对性能产生负面影响。  
  
X86 和 x64 体系结构中，默认值是**/volatile: ms**由于已创建针对这些体系结构使用的 Microsoft c + + 编译器的软件大部分依赖于它们。 X86 和 x64 程序编译时，你可以指定**/volatile:iso**交换机以帮助避免不必要依赖的传统的可变语义，并将提升可移植性。  
  
## <a name="see-also"></a>另请参阅  

[配置 ARM 处理器的 Visual c + +](../build/configuring-programs-for-arm-processors-visual-cpp.md)