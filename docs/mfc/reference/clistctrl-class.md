---
title: CListCtrl 类
ms.date: 06/13/2019
f1_keywords:
- CListCtrl
- AFXCMN/CListCtrl
- AFXCMN/CListCtrl::CListCtrl
- AFXCMN/CListCtrl::ApproximateViewRect
- AFXCMN/CListCtrl::Arrange
- AFXCMN/CListCtrl::CancelEditLabel
- AFXCMN/CListCtrl::Create
- AFXCMN/CListCtrl::CreateDragImage
- AFXCMN/CListCtrl::CreateEx
- AFXCMN/CListCtrl::DeleteAllItems
- AFXCMN/CListCtrl::DeleteColumn
- AFXCMN/CListCtrl::DeleteItem
- AFXCMN/CListCtrl::DrawItem
- AFXCMN/CListCtrl::EditLabel
- AFXCMN/CListCtrl::EnableGroupView
- AFXCMN/CListCtrl::EnsureVisible
- AFXCMN/CListCtrl::FindItem
- AFXCMN/CListCtrl::GetBkColor
- AFXCMN/CListCtrl::GetBkImage
- AFXCMN/CListCtrl::GetCallbackMask
- AFXCMN/CListCtrl::GetCheck
- AFXCMN/CListCtrl::GetColumn
- AFXCMN/CListCtrl::GetColumnOrderArray
- AFXCMN/CListCtrl::GetColumnWidth
- AFXCMN/CListCtrl::GetCountPerPage
- AFXCMN/CListCtrl::GetEditControl
- AFXCMN/CListCtrl::GetEmptyText
- AFXCMN/CListCtrl::GetExtendedStyle
- AFXCMN/CListCtrl::GetFirstSelectedItemPosition
- AFXCMN/CListCtrl::GetFocusedGroup
- AFXCMN/CListCtrl::GetGroupCount
- AFXCMN/CListCtrl::GetGroupInfo
- AFXCMN/CListCtrl::GetGroupInfoByIndex
- AFXCMN/CListCtrl::GetGroupMetrics
- AFXCMN/CListCtrl::GetGroupRect
- AFXCMN/CListCtrl::GetGroupState
- AFXCMN/CListCtrl::GetHeaderCtrl
- AFXCMN/CListCtrl::GetHotCursor
- AFXCMN/CListCtrl::GetHotItem
- AFXCMN/CListCtrl::GetHoverTime
- AFXCMN/CListCtrl::GetImageList
- AFXCMN/CListCtrl::GetInsertMark
- AFXCMN/CListCtrl::GetInsertMarkColor
- AFXCMN/CListCtrl::GetInsertMarkRect
- AFXCMN/CListCtrl::GetItem
- AFXCMN/CListCtrl::GetItemCount
- AFXCMN/CListCtrl::GetItemData
- AFXCMN/CListCtrl::GetItemIndexRect
- AFXCMN/CListCtrl::GetItemPosition
- AFXCMN/CListCtrl::GetItemRect
- AFXCMN/CListCtrl::GetItemSpacing
- AFXCMN/CListCtrl::GetItemState
- AFXCMN/CListCtrl::GetItemText
- AFXCMN/CListCtrl::GetNextItem
- AFXCMN/CListCtrl::GetNextItemIndex
- AFXCMN/CListCtrl::GetNextSelectedItem
- AFXCMN/CListCtrl::GetNumberOfWorkAreas
- AFXCMN/CListCtrl::GetOrigin
- AFXCMN/CListCtrl::GetOutlineColor
- AFXCMN/CListCtrl::GetSelectedColumn
- AFXCMN/CListCtrl::GetSelectedCount
- AFXCMN/CListCtrl::GetSelectionMark
- AFXCMN/CListCtrl::GetStringWidth
- AFXCMN/CListCtrl::GetSubItemRect
- AFXCMN/CListCtrl::GetTextBkColor
- AFXCMN/CListCtrl::GetTextColor
- AFXCMN/CListCtrl::GetTileInfo
- AFXCMN/CListCtrl::GetTileViewInfo
- AFXCMN/CListCtrl::GetToolTips
- AFXCMN/CListCtrl::GetTopIndex
- AFXCMN/CListCtrl::GetView
- AFXCMN/CListCtrl::GetViewRect
- AFXCMN/CListCtrl::GetWorkAreas
- AFXCMN/CListCtrl::HasGroup
- AFXCMN/CListCtrl::HitTest
- AFXCMN/CListCtrl::InsertColumn
- AFXCMN/CListCtrl::InsertGroup
- AFXCMN/CListCtrl::InsertGroupSorted
- AFXCMN/CListCtrl::InsertItem
- AFXCMN/CListCtrl::InsertMarkHitTest
- AFXCMN/CListCtrl::IsGroupViewEnabled
- AFXCMN/CListCtrl::IsItemVisible
- AFXCMN/CListCtrl::MapIDToIndex
- AFXCMN/CListCtrl::MapIndexToID
- AFXCMN/CListCtrl::MoveGroup
- AFXCMN/CListCtrl::MoveItemToGroup
- AFXCMN/CListCtrl::RedrawItems
- AFXCMN/CListCtrl::RemoveAllGroups
- AFXCMN/CListCtrl::RemoveGroup
- AFXCMN/CListCtrl::Scroll
- AFXCMN/CListCtrl::SetBkColor
- AFXCMN/CListCtrl::SetBkImage
- AFXCMN/CListCtrl::SetCallbackMask
- AFXCMN/CListCtrl::SetCheck
- AFXCMN/CListCtrl::SetColumn
- AFXCMN/CListCtrl::SetColumnOrderArray
- AFXCMN/CListCtrl::SetColumnWidth
- AFXCMN/CListCtrl::SetExtendedStyle
- AFXCMN/CListCtrl::SetGroupInfo
- AFXCMN/CListCtrl::SetGroupMetrics
- AFXCMN/CListCtrl::SetHotCursor
- AFXCMN/CListCtrl::SetHotItem
- AFXCMN/CListCtrl::SetHoverTime
- AFXCMN/CListCtrl::SetIconSpacing
- AFXCMN/CListCtrl::SetImageList
- AFXCMN/CListCtrl::SetInfoTip
- AFXCMN/CListCtrl::SetInsertMark
- AFXCMN/CListCtrl::SetInsertMarkColor
- AFXCMN/CListCtrl::SetItem
- AFXCMN/CListCtrl::SetItemCount
- AFXCMN/CListCtrl::SetItemCountEx
- AFXCMN/CListCtrl::SetItemData
- AFXCMN/CListCtrl::SetItemIndexState
- AFXCMN/CListCtrl::SetItemPosition
- AFXCMN/CListCtrl::SetItemState
- AFXCMN/CListCtrl::SetItemText
- AFXCMN/CListCtrl::SetOutlineColor
- AFXCMN/CListCtrl::SetSelectedColumn
- AFXCMN/CListCtrl::SetSelectionMark
- AFXCMN/CListCtrl::SetTextBkColor
- AFXCMN/CListCtrl::SetTextColor
- AFXCMN/CListCtrl::SetTileInfo
- AFXCMN/CListCtrl::SetTileViewInfo
- AFXCMN/CListCtrl::SetToolTips
- AFXCMN/CListCtrl::SetView
- AFXCMN/CListCtrl::SetWorkAreas
- AFXCMN/CListCtrl::SortGroups
- AFXCMN/CListCtrl::SortItems
- AFXCMN/CListCtrl::SortItemsEx
- AFXCMN/CListCtrl::SubItemHitTest
- AFXCMN/CListCtrl::Update
helpviewer_keywords:
- CListCtrl [MFC], CListCtrl
- CListCtrl [MFC], ApproximateViewRect
- CListCtrl [MFC], Arrange
- CListCtrl [MFC], CancelEditLabel
- CListCtrl [MFC], Create
- CListCtrl [MFC], CreateDragImage
- CListCtrl [MFC], CreateEx
- CListCtrl [MFC], DeleteAllItems
- CListCtrl [MFC], DeleteColumn
- CListCtrl [MFC], DeleteItem
- CListCtrl [MFC], DrawItem
- CListCtrl [MFC], EditLabel
- CListCtrl [MFC], EnableGroupView
- CListCtrl [MFC], EnsureVisible
- CListCtrl [MFC], FindItem
- CListCtrl [MFC], GetBkColor
- CListCtrl [MFC], GetBkImage
- CListCtrl [MFC], GetCallbackMask
- CListCtrl [MFC], GetCheck
- CListCtrl [MFC], GetColumn
- CListCtrl [MFC], GetColumnOrderArray
- CListCtrl [MFC], GetColumnWidth
- CListCtrl [MFC], GetCountPerPage
- CListCtrl [MFC], GetEditControl
- CListCtrl [MFC], GetEmptyText
- CListCtrl [MFC], GetExtendedStyle
- CListCtrl [MFC], GetFirstSelectedItemPosition
- CListCtrl [MFC], GetFocusedGroup
- CListCtrl [MFC], GetGroupCount
- CListCtrl [MFC], GetGroupInfo
- CListCtrl [MFC], GetGroupInfoByIndex
- CListCtrl [MFC], GetGroupMetrics
- CListCtrl [MFC], GetGroupRect
- CListCtrl [MFC], GetGroupState
- CListCtrl [MFC], GetHeaderCtrl
- CListCtrl [MFC], GetHotCursor
- CListCtrl [MFC], GetHotItem
- CListCtrl [MFC], GetHoverTime
- CListCtrl [MFC], GetImageList
- CListCtrl [MFC], GetInsertMark
- CListCtrl [MFC], GetInsertMarkColor
- CListCtrl [MFC], GetInsertMarkRect
- CListCtrl [MFC], GetItem
- CListCtrl [MFC], GetItemCount
- CListCtrl [MFC], GetItemData
- CListCtrl [MFC], GetItemIndexRect
- CListCtrl [MFC], GetItemPosition
- CListCtrl [MFC], GetItemRect
- CListCtrl [MFC], GetItemSpacing
- CListCtrl [MFC], GetItemState
- CListCtrl [MFC], GetItemText
- CListCtrl [MFC], GetNextItem
- CListCtrl [MFC], GetNextItemIndex
- CListCtrl [MFC], GetNextSelectedItem
- CListCtrl [MFC], GetNumberOfWorkAreas
- CListCtrl [MFC], GetOrigin
- CListCtrl [MFC], GetOutlineColor
- CListCtrl [MFC], GetSelectedColumn
- CListCtrl [MFC], GetSelectedCount
- CListCtrl [MFC], GetSelectionMark
- CListCtrl [MFC], GetStringWidth
- CListCtrl [MFC], GetSubItemRect
- CListCtrl [MFC], GetTextBkColor
- CListCtrl [MFC], GetTextColor
- CListCtrl [MFC], GetTileInfo
- CListCtrl [MFC], GetTileViewInfo
- CListCtrl [MFC], GetToolTips
- CListCtrl [MFC], GetTopIndex
- CListCtrl [MFC], GetView
- CListCtrl [MFC], GetViewRect
- CListCtrl [MFC], GetWorkAreas
- CListCtrl [MFC], HasGroup
- CListCtrl [MFC], HitTest
- CListCtrl [MFC], InsertColumn
- CListCtrl [MFC], InsertGroup
- CListCtrl [MFC], InsertGroupSorted
- CListCtrl [MFC], InsertItem
- CListCtrl [MFC], InsertMarkHitTest
- CListCtrl [MFC], IsGroupViewEnabled
- CListCtrl [MFC], IsItemVisible
- CListCtrl [MFC], MapIDToIndex
- CListCtrl [MFC], MapIndexToID
- CListCtrl [MFC], MoveGroup
- CListCtrl [MFC], MoveItemToGroup
- CListCtrl [MFC], RedrawItems
- CListCtrl [MFC], RemoveAllGroups
- CListCtrl [MFC], RemoveGroup
- CListCtrl [MFC], Scroll
- CListCtrl [MFC], SetBkColor
- CListCtrl [MFC], SetBkImage
- CListCtrl [MFC], SetCallbackMask
- CListCtrl [MFC], SetCheck
- CListCtrl [MFC], SetColumn
- CListCtrl [MFC], SetColumnOrderArray
- CListCtrl [MFC], SetColumnWidth
- CListCtrl [MFC], SetExtendedStyle
- CListCtrl [MFC], SetGroupInfo
- CListCtrl [MFC], SetGroupMetrics
- CListCtrl [MFC], SetHotCursor
- CListCtrl [MFC], SetHotItem
- CListCtrl [MFC], SetHoverTime
- CListCtrl [MFC], SetIconSpacing
- CListCtrl [MFC], SetImageList
- CListCtrl [MFC], SetInfoTip
- CListCtrl [MFC], SetInsertMark
- CListCtrl [MFC], SetInsertMarkColor
- CListCtrl [MFC], SetItem
- CListCtrl [MFC], SetItemCount
- CListCtrl [MFC], SetItemCountEx
- CListCtrl [MFC], SetItemData
- CListCtrl [MFC], SetItemIndexState
- CListCtrl [MFC], SetItemPosition
- CListCtrl [MFC], SetItemState
- CListCtrl [MFC], SetItemText
- CListCtrl [MFC], SetOutlineColor
- CListCtrl [MFC], SetSelectedColumn
- CListCtrl [MFC], SetSelectionMark
- CListCtrl [MFC], SetTextBkColor
- CListCtrl [MFC], SetTextColor
- CListCtrl [MFC], SetTileInfo
- CListCtrl [MFC], SetTileViewInfo
- CListCtrl [MFC], SetToolTips
- CListCtrl [MFC], SetView
- CListCtrl [MFC], SetWorkAreas
- CListCtrl [MFC], SortGroups
- CListCtrl [MFC], SortItems
- CListCtrl [MFC], SortItemsEx
- CListCtrl [MFC], SubItemHitTest
- CListCtrl [MFC], Update
ms.assetid: fe08a1ca-4b05-4ff7-a12a-ee4c765a2197
ms.openlocfilehash: 19939ce7dacc1b826e0a2f067c43fc65db328a54
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370156"
---
# <a name="clistctrl-class"></a>CListCtrl 类

封装显示一组项的“列表视图控件”功能，每一项均包含一个图标（来自图像列表）和标签。

## <a name="syntax"></a>语法

```
class CListCtrl : public CWnd
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|[CListCtrl：：CListCtrl](#clistctrl)|构造 `CListCtrl` 对象。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CListCtrl：：近似视图重新](#approximateviewrect)|确定显示列表视图控件项所需的宽度和高度。|
|[CListCtrl：排列](#arrange)|对齐网格上的项目。|
|[CListCtrl：：取消编辑标签](#canceleditlabel)|取消项目文本编辑操作。|
|[CListCtrl：：创建](#create)|创建列表控件并将其附加到`CListCtrl`对象。|
|[CListCtrl：：创建拖动图像](#createdragimage)|为指定项目创建拖动图像列表。|
|[CListCtrl：：创建Ex](#createex)|使用指定的 Windows 扩展样式创建列表控件，并将其附加到`CListCtrl`对象。|
|[CListCtrl：:DeleteAll项目](#deleteallitems)|从控件中删除所有项。|
|[CListCtrl：:DeleteColumn](#deletecolumn)|从列表视图控件中删除列。|
|[CListCtrl：:Delete项目](#deleteitem)|从控件中删除项。|
|[CListCtrl：:D原始项目](#drawitem)|当所有者绘制控件的可视方面发生更改时调用。|
|[CListCtrl：：编辑标签](#editlabel)|开始就地编辑项目的文本。|
|[CListCtrl：：启用群景视图](#enablegroupview)|启用或禁用列表视图控件中的项是否显示为组。|
|[CListCtrl：：确保可见](#ensurevisible)|确保项可见。|
|[CListCtrl：：查找项目](#finditem)|搜索具有指定特征的列表视图项。|
|[CListCtrl：getBkColor](#getbkcolor)|检索列表视图控件的背景颜色。|
|[CListCtrl：：GetBkImage](#getbkimage)|检索列表视图控件的当前背景图像。|
|[CListCtrl：：获取回拨掩码](#getcallbackmask)|检索列表视图控件的回调掩码。|
|[CListCtrl：获取检查](#getcheck)|检索与项目关联的状态图像的当前显示状态。|
|[CListCtrl：获取列](#getcolumn)|检索控件列的属性。|
|[CListCtrl：：获取列柱顺序数组](#getcolumnorderarray)|检索列表视图控件的列顺序（从左到右）。|
|[CListCtrl：获取纵杆宽度](#getcolumnwidth)|检索报表视图或列表视图中列的宽度。|
|[CListCtrl：：获取计数Perpage](#getcountperpage)|计算可垂直适合列表视图控件的项数。|
|[CListCtrl：获取编辑控制](#geteditcontrol)|检索用于编辑项目文本的编辑控件的句柄。|
|[CListCtrl：获取空文本](#getemptytext)|检索要显示的字符串，如果当前列表视图控件为空。|
|[CListCtrl：：获取扩展样式](#getextendedstyle)|检索列表视图控件的当前扩展样式。|
|[CListCtrl：获取第一选择项目位置](#getfirstselecteditemposition)|检索列表视图控件中第一个选定列表视图项的位置。|
|[CListCtrl：获取焦点组](#getfocusedgroup)|检索当前列表视图控件中具有键盘焦点的组。|
|[CListCtrl：：获取群数](#getgroupcount)|检索当前列表视图控件中的组数。|
|[CListCtrl：获取群信息](#getgroupinfo)|获取列表视图控件的指定组的信息。|
|[CListCtrl：获取群信息索引](#getgroupinfobyindex)|检索当前列表视图控件中指定组的信息。|
|[CListCtrl：获取集团指标](#getgroupmetrics)|检索组的指标。|
|[CListCtrl：：获取群组](#getgrouprect)|检索当前列表视图控件中指定组的边界矩形。|
|[CListCtrl：：获取群组状态](#getgroupstate)|检索当前列表视图控件中指定组的状态。|
|[CListCtrl：：获取头Ctrl](#getheaderctrl)|检索列表视图控件的标头控件。|
|[CListCtrl：获取霍伯库伯](#gethotcursor)|检索为列表视图控件启用热跟踪时使用的光标。|
|[CListCtrl：获取 Hot 项目](#gethotitem)|检索当前在游标下的列表视图项。|
|[CListCtrl：：获取悬停时间](#gethovertime)|检索列表视图控件的当前悬停时间。|
|[CListCtrl：获取图片列表](#getimagelist)|检索用于绘制列表视图项的图像列表的句柄。|
|[CListCtrl：：获取插入标记](#getinsertmark)|检索插入标记的当前位置。|
|[CListCtrl：：获取插入标记颜色](#getinsertmarkcolor)|检索插入标记的当前颜色。|
|[CListCtrl：：获取插入标记](#getinsertmarkrect)|检索绑定插入点的矩形。|
|[CListCtrl：获取项目](#getitem)|检索列表视图项的属性。|
|[CListCtrl：：获取项目计数](#getitemcount)|检索列表视图控件中的项数。|
|[CListCtrl：获取项目数据](#getitemdata)|检索与项关联的特定于应用程序的值。|
|[CListCtrl：：获取项目索引重新完成](#getitemindexrect)|检索当前列表视图控件中全部或部分子项的边界矩形。|
|[CListCtrl：获取项目位置](#getitemposition)|检索列表视图项的位置。|
|[CListCtrl：：获取项目重新完成](#getitemrect)|检索项的边界矩形。|
|[CListCtrl：获取项目间距](#getitemspacing)|计算当前列表视图控件中的项之间的间距。|
|[CListCtrl：：获取项目状态](#getitemstate)|检索列表视图项的状态。|
|[CListCtrl：：获取项目文本](#getitemtext)|检索列表视图项或子项的文本。|
|[CListCtrl：：获取下一个项目](#getnextitem)|搜索具有指定属性且与给定项具有指定关系的列表视图项。|
|[CListCtrl：：获取下一个项目索引](#getnextitemindex)|检索具有指定属性集的当前列表视图控件中的项的索引。|
|[CListCtrl：：获取下一个选定项目](#getnextselecteditem)|检索列表视图项位置的索引，以及下一个选定列表视图项用于迭代的位置。|
|[CListctrl：获取工作范围](#getnumberofworkareas)|检索列表视图控件的当前工作区数。|
|[CListCtrl：获取原点](#getorigin)|检索列表视图控件的当前视图源。|
|[CListCtrl：：获取大纲颜色](#getoutlinecolor)|检索列表视图控件的边框的颜色。|
|[CListCtrl：获取精选列](#getselectedcolumn)|检索列表控件中当前选定列的索引。|
|[CListCtrl：获取精选计数](#getselectedcount)|检索列表视图控件中选定项的数量。|
|[CListCtrl：获取选择标记](#getselectionmark)|检索列表视图控件的选择标记。|
|[CListCtrl：：获取字符串宽度](#getstringwidth)|确定显示所有给定字符串所需的最小列宽度。|
|[CListCtrl：：获取子项目重新完成](#getsubitemrect)|检索列表视图控件中项的边界矩形。|
|[CListCtrl：获取文本BkColor](#gettextbkcolor)|检索列表视图控件的文本背景颜色。|
|[CListCtrl：获取文本颜色](#gettextcolor)|检索列表视图控件的文本颜色。|
|[CListCtrl：：获取Tileinfo](#gettileinfo)|检索有关列表视图控件中磁贴的信息。|
|[CListCtrl：：获取TileViewInfo](#gettileviewinfo)|检索有关磁贴视图中的列表视图控件的信息。|
|[CListCtrl：获取工具提示](#gettooltips)|检索列表视图控件用于显示工具提示的工具提示控件。|
|[CListCtrl：获取Topindex](#gettopindex)|检索最顶层可见项的索引。|
|[CListCtrl：获取视图](#getview)|获取列表视图控件的视图。|
|[CListCtrl：：获取视图Rect](#getviewrect)|检索列表视图控件中所有项的边界矩形。|
|[CListCtrl：：获取工作领域](#getworkareas)|检索列表视图控件的当前工作区。|
|[CListCtrl：：哈斯集团](#hasgroup)|确定列表视图控件是否具有指定的组。|
|[CListCtrl：hitTest](#hittest)|确定哪个列表视图项位于指定位置。|
|[CListCtrl：：插入列](#insertcolumn)|在列表视图控件中插入新列。|
|[CListCtrl：：插入组](#insertgroup)|将组插入到列表视图控件中。|
|[CListCtrl：：插入组排序](#insertgroupsorted)|将指定的组插入有序的组列表中。|
|[CListCtrl：：插入项目](#insertitem)|在列表视图控件中插入新项。|
|[CListCtrl：：插入马克希特测试](#insertmarkhittest)|检索最接近指定点的插入点。|
|[CListCtrl：是否启用了群视图](#isgroupviewenabled)|确定是否为列表视图控件启用组视图。|
|[CListCtrl：是可分割的](#isitemvisible)|指示当前列表视图控件中的指定项是否可见。|
|[CListctrl：mapIDToindex](#mapidtoindex)|将当前列表视图控件中项的唯一 ID 映射到索引。|
|[CListctrl：：映射索引TOID](#mapindextoid)|将当前列表视图控件中的项索引映射到唯一 ID。|
|[CListCtrl：：移动组](#movegroup)|移动指定的组。|
|[CListctrl：：移动项目组](#moveitemtogroup)|将指定的组移动到列表视图控件的指定基于零的索引。|
|[CListCtrl：：重绘项目](#redrawitems)|强制列表视图控件重新绘制一系列项。|
|[CListCtrl：：删除所有组](#removeallgroups)|从列表视图控件中删除所有组。|
|[CListCtrl：：删除组](#removegroup)|从列表视图控件中删除指定的组。|
|[CListCtrl：：滚动](#scroll)|滚动列表视图控件的内容。|
|[CListCtrl：：SetBkColor](#setbkcolor)|设置列表视图控件的背景颜色。|
|[CListCtrl：：SetBkImage](#setbkimage)|设置列表视图控件的当前背景图像。|
|[CListCtrl：：设置回拨掩码](#setcallbackmask)|设置列表视图控件的回调掩码。|
|[CListCtrl：：设置检查](#setcheck)|设置与项目关联的状态图像的当前显示状态。|
|[CListCtrl：：设置列](#setcolumn)|设置列表视图列的属性。|
|[CListCtrl：：设置列阵数组](#setcolumnorderarray)|设置列表视图控件的列顺序（从左到右）。|
|[CListCtrl：：设置列宽](#setcolumnwidth)|更改报表视图或列表视图中列的宽度。|
|[CListCtrl：：设置扩展样式](#setextendedstyle)|设置列表视图控件的当前扩展样式。|
|[CListCtrl：：SetGroupInfo](#setgroupinfo)|设置列表视图控件的指定组的信息。|
|[CListCtrl：：设置组指标](#setgroupmetrics)|设置列表视图控件的组指标。|
|[CListCtrl：：设置HotCursor](#sethotcursor)|设置为列表视图控件启用热跟踪时使用的游标。|
|[CListCtrl：：设置Hot项目](#sethotitem)|设置列表视图控件的当前热项。|
|[CListCtrl：：设置悬停时间](#sethovertime)|设置列表视图控件的当前悬停时间。|
|[CListCtrl：：设置图标](#seticonspacing)|设置列表视图控件中图标之间的间距。|
|[CListCtrl：：设置图像列表](#setimagelist)|将图像列表分配给列表视图控件。|
|[CListCtrl：：设置信息提示](#setinfotip)|设置工具提示文本。|
|[CListCtrl：：设置插入标记](#setinsertmark)|将插入点设置到定义的位置。|
|[CListCtrl：：设置插入标记颜色](#setinsertmarkcolor)|设置插入点的颜色。|
|[CListCtrl：设置项目](#setitem)|设置列表视图项的部分或全部属性。|
|[CListCtrl：：设置项目计数](#setitemcount)|准备列表视图控件以添加大量项。|
|[CListCtrl：：设置项目计数Ex](#setitemcountex)|设置虚拟列表视图控件的项计数。|
|[CListCtrl：：设置项目数据](#setitemdata)|设置项的应用程序特定值。|
|[CListCtrl：：设置项目索引状态](#setitemindexstate)|设置当前列表视图控件中项的状态。|
|[CListCtrl：：设置项目位置](#setitemposition)|将项移动到列表视图控件中的指定位置。|
|[CListCtrl：：设置项目状态](#setitemstate)|更改列表视图控件中项的状态。|
|[CListCtrl：：设置项目文本](#setitemtext)|更改列表视图项或子项的文本。|
|[CListCtrl：：设置大纲颜色](#setoutlinecolor)|设置列表视图控件的边框颜色。|
|[CListCtrl：：设置选择列](#setselectedcolumn)|设置列表视图控件的选定列。|
|[CListCtrl：：设置选择标记](#setselectionmark)|设置列表视图控件的选择标记。|
|[CListCtrl：：设置文本BkColor](#settextbkcolor)|设置列表视图控件中文本的背景颜色。|
|[CListCtrl：：设置文本颜色](#settextcolor)|设置列表视图控件的文本颜色。|
|[CListCtrl：：SetTileInfo](#settileinfo)|设置列表视图控件的磁贴的信息。|
|[CListCtrl：：SetTileViewInfo](#settileviewinfo)|设置列表视图控件在磁贴视图中使用的信息。|
|[CListCtrl：：设置工具提示](#settooltips)|设置列表视图控件将用于显示工具提示的工具提示控件。|
|[CListCtrl：：SetView](#setview)|设置列表视图控件的视图。|
|[CListCtrl：：设置工作区域](#setworkareas)|设置图标可以在列表视图控件中显示的区域。|
|[CListCtrl：：排序组](#sortgroups)|使用用户定义的函数对列表视图控件的组进行排序。|
|[CListCtrl：：排序项目](#sortitems)|使用应用程序定义的比较函数对列表视图项进行排序。|
|[CListCtrl：：排序项目Ex](#sortitemsex)|使用应用程序定义的比较函数对列表视图项进行排序。|
|[CListCtrl：：子项目命中测试](#subitemhittest)|确定哪个列表视图项（如果有）位于给定位置。|
|[CListCtrl：：更新](#update)|强制控件重新绘制指定的项。|

## <a name="remarks"></a>备注

除了图标和标签之外，每个项目都可以在图标和标签右侧的列中显示信息。 此控件（因此该`CListCtrl`类）仅适用于在 Windows 95/98 和 Windows NT 版本 3.51 及更高版本下运行的程序。

以下是`CListCtrl`该类的简要概述。 有关详细的概念讨论，请参阅[使用 CListCtrl](../../mfc/using-clistctrl.md)和[控件](../../mfc/controls-mfc.md)。

## <a name="views"></a>视图

列表视图控件可以通过四种不同的方式显示其内容，称为"视图"。

- 图标视图

   每个项目都显示为全尺寸图标（32 x 32 像素），下方有一个标签。 用户可以将项目拖动到列表视图窗口中的任何位置。

- 小图标视图

   每个项目都显示为一个小图标（16 x 16 像素），标签在它的右侧。 用户可以将项目拖动到列表视图窗口中的任何位置。

- “列表”视图

   每个项目都显示为一个小图标，其右侧有一个标签。 项目以列方式排列，无法拖动到列表视图窗口中的任何位置。

- 报表视图

   每个项目都出现在自己的行上，其他信息排列在右侧的列中。 最左边的列包含小图标和标签，后续列包含应用程序指定的子项。 嵌入的标头控件 （类[CHeaderCtrl](../../mfc/reference/cheaderctrl-class.md)） 实现这些列。 有关报表视图中的标头控件和列的详细信息，请参阅[使用 CListCtrl：向控件添加列（报表视图）。](../../mfc/adding-columns-to-the-control-report-view.md)

控件的当前列表视图的样式确定当前视图。 有关这些样式及其用法的详细信息，请参阅使用[CListCtrl：更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="extended-styles"></a>扩展样式

除了标准列表样式外，类`CListCtrl`还支持大量扩展样式，提供丰富的功能。 此功能的一些示例包括：

- 悬停选择

   启用后，当光标在项目上保留一段时间时，允许自动选择项。

- 虚拟列表视图

   启用后，允许控件最多支持 DWORD 项。 这可以通过将管理项数据的开销放在应用程序上来。 除项目选择和焦点信息外，所有项目信息必须由应用程序管理。 有关详细信息，请参阅使用[CListCtrl：虚拟列表控件](../../mfc/virtual-list-controls.md)。

- 一键和双击激活

   启用后，允许热跟踪（项目文本的自动突出显示）和突出显示项的一次或两次单击激活。

- 拖放列顺序

   启用后，允许在列表视图控件中拖放重新排序列。 仅在报表视图中可用。

有关使用这些新的扩展样式的信息，请参阅使用[CListCtrl：更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="items-and-subitems"></a>项目和子项目

列表视图控件中的每个项都由图标（从图像列表中）、标签、当前状态和应用程序定义值（称为"项数据"）组成。 也可以与每个项目关联一个或多个子项。 "子项"是一个字符串，在报表视图中，可以在项图标和标签右侧的列中显示。 列表视图控件中的所有项必须具有相同的子项数。

类`CListCtrl`提供了多个用于插入、删除、查找和修改这些项目的功能。 有关详细信息，请参阅[CListCtrl：：获取项目](#getitem)[、CListCtrl：：插入项目](#insertitem)，和[CListCtrl：查找项目](#finditem)，[将项目添加到控件](../adding-items-to-the-control.md)，并在[列表控件中滚动、排列、排序和查找](../scrolling-arranging-sorting-and-finding-in-list-controls.md)。

默认情况下，列表视图控件负责存储项的图标和文本属性。 但是，除了这些项类型之外，类`CListCtrl`还支持"回调项"。 "回调项"是应用程序（而不是控件）存储文本、图标或两者的列表视图项。 回调掩码用于指定应用程序提供的项目属性（文本和/或图标）。 如果应用程序使用回调项，它必须能够按需提供文本和/或图标属性。 当应用程序已维护某些此信息时，回调项非常有用。 有关详细信息，请参阅使用[CListCtrl：回调项和回调掩码](../callback-items-and-the-callback-mask.md)。

## <a name="image-lists"></a>图像列表

列表视图项的图标、标题项图像和应用程序定义状态包含在多个图像列表中（由类[CImageList](cimagelist-class.md)实现），您创建这些列表视图项并将其分配给列表视图控件。 每个列表视图控件最多可以有四种不同类型的图像列表：

- 大图标

   在全尺寸图标的图标视图中使用。

- 小图标

   在图标视图中使用的较小版本的图标的小图标、列表和报表视图中使用。

- 应用程序定义状态

   包含状态图像，这些图像显示在项的图标旁边，以指示应用程序定义的状态。

- 标头项

   在报表视图中用于出现在每个标头控制项中的小图像。

默认情况下，列表视图控件销毁分配给它的图像列表;因此，列表视图控件会销毁分配给它的图像列表。但是，开发人员可以通过在不再使用每个映像列表时（由应用程序确定）来自定义此行为。 有关详细信息，请参阅使用[CListCtrl：列表项和图像列表](../list-items-and-image-lists.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](cobject-class.md)

[CCmdTarget](ccmdtarget-class.md)

[CWnd](cwnd-class.md)

`CListCtrl`

## <a name="requirements"></a>要求

**标头：** afxcmn.h

## <a name="clistctrlapproximateviewrect"></a><a name="approximateviewrect"></a>CListCtrl：：近似视图重新

确定显示列表视图控件项所需的宽度和高度。

```
CSize ApproximateViewRect(
    CSize sz = CSize(-1, -1),
    int iCount = -1) const;
```

### <a name="parameters"></a>参数

*深圳*<br/>
控件的拟议尺寸（以像素为单位）。 如果未指定尺寸，则框架将使用控件的当前宽度或高度值。

*iCount*<br/>
要在控件中显示的项数。 如果此参数为 -1，则框架将使用控件中当前项的总数。

### <a name="return-value"></a>返回值

包含`CSize`以像素为单位显示项目所需的近似宽度和高度的对象。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_ApproximateViewRect](/windows/win32/api/commctrl/nf-commctrl-listview_approximateviewrect)的行为，如 Windows SDK 中所述。

## <a name="clistctrlarrange"></a><a name="arrange"></a>CListCtrl：排列

重新定位图标视图中的项目，使其在网格上对齐。

```
BOOL Arrange(UINT nCode);
```

### <a name="parameters"></a>参数

*n代码*<br/>
指定项的对齐样式。 可以为下列值之一：

- LVA_ALIGNLEFT沿窗口左边缘对齐项目。

- LVA_ALIGNTOP沿窗口的上边缘对齐项目。

- LVA_DEFAULT根据列表视图的当前对齐样式（默认值）对齐项。

- LVA_SNAPTOGRID将所有图标捕捉到最近的网格位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

*nCode*参数指定对齐样式。

### <a name="example"></a>示例

```cpp
    // Align all of the list view control items along the top
    // of the window (the list view control must be in icon or
    // small icon mode).
    m_myListCtrl.Arrange(LVA_ALIGNTOP);
```

## <a name="clistctrlcanceleditlabel"></a><a name="canceleditlabel"></a>CListCtrl：：取消编辑标签

取消项目文本编辑操作。

```
void CancelEditLabel();
```

### <a name="remarks"></a>备注

此成员函数模拟[LVM_CANCELEDITLABEL](/windows/win32/Controls/lvm-canceleditlabel)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlclistctrl"></a><a name="clistctrl"></a>CListCtrl：：CListCtrl

构造 `CListCtrl` 对象。

```
CListCtrl();
```

## <a name="clistctrlcreate"></a><a name="create"></a>CListCtrl：：创建

创建列表控件并将其附加到`CListCtrl`对象。

```
virtual BOOL Create(
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>参数

*dwStyle*<br/>
指定列表控件的样式。 将列表控件样式的任意组合应用于控件。 有关这些样式的完整列表，请参阅 Windows SDK 中的[列表视图窗口样式](/windows/win32/Controls/list-view-window-styles)。 使用[Set 扩展样式](#setextendedstyle)设置特定于控件的扩展样式。

*矩形*<br/>
指定列表控件的大小和位置。 它可以是`CRect`对象或[RECT](/previous-versions/dd162897\(v=vs.85\))结构。

*pparentwnd*<br/>
指定列表控件的父窗口（通常为`CDialog`。 值不得为 NULL。

*nID*<br/>
指定列表控件的 ID。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

在两个步骤`CListCtrl`中构造 一个。 首先调用构造函数，然后调用`Create`，这将创建列表视图控件并将其附加到`CListCtrl`对象。

要将扩展的 Windows 样式应用于列表控件对象，请调用`Create`[CreateEx](#createex)而不是 。

### <a name="example"></a>示例

```cpp
    m_myListCtrl.Create(
        WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_EDITLABELS,
        CRect(10,10,400,200), pParentWnd, IDD_MYLISTCTRL);
```

## <a name="clistctrlcreateex"></a><a name="createex"></a>CListCtrl：：创建Ex

创建控件（子窗口），并将其与`CListCtrl`对象关联。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>参数

*dwExStyle*<br/>
指定要创建的控件的扩展样式。 有关扩展 Windows 样式的列表，请参阅 Windows SDK 中[创建 WindowEx](/windows/win32/api/winuser/nf-winuser-createwindowexw)的*dwExStyle*参数。

*dwStyle*<br/>
指定列表控件的样式。 将列表控件样式的任意组合应用于控件。 有关这些样式的完整列表，请参阅 Windows SDK 中的[列表视图窗口样式](/windows/win32/Controls/list-view-window-styles)。

*矩形*<br/>
对[RECT](/previous-versions/dd162897\(v=vs.85\))结构的引用，描述要创建的窗口的大小和位置，在*pParentWnd*的客户端坐标中。

*pparentwnd*<br/>
指向控件的父窗口的指针。

*nID*<br/>
控件的子窗口 ID。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

使用`CreateEx`而不是["创建](#create)"来应用扩展的 Windows 样式，该样式由 Windows 扩展样式前言**WS_EX_** 指定。

`CreateEx`使用*dwExStyle*指定的扩展 Windows 样式创建控件。 要设置特定于控件的扩展样式，请调用[Set 扩展样式](#setextendedstyle)。 例如，用于`CreateEx`将此类样式设置为WS_EX_CONTEXTHELP，但用于`SetExtendedStyle`将此类样式设置为LVS_EX_FULLROWSELECT。 有关详细信息，请参阅 Windows SDK 中的["扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)"一文中描述的样式。

## <a name="clistctrlcreatedragimage"></a><a name="createdragimage"></a>CListCtrl：：创建拖动图像

为*nItem*指定的项创建拖动图像列表。

```
CImageList* CreateDragImage(
    int nItem,
    LPPOINT lpPoint);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要创建其拖动图像列表的项的索引。

*lpPoint*<br/>
在视图坐标中接收图像左上角的初始位置的[POINT](/previous-versions/dd162805\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，指向拖动图像列表的指针;否则 NULL。

### <a name="remarks"></a>备注

该`CImageList`对象是永久性的，您必须在完成该对象后将其删除。 例如：

```cpp
        CImageList* pImageList = m_myListCtrl.CreateDragImage(nItem, &point);

        // do something

        delete pImageList;
```

## <a name="clistctrldeleteallitems"></a><a name="deleteallitems"></a>CListCtrl：:DeleteAll项目

从列表视图控件中删除所有项。

```
BOOL DeleteAllItems();
```

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Delete all of the items from the list view control.
    m_myListCtrl.DeleteAllItems();
    ASSERT(m_myListCtrl.GetItemCount() == 0);
```

## <a name="clistctrldeletecolumn"></a><a name="deletecolumn"></a>CListCtrl：:DeleteColumn

从列表视图控件中删除列。

```
BOOL DeleteColumn(int nCol);
```

### <a name="parameters"></a>参数

*nCol*<br/>
要删除的列的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Delete all of the columns.
        for (int i=0; i < nColumnCount; i++)
        {
            m_myListCtrl.DeleteColumn(0);
        }
```

## <a name="clistctrldeleteitem"></a><a name="deleteitem"></a>CListCtrl：:Delete项目

从列表视图控件中删除项。

```
BOOL DeleteItem(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
指定要删除的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();

        // Delete all of the items from the list view control.
        for (int i=0; i < nCount; i++)
        {
            m_myListCtrl.DeleteItem(0);
        }
```

## <a name="clistctrldrawitem"></a><a name="drawitem"></a>CListCtrl：:D原始项目

当所有者绘制列表视图控件的可视方面发生更改时，由框架调用。

```
virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>参数

*lpDraw 项目已结*<br/>
指向包含所需绘图类型`DRAWITEMSTRUCT`信息的结构的长指针。

### <a name="remarks"></a>备注

`itemAction` [DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)结构的成员定义要执行的绘图操作。

默认情况下，此成员函数不执行任何操作。 重写此成员函数以实现所有者绘制对象的绘图`CListCtrl`。

应用程序应还原在此成员函数终止之前为*lpDrawItemStruct*中提供的显示上下文选择的所有图形设备接口 （GDI） 对象。

## <a name="clistctrleditlabel"></a><a name="editlabel"></a>CListCtrl：：编辑标签

开始就地编辑项目的文本。

```
CEdit* EditLabel(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要编辑的列表视图项的索引。

### <a name="return-value"></a>返回值

如果成功，则指向用于编辑`CEdit`项目文本的对象的指针;如果成功，则指向用于编辑项目文本的对象。否则 NULL。

### <a name="remarks"></a>备注

具有LVS_EDITLABELS窗口样式的列表视图控件使用户能够就地编辑项目标签。 用户通过单击具有焦点的项目的标签开始编辑。

使用此函数开始就地编辑指定的列表视图项的文本。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Show the edit control on the label of the first
        // item in the list view control.
        CEdit* pmyEdit = m_myListCtrl.EditLabel(1);
        ASSERT(pmyEdit != NULL);
```

## <a name="clistctrlenablegroupview"></a><a name="enablegroupview"></a>CListCtrl：：启用群景视图

启用或禁用列表视图控件中的项是否显示为组。

```
LRESULT EnableGroupView(BOOL fEnable);
```

### <a name="parameters"></a>参数

*f 启用*<br/>
指示是否启用列表视图控件对显示的项目进行分组。 TRUE 以启用分组;FALSE 禁用它。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**已启用或禁用将列表视图项显示为组的能力。

- **1**控件的状态已成功更改。

- **-1**操作失败。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_ENABLEGROUPVIEW](/windows/win32/Controls/lvm-enablegroupview)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlensurevisible"></a><a name="ensurevisible"></a>CListCtrl：：确保可见

确保列表视图项至少部分可见。

```
BOOL EnsureVisible(
    int nItem,
    BOOL bPartialOK);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要可见的列表视图项的索引。

*b 部分OK*<br/>
指定部分可见性是否可以接受。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如有必要，将滚动列表视图控件。 如果*bPartialOK*参数是非零，则如果项目部分可见，则不会发生滚动。

### <a name="example"></a>示例

```cpp
        // Ensure that the last item is visible.
        int nCount = m_myListCtrl.GetItemCount();
        if (nCount > 0)
            m_myListCtrl.EnsureVisible(nCount-1, FALSE);
```

## <a name="clistctrlfinditem"></a><a name="finditem"></a>CListCtrl：：查找项目

搜索具有指定特征的列表视图项。

```
int FindItem(
    LVFINDINFO* pFindInfo,
    int nStart = -1) const;
```

### <a name="parameters"></a>参数

*pFindInfo*<br/>
指向[LVFINDINFO](/windows/win32/api/commctrl/ns-commctrl-lvfindinfow)结构的指针，其中包含有关要搜索的项的信息。

*n 开始*<br/>
要开始搜索的项的索引，或从开头开始的 -1。 如果*nStart*不等于 -1，则从搜索中排除*nStart*处的项目。

### <a name="return-value"></a>返回值

如果成功或 -1，则项的索引。

### <a name="remarks"></a>备注

*pFindInfo*参数指向一个`LVFINDINFO`结构，该结构包含用于搜索列表视图项的信息。

### <a name="example"></a>示例

```cpp
        LVFINDINFO info;
        int nIndex;

        info.flags = LVFI_PARTIAL|LVFI_STRING;
        info.psz = _T("item");

        // Delete all of the items that begin with the string.
        while ((nIndex = m_myListCtrl.FindItem(&info)) != -1)
        {
            m_myListCtrl.DeleteItem(nIndex);
        }
```

## <a name="clistctrlgetbkcolor"></a><a name="getbkcolor"></a>CListCtrl：getBkColor

检索列表视图控件的背景颜色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的 32 位值。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：setBkColor](#setbkcolor)。

## <a name="clistctrlgetbkimage"></a><a name="getbkimage"></a>CListCtrl：：GetBkImage

检索列表视图控件的当前背景图像。

```
BOOL GetBkImage(LVBKIMAGE* plvbkImage) const;
```

### <a name="parameters"></a>参数

*plvbk图像*<br/>
指向包含列表视图`LVBKIMAGE`的当前背景图像的结构的指针。

### <a name="return-value"></a>返回值

如果成功，则返回非零，否则返回零。

### <a name="remarks"></a>备注

此方法实现 Win32 宏[ListView_GetBkImage](/windows/win32/api/commctrl/nf-commctrl-listview_getbkimage)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        LVBKIMAGE bki;

        // If no background image is set for the list view control use
        // the Microsoft homepage image as the background image.
        if (m_myListCtrl.GetBkImage(&bki) && (bki.ulFlags == LVBKIF_SOURCE_NONE))
        {
            m_myListCtrl.SetBkImage(
                _T("https://www.microsoft.com/library/images/gifs/homepage/microsoft.gif"),
                TRUE);
        }
```

## <a name="clistctrlgetcallbackmask"></a><a name="getcallbackmask"></a>CListCtrl：：获取回拨掩码

检索列表视图控件的回调掩码。

```
UINT GetCallbackMask() const;
```

### <a name="return-value"></a>返回值

列表视图控件的回调掩码。

### <a name="remarks"></a>备注

"回调项"是应用程序（而不是控件）存储文本、图标或两者的列表视图项。 尽管列表视图控件可以为您存储这些属性，但如果应用程序已维护某些此信息，则可能需要使用回调项。 回调掩码指定应用程序维护的项状态位，它适用于整个控件，而不是特定项。 回调掩码默认为零，这意味着控件将跟踪所有项状态。 如果应用程序使用回调项或指定非零回调掩码，则必须能够按需提供列表视图项属性。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：设置回拨掩码](#setcallbackmask)。

## <a name="clistctrlgetcheck"></a><a name="getcheck"></a>CListCtrl：获取检查

检索与项目关联的状态图像的当前显示状态。

```
BOOL GetCheck(int nItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
列表控件项的零基索引。

### <a name="return-value"></a>返回值

如果选中项目，则非零，否则为 0。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetCheckState](/windows/win32/api/commctrl/nf-commctrl-listview_getcheckstate)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：SetCheck](#setcheck)。

## <a name="clistctrlgetcolumn"></a><a name="getcolumn"></a>CListCtrl：获取列

检索列表视图控件列的属性。

```
BOOL GetColumn(
    int nCol,
    LVCOLUMN* pColumn) const;
```

### <a name="parameters"></a>参数

*nCol*<br/>
要检索其属性的列的索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构的地址，用于指定要检索和接收有关列的信息的信息。 成员`mask`指定要检索的列属性。 如果`mask`成员指定LVCF_TEXT值，`pszText`则成员必须包含接收项文本的缓冲区的地址，`cchTextMax`并且成员必须指定缓冲区的大小。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

结构`LVCOLUMN`包含有关报表视图中的列的信息。

### <a name="example"></a>示例

```cpp
        LVCOLUMN col;

        col.mask = LVCF_WIDTH;

        // Double the column width of the first column.
        if (m_myListCtrl.GetColumn(0, &col))
        {
            col.cx *= 2;
            m_myListCtrl.SetColumn(0, &col);
        }
```

## <a name="clistctrlgetcolumnorderarray"></a><a name="getcolumnorderarray"></a>CListCtrl：：获取列柱顺序数组

检索列表视图控件的列顺序（从左到右）。

```
BOOL GetColumnOrderArray(
    LPINT piArray,
    int iCount = -1);
```

### <a name="parameters"></a>参数

*皮拉里*<br/>
指向缓冲区的指针，该缓冲区将包含列表视图控件中列的索引值。 缓冲区必须足够大，以包含列表视图控件中的列总数。

*iCount*<br/>
列表视图控件中的列数。 如果此参数为 -1，则框架会自动检索列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_getcolumnorderarray)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // Reverse the order of the columns in the list view control
        // (i.e. make the first column the last, the last column
        // the first, and so on...).
        CHeaderCtrl* pHeaderCtrl = m_myListCtrl.GetHeaderCtrl();

        if (pHeaderCtrl != NULL)
        {
            int  nColumnCount = pHeaderCtrl->GetItemCount();
            LPINT pnOrder = (LPINT) malloc(nColumnCount*sizeof(int));
            ASSERT(pnOrder != NULL);
            m_myListCtrl.GetColumnOrderArray(pnOrder, nColumnCount);

            int i, j, nTemp;
            for (i = 0, j = nColumnCount-1; i < j; i++, j--)
            {
                nTemp = pnOrder[i];
                pnOrder[i] = pnOrder[j];
                pnOrder[j] = nTemp;
            }

            m_myListCtrl.SetColumnOrderArray(nColumnCount, pnOrder);
            free(pnOrder);
        }
```

## <a name="clistctrlgetcolumnwidth"></a><a name="getcolumnwidth"></a>CListCtrl：获取纵杆宽度

检索报表视图或列表视图中列的宽度。

```
int GetColumnWidth(int nCol) const;
```

### <a name="parameters"></a>参数

*nCol*<br/>
指定要检索其宽度的列的索引。

### <a name="return-value"></a>返回值

*nCol*指定的列的宽度（以像素为单位）。

### <a name="example"></a>示例

```cpp
        // Increase the column width of the second column by 20.
        int nWidth = m_myListCtrl.GetColumnWidth(1);
        m_myListCtrl.SetColumnWidth(1, 20 + nWidth);
```

## <a name="clistctrlgetcountperpage"></a><a name="getcountperpage"></a>CListCtrl：：获取计数Perpage

计算在列表视图或报表视图中时可垂直适合列表视图控件可见区域的项数。

```
int GetCountPerPage() const;
```

### <a name="return-value"></a>返回值

在列表视图或报表视图中时，可以垂直适合列表视图控件的可见区域的项数。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：getTopIndex](#gettopindex)。

## <a name="clistctrlgeteditcontrol"></a><a name="geteditcontrol"></a>CListCtrl：获取编辑控制

检索用于编辑列表视图项文本的编辑控件的句柄。

```
CEdit* GetEditControl() const;
```

### <a name="return-value"></a>返回值

如果成功，则指向用于编辑项目文本的 CEdit 对象的指针;如果成功，则指向[CEdit](cedit-class.md)对象。否则 NULL。

### <a name="example"></a>示例

```cpp
        // The string replacing the text in the edit control.
        LPCTSTR lpszmyString = _T("custom label!");

        // If possible, replace the text in the label edit control.
        CEdit* pEdit = m_myListCtrl.GetEditControl();

        if (pEdit != NULL)
        {
            pEdit->SetWindowText(lpszmyString);
        }
```

## <a name="clistctrlgetemptytext"></a><a name="getemptytext"></a>CListCtrl：获取空文本

检索要显示的字符串，如果当前列表视图控件为空。

```
CString GetEmptyText() const;
```

### <a name="return-value"></a>返回值

包含控件为空时要显示的文本的[CString。](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="remarks"></a>备注

此方法发送[LVM_GETEMPTYTEXT](/windows/win32/Controls/lvm-getemptytext)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlgetextendedstyle"></a><a name="getextendedstyle"></a>CListCtrl：：获取扩展样式

检索列表视图控件的当前扩展样式。

```
DWORD GetExtendedStyle();
```

### <a name="return-value"></a>返回值

列表视图控件当前正在使用的扩展样式的组合。 有关这些扩展样式的描述性列表，请参阅 Windows SDK 中的[扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)一文。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_GetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_getextendedlistviewstyle)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：设置扩展样式](#setextendedstyle)。

## <a name="clistctrlgetfirstselecteditemposition"></a><a name="getfirstselecteditemposition"></a>CListCtrl：获取第一选择项目位置

获取列表视图控件中第一个选定项的位置。

```
POSITION GetFirstSelectedItemPosition() const;
```

### <a name="return-value"></a>返回值

可用于迭代或对象指针检索的定位值;如果未选择任何项目，则为 NULL。

### <a name="example"></a>示例

以下代码示例演示了此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="clistctrlgetfocusedgroup"></a><a name="getfocusedgroup"></a>CListCtrl：获取焦点组

检索当前列表视图控件中具有键盘焦点的组。

```
int GetFocusedGroup() const;
```

### <a name="return-value"></a>返回值

其状态为LVGS_FOCUSED的组的索引（如果有这样的组）;否则，-1。

### <a name="remarks"></a>备注

此方法发送[LVM_GETFOCUSEDGROUP](/windows/win32/Controls/lvm-getfocusedgroup)消息，这在 Windows SDK 中介绍。 有关详细信息，请参阅`state`[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构成员LVGS_FOCUSED值。

## <a name="clistctrlgetgroupcount"></a><a name="getgroupcount"></a>CListCtrl：：获取群数

检索当前列表视图控件中的组数。

```
int GetGroupCount()const;
```

### <a name="return-value"></a>返回值

列表视图控件中的组数。

### <a name="remarks"></a>备注

此方法发送[LVM_GETGROUPCOUNT](/windows/win32/Controls/lvm-getgroupcount)消息，这在 Windows SDK > 中描述。

## <a name="clistctrlgetgroupinfo"></a><a name="getgroupinfo"></a>CListCtrl：获取群信息

获取列表视图控件的指定组的信息。

```
int GetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp) const;
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要检索其信息的组的标识符。

*pgrp*<br/>
指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)的指针，其中包含指定组的信息。

### <a name="return-value"></a>返回值

如果成功，则返回组的 ID，否则返回 -1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETGROUPINFO](/windows/win32/Controls/lvm-getgroupinfo)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetgroupinfobyindex"></a><a name="getgroupinfobyindex"></a>CListCtrl：获取群信息索引

检索当前列表视图控件中指定组的信息。

```
BOOL GetGroupInfoByIndex(
    int iIndex,
    PLVGROUP pGroup) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*iIndex*|[在]组的零索引。|
|*p组*|[出]指向接收*iIndex*参数指定的组信息的[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针。<br /><br /> 调用方负责初始化[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的成员。 将`cbSize`成员设置为结构的大小，并将`mask`成员的标志设置为指定要检索的信息。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

此方法发送[LVM_GETGROUPINFOBYINDEX](/windows/win32/controls/lvm-getgroupinfobyindex)消息，该消息在 Windows SDK 中描述 ，>。

### <a name="example"></a>示例

以下代码示例定义用于访问当前列表视图`m_listCtrl`控件的变量 。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

以下代码示例演示了该方法`GetGroupInfoByIndex`。 在此代码示例的较早部分中，我们创建了一个列表视图控件，该控件在报表视图中显示两列标题为"ClientID"和"分级"。 以下代码示例检索有关索引为 0 的组的信息（如果存在此类组）。

```cpp
    // GetGroupInfoByIndex
    const int GROUP_HEADER_BUFFER_SIZE = 40;

// Initialize the structure
    LVGROUP gInfo = {0};
    gInfo.cbSize = sizeof(LVGROUP);
    wchar_t wstrHeadGet[GROUP_HEADER_BUFFER_SIZE] = {0};
    gInfo.cchHeader = GROUP_HEADER_BUFFER_SIZE;
    gInfo.pszHeader = wstrHeadGet;
    gInfo.mask = (LVGF_ALIGN | LVGF_STATE | LVGF_HEADER | LVGF_GROUPID);
    gInfo.state = LVGS_NORMAL;
    gInfo.uAlign  = LVGA_HEADER_LEFT;

    BOOL bRet = m_listCtrl.GetGroupInfoByIndex( 0, &gInfo );
    if (bRet == TRUE) {
        CString strHeader = CString( gInfo.pszHeader );
        CString str;
        str.Format(_T("Header: '%s'"), strHeader);
        AfxMessageBox(str, MB_ICONINFORMATION);
    }
    else
    {
        AfxMessageBox(_T("No group information was retrieved."));
    }
```

## <a name="clistctrlgetgroupmetrics"></a><a name="getgroupmetrics"></a>CListCtrl：获取集团指标

检索组的指标。

```
void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const;
```

### <a name="parameters"></a>参数

*p组指标*<br/>
指向包含组指标信息的[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)的指针。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETGROUPMETRICS](/windows/win32/Controls/lvm-getgroupmetrics)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetgrouprect"></a><a name="getgrouprect"></a>CListCtrl：：获取群组

检索当前列表视图控件中指定组的边界矩形。

```
BOOL GetGroupRect(
    int iGroupId,
    LPRECT lpRect,
    int iCoords = LVGGR_GROUP) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*iGroupId*|[在]指定组。|
|*lpRect*|[进出]指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针。 如果此方法成功，则结构将接收*iGroupId*指定的组的矩形坐标。|
|*iCoords*|[在]指定要检索的矩形坐标。 使用以下值之一：<br /><br /> - LVGGR_GROUP - （默认）整个展开的组的坐标。<br />- LVGGR_HEADER - 仅坐标的标头（折叠组）。<br />- LVGGR_SUBSETLINK - 仅坐标子集链接（标记子集）。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

调用方负责分配*pRect*参数指向的[RECT](/previous-versions/dd162897\(v=vs.85\))结构。

此方法发送[LVM_GETGROUPRECT](/windows/win32/Controls/lvm-getgrouprect)消息，这在 Windows SDK 中介绍。

### <a name="example"></a>示例

以下代码示例定义用于访问当前列表视图`m_listCtrl`控件的变量 。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

以下代码示例演示了该方法`GetGroupRect`。 在此代码示例的较早部分中，我们创建了一个列表视图控件，该控件在报表视图中显示两列标题为"ClientID"和"分级"。 以下代码示例围绕索引为 0 的组（如果存在）绘制一个 3D 矩形。

```cpp
    // GetGroupRect

    // Get the graphics rectangle that surrounds group 0.
    CRect rect;
    BOOL bRet = m_listCtrl.GetGroupRect( 0, &rect, LVGGR_GROUP);
    // Draw a blue rectangle around group 0.
    if (bRet == TRUE) {
        m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(0, 0, 255), RGB(0, 0, 255));
    }
    else {
        AfxMessageBox(_T("No group information was retrieved."), MB_ICONINFORMATION);
    }
```

## <a name="clistctrlgetgroupstate"></a><a name="getgroupstate"></a>CListCtrl：：获取群组状态

检索当前列表视图控件中指定组的状态。

```
UINT GetGroupState(
    int iGroupId,
    DWORD dwMask) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*iGroupId*|[在]组的零索引。|
|*dwMask*|[在]指定要为指定组检索的状态值的掩码。 有关详细信息，`mask`请参阅[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的成员。|

### <a name="return-value"></a>返回值

指定组的请求状态，如果找不到组，则为 0。

### <a name="remarks"></a>备注

返回值是对*dwMask*参数的位和操作的结果，以及表示当前列表视图控件的`state`[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构成员的值。

此方法发送[LVM_GETGROUPSTATE](/windows/win32/Controls/lvm-getgroupstate)消息，这在 Windows SDK 中介绍。 有关详细信息，请参阅[ListView_GetGroupState](/windows/win32/api/commctrl/nf-commctrl-listview_getgroupstate)宏。

## <a name="clistctrlgetheaderctrl"></a><a name="getheaderctrl"></a>CListCtrl：：获取头Ctrl

检索列表视图控件的标头控件。

```
CHeaderCtrl* GetHeaderCtrl();
```

### <a name="return-value"></a>返回值

指向标题控件的指针，由列表视图控件使用。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetHeader](/windows/win32/api/commctrl/nf-commctrl-listview_getheader)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取列柱顺序数组](#getcolumnorderarray)。

## <a name="clistctrlgethotcursor"></a><a name="gethotcursor"></a>CListCtrl：获取霍伯库伯

检索为列表视图控件启用热跟踪时使用的光标。

```
HCURSOR GetHotCursor();
```

### <a name="return-value"></a>返回值

列表视图控件正在使用的当前热游标资源的句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_gethotcursor)的行为，如 Windows SDK 中所述。 仅当游标经过任何列表视图项时，才会显示热游标，仅在启用悬停选择时才可见。 通过设置扩展样式LVS_EX_TRACKSELECT启用悬停选择。

### <a name="example"></a>示例

```cpp
        // Set the hot cursor to be the system app starting cursor.
        HCURSOR hCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
        m_myListCtrl.SetHotCursor(hCursor);
        ASSERT(m_myListCtrl.GetHotCursor() == hCursor);
```

## <a name="clistctrlgethotitem"></a><a name="gethotitem"></a>CListCtrl：获取 Hot 项目

检索当前在游标下的列表视图项。

```
int GetHotItem();
```

### <a name="return-value"></a>返回值

列表视图控件的当前热项的索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_gethotitem)的行为，如 Windows SDK 中所述。 启用热跟踪（和悬停选择）时，热项定义为当前选定的项。

如果启用了热跟踪，当用户暂停列表视图项时，则项目标签将自动突出显示，而无需使用鼠标按钮。

### <a name="example"></a>示例

```cpp
    // Set the hot item to the first item only if no other item is
    // highlighted.
    if (m_myListCtrl.GetHotItem() == -1)
        m_myListCtrl.SetHotItem(0);
```

## <a name="clistctrlgethovertime"></a><a name="gethovertime"></a>CListCtrl：：获取悬停时间

检索列表视图控件的当前悬停时间。

```
DWORD GetHoverTime() const;
```

### <a name="return-value"></a>返回值

返回延迟（以毫秒为单位），鼠标光标必须在选择之前将延迟悬停在项目上。 如果返回值为 -1，则悬停时间是默认悬停时间。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_gethovertime)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // If the hover time is the default set to 1 sec.
        DWORD dwTime = m_myListCtrl.GetHoverTime();
        if (dwTime == -1)
            m_myListCtrl.SetHoverTime(1000);
```

## <a name="clistctrlgetimagelist"></a><a name="getimagelist"></a>CListCtrl：获取图片列表

检索用于绘制列表视图项的图像列表的句柄。

```
CImageList* GetImageList(int nImageList) const;
```

### <a name="parameters"></a>参数

*n图像列表*<br/>
指定要检索的图像列表的值。 它可以是以下值之一：

- LVSIL_NORMAL具有大图标的图像列表。

- LVSIL_SMALL带有小图标的图像列表。

- LVSIL_STATE图像列表与状态图像。

### <a name="return-value"></a>返回值

指向用于绘制列表视图项的图像列表的指针。

### <a name="example"></a>示例

```cpp
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == NULL);
        m_myListCtrl.SetImageList(&m_lcImageList, LVSIL_NORMAL);
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == &m_lcImageList);
```

## <a name="clistctrlgetinsertmark"></a><a name="getinsertmark"></a>CListCtrl：：获取插入标记

检索插入标记的当前位置。

```
BOOL GetInsertMark(LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>参数

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，其中包含插入标记的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。 如果`cbSize``LVINSERTMARK`结构成员中的大小不等于结构的实际大小，则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARK](/windows/win32/Controls/lvm-getinsertmark)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetinsertmarkcolor"></a><a name="getinsertmarkcolor"></a>CListCtrl：：获取插入标记颜色

检索插入标记的当前颜色。

```
COLORREF GetInsertMarkColor() const;
```

### <a name="return-value"></a>返回值

返回包含插入点颜色的[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARKCOLOR](/windows/win32/Controls/lvm-getinsertmarkcolor)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetinsertmarkrect"></a><a name="getinsertmarkrect"></a>CListCtrl：：获取插入标记

检索绑定插入点的矩形。

```
int GetInsertMarkRect(LPRECT pRect) const;
```

### <a name="parameters"></a>参数

*普雷克*<br/>
指向`RECT`包含绑定插入点的矩形坐标的结构的指针。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**未找到插入点。

- **找到 1**插入点。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARKRECT](/windows/win32/Controls/lvm-getinsertmarkrect)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetitem"></a><a name="getitem"></a>CListCtrl：获取项目

检索列表视图项的部分或全部属性。

```
BOOL GetItem(LVITEM* pItem) const;
```

### <a name="parameters"></a>参数

*pItem*<br/>
指向接收项属性的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的指针。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

结构`LVITEM`指定或接收列表视图项的属性。

## <a name="clistctrlgetitemcount"></a><a name="getitemcount"></a>CListCtrl：：获取项目计数

检索列表视图控件中的项数。

```
int GetItemCount() const;
```

### <a name="return-value"></a>返回值

列表视图控件中的项数。

### <a name="example"></a>示例

请参阅[CListCtrl：:Delete 项目](#deleteitem)的示例。

## <a name="clistctrlgetitemdata"></a><a name="getitemdata"></a>CListCtrl：获取项目数据

检索与 指定的`nItem`项关联的 32 位应用程序特定值。

```
DWORD_PTR GetItemData(int nItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其数据的列表项的索引。

### <a name="return-value"></a>返回值

与指定项关联的 32 位应用程序特定值。

### <a name="remarks"></a>备注

此值是`lParam` [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的成员，如 Windows SDK 中所述

### <a name="example"></a>示例

```cpp
    // If any item's data is equal to zero then reset it to -1.
    for (int i=0; i < m_myListCtrl.GetItemCount(); i++)
    {
        if (m_myListCtrl.GetItemData(i) == 0)
        {
            m_myListCtrl.SetItemData(i, (DWORD) -1);
        }
    }
```

## <a name="clistctrlgetitemindexrect"></a><a name="getitemindexrect"></a>CListCtrl：：获取项目索引重新完成

检索当前列表视图控件中全部或部分子项的边界矩形。

```
BOOL GetItemIndexRect(
    PLVITEMINDEX pItemIndex,
    int iColumn,
    int rectType,
    LPRECT pRect) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pItem索引*|[在]指向子项的父项的[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针。<br /><br /> 调用方负责分配和设置[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的成员。 此参数不能为 NULL。|
|*iColumn*|[在]控件中列的零基索引。|
|*整流类型*|[在]检索边界矩形的列表视图子项的一部分。 指定以下值之一：<br /><br /> LVIR_BOUNDS - 返回整个子项的边界矩形，包括图标和标签。<br /><br /> LVIR_ICON - 返回图标的边界矩形或子项的小图标。<br /><br /> LVIR_LABEL - 返回子项文本的边界矩形。|
|*普雷克*|[出]指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针，该结构接收有关子项的边界矩形的信息。<br /><br /> 调用方负责分配[RECT](/previous-versions/dd162897\(v=vs.85\))结构。 此参数不能为 NULL。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

此方法发送[LVM_GETITEMINDEXRECT](/windows/win32/Controls/lvm-getitemindexrect)消息，这在 Windows SDK 中介绍。 有关详细信息，请参阅[ListView_GetItemIndexRect宏](/windows/win32/api/commctrl/nf-commctrl-listview_getitemindexrect)。

### <a name="example"></a>示例

以下代码示例定义用于访问当前列表视图`m_listCtrl`控件的变量 。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

以下代码示例演示了该方法`GetGroupRect`。 在输入此代码示例之前，我们创建了一个列表视图控件，在报表视图中显示两列标题为"客户端 ID"和"分级"。 以下代码示例围绕两列中的第二个子项绘制一个 3D 矩形。

```cpp
    // GetItemIndexRect
    // Get the rectangle that bounds the second item in the first group.
    LVITEMINDEX lvItemIndex;
    lvItemIndex.iGroup = 0;
    lvItemIndex.iItem = 1;
    CRect rect;
    BOOL bRet = m_listCtrl.GetItemIndexRect(
        &lvItemIndex, 0, LVIR_BOUNDS, &rect);

    // Draw a red rectangle around the item.
    m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(255, 0, 0), RGB(255, 0, 0) );
```

## <a name="clistctrlgetitemposition"></a><a name="getitemposition"></a>CListCtrl：获取项目位置

检索列表视图项的位置。

```
BOOL GetItemPosition(
    int nItem,
    LPPOINT lpPoint) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其位置的项的索引。

*lpPoint*<br/>
在视图坐标中接收项目左上角位置的[POINT](/previous-versions/dd162805\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        POINT pt;

        // Move all items in the list control 100 pixels to the right.
        UINT i, nCount = m_myListCtrl.GetItemCount();

        for (i=0; i < nCount; i++)
        {
            m_myListCtrl.GetItemPosition(i, &pt);
            pt.x += 100;
            m_myListCtrl.SetItemPosition(i, pt);
        }
```

## <a name="clistctrlgetitemrect"></a><a name="getitemrect"></a>CListCtrl：：获取项目重新完成

检索当前视图中全部或部分项的边界矩形。

```
BOOL GetItemRect(
    int nItem,
    LPRECT lpRect,
    UINT nCode) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其位置的项的索引。

*lpRect*<br/>
接收边界矩形的[RECT](/previous-versions/dd162897\(v=vs.85\))结构的地址。

*n代码*<br/>
要为其检索边界矩形的列表视图项的一部分。 它可以是以下值之一：

- LVIR_BOUNDS 返回整个项目的边界矩形，包括图标和标签。

- LVIR_ICON 返回图标或小图标的边界矩形。

- LVIR_LABEL 返回项目文本的边界矩形。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
// OnClick is the handler for the NM_CLICK notification
void CListCtrlDlg::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;

    // Get the current mouse location and convert it to client
    // coordinates.
    CPoint pos( ::GetMessagePos() );
    ScreenToClient(&pos);

    // Get indexes of the first and last visible items in
    // the listview control.
    int index = m_myListCtrl.GetTopIndex();
    int last_visible_index = index + m_myListCtrl.GetCountPerPage();
    if (last_visible_index > m_myListCtrl.GetItemCount())
        last_visible_index = m_myListCtrl.GetItemCount();

    // Loop until number visible items has been reached.
    while (index <= last_visible_index)
    {
        // Get the bounding rectangle of an item. If the mouse
        // location is within the bounding rectangle of the item,
        // you know you have found the item that was being clicked.
        CRect r;
        m_myListCtrl.GetItemRect(index, &r, LVIR_BOUNDS);
        if (r.PtInRect(pia->ptAction))
        {
            UINT flag = LVIS_SELECTED | LVIS_FOCUSED;
            m_myListCtrl.SetItemState(index, flag, flag);
            break;
        }

        // Get the next item in listview control.
        index++;
    }
}
```

## <a name="clistctrlgetitemspacing"></a><a name="getitemspacing"></a>CListCtrl：获取项目间距

计算当前列表视图控件中的项之间的间距。

```
BOOL GetItemSpacing(
    BOOL fSmall,
    int* pnHorzSpacing,
    int* pnVertSpacing) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*fSmall*|[在]查看要为其检索项目间距的视图。 为小图标视图指定 TRUE，为图标视图指定 FALSE。|
|*pnHorzspacing*|[出]包含项之间的水平间距。|
|*pnVertspacing*|[出]包含项之间的垂直间距。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

此方法发送[LVM_GETITEMSPACING](/windows/win32/Controls/lvm-getitemspacing)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlgetitemstate"></a><a name="getitemstate"></a>CListCtrl：：获取项目状态

检索列表视图项的状态。

```
UINT GetItemState(
    int nItem,
    UINT nMask) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其状态的项的索引。

*nMask*<br/>
蒙版指定要返回哪个项的状态标志。

### <a name="return-value"></a>返回值

指定列表视图项的状态标志。

### <a name="remarks"></a>备注

项目的状态由`state`[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的成员指定，如 Windows SDK 中所述。 指定或更改项目的状态时，`stateMask`成员将指定要更改的状态位。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：getTopIndex](#gettopindex)。

## <a name="clistctrlgetitemtext"></a><a name="getitemtext"></a>CListCtrl：：获取项目文本

检索列表视图项或子项的文本。

```
int GetItemText(
    int nItem,
    int nSubItem,
    LPTSTR lpszText,
    int nLen) const;

CString GetItemText(
    int nItem,
    int nSubItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其文本的项的索引。

*n 子项目*<br/>
指定要检索其文本的子项。

*lpszText*<br/>
指向要接收项文本的字符串的指针。

*nLen*<br/>
*lpszText*指向的缓冲区的长度。

### <a name="return-value"></a>返回值

返回**int**的版本返回检索的字符串的长度。

返回 的版本`CString`返回项文本。

### <a name="remarks"></a>备注

如果 nSubItem 为零，则此函数将检索项标签;如果*nSubItem*为零，则此函数将检索物料标签。如果*nSubItem*是非零，它将检索子项的文本。 有关子项参数的详细信息，请参阅 Windows SDK 中有关[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的讨论。

## <a name="clistctrlgetnextitem"></a><a name="getnextitem"></a>CListCtrl：：获取下一个项目

搜索具有指定属性且与给定项具有指定关系的列表视图项。

```
int GetNextItem(
    int nItem,
    int nFlags) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要开始搜索的项的索引，或 -1 以查找与指定标志匹配的第一个项。 指定的项本身从搜索中排除。

*nFlags*<br/>
请求项与指定项的几何关系以及请求项的状态。 几何关系可以是以下值之一：

- LVNI_ABOVE 搜索高于指定项的项。

- LVNI_ALL按索引（默认值）搜索后续项。

- LVNI_BELOW搜索指定项下方的项。

- LVNI_TOLEFT 在指定项的左侧搜索项。

- LVNI_TORIGHT 搜索指定项右侧的项。

状态可以是零，也可以是以下一个或多个值：

- LVNI_DROPHILITED 项已设置LVIS_DROPHILITED状态标志。

- LVNI_FOCUSED 项已设置LVIS_FOCUSED状态标志。

- LVNI_SELECTED 项已设置LVIS_SELECTED状态标志。

如果项未设置所有指定状态标志，则搜索将继续执行下一个项目。

### <a name="return-value"></a>返回值

下一项的索引（如果成功）或 -1 否则。

## <a name="clistctrlgetnextitemindex"></a><a name="getnextitemindex"></a>CListCtrl：：获取下一个项目索引

检索具有指定属性集的当前列表视图控件中的项的索引。

```
BOOL GetNextItemIndex(
    PLVITEMINDEX pItemIndex,
    int nFlags) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pItem索引*|[进出]指向描述搜索开始项的[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针，或 -1 以查找与*nFlags*参数中的标志匹配的第一个项。<br /><br /> 如果此方法成功，则`LVITEMINDEX`结构将描述搜索找到的项。|
|*nFlags*|[在]指定如何执行搜索的标志的位组合 （OR）。<br /><br /> 搜索可以取决于目标项的索引、状态或外观，或者目标项相对于*pItemIndex*参数指定的项的物理位置。 有关详细信息，请参阅[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)消息中*的标志*参数。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

调用方负责分配和设置*pItemIndex*参数`LVITEMINDEX`指向的结构成员。

此方法发送[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlgetnextselecteditem"></a><a name="getnextselecteditem"></a>CListCtrl：：获取下一个选定项目

获取*pos*标识的列表项的索引，然后将*位置*设置到"位置"值。

```
int GetNextSelectedItem(POSITION& pos) const;
```

### <a name="parameters"></a>参数

*Pos*<br/>
对以前调用`GetNextSelectedItem`或`GetFirstSelectedItemPosition`返回的"位置"值的引用。 此调用将该值更新为下一个位置。

### <a name="return-value"></a>返回值

*由 pos*标识的列表项的索引。

### <a name="remarks"></a>备注

如果使用`GetNextSelectedItem`调用`GetFirstSelectedItemPosition`建立初始位置，则可以在转发迭代循环中使用。

您必须确保您的"位置"值有效。 如果无效，则 Microsoft 基础类库的调试版本断言。

### <a name="example"></a>示例

以下代码示例演示了此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="clistctrlgetnumberofworkareas"></a><a name="getnumberofworkareas"></a>CListctrl：获取工作范围

检索列表视图控件的当前工作区数。

```
UINT GetNumberOfWorkAreas() const;
```

### <a name="return-value"></a>返回值

此时未使用。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetNumberOfWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getnumberofworkareas)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        UINT i, uCount = m_myListCtrl.GetNumberOfWorkAreas();
        LPRECT lpRects = (LPRECT) malloc(uCount*sizeof(RECT));

        if (lpRects != NULL)
        {
            // Dump all of the work area dimensions.
            m_myListCtrl.GetWorkAreas(uCount, lpRects);

            for (i=0; i < uCount; i++)
            {
                TRACE(_T("Work area %d; left = %d, top = %d, right = %d, ")
                    _T("bottom = %d\r\n"),
                    i, lpRects[i].left, lpRects[i].top, lpRects[i].right,
                    lpRects[i].bottom);
            }

            free(lpRects);
        }
        else
        {
            TRACE(_T("Couldn't allocate enough memory!"));
        }
```

## <a name="clistctrlgetoutlinecolor"></a><a name="getoutlinecolor"></a>CListCtrl：：获取大纲颜色

检索列表视图控件的边框的颜色。

```
COLORREF GetOutlineColor() const;
```

### <a name="return-value"></a>返回值

返回包含轮廓颜色的[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETOUTLINECOLOR](/windows/win32/Controls/lvm-getoutlinecolor)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetorigin"></a><a name="getorigin"></a>CListCtrl：获取原点

检索列表视图控件的当前视图源。

```
BOOL GetOrigin(LPPOINT lpPoint) const;
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
接收视图源的[POINT](/previous-versions/dd162805\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。 但是，如果控件位于报表视图中，则返回值始终为零。

## <a name="clistctrlgetselectedcolumn"></a><a name="getselectedcolumn"></a>CListCtrl：获取精选列

检索列表控件中当前选定列的索引。

```
UINT GetSelectedColumn() const;
```

### <a name="return-value"></a>返回值

所选列的索引。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETSELECTEDCOLUMN](/windows/win32/Controls/lvm-getselectedcolumn)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetselectedcount"></a><a name="getselectedcount"></a>CListCtrl：获取精选计数

检索列表视图控件中选定项的数量。

```
UINT GetSelectedCount() const;
```

### <a name="return-value"></a>返回值

列表视图控件中所选项的数量。

### <a name="example"></a>示例

```cpp
        UINT i, uSelectedCount = m_myListCtrl.GetSelectedCount();
        int  nItem = -1;

        // Update all of the selected items.
        if (uSelectedCount > 0)
        {
            for (i=0; i < uSelectedCount; i++)
            {
                nItem = m_myListCtrl.GetNextItem(nItem, LVNI_SELECTED);
                ASSERT(nItem != -1);
                m_myListCtrl.Update(nItem);
            }
        }
```

## <a name="clistctrlgetselectionmark"></a><a name="getselectionmark"></a>CListCtrl：获取选择标记

检索列表视图控件的选择标记。

```
int GetSelectionMark();
```

### <a name="return-value"></a>返回值

零基选择标记，如果没有选择标记，则为 -1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_getselectionmark)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the selection mark to the first item only if no other item is
    // selected.
    if (m_myListCtrl.GetSelectionMark() == -1)
        m_myListCtrl.SetSelectionMark(0);
```

## <a name="clistctrlgetstringwidth"></a><a name="getstringwidth"></a>CListCtrl：：获取字符串宽度

确定显示所有给定字符串所需的最小列宽度。

```
int GetStringWidth(LPCTSTR lpsz) const;
```

### <a name="parameters"></a>参数

*lpsz*<br/>
要确定宽度的 null 终止字符串的地址。

### <a name="return-value"></a>返回值

以*lpsz*指向的字符串的宽度（以像素为单位）。

### <a name="remarks"></a>备注

返回的宽度会考虑控件的当前字体和列边距，但不考虑小图标的宽度。

### <a name="example"></a>示例

```cpp
        CString strColumn;
        int nWidth;

        // Insert six columns in the list view control. Make the width of
        // the column be the width of the column header plus 50%.
        for (int i = 0; i < 6; i++)
        {
            strColumn.Format(_T("column %d"), i);
            nWidth = 3*m_myListCtrl.GetStringWidth(strColumn)/2;
            m_myListCtrl.InsertColumn(i, strColumn, LVCFMT_LEFT, nWidth);
        }
```

## <a name="clistctrlgetsubitemrect"></a><a name="getsubitemrect"></a>CListCtrl：：获取子项目重新完成

检索列表视图控件中项的边界矩形。

```
BOOL GetSubItemRect(
    int iItem,
    int iSubItem,
    int nArea,
    CRect& ref);
```

### <a name="parameters"></a>参数

*iItem*<br/>
子项的父项的索引。

*i子项目*<br/>
子项的一个基于的索引。

*nArea*<br/>
确定要检索的边界矩形（列表视图子项）的部分。 边界矩形的部分（图标、标签或两者）通过将位或运算符应用于以下一个或多个值来指定：

- LVIR_BOUNDS 返回整个项目的边界矩形，包括图标和标签。

- LVIR_ICON 返回图标或小图标的边界矩形。

- LVIR_LABEL 返回整个项目的边界矩形，包括图标和标签。 这与LVIR_BOUNDS相同。

*ref*<br/>
对包含子项边界矩形坐标的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象的引用。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_GetSubItemRect](/windows/win32/api/commctrl/nf-commctrl-listview_getsubitemrect)的行为，如 Windows SDK 中所述。

## <a name="clistctrlgettextbkcolor"></a><a name="gettextbkcolor"></a>CListCtrl：获取文本BkColor

检索列表视图控件的文本背景颜色。

```
COLORREF GetTextBkColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的 32 位值。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：设置文本BkColor](#settextbkcolor)。

## <a name="clistctrlgettextcolor"></a><a name="gettextcolor"></a>CListCtrl：获取文本颜色

检索列表视图控件的文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的 32 位值。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：设置文本颜色](#settextcolor)。

## <a name="clistctrlgettileinfo"></a><a name="gettileinfo"></a>CListCtrl：：获取Tileinfo

检索有关列表视图控件中磁贴的信息。

```
BOOL GetTileInfo(PLVTILEINFO plvti) const;
```

### <a name="parameters"></a>参数

*普夫蒂*<br/>
指向接收切片信息的[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)结构的指针。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETTILEINFO](/windows/win32/Controls/lvm-gettileinfo)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgettileviewinfo"></a><a name="gettileviewinfo"></a>CListCtrl：：获取TileViewInfo

检索有关磁贴视图中的列表视图控件的信息。

```
BOOL GetTileViewInfo(PLVTILEVIEWINFO ptvi) const;
```

### <a name="parameters"></a>参数

*普特维*<br/>
指向接收检索信息的[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)结构的指针。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETTILEVIEWINFO](/windows/win32/Controls/lvm-gettileviewinfo)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgettooltips"></a><a name="gettooltips"></a>CListCtrl：获取工具提示

检索列表视图控件用于显示工具提示的工具提示控件。

```
CToolTipCtrl* GetToolTips() const;
```

### <a name="return-value"></a>返回值

指向列表控件使用的[CToolTipCtrl](ctooltipctrl-class.md)对象的指针。 如果["创建](#create)成员"函数使用样式LVS_NOTOOLTIPS，则不使用工具提示，并且返回 NULL。

### <a name="remarks"></a>备注

此成员函数实现 Win32 消息[LVM_GETTOOLTIPS](/windows/win32/Controls/lvm-gettooltips)的行为，如 Windows SDK 中所述。 的`GetToolTips`MFC 实现返回`CToolTipCtrl`由列表控件使用的对象，而不是工具提示控件的句柄。

### <a name="example"></a>示例

```cpp
        CToolTipCtrl* pTip = m_myListCtrl.GetToolTips();
        if (NULL != pTip)
        {
            pTip->UpdateTipText(_T("I'm a list view!"), &m_myListCtrl,
                IDD_MYLISTCTRL);
        }
```

## <a name="clistctrlgettopindex"></a><a name="gettopindex"></a>CListCtrl：获取Topindex

在列表视图或报表视图中检索最顶层可见项的索引。

```
int GetTopIndex() const;
```

### <a name="return-value"></a>返回值

最顶层可见项的索引。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Select all of the items that are completely visible.
        int n = m_myListCtrl.GetTopIndex();
        int nLast = n + m_myListCtrl.GetCountPerPage();

        for (; n < nLast; n++)
        {
            m_myListCtrl.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
            ASSERT(m_myListCtrl.GetItemState(n, LVIS_SELECTED) == LVIS_SELECTED);
        }
```

## <a name="clistctrlgetview"></a><a name="getview"></a>CListCtrl：获取视图

获取列表视图控件的视图。

```
DWORD GetView() const;
```

### <a name="return-value"></a>返回值

列表视图控件的当前视图。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETVIEW](/windows/win32/Controls/lvm-getview)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetviewrect"></a><a name="getviewrect"></a>CListCtrl：：获取视图Rect

检索列表视图控件中所有项的边界矩形。

```
BOOL GetViewRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
[RECT](/previous-versions/dd162897\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

列表视图必须位于图标视图或小图标视图中。

## <a name="clistctrlgetworkareas"></a><a name="getworkareas"></a>CListCtrl：：获取工作领域

检索列表视图控件的当前工作区。

```
void GetWorkAreas(
    int nWorkAreas,
    LPRECT pRect) const;
```

### <a name="parameters"></a>参数

*n工作领域*<br/>
`RECT` *pRect*数组中包含的结构数。

*普雷克*<br/>
指向接收列表视图控件工作区`RECT`的结构（或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象）数组的指针。 这些结构中的值位于客户端坐标中。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_GetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：获取工作范围的数量](#getnumberofworkareas)。

## <a name="clistctrlhasgroup"></a><a name="hasgroup"></a>CListCtrl：：哈斯集团

确定列表视图控件是否具有指定的组。

```
BOOL HasGroup(int iGroupId) const;
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要请求的组的标识符。

### <a name="return-value"></a>返回值

成功时返回 TRUE，在失败时返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_HASGROUP](/windows/win32/Controls/lvm-hasgroup)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlhittest"></a><a name="hittest"></a>CListCtrl：hitTest

确定哪个列表视图项（如果有）位于指定位置。

```
int HitTest(LVHITTESTINFO* pHitTestInfo) const;

int HitTest(
    CPoint pt,
    UINT* pFlags = NULL) const;
```

### <a name="parameters"></a>参数

*pHitTestInfo*<br/>
包含命中测试`LVHITTESTINFO`位置并接收命中测试结果信息的结构的地址。

*pt*<br/>
要测试的点。

*pFlags*<br/>
指向接收有关测试结果信息的整数的指针。 请参阅 Windows SDK`flags`中[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)结构成员的说明。

### <a name="return-value"></a>返回值

*pHitTestInfo*指定位置的项目索引（如果有）或 -1。

### <a name="remarks"></a>备注

您可以使用结构`flag`成员LVHT_ABOVE、LVHT_BELOW、LVHT_TOLEFT和LVHT_TORIGHT值来确定是否滚动列表视图控件的内容。 例如，如果位置位于工作区的上方和左侧，则可以组合其中两个标志。

您可以测试结构`flag`成员LVHT_ONITEM值，以确定给定位置是否超过列表视图项。 此值是对结构成员LVHT_ONITEMICON、LVHT_ONITEMLABEL和LVHT_ONITEMSTATEICON值的`flag`一点-OR 操作。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    CPoint point(pia->ptAction);

    // Select the item the user clicked on.
    UINT uFlags;
    int nItem = m_myListCtrl.HitTest(point, &uFlags);

    if (uFlags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItem(nItem, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED,
            LVIS_SELECTED, 0);
    }

    *pResult = 0;
}
```

## <a name="clistctrlinsertcolumn"></a><a name="insertcolumn"></a>CListCtrl：：插入列

在列表视图控件中插入新列。

```
int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,
    LPCTSTR lpszColumnHeading,
    int nFormat = LVCFMT_LEFT,
    int nWidth = -1,
    int nSubItem = -1);
```

### <a name="parameters"></a>参数

*nCol*<br/>
新列的索引。

*pColumn*<br/>
包含新列`LVCOLUMN`属性的结构的地址。

*lpszColumnheading*<br/>
包含列标题的字符串的地址。

*nFormat*<br/>
指定列对齐的整数。 它可以是这些值之一：LVCFMT_LEFT、LVCFMT_RIGHT或LVCFMT_CENTER。

*n 宽度*<br/>
列的宽度，以像素为单位。 如果此参数为 -1，则不设置列宽度。

*n 子项目*<br/>
与列关联的子项的索引。 如果此参数为 -1，则没有子项与列关联。

### <a name="return-value"></a>返回值

如果成功或 -1，则新列的索引。

### <a name="remarks"></a>备注

列表视图控件中最左侧的列必须左对齐。

[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构包含报表视图中列的属性。 它还用于接收有关列的信息。 此结构在 Windows SDK 中描述。

## <a name="clistctrlinsertgroup"></a><a name="insertgroup"></a>CListCtrl：：插入组

将组插入到列表视图控件中。

```
LRESULT InsertGroup(
    int index,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>参数

*index*<br/>
要插入组的项的索引。

*pgrp*<br/>
指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针，其中包含要添加的组。

### <a name="return-value"></a>返回值

返回组添加到的项的索引，如果操作失败，则返回 -1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTGROUP](/windows/win32/Controls/lvm-insertgroup)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlinsertgroupsorted"></a><a name="insertgroupsorted"></a>CListCtrl：：插入组排序

将指定的组插入有序的组列表中。

```
LRESULT InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert);
```

### <a name="parameters"></a>参数

*pStructInsert*<br/>
指向包含要插入的组的[LVINSERTGROUPSORTED 结构](/windows/win32/api/commctrl/ns-commctrl-lvinsertgroupsorted)的指针。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTGROUPSORTED](/windows/win32/Controls/lvm-insertgroupsorted)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlinsertitem"></a><a name="insertitem"></a>CListCtrl：：插入项目

将项插入到列表视图控件中。

```
int InsertItem(const LVITEM* pItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem,
    int nImage);

int InsertItem(
    UINT nMask,
    int nItem,
    LPCTSTR lpszItem,
    UINT nState,
    UINT nStateMask,
    int nImage,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*pItem*<br/>
指向[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的指针，该结构指定项目的属性，如 Windows SDK 中所述。

*nItem*<br/>
要插入的项的索引。

*lpszItem*<br/>
包含项标签的字符串的地址，如果项是回调项，则LPSTR_TEXTCALLBACK。 有关回调项目的信息，请参阅[CListCtrl：：获取回调掩码](#getcallbackmask)。

*n图像*<br/>
如果项是回调项，则I_IMAGECALLBACK索引。 有关回调项目的信息，请参阅[CListCtrl：：获取回调掩码](#getcallbackmask)。

*nMask*<br/>
*nMask*参数指定作为参数传递的项属性有效。 它可以是 Windows SDK 中的[LVITEM 结构](/windows/win32/api/commctrl/ns-commctrl-lvitemw)中描述的一个或多个掩码值。 有效值可以与位或运算符组合。

*n州*<br/>
指示项目的状态、状态图像和叠加图像。 有关详细信息，请参阅 Windows SDK 主题[LVITEM 结构和](/windows/win32/api/commctrl/ns-commctrl-lvitemw)[列表查看项目状态](/windows/win32/Controls/list-view-item-states)，了解有效标志的列表。

*nStateMask*<br/>
指示将检索或修改状态成员的哪些位。 有关详细信息，请参阅 Windows SDK 中的[LVITEM 结构](/windows/win32/api/commctrl/ns-commctrl-lvitemw)。

*lParam*<br/>
与项关联的 32 位应用程序特定值。 如果指定此参数，则必须将*nMask*属性LVIF_PARAM。

### <a name="return-value"></a>返回值

如果成功或 -1，则新项目的索引。

### <a name="remarks"></a>备注

调用此方法可能会导致LVM_INSERTITEM消息发送到控件窗口。 控件的关联消息处理程序可能无法在某些情况下设置项文本（例如使用窗口样式，如LVS_OWNERDRAW）。 有关这些条件的详细信息，请参阅 Windows SDK 中的[LVM_INSERTITEM。](/windows/win32/Controls/lvm-insertitem)

### <a name="example"></a>示例

```cpp
        CString strText;
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Insert 10 items in the list view control.
        for (int i = 0; i < 10; i++)
        {
            strText.Format(TEXT("item %d"), i);

            // Insert the item, select every other item.
            m_myListCtrl.InsertItem(LVIF_TEXT | LVIF_STATE, i, strText,
                (i % 2) == 0 ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, 0);

            // Initialize the text of the subitems.
            for (int j = 1; j < nColumnCount; j++)
            {
                strText.Format(TEXT("sub-item %d %d"), i, j);
                m_myListCtrl.SetItemText(i, j, strText);
            }
        }
```

## <a name="clistctrlinsertmarkhittest"></a><a name="insertmarkhittest"></a>CListCtrl：：插入马克希特测试

检索最接近指定点的插入点。

```
int InsertMarkHitTest(
    LPPOINT pPoint,
    LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>参数

*pPoint*<br/>
指向 POINT[结构的](/previous-versions/dd162805\(v=vs.85\))指针，该结构包含命中测试坐标，相对于列表控件的工作区区域。

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，用于指定最接近点参数定义的坐标的插入点。

### <a name="return-value"></a>返回值

最接近指定点的插入点。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTMARKHITTEST](/windows/win32/Controls/lvm-insertmarkhittest)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlisgroupviewenabled"></a><a name="isgroupviewenabled"></a>CListCtrl：是否启用了群视图

确定是否为列表视图控件启用组视图。

```
BOOL IsGroupViewEnabled() const;
```

### <a name="return-value"></a>返回值

如果启用了组视图，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_ISGROUPVIEWENABLED](/windows/win32/Controls/lvm-isgroupviewenabled)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlisitemvisible"></a><a name="isitemvisible"></a>CListCtrl：是可分割的

指示当前列表视图控件中的指定项是否可见。

```
BOOL IsItemVisible(int index) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*index*|[在]当前列表视图控件中项的零基索引。|

### <a name="return-value"></a>返回值

如果指定的项可见，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

此方法发送[LVM_ISITEMVISIBLE](/windows/win32/Controls/lvm-isitemvisible)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlmapidtoindex"></a><a name="mapidtoindex"></a>CListctrl：mapIDToindex

将当前列表视图控件中项的唯一 ID 映射到索引。

```
UINT MapIDToIndex(UINT id) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*id*|[在]项的唯一 ID。|

### <a name="return-value"></a>返回值

指定 ID 的当前索引。

### <a name="remarks"></a>备注

列表视图控件按索引在内部跟踪项。 这可能会带来问题，因为索引可以在控件的生存期内更改。 列表视图控件可以在创建项时使用 ID 标记项，并且您可以使用此 ID 来保证列表视图控件的生存期内的唯一性。

请注意，在多线程环境中，索引仅在承载列表视图控件的线程上得到保证，而在后台线程上。

此方法发送[LVM_MAPIDTOINDEX](/windows/win32/controls/lvm-mapidtoindex)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlmapindextoid"></a><a name="mapindextoid"></a>CListctrl：：映射索引TOID

将当前列表视图控件中的项索引映射到唯一 ID。

```
UINT MapIndexToID(UINT index) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*index*|[在]项的零基索引。|

### <a name="return-value"></a>返回值

指定项的唯一 ID。

### <a name="remarks"></a>备注

列表视图控件按索引在内部跟踪项。 这可能会带来问题，因为索引可以在控件的生存期内更改。 创建项时，列表视图控件可以使用 ID 标记项。 可以使用此 ID 访问列表视图控件生存期内的特定项。

请注意，在多线程环境中，索引仅在承载列表视图控件的线程上得到保证，而在后台线程上。

此方法发送[LVM_MAPINDEXTOID](/windows/win32/Controls/lvm-mapindextoid)消息，这在 Windows SDK 中介绍。

### <a name="example"></a>示例

以下代码示例定义用于访问当前列表视图`m_listCtrl`控件的变量 。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

以下代码示例演示了该方法`MapIndexToID`。 在此代码示例的较早部分中，我们创建了一个列表视图控件，该控件在报表视图中显示两列标题为"ClientID"和"分级"。 下面的示例将每个列表视图项的索引映射到标识号，然后检索每个标识号的索引。 最后，该示例报告是否检索了原始索引。

```cpp
    // MapIndexToID
    int iCount = m_listCtrl.GetItemCount();
    UINT nId = 0;
    UINT nIndex = 0;
    for (int iIndexOriginal = 0; iIndexOriginal < iCount; iIndexOriginal++)
    {
        // Map index to ID.
        nId = m_listCtrl.MapIndexToID((UINT)iIndexOriginal);

        // Map ID to index.
        nIndex = m_listCtrl.MapIDToIndex(nId);

        if (nIndex != (UINT)(iIndexOriginal))
        {
            CString str;
            str.Format(_T("Mapped index (%d) is not equal to original index (%d)"),
                nIndex, (UINT)(iIndexOriginal));
            AfxMessageBox(str);
            return;
        }
    }
    AfxMessageBox(_T("The mapped indexes and original indexes are equal."),
        MB_ICONINFORMATION);
```

## <a name="clistctrlmovegroup"></a><a name="movegroup"></a>CListCtrl：：移动组

将指定的组移动到列表视图控件的指定基于零的索引。

```
LRESULT MoveGroup(
    int iGroupId,
    int toIndex);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要移动的组的标识符。

*到索引*<br/>
要移动组的零基索引。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_MOVEGROUP](/windows/win32/Controls/lvm-movegroup)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlmoveitemtogroup"></a><a name="moveitemtogroup"></a>CListctrl：：移动项目组

将指定的项移动到指定的组中。

```
void MoveItemToGroup(
    int idItemFrom,
    int idGroupTo);
```

### <a name="parameters"></a>参数

*idItem 来自*<br/>
[在]要移动的项的索引。

*idGroupto*<br/>
[在]要移动到的组的标识符。

### <a name="remarks"></a>备注

> [!NOTE]
> 此方法当前未实现。

此方法模拟[LVM_MOVEITEMTOGROUP](/windows/win32/Controls/lvm-moveitemtogroup)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlredrawitems"></a><a name="redrawitems"></a>CListCtrl：：重绘项目

强制列表视图控件重新绘制一系列项。

```
BOOL RedrawItems(
    int nFirst,
    int nLast);
```

### <a name="parameters"></a>参数

*n第一*<br/>
要重新绘制的第一个项目的索引。

*n 上次*<br/>
要重新绘制的最后一个项目的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

在列表视图窗口收到WM_PAINT消息之前，实际上不会重新绘制指定的项目。 要立即重新绘制，请使用此功能后调用 Windows[更新窗口](/windows/win32/api/winuser/nf-winuser-updatewindow)功能。

## <a name="clistctrlremoveallgroups"></a><a name="removeallgroups"></a>CListCtrl：：删除所有组

从列表视图控件中删除所有组。

```
void RemoveAllGroups();
```

### <a name="remarks"></a>备注

此成员函数模拟[LVM_REMOVEALLGROUPS](/windows/win32/Controls/lvm-removeallgroups)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlremovegroup"></a><a name="removegroup"></a>CListCtrl：：删除组

从列表视图控件中删除指定的组。

```
LRESULT RemoveGroup(int iGroupId);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要删除的组的标识符。

### <a name="return-value"></a>返回值

如果成功，则返回组的索引，否则返回 -1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_REMOVEGROUP](/windows/win32/Controls/lvm-removegroup)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlscroll"></a><a name="scroll"></a>CListCtrl：：滚动

滚动列表视图控件的内容。

```
BOOL Scroll(CSize size);
```

### <a name="parameters"></a>参数

*大小*<br/>
指定`CSize`水平和垂直滚动量（以像素为单位）的对象。 大小`y`成员除*size*以列表视图控件行的高度（以像素为单位），控件按生成的行数滚动。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="clistctrlsetbkcolor"></a><a name="setbkcolor"></a>CListCtrl：：SetBkColor

设置列表视图控件的背景颜色。

```
BOOL SetBkColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*铬*<br/>
要设置的背景颜色，或无背景颜色的CLR_NONE值。 具有背景颜色的列表视图控件比没有背景颜色的控件重绘速度明显快。 有关详细信息，请参阅 Windows SDK 中的[COLORREF。](/windows/win32/gdi/colorref)

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetBkColor() == crBkColor);
```

## <a name="clistctrlsetbkimage"></a><a name="setbkimage"></a>CListCtrl：：SetBkImage

设置列表视图控件的背景图像。

```
BOOL SetBkImage(LVBKIMAGE* plvbkImage);

BOOL SetBkImage(
    HBITMAP hBitmap,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);

BOOL SetBkImage(
    LPTSTR pszUrl,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);
```

### <a name="parameters"></a>参数

*plvbk图像*<br/>
`LVBKIMAGE`包含新背景图像信息的结构的地址。

*hBitmap*<br/>
处理位图。

*pszUrl*<br/>
包含背景图像 URL 的 NULL 终止字符串。

*fTile*<br/>
如果要在列表视图控件的后台平铺图像，则非零;否则 0。

*x 偏移百分比*<br/>
图像左边缘的偏移量（以像素为单位），与列表视图控件的原点。

*yOffset%*<br/>
图像上边缘的偏移量（以像素为单位）来自列表视图控件的原点。

### <a name="return-value"></a>返回值

如果成功，则返回非零，否则返回零。

### <a name="remarks"></a>备注

> [!NOTE]
> 由于`CListCtrl::SetBkImage`使用 OLE COM 功能，因此在使用`SetBkImage`之前必须初始化 OLE 库。 最好在应用程序初始化时初始化 COM 库，并在应用程序终止时取消初始化库。 这可在使用 ActiveX 技术、OLE 自动化、OLE 链接/嵌入或 ODBC/DAO 操作的 MFC 应用程序中自动完成。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：getBkImage](#getbkimage)。

## <a name="clistctrlsetcallbackmask"></a><a name="setcallbackmask"></a>CListCtrl：：设置回拨掩码

设置列表视图控件的回调掩码。

```
BOOL SetCallbackMask(UINT nMask);
```

### <a name="parameters"></a>参数

*nMask*<br/>
回调掩码的新值。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Set the callback mask so that only the selected and focused states
    // are stored for each item.
    m_myListCtrl.SetCallbackMask(LVIS_SELECTED|LVIS_FOCUSED);
    ASSERT(m_myListCtrl.GetCallbackMask() ==
        (LVIS_SELECTED|LVIS_FOCUSED));
```

## <a name="clistctrlsetcheck"></a><a name="setcheck"></a>CListCtrl：：设置检查

确定列表控件项的状态图像是否可见。

```
BOOL SetCheck(
    int nItem,
    BOOL fCheck = TRUE);
```

### <a name="parameters"></a>参数

*nItem*<br/>
列表控件项的零基索引。

*f检查*<br/>
指定项目的状态图像是否应可见。 默认情况下 *，fCheck*为 TRUE，状态图像可见。 如果*fCheck*是 FALSE，则它不可见。

### <a name="return-value"></a>返回值

如果选中项目，则非零，否则为 0。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();
        BOOL fCheck = FALSE;

        // Set the check state of every other item to TRUE and
        // all others to FALSE.
        for (int i = 0; i < nCount; i++)
        {
            m_myListCtrl.SetCheck(i, fCheck);
            ASSERT((m_myListCtrl.GetCheck(i) && fCheck) ||
                (!m_myListCtrl.GetCheck(i) && !fCheck));
            fCheck = !fCheck;
        }
```

## <a name="clistctrlsetcolumn"></a><a name="setcolumn"></a>CListCtrl：：设置列

设置列表视图列的属性。

```
BOOL SetColumn(
    int nCol,
    const LVCOLUMN* pColumn);
```

### <a name="parameters"></a>参数

*nCol*<br/>
要设置其属性的列的索引。

*pColumn*<br/>
包含新列属性的[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构的地址，如 Windows SDK 中所述。 结构的成员`mask`指定要设置的列属性。 如果`mask`成员指定LVCF_TEXT值，则结构的成员`pszText`是 null 终止字符串的地址，并且忽略结构`cchTextMax`的成员。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取列。](#getcolumn)

## <a name="clistctrlsetcolumnorderarray"></a><a name="setcolumnorderarray"></a>CListCtrl：：设置列阵数组

设置列表视图控件的列顺序（从左到右）。

```
BOOL SetColumnOrderArray(
    int iCount,
    LPINT piArray);
```

### <a name="parameters"></a>参数

*皮拉里*<br/>
指向包含列表视图控件中列的索引值的缓冲区的指针（从左到右）。 缓冲区必须足够大，以包含列表视图控件中的列总数。

*iCount*<br/>
列表视图控件中的列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_setcolumnorderarray)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取列柱顺序数组](#getcolumnorderarray)。

## <a name="clistctrlsetcolumnwidth"></a><a name="setcolumnwidth"></a>CListCtrl：：设置列宽

更改报表视图或列表视图中列的宽度。

```
BOOL SetColumnWidth(
    int nCol,
    int cx);
```

### <a name="parameters"></a>参数

*nCol*<br/>
要为其设置宽度的列的索引。 在列表视图中，此参数必须为 0。

*残雪*<br/>
列的新宽度。 可以是LVSCW_AUTOSIZE也可以LVSCW_AUTOSIZE_USEHEADER，如 Windows SDK[中LVM_SETCOLUMNWIDTH](/windows/win32/Controls/lvm-setcolumnwidth)所述。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="clistctrlsetextendedstyle"></a><a name="setextendedstyle"></a>CListCtrl：：设置扩展样式

设置列表视图控件的当前扩展样式。

```
DWORD SetExtendedStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>参数

*dwNewStyle*<br/>
列表视图控件使用的扩展样式的组合。 有关这些样式的描述性列表，请参阅 Windows SDK 中的[扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)主题。

### <a name="return-value"></a>返回值

列表视图控件使用以前的扩展样式的组合。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_setextendedlistviewstyle)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Allow the header controls item to be movable by the user.
    m_myListCtrl.SetExtendedStyle
        (m_myListCtrl.GetExtendedStyle()|LVS_EX_HEADERDRAGDROP);
```

## <a name="clistctrlsetgroupinfo"></a><a name="setgroupinfo"></a>CListCtrl：：SetGroupInfo

设置描述当前列表视图控件的指定组的信息。

```
int SetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
其信息集组的标识符。

*pgrp*<br/>
指向包含要设置的信息的[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针。 调用方负责分配此结构并设置其成员。

### <a name="return-value"></a>返回值

如果方法成功，则组的 ID;否则，-1。

### <a name="remarks"></a>备注

此方法发送[LVM_SETGROUPINFO](/windows/win32/Controls/lvm-setgroupinfo)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlsetgroupmetrics"></a><a name="setgroupmetrics"></a>CListCtrl：：设置组指标

设置列表视图控件的组指标。

```
void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics);
```

### <a name="parameters"></a>参数

*p组指标*<br/>
指向[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)结构的指针，其中包含要设置的组指标信息。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETGROUPMETRICS](/windows/win32/Controls/lvm-setgroupmetrics)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsethotcursor"></a><a name="sethotcursor"></a>CListCtrl：：设置HotCursor

设置为列表视图控件启用热跟踪时使用的游标。

```
HCURSOR SetHotCursor(HCURSOR hc);
```

### <a name="parameters"></a>参数

*Hc*<br/>
游标资源的句柄，用于表示热游标。

### <a name="return-value"></a>返回值

列表视图控件正在使用以前的热游标资源的句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_sethotcursor)的行为，如 Windows SDK 中所述。

热光标（仅在启用悬停选择时可见）出现在光标经过任何列表视图项时。 通过设置扩展样式LVS_EX_TRACKSELECT启用悬停选择。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取 HotCursor](#gethotcursor)。

## <a name="clistctrlsethotitem"></a><a name="sethotitem"></a>CListCtrl：：设置Hot项目

设置列表视图控件的当前热项。

```
int SetHotItem(int iIndex);
```

### <a name="parameters"></a>参数

*iIndex*<br/>
要设置为热项的项的零基索引。

### <a name="return-value"></a>返回值

以前热项的零基索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_SetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_sethotitem)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：获取 HotItem](#gethotitem)。

## <a name="clistctrlsethovertime"></a><a name="sethovertime"></a>CListCtrl：：设置悬停时间

设置列表视图控件的当前悬停时间。

```
DWORD SetHoverTime(DWORD dwHoverTime = (DWORD)-1);
```

### <a name="parameters"></a>参数

*dwHover时间*<br/>
新的延迟（以毫秒为单位），鼠标光标必须在选择项目之前将其悬停在项目上。 如果传递默认值，则时间设置为默认悬停时间。

### <a name="return-value"></a>返回值

上一个悬停时间，以毫秒为单位。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_sethovertime)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取悬停时间](#gethovertime)。

## <a name="clistctrlseticonspacing"></a><a name="seticonspacing"></a>CListCtrl：：设置图标

设置列表视图控件中图标之间的间距。

```
CSize SetIconSpacing(
    int cx,
    int cy);

CSize SetIconSpacing(CSize size);
```

### <a name="parameters"></a>参数

*残雪*<br/>
x 轴图标之间的距离（以像素为单位）。

*cy*<br/>
y 轴图标之间的距离（以像素为单位）。

*大小*<br/>
指定`CSize`x 轴和 y 轴图标之间的距离（以像素为单位）的对象。

### <a name="return-value"></a>返回值

包含图标间距的先前值的[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetIconSpacing](/windows/win32/api/commctrl/nf-commctrl-listview_seticonspacing)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Leave lots of space between icons.
    m_myListCtrl.SetIconSpacing(CSize(100, 100));
```

## <a name="clistctrlsetimagelist"></a><a name="setimagelist"></a>CListCtrl：：设置图像列表

将图像列表分配给列表视图控件。

```
CImageList* SetImageList(
    CImageList* pImageList,
    int nImageListType);
```

### <a name="parameters"></a>参数

*pImageList*<br/>
指向要分配的图像列表的指针。

*n图像列表类型*<br/>
图像列表的类型。 它可以是以下值之一：

- LVSIL_NORMAL具有大图标的图像列表。

- LVSIL_SMALL带有小图标的图像列表。

- LVSIL_STATE图像列表与状态图像。

### <a name="return-value"></a>返回值

指向上一个图像列表的指针。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取图像列表](#getimagelist)。

## <a name="clistctrlsetinfotip"></a><a name="setinfotip"></a>CListCtrl：：设置信息提示

设置工具提示文本。

```
BOOL SetInfoTip(PLVSETINFOTIP plvInfoTip);
```

### <a name="parameters"></a>参数

*plvInfo提示*<br/>
指向[LVFSETINFOTIP](/windows/win32/api/commctrl/ns-commctrl-lvsetinfotip)结构的指针，其中包含要设置的信息。

### <a name="return-value"></a>返回值

成功时返回 TRUE，在失败时返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINFOTIP](/windows/win32/Controls/lvm-setinfotip)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetinsertmark"></a><a name="setinsertmark"></a>CListCtrl：：设置插入标记

将插入点设置到定义的位置。

```
BOOL SetInsertMark(LPLVINSERTMARK plvim);
```

### <a name="parameters"></a>参数

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，指定在何处设置插入点。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。 如果`cbSize``LVINSERTMARK`结构成员中的大小不等于结构的实际大小，或者插入点不应用于当前视图中，则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINSERTMARK](/windows/win32/Controls/lvm-setinsertmark)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetinsertmarkcolor"></a><a name="setinsertmarkcolor"></a>CListCtrl：：设置插入标记颜色

设置插入点的颜色。

```
COLORREF SetInsertMarkColor(COLORREF color);
```

### <a name="parameters"></a>参数

*颜色*<br/>
指定颜色以设置插入点的[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="return-value"></a>返回值

返回包含`COLORREF`前一种颜色的结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINSERTMARKCOLOR](/windows/win32/Controls/lvm-setinsertmarkcolor)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetitem"></a><a name="setitem"></a>CListCtrl：设置项目

设置列表视图项的部分或全部属性。

```
BOOL SetItem(const LVITEM* pItem);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam,
    int nIndent);
```

### <a name="parameters"></a>参数

*pItem*<br/>
包含新项目属性的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的地址，如 Windows SDK 中所述。 结构的成员`iItem``iSubItem`标识项或子项，结构`mask`的成员指定要设置的属性。 有关成员的详细信息，`mask`请参阅**备注**。

*nItem*<br/>
要设置其属性的项的索引。

*n 子项目*<br/>
要设置其属性的子项的索引。

*nMask*<br/>
指定要设置的属性（请参阅备注）。

*lpszItem*<br/>
指定项标签的 null 终止字符串的地址。

*n图像*<br/>
项目图像在图像列表中的索引。

*n州*<br/>
指定要更改状态的值（请参阅备注）。

*nStateMask*<br/>
指定要更改哪些状态（请参阅备注）。

*lParam*<br/>
要与项关联的 32 位应用程序特定值。

*n 因登特*<br/>
缩进的宽度（以像素为单位）。 如果*nIndent*小于系统定义的最小宽度，则新宽度将设置为系统定义的最小宽度

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVITEM`结构`iItem`的`iSubItem`和 成员以及*nItem*和*nSubItem*参数标识要设置其属性的项和子项。

结构和`mask` `LVITEM` *nMask*参数的成员指定要设置的项属性：

- LVIF_TEXT`pszText`成员或*lpszItem*参数是 null 终止字符串的地址;将`cchTextMax`忽略该成员。

- LVIF_STATE`stateMask`成员或*nStateMask*参数指定要更改的项状态`state`，并且成员或*nState*参数包含这些状态的值。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：hitTest](#hittest)。

## <a name="clistctrlsetitemcount"></a><a name="setitemcount"></a>CListCtrl：：设置项目计数

准备列表视图控件以添加大量项。

```
void SetItemCount(int nItems);
```

### <a name="parameters"></a>参数

*n项目*<br/>
控件最终将包含的项数。

### <a name="remarks"></a>备注

要设置虚拟列表视图控件的项计数，请参阅[CListCtrl：：setItemCountEx](#setitemcountex)。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_SetItemCount](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcount)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.
        m_myListCtrl.SetItemCount(1024);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myListCtrl.InsertItem(i, str);
        }
```

## <a name="clistctrlsetitemcountex"></a><a name="setitemcountex"></a>CListCtrl：：设置项目计数Ex

设置虚拟列表视图控件的项计数。

```
BOOL SetItemCountEx(
    int iCount,
    DWORD dwFlags = LVSICF_NOINVALIDATEALL);
```

### <a name="parameters"></a>参数

*iCount*<br/>
控件最终将包含的项数。

dwFlags**<br/>
指定重置项目计数后列表视图控件的行为。 此值可以是以下因素的组合：

- LVSICF_NOINVALIDATEALL 除非受影响的项当前在视图中，否则列表视图控件不会重新绘制。 这是默认值。

- LVSICF_NOSCROLL 当项目计数更改时，列表视图控件不会更改滚动位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetItemCountEx](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcountex)的行为，如 Windows SDKand 中所述，应仅调用虚拟列表视图。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.

        // Force my virtual list view control to allocate
        // enough memory for my 1024 items.
        m_myVirtualListCtrl.SetItemCountEx(1024, LVSICF_NOSCROLL|
            LVSICF_NOINVALIDATEALL);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myVirtualListCtrl.InsertItem(i, str);
        }
```

## <a name="clistctrlsetitemdata"></a><a name="setitemdata"></a>CListCtrl：：设置项目数据

设置与*nItem*指定的项关联的 32 位应用程序特定值。

```
BOOL SetItemData(int nItem, DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要设置其数据的列表项的索引。

*dwData*<br/>
要与项关联的 32 位值。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

此值是`lParam` [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的成员，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the data of each item to be equal to its index.
    for (int i = 0; i < m_myListCtrl.GetItemCount(); i++)
    {
        m_myListCtrl.SetItemData(i, i);
    }
```

## <a name="clistctrlsetitemindexstate"></a><a name="setitemindexstate"></a>CListCtrl：：设置项目索引状态

设置当前列表视图控件中项的状态。

```
BOOL SetItemIndexState(
    PLVITEMINDEX pItemIndex,
    DWORD dwState,
    DWORD dwMask) const;
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*pItem索引*|[在]指向描述项的[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针。 调用方负责分配此结构并设置其成员。|
|*德沃州*|[在]要设置项的状态，这是[列表视图项状态](/windows/win32/Controls/list-view-item-states)的位组合。 指定要重置的零或要设置的状态。|
|*dwMask*|[在]*dwState*参数指定的状态的有效位的掩码。 指定[列表视图项状态](/windows/win32/Controls/list-view-item-states)的位组合 （OR）。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

有关*dwState*参数的详细信息，请参阅[列表视图项状态](/windows/win32/Controls/list-view-item-states)。

有关*dwMask*参数的详细信息，请参阅[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构*的状态掩码*成员。

此方法发送[LVM_SETITEMINDEXSTATE](/windows/win32/Controls/lvm-setitemindexstate)消息，这在 Windows SDK 中介绍。

## <a name="clistctrlsetitemposition"></a><a name="setitemposition"></a>CListCtrl：：设置项目位置

将项移动到列表视图控件中的指定位置。

```
BOOL SetItemPosition(
    int nItem,
    POINT pt);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要设置其位置的项的索引。

*pt*<br/>
指定项目左上角的新位置（在视图坐标中）的[POINT](/previous-versions/dd162805\(v=vs.85\))结构。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

控件必须位于图标或小图标视图中。

如果列表视图控件具有LVS_AUTOARRANGE样式，则列表视图在设置项目位置后进行排列。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取项目位置](#getitemposition)。

## <a name="clistctrlsetitemstate"></a><a name="setitemstate"></a>CListCtrl：：设置项目状态

更改列表视图控件中项的状态。

```
BOOL SetItemState(
    int nItem,
    LVITEM* pItem);

BOOL SetItemState(
    int nItem,
    UINT nState,
    UINT nMask);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要设置其状态的项的索引。

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的地址，如 Windows SDK 中所述。 结构的成员`stateMask`指定要更改的状态位，并且结构的成员`state`包含这些位的新值。 其他成员将被忽略。

*n州*<br/>
状态位的新值。 有关可能值的列表，请参阅[CListCtrl：getNextItem](#getnextitem)和[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)状态成员。

*nMask*<br/>
蒙版指定要更改的状态位。 此值对应于[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的状态掩码成员。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

项的"状态"是指定项的可用性、指示用户操作或以其他方式反映项状态的值。 列表视图控件会更改某些状态位，例如当用户选择项时。 应用程序可能会更改其他状态位以禁用或隐藏该项目，或指定叠加图像或状态图像。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：getTopIndex](#gettopindex)。

## <a name="clistctrlsetitemtext"></a><a name="setitemtext"></a>CListCtrl：：设置项目文本

更改列表视图项或子项的文本。

```
BOOL SetItemText(
    int nItem,
    int nSubItem,
    LPCTSTR lpszText);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要设置其文本的项的索引。

*n 子项目*<br/>
子项的索引，或用于设置项标签的零。

*lpszText*<br/>
指向包含新项目文本的字符串的指针。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此方法不适用于包含LVS_OWNERDATA窗口样式的控件（实际上，这将导致调试版本中的断言）。 有关此列表控件样式的详细信息，请参阅[列表视图控件概述](/windows/win32/Controls/list-view-controls-overview)。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：插入项目](#insertitem)。

## <a name="clistctrlsetoutlinecolor"></a><a name="setoutlinecolor"></a>CListCtrl：：设置大纲颜色

如果设置了[LVS_EX_BORDERSELECT](/windows/win32/Controls/list-view-window-styles)扩展窗口样式，则设置列表视图控件的边框颜色。

```
COLORREF SetOutlineColor(COLORREF color);
```

### <a name="parameters"></a>参数

*颜色*<br/>
包含轮廓颜色的新[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="return-value"></a>返回值

包含轮`COLORREF`廓颜色的前一个结构

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETOUTLINECOLOR](/windows/win32/Controls/lvm-setoutlinecolor)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetselectedcolumn"></a><a name="setselectedcolumn"></a>CListCtrl：：设置选择列

设置列表视图控件的选定列。

```
LRESULT SetSelectedColumn(int iCol);
```

### <a name="parameters"></a>参数

*iCol*<br/>
要选择的列的索引。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETSELECTEDCOLUMN](/windows/win32/Controls/lvm-setselectedcolumn)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetselectionmark"></a><a name="setselectionmark"></a>CListCtrl：：设置选择标记

设置列表视图控件的选择标记。

```
int SetSelectionMark(int iIndex);
```

### <a name="parameters"></a>参数

*iIndex*<br/>
多个选定中第一项的零基索引。

### <a name="return-value"></a>返回值

上一个选择标记，如果没有选择标记，则为 -1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_SetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_setselectionmark)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取选择标记](#getselectionmark)。

## <a name="clistctrlsettextbkcolor"></a><a name="settextbkcolor"></a>CListCtrl：：设置文本BkColor

设置列表视图控件中文本的背景颜色。

```
BOOL SetTextBkColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*铬*<br/>
指定新文本背景颜色的 COLORREF。 有关详细信息，请参阅 Windows SDK 中的[COLORREF。](/windows/win32/gdi/colorref)

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetTextBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetTextBkColor() == crBkColor);
```

## <a name="clistctrlsettextcolor"></a><a name="settextcolor"></a>CListCtrl：：设置文本颜色

设置列表视图控件的文本颜色。

```
BOOL SetTextColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*铬*<br/>
指定新文本颜色的 COLORREF。 有关详细信息，请参阅 Windows SDK 中的[COLORREF。](/windows/win32/gdi/colorref)

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Use the window text color for
    // the item text of the list view control.
    COLORREF crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
    m_myListCtrl.SetTextColor(crTextColor);
    ASSERT(m_myListCtrl.GetTextColor() == crTextColor);
```

## <a name="clistctrlsettileinfo"></a><a name="settileinfo"></a>CListCtrl：：SetTileInfo

设置列表视图控件的磁贴的信息。

```
BOOL SetTileInfo(PLVTILEINFO pTileInfo);
```

### <a name="parameters"></a>参数

*pTileInfo*<br/>
指向[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)结构的指针，其中包含要设置的信息。

### <a name="return-value"></a>返回值

成功时返回 TRUE，在失败时返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETTILEINFO](/windows/win32/Controls/lvm-settileinfo)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsettileviewinfo"></a><a name="settileviewinfo"></a>CListCtrl：：SetTileViewInfo

设置列表视图控件在磁贴视图中使用的信息。

```
BOOL SetTileViewInfo(PLVTILEVIEWINFO ptvi);
```

### <a name="parameters"></a>参数

*普特维*<br/>
指向[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)结构的指针，其中包含要设置的信息。

### <a name="return-value"></a>返回值

成功时返回 TRUE，在失败时返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETTILEVIEWINFO](/windows/win32/Controls/lvm-settileviewinfo)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsettooltips"></a><a name="settooltips"></a>CListCtrl：：设置工具提示

设置列表视图控件将用于显示工具提示的工具提示控件。

```
CToolTipCtrl* SetToolTips(CToolTipCtrl* pWndTip);
```

### <a name="parameters"></a>参数

*pwndTip*<br/>
指向列表控件将使用`CToolTipCtrl`的对象的指针。

### <a name="return-value"></a>返回值

指向包含控件以前使用的工具提示的[CToolTipCtrl](ctooltipctrl-class.md)对象的指针，如果以前未使用工具提示，则指向 NULL。

### <a name="remarks"></a>备注

此成员函数实现 Win32 消息[LVM_SETTOOLTIPS](/windows/win32/Controls/lvm-settooltips)的行为，如 Windows SDK 中所述。

要不使用工具提示，请指示创建`CListCtrl`对象时LVS_NOTOOLTIPS样式。

## <a name="clistctrlsetview"></a><a name="setview"></a>CListCtrl：：SetView

设置列表视图控件的视图。

```
DWORD SetView(int iView);
```

### <a name="parameters"></a>参数

*iView*<br/>
要选择的视图。

### <a name="return-value"></a>返回值

如果成功，则返回 1，否则返回 -1。 例如，如果视图无效，则返回 -1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETVIEW](/windows/win32/Controls/lvm-setview)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetworkareas"></a><a name="setworkareas"></a>CListCtrl：：设置工作区域

设置图标可以在列表视图控件中显示的区域。

```
void SetWorkAreas(
    int nWorkAreas,
    LPRECT lpRect);
```

### <a name="parameters"></a>参数

*n工作领域*<br/>
`RECT` *lpRect*指向的数组中的结构（或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象）的数量。

*lpRect*<br/>
指定列表视图控件的新工作`RECT`区域的结构（`CRect`或对象）数组的地址。 这些区域必须在客户端坐标中指定。 如果此参数为 NULL，则工作区将设置为控件的工作区。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[ListView_SetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_setworkareas)的行为，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Remove all working areas.
    m_myListCtrl.SetWorkAreas(0, NULL);
```

## <a name="clistctrlsortgroups"></a><a name="sortgroups"></a>CListCtrl：：排序组

使用应用程序定义的比较函数按列表视图控件中的 ID 对组进行排序。

```
BOOL SortGroups(
    PFNLVGROUPCOMPARE _pfnGroupCompare,
    LPVOID _plv);
```

### <a name="parameters"></a>参数

*_pfnGroupCompare*<br/>
指向组比较函数的指针。

*_plv*<br/>
虚空指针。

### <a name="return-value"></a>返回值

成功时返回 TRUE，在失败时返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SORTGROUPS](/windows/win32/Controls/lvm-sortgroups)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsortitems"></a><a name="sortitems"></a>CListCtrl：：排序项目

使用应用程序定义的比较函数对列表视图项进行排序。

```
BOOL SortItems(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

*普芬比较*<br/>
[在]应用程序定义的比较函数的地址。

每次需要确定两个列表项的相对顺序时，排序操作都会调用比较函数。 比较函数必须是类的静态成员，或者不是任何类成员的独立函数。

*dwData*<br/>
[在]传递给比较函数的应用程序定义值。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

此方法更改每个项的索引以反映新序列。

比较函数*pfn比较*具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```

如果第一个项应位于第二个项之前，则比较函数必须返回负值;如果第一个项应遵循第二个项，则返回正值;如果两个项相等，则比较函数必须返回负值。

*lParam1*参数是与比较的第一个项关联的 32 位值 *，lParam2*参数是与第二个项关联的值。 这些是在项目[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的*lParam*成员中指定的值，当这些值插入到列表中时。 *lParamSort*参数与*dwData*值相同。

此方法发送[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)消息，这在 Windows SDK 中介绍。

### <a name="example"></a>示例

下面是一个简单的比较函数，它会导致按其*lParam*值对项进行排序。

```cpp
// Sort items by associated lParam
int CALLBACK CListCtrlDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    UNREFERENCED_PARAMETER(lParamSort);
    return (int)(lParam1 - lParam2);
}
```

```cpp
// Sort the items by passing in the comparison function.
void CListCtrlDlg::Sort()
{
    m_myListCtrl.SortItems(&CListCtrlDlg::MyCompareProc, 0);
}
```

## <a name="clistctrlsortitemsex"></a><a name="sortitemsex"></a>CListCtrl：：排序项目Ex

使用应用程序定义的比较函数对当前列表视图控件的项进行排序。

```
BOOL SortItemsEx(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

|参数|说明|
|---------------|-----------------|
|*普芬比较*|[在]应用程序定义的比较函数的地址。<br /><br /> 每次需要确定两个列表项的相对顺序时，排序操作都会调用比较函数。 比较函数必须是类的静态成员，或者不是任何类成员的独立函数。|
|*dwData*|[在]应用程序定义的值传递给比较函数。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

此方法更改每个项的索引以反映新序列。

比较函数*pfn比较*具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```

此消息类似于[LVM_SORTITEMS，](/windows/win32/Controls/lvm-sortitems)但传递给比较函数的信息类型除外。 在[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)*LVM_SORTITEMS，lParam1*和*lParam2*是要比较的项目的值。 在[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)中 *，lParam1*是比较的第一个项目的当前索引，*而lParam2*是第二个项目的当前索引。 您可以发送[LVM_GETITEMTEXT](/windows/win32/Controls/lvm-getitemtext)消息来检索有关项目的详细信息。

如果第一个项应位于第二个项之前，则比较函数必须返回负值;如果第一个项应遵循第二个项，则返回正值;如果两个项相等，则比较函数必须返回负值。

> [!NOTE]
> 在排序过程中，列表视图内容不稳定。 如果回调函数向列表视图控件发送[LVM_GETITEM以外的任何消息](/windows/win32/Controls/lvm-getitem)，则结果不可预测。

此方法发送[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)消息，这在 Windows SDK 中介绍。

### <a name="example"></a>示例

以下代码示例定义用于访问当前列表视图`m_listCtrl`控件的变量 。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

以下代码示例演示了该方法`SortItemEx`。 在此代码示例的较早部分中，我们创建了一个列表视图控件，该控件在报表视图中显示两列标题为"ClientID"和"分级"。 以下代码示例使用"坡度"列中的值对表进行排序。

```cpp
// The ListCompareFunc() method is a global function used by SortItemEx().
int CALLBACK ListCompareFunc(
                             LPARAM lParam1,
                             LPARAM lParam2,
                             LPARAM lParamSort)
{
    CListCtrl* pListCtrl = (CListCtrl*) lParamSort;
    CString    strItem1 = pListCtrl->GetItemText(static_cast<int>(lParam1), 1);
    CString    strItem2 = pListCtrl->GetItemText(static_cast<int>(lParam2), 1)
    int x1 = _tstoi(strItem1.GetBuffer());
    int x2 = _tstoi(strItem2.GetBuffer());
    int result = 0;
    if ((x1 - x2) < 0)
        result = -1;
    else if ((x1 - x2) == 0)
        result = 0;
    else
        result = 1;

    return result;
}

void CCListCtrl_s2Dlg::OnBnClickedButton1()
{
    // SortItemsEx
    m_listCtrl.SortItemsEx( ListCompareFunc, (LPARAM)&m_listCtrl );
}
```

## <a name="clistctrlsubitemhittest"></a><a name="subitemhittest"></a>CListCtrl：：子项目命中测试

确定哪个列表视图项（如果有）位于给定位置。

```
int SubItemHitTest(LPLVHITTESTINFO pInfo);
```

### <a name="parameters"></a>参数

*pInfo*<br/>
指向[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)结构的指针。

### <a name="return-value"></a>返回值

正在测试的项或子项的基于一个索引（如果有），否则为 -1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏[的行为，ListView_SubItemHitTest](/windows/win32/api/commctrl/nf-commctrl-listview_subitemhittest)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    LVHITTESTINFO lvhti;

    // Clear the subitem text the user clicked on.
    lvhti.pt = pia->ptAction;
    m_myListCtrl.SubItemHitTest(&lvhti);

    if (lvhti.flags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItemText(lvhti.iItem, lvhti.iSubItem, NULL);
    }
}
```

## <a name="clistctrlupdate"></a><a name="update"></a>CListCtrl：：更新

强制列表视图控件重新绘制*nItem*指定的项。

```
BOOL Update(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要更新的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如果列表视图控件具有LVS_AUTOARRANGE样式，则此功能还会排列列表视图控件。

### <a name="example"></a>示例

请参阅[CListCtrl 的示例：：获取选择计数](#getselectedcount)。

## <a name="see-also"></a>另请参阅

[MFC 样品 ROWLIST](../../overview/visual-cpp-samples.md)<br/>
[CWnd 类](cwnd-class.md)<br/>
[层次结构图表](../hierarchy-chart.md)<br/>
[CImageList 类](cimagelist-class.md)
