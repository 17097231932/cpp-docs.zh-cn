---
title: Visual C++ ARM 迁移的常见问题
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 518b8872b301a8fcfc0f154cb3d5d0299efb0975
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303227"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 迁移的常见问题

使用 Microsoft C++编译器（MSVC）时，相同C++的源代码可能会在 ARM 体系结构上产生与在 x86 或 x64 体系结构上不同的结果。

## <a name="sources-of-migration-issues"></a>迁移问题的源

将代码从 x86 或 x64 体系结构迁移到 ARM 体系结构时可能会遇到的许多问题与可能调用未定义、实现定义或未指定行为的源代码构造有关。

*未*定义的行为是C++标准未定义的行为，这是由于没有合理结果的操作引起的：例如，将浮点值转换为无符号整数，或者将值转换为负值或超出其升级类型中的位数。

*实现定义的行为*是C++标准要求编译器供应商定义和记录的行为。 程序可以安全地依赖于实现定义的行为，但这样做可能无法移植。 实现定义的行为的示例包括内置数据类型的大小及其对齐要求。 可能受实现定义的行为影响的操作示例是访问变量参数列表。

*未指定的行为*是C++标准留给非确定性的行为。 尽管此行为被视为非确定性的，但未指定行为的特定调用由编译器实现确定。 但是，不要求编译器供应商预先确定结果，也不要求保证可比较调用之间一致的行为，也不要求文档。 未指定行为的示例是计算子表达式（其中包含函数调用的自变量）的顺序。

其他迁移问题可能是 ARM 和 x86 或 x64 体系结构之间的硬件差异造成的，它们C++以不同的方式与标准交互。 例如，x86 和 x64 体系结构的强内存模型为 `volatile`限定的变量提供了一些附加属性，这些属性已用于促进过去特定类型的线程间通信。 但 ARM 体系结构的弱内存模型不支持这种使用， C++标准也不需要。

> [!IMPORTANT]
>  尽管 `volatile` 会获得一些属性，这些属性可用于实现 x86 和 x64 上的线程间通信的有限形式，但这些附加属性并不足以实现一般的线程间通信。 C++标准建议使用适当的同步基元来实现此类通信。

由于不同的平台可能以不同的方式表示这些类型的行为，因此在平台之间移植软件可能会很困难，如果依赖于特定平台的行为，则可能容易出错。 尽管可能会观察到其中许多类型的行为，并且它们可能会稳定，但依赖于它们至少是不可移植的，在未定义或未指定的行为情况下，也是错误的。 即使此文档中提到的行为不应依赖于，以后的编译器或 CPU 实现可能会发生变化。

## <a name="example-migration-issues"></a>示例迁移问题

本文档的其余部分介绍了这些C++语言元素的不同行为如何在不同的平台上产生不同的结果。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>浮点到无符号整数的转换

在 ARM 体系结构上，浮点值到32位整数的转换会使整数可表示的最接近的值越接近于整数可以表示的范围之外。 在 x86 和 x64 体系结构上，如果整数是无符号的，则转换将进行换行，如果整数已签名，则设置为-2147483648。 所有这些体系结构都不直接支持将浮点值转换为较小的整数类型;相反，转换将执行到32位，并将结果截断为较小的大小。

对于 ARM 体系结构，饱和度和截断的组合意味着转换为无符号类型会在达到32位整数时正确地使用较小的无符号类型，但会为大于较小的类型可以表示，但太小，以致于完整的32位整数。 转换也会正确地用于32位有符号整数，但截断饱和的带符号整数时，会导致返回值为-1 的值，值为0，表示有不利的饱和值。 转换为较小的带符号整数将产生不可预知的截断结果。

对于 x86 和 x64 体系结构，在溢出时，无符号整数转换和显式求出带符号整数转换的环绕行为的组合，并进行截断，使大多数移位的结果无法预测太大。

这些平台在处理从 NaN （非数字）到整数类型的转换的方式上也有所不同。 在 ARM 上，NaN 转换为 0x00000000;在 x86 和 x64 上，它转换为0x80000000。

如果你知道值在要转换为的整数类型范围内，则只能依赖于浮点转换。

### <a name="shift-operator---behavior"></a>移位运算符（\<\< > >）行为

在 ARM 体系结构上，可在模式开始重复之前，将值向左或向右移动到255位。 在 x86 和 x64 体系结构上，模式将在32的每个倍数重复，除非模式的源是64位变量;在这种情况下，模式将在 x64 上的每个64上重复，每个256在 x86 上重复，其中使用了软件实现。 例如，对于一个值为1的32位变量，该变量的值向左移动32个位置，在 ARM 上，结果为0，在 x86 上，结果为1，在 x64 上，结果也为1。 但是，如果值的源是一个64位变量，则所有三个平台上的结果都是4294967296，并且值不会 "换行"，直到它在 x64 上移动了64位置，或 ARM 和 x86 上的256位置。

由于移位运算的结果超出了源类型中的位数，因此不要求编译器在所有情况下都具有一致的行为。 例如，如果一个移位的两个操作数在编译时是已知的，则编译器可能会通过使用内部例程预先计算移位结果，并将结果替换为替换移位运算的结果，来优化程序。 如果移位量过大或为负，则内部例程的结果可能不同于 CPU 执行的相同移位表达式的结果。

### <a name="variable-arguments-varargs-behavior"></a>变量参数（varargs）行为

在 ARM 体系结构上，在堆栈上传递的 "变量参数" 列表中的参数需要进行对齐。 例如，64位参数在64位边界上对齐。 在 x86 和 x64 上，在堆栈上传递的参数不会受到对齐和打包的限制。 这种差异可能会导致可变参数函数（如 `printf`）读取要在 ARM 上填充的内存地址（如果不完全匹配变量参数列表的预期布局），即使它可能适用于 x86 或 x64 体系结构的某些值的子集。 请看以下示例：

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

在这种情况下，可以通过确保使用正确的格式规范来修复 bug，以便考虑参数的对齐方式。 此代码是正确的：

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>参数计算顺序

由于 ARM、x86 和 x64 处理器的不同之处，它们可能会对编译器实现提供不同的要求，并且也会对优化有不同的机会。 因此，与调用约定和优化设置等其他因素一起使用时，编译器可能会以不同的顺序在不同体系结构上或在其他因素发生更改时计算函数参数。 这可能导致依赖于特定计算顺序的应用的行为发生意外更改。

如果函数的参数有副作用会影响同一调用中的函数的其他参数，则会发生这种错误。 此类依赖项通常很容易避免，但有时可能会被难以理解的依赖项或运算符重载所遮住。 请看下面的代码示例：

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

这会正确定义，但如果 `->` 和 `*` 是重载的运算符，则此代码将转换为类似于下面的内容：

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

如果 `operator->(memory_handle)` 和 `operator*(p)`之间存在依赖关系，则代码可能依赖于特定的计算顺序，即使原始代码看起来不可能有依赖关系。

### <a name="volatile-keyword-default-behavior"></a>volatile 关键字默认行为

MSVC 编译器支持两种不同的 `volatile` 存储限定符解释，您可以使用编译器开关来指定。 [/Volatile： ms](reference/volatile-volatile-keyword-interpretation.md)开关选择 Microsoft 扩展的可变语义，该语义保证了强排序，因为在这些体系结构上存在强大的内存模型，因此 x86 和 x64 的传统情况是如此。 [/Volatile： iso](reference/volatile-volatile-keyword-interpretation.md)开关选择不保证强C++排序的 strict 标准可变语义。

在 ARM 体系结构上，默认值为 **/volatile： iso** ，因为 arm 处理器具有弱顺序的内存模型，因为 arm 软件不依赖于 **/volatile： ms**的扩展语义，并且通常不需要与执行的软件进行交互。 但是，编译 ARM 程序以使用扩展语义有时会很方便，甚至也是必需的。 例如，移植程序使用 ISO C++语义的开销可能太大，或驱动程序软件可能必须遵循传统语义才能正常工作。 在这些情况下，可以使用 **/volatile： ms**开关;但是，若要在 ARM 目标上重新创建传统的可变语义，编译器必须在每次读取或写入 `volatile` 变量周围插入内存障碍，以强制执行强排序，这会对性能产生负面影响。

在 x86 和 x64 体系结构上，默认为 **/volatile： ms** ，因为已通过使用 MSVC 为这些体系结构创建的大部分软件依赖于它们。 编译 x86 和 x64 程序时，可以指定 **/volatile： iso**开关来帮助避免不必要地依赖传统的可变语义，并提高可移植性。

## <a name="see-also"></a>另请参阅

[为 ARM 处理器配置 Visual C++](configuring-programs-for-arm-processors-visual-cpp.md)
