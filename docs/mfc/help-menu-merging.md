---
title: 帮助菜单合并
ms.date: 11/04/2016
helpviewer_keywords:
- menus [MFC], merging
- merging Help menus [MFC]
- Help [MFC], for active document containers
ms.assetid: 9d615999-79ba-471a-9288-718f0c903d49
ms.openlocfilehash: 1bd70af6f24ee6f9873b89b2060f4b2d90149c90
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/09/2020
ms.locfileid: "84620131"
---
# <a name="help-menu-merging"></a>帮助菜单合并

当对象在容器中处于活动状态时，OLE 文档的菜单合并协议将为 "**帮助**" 菜单提供 "完全控制" 控件。 因此，容器的帮助主题将不可用，除非用户停用该对象。 活动文档包容体系结构基于就地菜单合并的规则进行扩展，以允许容器和活动文档共享此菜单。 新规则是一些有关哪些组件拥有菜单的哪个部分以及如何构造共享菜单的额外约定。

新约定很简单。 在活动文档中，"**帮助**" 菜单按如下方式组织了两个顶级菜单项：

`Help`

`Container Help >`

`Object Help    >`

例如，当 Word 部分在 Office 活页夹中处于活动状态时，"**帮助**" 菜单将如下所示：

`Help`

`Binder Help >`

`Word Help   >`

这两个菜单项都是级联菜单，其下方是特定于容器的任何附加菜单项和提供给用户的对象。 此处显示的项随容器和包含的对象而异。

为了构造此合并的 "**帮助**" 菜单，活动文档包容体系结构将修改普通的 OLE 文档过程。 根据 OLE 文档，合并的菜单栏可以有六组菜单，即 "**文件**"、"**编辑**"、"**容器**"、"**对象**"、"**窗口**" 和 "**帮助**"。 每个组可包含零个或多个菜单。 组**文件**、**容器**和**窗口**属于容器，组**编辑**、**对象**和**帮助**属于对象。 当对象需要执行菜单合并时，它会创建一个空白菜单栏并将其传递给容器。 然后，容器通过调用插入其菜单 `IOleInPlaceFrame::InsertMenus` 。 对象还传递一个结构，它是一个包含六个长值（**OLEMENUGROUPWIDTHS**）的数组。 在插入菜单后，容器将标记它在每个组中添加的菜单数，然后返回。 然后，此对象插入其菜单，请注意每个容器组中的菜单计数。 最后，对象会将合并的菜单栏和数组（包含每个组中的菜单计数）传递给 OLE，后者将返回一个不透明的“菜单描述符”句柄。 稍后，对象通过将该句柄和合并的菜单栏传递到容器 `IOleInPlaceFrame::SetMenu` 。 此时，容器将显示合并后的菜单栏，并且还会将句柄传递给 OLE，以便 OLE 能够对菜单消息进行正确的调度。

在修改的活动文档过程中，对象必须先将**OLEMENUGROUPWIDTHS**元素初始化为零，然后再将其传递给容器。 然后，该容器执行一个常规菜单插入操作，但有一个例外：容器将 "**帮助**" 菜单插入为最后一项，并在**OLEMENUGROUPWIDTHS**数组的最后一个（第六个）条目中存储值1（即，宽度 [5]，它属于对象的 "帮助" 组）。 此**帮助**菜单将只有一项是子菜单，如前面所述的 "**容器帮助**>" 级联菜单。

然后，该对象执行其常规菜单插入代码，但在插入其 "**帮助**" 菜单之前，它会检查**OLEMENUGROUPWIDTHS**数组的第六个条目。 如果值为1，且最后一个菜单的名称为 "**帮助**" （或适当的本地化字符串），则对象会将其 "**帮助**" 菜单插入容器的 "**帮助**" 菜单的子菜单。

然后，该对象将**OLEMENUGROUPWIDTHS**的第六个元素设置为零，并将第五个元素递增1。 这允许 OLE 知道 "**帮助**" 菜单属于容器，而与该菜单（及其子菜单）对应的菜单消息应该路由到容器。 然后，容器负责转发**WM_INITMENUPOPUP**、 **WM_SELECT**、 **WM_COMMAND**和其他与菜单相关的消息，这些消息属于 "**帮助**" 菜单的对象部分。 这是通过使用**WM_INITMENU**清除标志来完成的，该标志告知容器用户是否已导航至对象的 "**帮助**" 菜单。 然后，该容器监视**WM_MENUSELECT** ，以便进入或退出该容器未添加自身的 "**帮助**" 菜单上的任何项。 进入时，这意味着用户已导航到对象菜单，因此容器设置 "在对象帮助菜单中" 标志，并使用该标志的状态将任何**WM_MENUSELECT**、 **WM_INITMENUPOPUP**和**WM_COMMAND**消息至少转发到对象窗口。 （退出时，容器会清除标志，然后处理相同的消息。）容器应使用从对象函数返回的窗口 `IOleInPlaceActiveObejct::GetWindow` 作为这些消息的目标。

如果该对象在**OLEMENUGROUPWIDTHS**的第六个元素中检测到零，它将根据正常的 OLE 文档规则继续。 此过程介绍了参与 "**帮助**" 菜单合并的容器以及不参与此操作的容器。

当对象调用时 `IOleInPlaceFrame::SetMenu` ，在显示合并的菜单栏之前，该容器还会检查 "**帮助**" 菜单是否还有一个附加子菜单，以及容器插入的内容。 如果是这样，则容器会将其 "**帮助**" 菜单保留在合并的菜单栏中。 如果 "**帮助**" 菜单没有附加子菜单，则容器将从合并的菜单栏中删除其 "**帮助**" 菜单。 此过程涉及参与 "**帮助**" 菜单合并的对象和不包含这些对象的对象。

最后，当需要反汇编菜单时，对象除了删除其他插入的菜单之外，还会删除插入的 "**帮助**" 菜单。 当容器删除其菜单时，它将删除其 "**帮助**" 菜单以及已插入的其他菜单。

## <a name="see-also"></a>另请参阅

[活动文档容器](active-document-containers.md)
