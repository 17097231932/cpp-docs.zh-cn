---
title: 1. 简介
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 60a5090814b722cc0d9f6e51ab9038e697a4ed2a
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231645"
---
# <a name="1-introduction"></a>1.简介

本文档指定可用于指定 C 和 c + + 程序中的共享内存并行的编译器指令、库函数和环境变量的集合。 本文档中所述的功能统称为*OpenMP C/c + + 应用程序接口（API）*。 此规范的目标是为并行编程提供一个模型，该模型允许程序在不同供应商的共享内存体系结构中进行移植。 许多供应商提供的编译器支持 OpenMP C/c + + API。 有关 OpenMP 的详细信息，包括*Openmp Fortran 应用程序界面*，请参阅以下网站：

[https://www.openmp.org](https://www.openmp.org)

本文档中定义的指令、库函数和环境变量允许您创建和管理并行程序，同时允许可移植性。 指令使用单个程序多个数据（SPMD）构造、工作共享构造和同步构造扩展 C 和 c + + 顺序编程模型。 它们还支持数据的共享和私有化。 支持 OpenMP C 和 c + + API 的编译器包含一个命令行选项，该选项用于激活并允许解释所有 OpenMP 编译器指令的编译器。

## <a name="11-scope"></a>1.1 范围

此规范仅涵盖用户定向并行度，其中显式定义了编译器和运行时系统执行并行执行程序所需的操作。 不需要 OpenMP C 和 c + + 实现来检查依赖关系、冲突、死锁、争用条件或导致程序执行不正确的其他问题。 你负责确保使用 OpenMP C 和 c + + API 构造的应用程序正确执行。 编译器生成的自动并行化和指令到编译器，以协助此类并行化。

## <a name="12-definition-of-terms"></a>1.2 术语定义

本文档中使用了以下术语：

- barrier

  团队中的所有线程都必须达到的同步点。  每个线程都将等待，直到团队中的所有线程到达此点。 由实现创建的指令和隐式关卡确定了明确的障碍。

- 构造

  构造是一个语句。 它包含指令和结构化块。 某些指令不是构造的组成部分。 （请参阅[附录 C](c-openmp-c-and-cpp-grammar.md)中*的 openmp 指令*）。

- 指令

  `#pragma`后跟 `omp` 标识符、其他文本和新行的 c 或 c + +。 指令指定程序行为。

- 动态区

  *词法范围*内的所有语句，以及在词法范围内执行语句后执行的函数中的任何语句。 动态区也称为*区域*。

- 词法范围

  词法上保存在*结构化块*内的语句。

- 主线程

  在输入*并行区域*时创建团队的线程。

- 并行区域

  绑定到 OpenMP 并行构造并可由多个线程执行的语句。

- private

  一个私有变量，它将一个存储块命名为唯一的，这是进行引用的线程所特有的。 有多种方法可以指定变量是私有的：并行区域中的定义、指令、、、 `threadprivate` `private` `firstprivate` `lastprivate` 或 `reduction` 子句，或将变量用作 **`for`** **`for`** 紧随或指令后的循环中的循环控制变量 `for` `parallel for` 。

- region

  动态区。

- 串行区域

  语句仅在任何*并行区域*的动态范围之外的*主线程*上执行。

- serialize

  使用执行并行构造：

  - 仅由一个线程组成的线程团队（这是该并行构造的主线程），

  - 结构化块中语句的执行序列顺序（顺序与块不是并行构造的一部分）和

  - 对返回的值没有影响 `omp_in_parallel()` （除了任何嵌套的并行构造的影响）。

- 共享

  共享变量为单一存储块命名。 团队中访问此变量的所有线程也访问此单个存储块。

- 结构化块

  结构化块是包含单个项和一个退出的语句（单一或复合）。 如果有跳转或跳出语句，则该语句是结构化块。 （此规则包括对的调用 `longjmp`（3C）或的用法 `throw` ，但允许对的调用 `exit` 。）如果其执行始终从开始处开始， `{` 并在结束时始终结束 `}` ，则复合语句是结构化的块。 如果通过将表达式语句、选择语句、迭代语句或 **`try`** 块放入，并将其 `{` `}` 作为结构化块来获取，则该语句是结构化块。 跳转语句、标记语句或声明语句不是结构化的块。

- 团队

  构造的执行中有一个或多个线程协同工作。

- 线程 (thread)

  一个执行实体，它具有串行流控制、一组私有变量以及对共享变量的访问。

- 可变

  命名空间名称（可选）命名对象的标识符（可选）。

## <a name="13-execution-model"></a>1.3 执行模型

OpenMP 使用并行执行的分叉联接模型。 尽管此分叉联接模型可用于解决各种问题，但它是针对大型基于阵列的应用程序定制的。 OpenMP 旨在支持作为并行程序（多个执行线程和完全 OpenMP 支持库）正确执行的程序。 它还适用于按顺序程序正确执行的程序（忽略指令，并使用简单的 OpenMP 存根库）。 但是，可以在按顺序执行时开发不能正常运行的程序。 此外，由于数字运算的关联发生变化，不同程度的并行度可能会导致不同的数值结果。 例如，串行加法缩减可能与并行减少模式具有不同的加法关联模式。 这些不同的关联可能会更改浮点加法的结果。

使用 OpenMP C/c + + API 编写的程序将作为名为 "*主线程*" 的单个执行线程开始执行。 主线程在串行区域执行，直到遇到第一个并行构造。 在 OpenMP C/c + + API 中， `parallel` 指令构成了并行构造。 当遇到并行构造时，主线程将创建一个线程团队，并将主节点作为该团队的主节点。 除了工作共享构造以外，团队中的每个线程都将执行并行区域的动态范围内的语句。 团队中的所有线程都必须以相同顺序遇到工作共享构造，并且一个或多个线程执行关联的结构化块中的语句。 不带子句的工作共享构造末尾隐含的关卡 `nowait` 由团队中的所有线程执行。

如果线程修改了某个共享对象，则该对象不仅会影响其自己的执行环境，还会影响程序中其他线程的执行环境。 仅当对象被声明为易失性时，才可以在下一个序列点（在基本语言中定义）的下一个序列点上，保证从另一个线程的角度来看修改。 否则，修改将保证在第一次修改线程之后完成。 然后，其他线程（或并发）会看到 `flush` 指定对象（隐式或显式）的指令。 如果 `flush` 其他 OpenMP 指令隐含的指令不能保证正确的副作用顺序，则程序员应负责提供其他显式 `flush` 指令。

并行构造完成后，团队中的线程将在隐式屏障上同步，且只有主线程继续执行。 可在一个程序中指定任意数量的并行构造。 因此，程序可能在执行期间分叉和联接多次。

通过 OpenMP C/c + + API，程序员可以在从并行构造内调用的函数中使用指令。 不出现在并行构造的词法范围内但可能位于动态区中的指令称为 "*孤立*指令"。 利用孤立的指令，程序员可以并行执行其程序的主要部分，只需对顺序程序进行少量的更改。 利用此功能，可以在程序调用树的顶级对并行构造进行编码，并使用指令来控制任何被调用函数中的执行。

对 C 和 c + + 输出函数的非同步调用写入同一文件可能会导致输出，而由不同的线程写入的数据将按不确定的顺序显示。 同样，从同一文件中读取的输入函数的未同步调用可以按非确定性顺序读取数据。 不同步地使用 i/o，因此，每个线程访问不同的文件，生成的结果与 i/o 函数的串行执行相同。

## <a name="14-compliance"></a>1.4 遵从性

如果 OpenMP C/c + + API 的实现可识别并保留此规范的所有元素的语义（如第1章、第2、第3、第4和附录 C 中所述），则它是*openmp 兼容*的。附录 A、B、D、E 和 F 仅用于信息，并且不是规范的组成部分。 仅包含 API 子集的实现不符合 OpenMP。

OpenMP C 和 c + + API 是实现所支持的基本语言的扩展。 如果该基本语言不支持本文档中显示的语言构造或扩展，则 OpenMP 实现不需要支持该语言。

所有标准 C 和 c + + 库函数以及内置函数（即编译器具有特定知识的函数）必须是线程安全的。 并行区域中不同线程的线程安全函数的未同步使用不会产生未定义的行为。 但行为可能与在串行区域中的行为不同。 （随机数字生成函数是一个示例。）

OpenMP C/c + + API 指定特定行为是*实现定义的。* 在这些情况下，需要使用一致的 OpenMP 实现来定义和记录其行为。 有关实现定义的行为的列表，请参阅[附录 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)。

## <a name="15-normative-references"></a>1.5 规范引用

- ISO/IEC 9899:1999，*信息技术-C*。此 OpenMP API 规范将 ISO/IEC 9899:1999 表示为 C99。

- ISO/IEC 9899:1990，*信息技术-C*。此 OpenMP API 规范将 ISO/IEC 9899:1990 表示为 C90。

- ISO/IEC 14882:1998，*信息技术-编程语言-c + +*。 此 OpenMP API 规范将 ISO/IEC 14882:1998 表示为 c + +。

如果此 OpenMP API 规范引用 C，则对实现支持的基本语言进行引用。

## <a name="16-organization"></a>1.6 组织

- [运行时库函数](3-run-time-library-functions.md)
- [环境变量](4-environment-variables.md)
- [OpenMP C/C++ 中实现定义的行为](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C/c + + 版本2.0 中的新增功能](f-new-features-and-clarifications-in-version-2-0.md)
