---
title: CListCtrl 类
ms.date: 06/13/2019
f1_keywords:
- CListCtrl
- AFXCMN/CListCtrl
- AFXCMN/CListCtrl::CListCtrl
- AFXCMN/CListCtrl::ApproximateViewRect
- AFXCMN/CListCtrl::Arrange
- AFXCMN/CListCtrl::CancelEditLabel
- AFXCMN/CListCtrl::Create
- AFXCMN/CListCtrl::CreateDragImage
- AFXCMN/CListCtrl::CreateEx
- AFXCMN/CListCtrl::DeleteAllItems
- AFXCMN/CListCtrl::DeleteColumn
- AFXCMN/CListCtrl::DeleteItem
- AFXCMN/CListCtrl::DrawItem
- AFXCMN/CListCtrl::EditLabel
- AFXCMN/CListCtrl::EnableGroupView
- AFXCMN/CListCtrl::EnsureVisible
- AFXCMN/CListCtrl::FindItem
- AFXCMN/CListCtrl::GetBkColor
- AFXCMN/CListCtrl::GetBkImage
- AFXCMN/CListCtrl::GetCallbackMask
- AFXCMN/CListCtrl::GetCheck
- AFXCMN/CListCtrl::GetColumn
- AFXCMN/CListCtrl::GetColumnOrderArray
- AFXCMN/CListCtrl::GetColumnWidth
- AFXCMN/CListCtrl::GetCountPerPage
- AFXCMN/CListCtrl::GetEditControl
- AFXCMN/CListCtrl::GetEmptyText
- AFXCMN/CListCtrl::GetExtendedStyle
- AFXCMN/CListCtrl::GetFirstSelectedItemPosition
- AFXCMN/CListCtrl::GetFocusedGroup
- AFXCMN/CListCtrl::GetGroupCount
- AFXCMN/CListCtrl::GetGroupInfo
- AFXCMN/CListCtrl::GetGroupInfoByIndex
- AFXCMN/CListCtrl::GetGroupMetrics
- AFXCMN/CListCtrl::GetGroupRect
- AFXCMN/CListCtrl::GetGroupState
- AFXCMN/CListCtrl::GetHeaderCtrl
- AFXCMN/CListCtrl::GetHotCursor
- AFXCMN/CListCtrl::GetHotItem
- AFXCMN/CListCtrl::GetHoverTime
- AFXCMN/CListCtrl::GetImageList
- AFXCMN/CListCtrl::GetInsertMark
- AFXCMN/CListCtrl::GetInsertMarkColor
- AFXCMN/CListCtrl::GetInsertMarkRect
- AFXCMN/CListCtrl::GetItem
- AFXCMN/CListCtrl::GetItemCount
- AFXCMN/CListCtrl::GetItemData
- AFXCMN/CListCtrl::GetItemIndexRect
- AFXCMN/CListCtrl::GetItemPosition
- AFXCMN/CListCtrl::GetItemRect
- AFXCMN/CListCtrl::GetItemSpacing
- AFXCMN/CListCtrl::GetItemState
- AFXCMN/CListCtrl::GetItemText
- AFXCMN/CListCtrl::GetNextItem
- AFXCMN/CListCtrl::GetNextItemIndex
- AFXCMN/CListCtrl::GetNextSelectedItem
- AFXCMN/CListCtrl::GetNumberOfWorkAreas
- AFXCMN/CListCtrl::GetOrigin
- AFXCMN/CListCtrl::GetOutlineColor
- AFXCMN/CListCtrl::GetSelectedColumn
- AFXCMN/CListCtrl::GetSelectedCount
- AFXCMN/CListCtrl::GetSelectionMark
- AFXCMN/CListCtrl::GetStringWidth
- AFXCMN/CListCtrl::GetSubItemRect
- AFXCMN/CListCtrl::GetTextBkColor
- AFXCMN/CListCtrl::GetTextColor
- AFXCMN/CListCtrl::GetTileInfo
- AFXCMN/CListCtrl::GetTileViewInfo
- AFXCMN/CListCtrl::GetToolTips
- AFXCMN/CListCtrl::GetTopIndex
- AFXCMN/CListCtrl::GetView
- AFXCMN/CListCtrl::GetViewRect
- AFXCMN/CListCtrl::GetWorkAreas
- AFXCMN/CListCtrl::HasGroup
- AFXCMN/CListCtrl::HitTest
- AFXCMN/CListCtrl::InsertColumn
- AFXCMN/CListCtrl::InsertGroup
- AFXCMN/CListCtrl::InsertGroupSorted
- AFXCMN/CListCtrl::InsertItem
- AFXCMN/CListCtrl::InsertMarkHitTest
- AFXCMN/CListCtrl::IsGroupViewEnabled
- AFXCMN/CListCtrl::IsItemVisible
- AFXCMN/CListCtrl::MapIDToIndex
- AFXCMN/CListCtrl::MapIndexToID
- AFXCMN/CListCtrl::MoveGroup
- AFXCMN/CListCtrl::MoveItemToGroup
- AFXCMN/CListCtrl::RedrawItems
- AFXCMN/CListCtrl::RemoveAllGroups
- AFXCMN/CListCtrl::RemoveGroup
- AFXCMN/CListCtrl::Scroll
- AFXCMN/CListCtrl::SetBkColor
- AFXCMN/CListCtrl::SetBkImage
- AFXCMN/CListCtrl::SetCallbackMask
- AFXCMN/CListCtrl::SetCheck
- AFXCMN/CListCtrl::SetColumn
- AFXCMN/CListCtrl::SetColumnOrderArray
- AFXCMN/CListCtrl::SetColumnWidth
- AFXCMN/CListCtrl::SetExtendedStyle
- AFXCMN/CListCtrl::SetGroupInfo
- AFXCMN/CListCtrl::SetGroupMetrics
- AFXCMN/CListCtrl::SetHotCursor
- AFXCMN/CListCtrl::SetHotItem
- AFXCMN/CListCtrl::SetHoverTime
- AFXCMN/CListCtrl::SetIconSpacing
- AFXCMN/CListCtrl::SetImageList
- AFXCMN/CListCtrl::SetInfoTip
- AFXCMN/CListCtrl::SetInsertMark
- AFXCMN/CListCtrl::SetInsertMarkColor
- AFXCMN/CListCtrl::SetItem
- AFXCMN/CListCtrl::SetItemCount
- AFXCMN/CListCtrl::SetItemCountEx
- AFXCMN/CListCtrl::SetItemData
- AFXCMN/CListCtrl::SetItemIndexState
- AFXCMN/CListCtrl::SetItemPosition
- AFXCMN/CListCtrl::SetItemState
- AFXCMN/CListCtrl::SetItemText
- AFXCMN/CListCtrl::SetOutlineColor
- AFXCMN/CListCtrl::SetSelectedColumn
- AFXCMN/CListCtrl::SetSelectionMark
- AFXCMN/CListCtrl::SetTextBkColor
- AFXCMN/CListCtrl::SetTextColor
- AFXCMN/CListCtrl::SetTileInfo
- AFXCMN/CListCtrl::SetTileViewInfo
- AFXCMN/CListCtrl::SetToolTips
- AFXCMN/CListCtrl::SetView
- AFXCMN/CListCtrl::SetWorkAreas
- AFXCMN/CListCtrl::SortGroups
- AFXCMN/CListCtrl::SortItems
- AFXCMN/CListCtrl::SortItemsEx
- AFXCMN/CListCtrl::SubItemHitTest
- AFXCMN/CListCtrl::Update
helpviewer_keywords:
- CListCtrl [MFC], CListCtrl
- CListCtrl [MFC], ApproximateViewRect
- CListCtrl [MFC], Arrange
- CListCtrl [MFC], CancelEditLabel
- CListCtrl [MFC], Create
- CListCtrl [MFC], CreateDragImage
- CListCtrl [MFC], CreateEx
- CListCtrl [MFC], DeleteAllItems
- CListCtrl [MFC], DeleteColumn
- CListCtrl [MFC], DeleteItem
- CListCtrl [MFC], DrawItem
- CListCtrl [MFC], EditLabel
- CListCtrl [MFC], EnableGroupView
- CListCtrl [MFC], EnsureVisible
- CListCtrl [MFC], FindItem
- CListCtrl [MFC], GetBkColor
- CListCtrl [MFC], GetBkImage
- CListCtrl [MFC], GetCallbackMask
- CListCtrl [MFC], GetCheck
- CListCtrl [MFC], GetColumn
- CListCtrl [MFC], GetColumnOrderArray
- CListCtrl [MFC], GetColumnWidth
- CListCtrl [MFC], GetCountPerPage
- CListCtrl [MFC], GetEditControl
- CListCtrl [MFC], GetEmptyText
- CListCtrl [MFC], GetExtendedStyle
- CListCtrl [MFC], GetFirstSelectedItemPosition
- CListCtrl [MFC], GetFocusedGroup
- CListCtrl [MFC], GetGroupCount
- CListCtrl [MFC], GetGroupInfo
- CListCtrl [MFC], GetGroupInfoByIndex
- CListCtrl [MFC], GetGroupMetrics
- CListCtrl [MFC], GetGroupRect
- CListCtrl [MFC], GetGroupState
- CListCtrl [MFC], GetHeaderCtrl
- CListCtrl [MFC], GetHotCursor
- CListCtrl [MFC], GetHotItem
- CListCtrl [MFC], GetHoverTime
- CListCtrl [MFC], GetImageList
- CListCtrl [MFC], GetInsertMark
- CListCtrl [MFC], GetInsertMarkColor
- CListCtrl [MFC], GetInsertMarkRect
- CListCtrl [MFC], GetItem
- CListCtrl [MFC], GetItemCount
- CListCtrl [MFC], GetItemData
- CListCtrl [MFC], GetItemIndexRect
- CListCtrl [MFC], GetItemPosition
- CListCtrl [MFC], GetItemRect
- CListCtrl [MFC], GetItemSpacing
- CListCtrl [MFC], GetItemState
- CListCtrl [MFC], GetItemText
- CListCtrl [MFC], GetNextItem
- CListCtrl [MFC], GetNextItemIndex
- CListCtrl [MFC], GetNextSelectedItem
- CListCtrl [MFC], GetNumberOfWorkAreas
- CListCtrl [MFC], GetOrigin
- CListCtrl [MFC], GetOutlineColor
- CListCtrl [MFC], GetSelectedColumn
- CListCtrl [MFC], GetSelectedCount
- CListCtrl [MFC], GetSelectionMark
- CListCtrl [MFC], GetStringWidth
- CListCtrl [MFC], GetSubItemRect
- CListCtrl [MFC], GetTextBkColor
- CListCtrl [MFC], GetTextColor
- CListCtrl [MFC], GetTileInfo
- CListCtrl [MFC], GetTileViewInfo
- CListCtrl [MFC], GetToolTips
- CListCtrl [MFC], GetTopIndex
- CListCtrl [MFC], GetView
- CListCtrl [MFC], GetViewRect
- CListCtrl [MFC], GetWorkAreas
- CListCtrl [MFC], HasGroup
- CListCtrl [MFC], HitTest
- CListCtrl [MFC], InsertColumn
- CListCtrl [MFC], InsertGroup
- CListCtrl [MFC], InsertGroupSorted
- CListCtrl [MFC], InsertItem
- CListCtrl [MFC], InsertMarkHitTest
- CListCtrl [MFC], IsGroupViewEnabled
- CListCtrl [MFC], IsItemVisible
- CListCtrl [MFC], MapIDToIndex
- CListCtrl [MFC], MapIndexToID
- CListCtrl [MFC], MoveGroup
- CListCtrl [MFC], MoveItemToGroup
- CListCtrl [MFC], RedrawItems
- CListCtrl [MFC], RemoveAllGroups
- CListCtrl [MFC], RemoveGroup
- CListCtrl [MFC], Scroll
- CListCtrl [MFC], SetBkColor
- CListCtrl [MFC], SetBkImage
- CListCtrl [MFC], SetCallbackMask
- CListCtrl [MFC], SetCheck
- CListCtrl [MFC], SetColumn
- CListCtrl [MFC], SetColumnOrderArray
- CListCtrl [MFC], SetColumnWidth
- CListCtrl [MFC], SetExtendedStyle
- CListCtrl [MFC], SetGroupInfo
- CListCtrl [MFC], SetGroupMetrics
- CListCtrl [MFC], SetHotCursor
- CListCtrl [MFC], SetHotItem
- CListCtrl [MFC], SetHoverTime
- CListCtrl [MFC], SetIconSpacing
- CListCtrl [MFC], SetImageList
- CListCtrl [MFC], SetInfoTip
- CListCtrl [MFC], SetInsertMark
- CListCtrl [MFC], SetInsertMarkColor
- CListCtrl [MFC], SetItem
- CListCtrl [MFC], SetItemCount
- CListCtrl [MFC], SetItemCountEx
- CListCtrl [MFC], SetItemData
- CListCtrl [MFC], SetItemIndexState
- CListCtrl [MFC], SetItemPosition
- CListCtrl [MFC], SetItemState
- CListCtrl [MFC], SetItemText
- CListCtrl [MFC], SetOutlineColor
- CListCtrl [MFC], SetSelectedColumn
- CListCtrl [MFC], SetSelectionMark
- CListCtrl [MFC], SetTextBkColor
- CListCtrl [MFC], SetTextColor
- CListCtrl [MFC], SetTileInfo
- CListCtrl [MFC], SetTileViewInfo
- CListCtrl [MFC], SetToolTips
- CListCtrl [MFC], SetView
- CListCtrl [MFC], SetWorkAreas
- CListCtrl [MFC], SortGroups
- CListCtrl [MFC], SortItems
- CListCtrl [MFC], SortItemsEx
- CListCtrl [MFC], SubItemHitTest
- CListCtrl [MFC], Update
ms.assetid: fe08a1ca-4b05-4ff7-a12a-ee4c765a2197
ms.openlocfilehash: c8f1b8a9ed0ca8437ba40e77b47448d1bb209d20
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/16/2020
ms.locfileid: "79424439"
---
# <a name="clistctrl-class"></a>CListCtrl 类

封装显示一组项的“列表视图控件”功能，每一项均包含一个图标（来自图像列表）和标签。

## <a name="syntax"></a>语法

```
class CListCtrl : public CWnd
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|[CListCtrl：： CListCtrl](#clistctrl)|构造 `CListCtrl` 对象。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CListCtrl：： ApproximateViewRect](#approximateviewrect)|确定显示列表视图控件的项所需的宽度和高度。|
|[CListCtrl：：排列](#arrange)|对齐网格上的项。|
|[CListCtrl：： CancelEditLabel](#canceleditlabel)|取消项文本编辑操作。|
|[CListCtrl：： Create](#create)|创建一个列表控件，并将其附加到 `CListCtrl` 对象上。|
|[CListCtrl：： CreateDragImage](#createdragimage)|为指定的项创建一个拖动图像列表。|
|[CListCtrl：： CreateEx](#createex)|创建具有指定 Windows 扩展样式的列表控件，并将其附加到 `CListCtrl` 的对象。|
|[CListCtrl：:D eleteAllItems](#deleteallitems)|从控件中删除所有项。|
|[CListCtrl：:D eleteColumn](#deletecolumn)|从列表视图控件中删除列。|
|[CListCtrl：:D eleteItem](#deleteitem)|删除控件中的项。|
|[CListCtrl：:D rawItem](#drawitem)|当所有者描述的控件的可视方位发生更改时调用。|
|[CListCtrl：： EditLabel](#editlabel)|开始就地编辑项的文本。|
|[CListCtrl：： EnableGroupView](#enablegroupview)|启用或禁用列表视图控件中的项是否显示为组。|
|[CListCtrl：： Ensurevisible\](#ensurevisible)|确保项可见。|
|[CListCtrl：： FindItem](#finditem)|搜索具有指定特征的列表视图项。|
|[CListCtrl：： GetBkColor](#getbkcolor)|检索列表视图控件的背景色。|
|[CListCtrl：： GetBkImage](#getbkimage)|检索列表视图控件的当前背景图像。|
|[CListCtrl：： GetCallbackMask](#getcallbackmask)|检索列表视图控件的回调掩码。|
|[CListCtrl：： GetCheck](#getcheck)|检索与项关联的状态图像的当前显示状态。|
|[CListCtrl：： GetColumn](#getcolumn)|检索控件的列的属性。|
|[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)|检索列表视图控件的列顺序（从左到右）。|
|[CListCtrl：： GetColumnWidth](#getcolumnwidth)|检索报表视图或列表视图中列的宽度。|
|[CListCtrl：： GetCountPerPage](#getcountperpage)|计算列表视图控件中可垂直容纳的项数。|
|[CListCtrl：： GetEditControl](#geteditcontrol)|检索用于编辑项文本的编辑控件的句柄。|
|[CListCtrl：： GetEmptyText](#getemptytext)|检索当前列表视图控件为空时要显示的字符串。|
|[CListCtrl：： GetExtendedStyle](#getextendedstyle)|检索列表视图控件的当前扩展样式。|
|[CListCtrl：： GetFirstSelectedItemPosition](#getfirstselecteditemposition)|检索列表视图控件中第一个选定列表视图项的位置。|
|[CListCtrl：： GetFocusedGroup](#getfocusedgroup)|检索在当前列表视图控件中具有键盘焦点的组。|
|[CListCtrl：： GetGroupCount](#getgroupcount)|检索当前列表视图控件中的组数。|
|[CListCtrl：： GetGroupInfo](#getgroupinfo)|获取列表视图控件的指定组的信息。|
|[CListCtrl：： GetGroupInfoByIndex](#getgroupinfobyindex)|检索有关当前列表视图控件中指定组的信息。|
|[CListCtrl：： GetGroupMetrics](#getgroupmetrics)|检索组的度量值。|
|[CListCtrl：： GetGroupRect](#getgrouprect)|检索当前列表视图控件中指定组的边框。|
|[CListCtrl：： GetGroupState](#getgroupstate)|检索当前列表视图控件中指定组的状态。|
|[CListCtrl：： GetHeaderCtrl](#getheaderctrl)|检索列表视图控件的标题控件。|
|[CListCtrl：： GetHotCursor](#gethotcursor)|检索对列表视图控件启用热跟踪时使用的光标。|
|[CListCtrl：： GetHotItem](#gethotitem)|检索当前光标下的列表视图项。|
|[CListCtrl：： GetHoverTime](#gethovertime)|检索列表视图控件的当前悬停时间。|
|[CListCtrl：： GetImageList](#getimagelist)|检索用于绘制列表视图项的图像列表的句柄。|
|[CListCtrl：： GetInsertMark](#getinsertmark)|检索插入标记的当前位置。|
|[CListCtrl：： GetInsertMarkColor](#getinsertmarkcolor)|检索插入标记的当前颜色。|
|[CListCtrl：： GetInsertMarkRect](#getinsertmarkrect)|检索限定插入点的矩形。|
|[CListCtrl：： GetItem](#getitem)|检索列表视图项的特性。|
|[CListCtrl：： GetItemCount](#getitemcount)|检索列表视图控件中的项数。|
|[CListCtrl：： GetItemData](#getitemdata)|检索与项关联的应用程序特定的值。|
|[CListCtrl：： GetItemIndexRect](#getitemindexrect)|检索当前列表视图控件中子项的全部或部分的边框。|
|[CListCtrl：： GetItemPosition](#getitemposition)|检索列表视图项的位置。|
|[CListCtrl：： GetItemRect](#getitemrect)|检索项的边框。|
|[CListCtrl：： GetItemSpacing](#getitemspacing)|计算当前列表视图控件中各项之间的间距。|
|[CListCtrl：： GetItemState](#getitemstate)|检索列表视图项的状态。|
|[CListCtrl：： GetItemText](#getitemtext)|检索列表视图项或子项的文本。|
|[CListCtrl：： GetNextItem](#getnextitem)|使用指定的属性和与给定项的指定关系搜索列表视图项。|
|[CListCtrl：： GetNextItemIndex](#getnextitemindex)|检索当前列表视图控件中具有一组指定属性的项的索引。|
|[CListCtrl：： GetNextSelectedItem](#getnextselecteditem)|检索列表视图项位置的索引，以及用于迭代的下一个选定列表视图项的位置。|
|[CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)|检索列表视图控件的当前工作区数。|
|[CListCtrl：： GetOrigin](#getorigin)|检索列表视图控件的当前视图源。|
|[CListCtrl：： GetOutlineColor](#getoutlinecolor)|检索列表视图控件边框的颜色。|
|[CListCtrl：： GetSelectedColumn](#getselectedcolumn)|检索列表控件中当前所选列的索引。|
|[CListCtrl：： GetSelectedCount](#getselectedcount)|检索列表视图控件中选定项的数目。|
|[CListCtrl：： GetSelectionMark](#getselectionmark)|检索列表视图控件的选择标记。|
|[CListCtrl：： GetStringWidth](#getstringwidth)|确定显示给定字符串的所有所需的最小列宽。|
|[CListCtrl：： GetSubItemRect](#getsubitemrect)|检索列表视图控件中项的边框。|
|[CListCtrl：： GetTextBkColor](#gettextbkcolor)|检索列表视图控件的文本背景色。|
|[CListCtrl：： GetTextColor](#gettextcolor)|检索列表视图控件的文本颜色。|
|[CListCtrl：： GetTileInfo](#gettileinfo)|检索有关列表视图控件中的图块的信息。|
|[CListCtrl：： GetTileViewInfo](#gettileviewinfo)|检索有关磁贴视图中的列表视图控件的信息。|
|[CListCtrl：： GetToolTips](#gettooltips)|检索列表视图控件用来显示工具提示的 tooltip 控件。|
|[CListCtrl：： GetTopIndex](#gettopindex)|检索最顶层可见项的索引。|
|[CListCtrl：： GetView](#getview)|获取列表视图控件的视图。|
|[CListCtrl：： GetViewRect](#getviewrect)|检索列表视图控件中所有项的边框。|
|[CListCtrl：： GetWorkAreas](#getworkareas)|检索列表视图控件的当前工作区。|
|[CListCtrl：： HasGroup](#hasgroup)|确定列表视图控件是否具有指定的组。|
|[CListCtrl：： System.windows.media.visualtreehelper.hittest](#hittest)|确定位于指定位置的列表视图项。|
|[CListCtrl：： InsertColumn](#insertcolumn)|在列表视图控件中插入新列。|
|[CListCtrl：： InsertGroup](#insertgroup)|将组插入到列表视图控件中。|
|[CListCtrl：： InsertGroupSorted](#insertgroupsorted)|将指定的组插入组的有序列表。|
|[CListCtrl：： InsertItem](#insertitem)|在列表视图控件中插入新项。|
|[CListCtrl：： InsertMarkHitTest](#insertmarkhittest)|检索距离指定点最近的插入点。|
|[CListCtrl：： IsGroupViewEnabled](#isgroupviewenabled)|确定是否为列表视图控件启用组视图。|
|[CListCtrl：： IsItemVisible](#isitemvisible)|指示当前列表视图控件中的指定项是否可见。|
|[CListCtrl：： MapIDToIndex](#mapidtoindex)|将当前列表视图控件中项的唯一 ID 映射到索引。|
|[CListCtrl：： MapIndexToID](#mapindextoid)|将当前列表视图控件中项的索引映射到唯一 ID。|
|[CListCtrl：： MoveGroup](#movegroup)|移动指定的组。|
|[CListCtrl：： MoveItemToGroup](#moveitemtogroup)|将指定组移动到列表视图控件的指定的从零开始的索引。|
|[CListCtrl：： RedrawItems](#redrawitems)|强制列表视图控件重绘一系列项。|
|[CListCtrl：： RemoveAllGroups](#removeallgroups)|从列表视图控件中删除所有组。|
|[CListCtrl：： RemoveGroup](#removegroup)|从列表视图控件中删除指定的组。|
|[CListCtrl：： Scroll](#scroll)|滚动列表视图控件的内容。|
|[CListCtrl：： SetBkColor](#setbkcolor)|设置列表视图控件的背景色。|
|[CListCtrl：： SetBkImage](#setbkimage)|设置列表视图控件的当前背景图像。|
|[CListCtrl：： SetCallbackMask](#setcallbackmask)|设置列表视图控件的回调掩码。|
|[CListCtrl：： SetCheck](#setcheck)|设置与项关联的状态图像的当前显示状态。|
|[CListCtrl：： SetColumn](#setcolumn)|设置列表视图列的属性。|
|[CListCtrl：： SetColumnOrderArray](#setcolumnorderarray)|设置列表视图控件的列顺序（从左到右）。|
|[CListCtrl：： SetColumnWidth](#setcolumnwidth)|更改报表视图或列表视图中列的宽度。|
|[CListCtrl：： SetExtendedStyle](#setextendedstyle)|设置列表视图控件的当前扩展样式。|
|[CListCtrl：： SetGroupInfo](#setgroupinfo)|设置列表视图控件的指定组的信息。|
|[CListCtrl：： SetGroupMetrics](#setgroupmetrics)|设置列表视图控件的组度量值。|
|[CListCtrl：： SetHotCursor](#sethotcursor)|设置为列表视图控件启用热跟踪时使用的光标。|
|[CListCtrl：： SetHotItem](#sethotitem)|设置列表视图控件的当前热项。|
|[CListCtrl：： SetHoverTime](#sethovertime)|设置列表视图控件的当前悬停时间。|
|[CListCtrl：： SetIconSpacing](#seticonspacing)|设置列表视图控件中图标的间距。|
|[CListCtrl：： SetImageList](#setimagelist)|将图像列表分配给列表视图控件。|
|[CListCtrl：： SetInfoTip](#setinfotip)|设置工具提示文本。|
|[CListCtrl：： SetInsertMark](#setinsertmark)|将插入点设置为定义的位置。|
|[CListCtrl：： SetInsertMarkColor](#setinsertmarkcolor)|设置插入点的颜色。|
|[CListCtrl：： SetItem](#setitem)|设置列表视图项的部分或全部属性。|
|[CListCtrl：： SetItemCount](#setitemcount)|准备用于添加大量项的列表视图控件。|
|[CListCtrl：： SetItemCountEx](#setitemcountex)|设置虚拟列表视图控件的项计数。|
|[CListCtrl：： SetItemData](#setitemdata)|设置项的应用程序特定的值。|
|[CListCtrl：： SetItemIndexState](#setitemindexstate)|设置当前列表视图控件中项的状态。|
|[CListCtrl：： SetItemPosition](#setitemposition)|将项移动到列表视图控件中的指定位置。|
|[CListCtrl：： SetItemState](#setitemstate)|更改列表视图控件中项的状态。|
|[CListCtrl：： SetItemText](#setitemtext)|更改列表视图项或子项的文本。|
|[CListCtrl：： SetOutlineColor](#setoutlinecolor)|设置列表视图控件边框的颜色。|
|[CListCtrl：： SetSelectedColumn](#setselectedcolumn)|设置列表视图控件的选定列。|
|[CListCtrl：： SetSelectionMark](#setselectionmark)|设置列表视图控件的选择标记。|
|[CListCtrl：： SetTextBkColor](#settextbkcolor)|设置列表视图控件中文本的背景色。|
|[CListCtrl：： SetTextColor](#settextcolor)|设置列表视图控件的文本颜色。|
|[CListCtrl：： SetTileInfo](#settileinfo)|设置列表视图控件的图块的信息。|
|[CListCtrl：： SetTileViewInfo](#settileviewinfo)|设置列表视图控件在磁贴视图中使用的信息。|
|[CListCtrl：： SetToolTips](#settooltips)|设置列表视图控件将用于显示工具提示的 tooltip 控件。|
|[CListCtrl：： SetView](#setview)|设置列表视图控件的视图。|
|[CListCtrl：： SetWorkAreas](#setworkareas)|设置可在列表视图控件中显示图标的区域。|
|[CListCtrl：： SortGroups](#sortgroups)|使用用户定义函数对列表视图控件的组进行排序。|
|[CListCtrl：： SortItems](#sortitems)|使用应用程序定义的比较函数对列表视图项进行排序。|
|[CListCtrl：： SortItemsEx](#sortitemsex)|使用应用程序定义的比较函数对列表视图项进行排序。|
|[CListCtrl：： SubItemHitTest](#subitemhittest)|确定位于给定位置的列表视图项（如果有）。|
|[CListCtrl：： Update](#update)|强制控件重绘指定的项。|

## <a name="remarks"></a>备注

除了图标和标签，每一项都可以将信息显示在图标和标签右侧的列中。 此控件（因此 `CListCtrl` 类）仅适用于在 Windows 95/98 和 Windows NT 版本3.51 及更高版本下运行的程序。

下面是 `CListCtrl` 类的简要概述。 有关详细的概念讨论，请参阅[使用 CListCtrl](../../mfc/using-clistctrl.md)和[控件](../../mfc/controls-mfc.md)。

## <a name="views"></a>视图

列表视图控件可以通过四种不同的方式显示其内容，称为 "视图"。

- 图标视图

   每个项都显示为一个完整大小的图标（32 x 32 像素），其下面有一个标签。 用户可以将这些项拖到 "列表视图" 窗口中的任何位置。

- 小图标视图

   每个项都显示为一个小图标（16 x 16 像素），标签位于其右侧。 用户可以将这些项拖到 "列表视图" 窗口中的任何位置。

- “列表”视图

   每个项都显示为一个小图标，其右侧有一个标签。 项按列排列，并且不能拖动到 "列表视图" 窗口中的任何位置。

- 报表视图

   每一项都显示在其自己的行上，附加信息排列在右侧的列中。 最左侧的列包含小图标和标签，后续列包含应用程序指定的子项。 嵌入的标头控件（类[CHeaderCtrl](../../mfc/reference/cheaderctrl-class.md)）实现了这些列。 有关报表视图中的标题控件和列的详细信息，请参阅[Using CListCtrl：向控件添加列（报表视图）](../../mfc/adding-columns-to-the-control-report-view.md)。

控件的当前列表视图的样式确定当前视图。 有关这些样式及其用法的详细信息，请参阅[Using CListCtrl：更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="extended-styles"></a>扩展样式

除了标准列表样式以外，类 `CListCtrl` 还支持大量扩展样式，提供丰富的功能。 此功能的一些示例包括：

- 悬停选定内容

   启用后，允许在光标停留在特定时间段时自动选择项。

- 虚拟列表视图

   启用后，允许控件支持最多 DWORD 项。 这可以通过在应用程序上施加管理项数据的开销来实现。 除项选择和焦点信息外，所有项信息都必须由应用程序管理。 有关详细信息，请参阅[Using CListCtrl： Virtual List Controls](../../mfc/virtual-list-controls.md)。

- 一键式激活

   启用后，允许热跟踪（对项文本进行自动突出显示）和突出显示项的一次或两次单击激活。

- 拖放列排序

   启用后，允许对列表视图控件中的列进行拖放排序。 仅在 "报表" 视图中可用。

有关使用这些新的扩展样式的信息，请参阅[使用 CListCtrl：更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="items-and-subitems"></a>项和子项

列表视图控件中的每一项都包含一个图标（来自图像列表）、一个标签、一个当前状态和一个应用程序定义的值（称为 "项数据"）。 也可以将一个或多个子项与每个项关联。 "子项" 是在 "报表" 视图中，可在项的图标和标签右侧的列中显示的字符串。 列表视图控件中的所有项必须具有相同数目的子项。

类 `CListCtrl` 提供了若干用于插入、删除、查找和修改这些项的函数。 有关详细信息，请参阅[CListCtrl：： GetItem](#getitem)、 [CListCtrl：： InsertItem](#insertitem)和[CListCtrl：： FindItem](#finditem)、[向控件添加项](../adding-items-to-the-control.md)以及[在列表控件中滚动、排列、排序和查找](../scrolling-arranging-sorting-and-finding-in-list-controls.md)。

默认情况下，列表视图控件负责存储项的图标和文本特性。 但是，除了这些项类型之外，类 `CListCtrl` 还支持 "回调项"。 "回调项" 是一个列表视图项，应用程序（而不是控件）存储文本和/或图标。 回调掩码用于指定应用程序提供的项属性（文本和/或图标）。 如果应用程序使用回叫项，则它必须能够按需提供文本和/或图标属性。 当你的应用程序已经维护了某些此信息时，回调项很有用。 有关详细信息，请参阅[使用 CListCtrl：回调项和回调掩码](../callback-items-and-the-callback-mask.md)。

## <a name="image-lists"></a>图像列表

列表视图项的图标、标头项图像和应用程序定义的状态包含在多个图像列表中（由[CImageList](cimagelist-class.md)类实现），您可以创建该列表并将其分配给列表视图控件。 每个列表视图控件最多可以有四种不同类型的图像列表：

- 大图标

   用于完整大小的图标的图标视图。

- 小图标

   用于 "图标" 视图中使用的较小版本图标的小图标、列表和报表视图中。

- 应用程序定义的状态

   包含状态图像，这些图像显示在项的图标旁边以指示应用程序定义的状态。

- 标头项

   用于显示在每个标头控件项中的小图像的报表视图中。

默认情况下，列表视图控件会在销毁时销毁分配给它的图像列表;但是，开发人员可以通过在不使用的情况下销毁每个图像列表（由应用程序确定）来自定义此行为。 有关详细信息，请参阅[使用 CListCtrl：列出项和图像列表](../list-items-and-image-lists.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](cobject-class.md)

[CCmdTarget](ccmdtarget-class.md)

[CWnd](cwnd-class.md)

`CListCtrl`

## <a name="requirements"></a>要求

**标头：** afxcmn.h

## <a name="approximateviewrect"></a>CListCtrl：： ApproximateViewRect

确定显示列表视图控件的项所需的宽度和高度。

```
CSize ApproximateViewRect(
    CSize sz = CSize(-1, -1),
    int iCount = -1) const;
```

### <a name="parameters"></a>parameters

*sz*<br/>
控件的建议尺寸（以像素为单位）。 如果未指定维度，则框架将使用控件的当前宽度或高度值。

*iCount*<br/>
要在控件中显示的项的数目。 如果此参数为-1，则框架将使用控件中当前的总项数。

### <a name="return-value"></a>返回值

一个 `CSize` 对象，它包含显示项所需的近似宽度和高度（以像素为单位）。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_ApproximateViewRect](/windows/win32/api/commctrl/nf-commctrl-listview_approximateviewrect)，如 Windows SDK 中所述。

## <a name="arrange"></a>CListCtrl：：排列

在图标视图中重新定位项，使其在网格上对齐。

```
BOOL Arrange(UINT nCode);
```

### <a name="parameters"></a>parameters

*nCode*<br/>
指定项的对齐样式。 可以为下列值之一：

- LVA_ALIGNLEFT 沿窗口左边缘对齐项。

- LVA_ALIGNTOP 沿窗口上边缘对齐项。

- LVA_DEFAULT 根据列表视图的当前对齐方式（默认值）对齐项。

- LVA_SNAPTOGRID 将所有图标对齐到最近的网格位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

*NCode*参数指定对齐样式。

### <a name="example"></a>示例

```cpp
    // Align all of the list view control items along the top
    // of the window (the list view control must be in icon or
    // small icon mode).
    m_myListCtrl.Arrange(LVA_ALIGNTOP);
```

## <a name="canceleditlabel"></a>CListCtrl：： CancelEditLabel

取消项文本编辑操作。

```
void CancelEditLabel();
```

### <a name="remarks"></a>备注

此成员函数模拟[LVM_CANCELEDITLABEL](/windows/win32/Controls/lvm-canceleditlabel)消息的功能，如 Windows SDK 中所述。

## <a name="clistctrl"></a>CListCtrl：： CListCtrl

构造 `CListCtrl` 对象。

```
CListCtrl();
```

## <a name="create"></a>CListCtrl：： Create

创建一个列表控件，并将其附加到 `CListCtrl` 对象上。

```
virtual BOOL Create(
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>parameters

*dwStyle*<br/>
指定列表控件的样式。 将列表控件样式的任意组合应用于控件。 有关这些样式的完整列表，请参阅 Windows SDK 中的[列表视图窗口样式](/windows/win32/Controls/list-view-window-styles)。 使用[SetExtendedStyle](#setextendedstyle)设置特定于控件的扩展样式。

*rect*<br/>
指定列表控件的大小和位置。 它可以是 `CRect` 对象或[RECT](/previous-versions/dd162897\(v=vs.85\))结构。

*pParentWnd*<br/>
指定列表控件的父窗口，通常为 `CDialog`。 值不得为 NULL。

*nID*<br/>
指定列表控件的 ID。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

可以通过两个步骤构造 `CListCtrl`。 首先，调用构造函数，然后调用 `Create`，这将创建列表视图控件，并将其附加到 `CListCtrl` 对象。

若要将扩展的 Windows 样式应用于 list 控件对象，请调用[CreateEx](#createex)而不是 `Create`。

### <a name="example"></a>示例

```cpp
    m_myListCtrl.Create(
        WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_EDITLABELS,
        CRect(10,10,400,200), pParentWnd, IDD_MYLISTCTRL);
```

## <a name="createex"></a>CListCtrl：： CreateEx

创建一个控件（子窗口）并将其与 `CListCtrl` 对象相关联。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>parameters

*dwExStyle*<br/>
指定正在创建的控件的扩展样式。 有关扩展 Windows 样式的列表，请参阅 Windows SDK 中[CreateWindowEx](/windows/win32/api/winuser/nf-winuser-createwindowexw)的*dwExStyle*参数。

*dwStyle*<br/>
指定列表控件的样式。 将列表控件样式的任意组合应用于控件。 有关这些样式的完整列表，请参阅 Windows SDK 中的[列表视图窗口样式](/windows/win32/Controls/list-view-window-styles)。

*rect*<br/>
对[矩形](/previous-versions/dd162897\(v=vs.85\))结构的引用，该结构描述要创建的窗口的大小和位置（以*pParentWnd*的工作区坐标表示）。

*pParentWnd*<br/>
指向作为控件的父级的窗口的指针。

*nID*<br/>
控件的子窗口 ID。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

使用 `CreateEx` 而不是[Create](#create)来应用扩展的 windows 样式，该样式由 Windows 扩展样式指定的前言**WS_EX_** 开头。

`CreateEx` 使用*dwExStyle*指定的扩展 Windows 样式创建控件。 若要设置特定于控件的扩展样式，请调用[SetExtendedStyle](#setextendedstyle)。 例如，使用 `CreateEx` 将此类样式设置 WS_EX_CONTEXTHELP，但使用 `SetExtendedStyle` 将此类样式设置为 "LVS_EX_FULLROWSELECT"。 有关详细信息，请参阅在 Windows SDK 中的[扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)一文中所述的样式。

## <a name="createdragimage"></a>CListCtrl：： CreateDragImage

为*nItem*指定的项创建一个拖动图像列表。

```
CImageList* CreateDragImage(
    int nItem,
    LPPOINT lpPoint);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要创建其拖动图像列表的项的索引。

*lpPoint*<br/>
用于接收图像左上角初始位置的[点](/previous-versions/dd162805\(v=vs.85\))结构的地址（以视图坐标表示）。

### <a name="return-value"></a>返回值

如果成功，则为指向拖动图像列表的指针;否则为 NULL。

### <a name="remarks"></a>备注

`CImageList` 对象是永久性的，并且必须在完成后将其删除。 例如：

```cpp
        CImageList* pImageList = m_myListCtrl.CreateDragImage(nItem, &point);

        // do something

        delete pImageList;
```

## <a name="deleteallitems"></a>CListCtrl：:D eleteAllItems

从列表视图控件中删除所有项。

```
BOOL DeleteAllItems();
```

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Delete all of the items from the list view control.
    m_myListCtrl.DeleteAllItems();
    ASSERT(m_myListCtrl.GetItemCount() == 0);
```

## <a name="deletecolumn"></a>CListCtrl：:D eleteColumn

从列表视图控件中删除列。

```
BOOL DeleteColumn(int nCol);
```

### <a name="parameters"></a>parameters

*nCol*<br/>
要删除的列的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Delete all of the columns.
        for (int i=0; i < nColumnCount; i++)
        {
            m_myListCtrl.DeleteColumn(0);
        }
```

## <a name="deleteitem"></a>CListCtrl：:D eleteItem

从列表视图控件中删除项。

```
BOOL DeleteItem(int nItem);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
指定要删除的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();

        // Delete all of the items from the list view control.
        for (int i=0; i < nCount; i++)
        {
            m_myListCtrl.DeleteItem(0);
        }
```

## <a name="drawitem"></a>CListCtrl：:D rawItem

当所有者描述的列表视图控件的可视方面发生更改时由框架调用。

```
virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>parameters

*lpDrawItemStruct*<br/>
指向 `DRAWITEMSTRUCT` 结构的长指针，该指针包含所需绘图类型的相关信息。

### <a name="remarks"></a>备注

[DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)结构的 `itemAction` 成员定义要执行的绘图操作。

默认情况下，此成员函数不执行任何操作。 重写此成员函数以实现 `CListCtrl` 对象的所有者描述的绘图。

此成员函数终止之前，应用程序应还原为*lpDrawItemStruct*中提供的显示上下文选择的所有图形设备接口（GDI）对象。

## <a name="editlabel"></a>CListCtrl：： EditLabel

开始就地编辑项的文本。

```
CEdit* EditLabel(int nItem);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要编辑的列表视图项的索引。

### <a name="return-value"></a>返回值

如果成功，则为指向用于编辑项文本的 `CEdit` 对象的指针;否则为 NULL。

### <a name="remarks"></a>备注

具有 "LVS_EDITLABELS" 窗口样式的列表视图控件允许用户就地编辑项标签。 用户通过单击具有焦点的项的标签开始编辑。

使用此函数开始就地编辑指定的列表视图项的文本。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Show the edit control on the label of the first
        // item in the list view control.
        CEdit* pmyEdit = m_myListCtrl.EditLabel(1);
        ASSERT(pmyEdit != NULL);
```

## <a name="enablegroupview"></a>CListCtrl：： EnableGroupView

启用或禁用列表视图控件中的项是否显示为组。

```
LRESULT EnableGroupView(BOOL fEnable);
```

### <a name="parameters"></a>parameters

*fEnable*<br/>
指示是否启用 listview 控件来对显示的项进行分组。 若要启用分组，则为 TRUE;若要禁用它，则为 FALSE。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**将列表视图项显示为组的功能已启用或已禁用。

- **1**已成功更改控件的状态。

- **-1**操作失败。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_ENABLEGROUPVIEW](/windows/win32/Controls/lvm-enablegroupview)消息的功能，如 Windows SDK 中所述。

## <a name="ensurevisible"></a>CListCtrl::Ensurevisible

确保列表视图项至少部分可见。

```
BOOL EnsureVisible(
    int nItem,
    BOOL bPartialOK);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要显示的列表视图项的索引。

*bPartialOK*<br/>
指定是否可接受部分可见性。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如果需要，将滚动列表视图控件。 如果*bPartialOK*参数为非零值，则不会在项部分可见时进行滚动。

### <a name="example"></a>示例

```cpp
        // Ensure that the last item is visible.
        int nCount = m_myListCtrl.GetItemCount();
        if (nCount > 0)
            m_myListCtrl.EnsureVisible(nCount-1, FALSE);
```

## <a name="finditem"></a>CListCtrl：： FindItem

搜索具有指定特征的列表视图项。

```
int FindItem(
    LVFINDINFO* pFindInfo,
    int nStart = -1) const;
```

### <a name="parameters"></a>parameters

*pFindInfo*<br/>
指向[LVFINDINFO](/windows/win32/api/commctrl/ns-commctrl-lvfindinfow)结构的指针，该结构包含要搜索的项的相关信息。

*nStart*<br/>
要开始搜索的项的索引，或者为-1，则从开头开始。 如果*nStart*不等于-1，则从搜索中排除*nStart*处的项。

### <a name="return-value"></a>返回值

如果成功，则为该项的索引; 否则为-1。

### <a name="remarks"></a>备注

*PFindInfo*参数指向 `LVFINDINFO` 结构，它包含用于搜索列表视图项的信息。

### <a name="example"></a>示例

```cpp
        LVFINDINFO info;
        int nIndex;

        info.flags = LVFI_PARTIAL|LVFI_STRING;
        info.psz = _T("item");

        // Delete all of the items that begin with the string.
        while ((nIndex = m_myListCtrl.FindItem(&info)) != -1)
        {
            m_myListCtrl.DeleteItem(nIndex);
        }
```

## <a name="getbkcolor"></a>CListCtrl：： GetBkColor

检索列表视图控件的背景色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的32位值。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetBkColor](#setbkcolor)的示例。

## <a name="getbkimage"></a>CListCtrl：： GetBkImage

检索列表视图控件的当前背景图像。

```
BOOL GetBkImage(LVBKIMAGE* plvbkImage) const;
```

### <a name="parameters"></a>parameters

*plvbkImage*<br/>
指向包含列表视图当前背景图像的 `LVBKIMAGE` 结构的指针。

### <a name="return-value"></a>返回值

如果成功，则返回非零; 否则返回零。

### <a name="remarks"></a>备注

此方法实现 Win32 宏的行为， [ListView_GetBkImage](/windows/win32/api/commctrl/nf-commctrl-listview_getbkimage)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        LVBKIMAGE bki;

        // If no background image is set for the list view control use
        // the Microsoft homepage image as the background image.
        if (m_myListCtrl.GetBkImage(&bki) && (bki.ulFlags == LVBKIF_SOURCE_NONE))
        {
            m_myListCtrl.SetBkImage(
                _T("https://www.microsoft.com/library/images/gifs/homepage/microsoft.gif"),
                TRUE);
        }
```

## <a name="getcallbackmask"></a>CListCtrl：： GetCallbackMask

检索列表视图控件的回调掩码。

```
UINT GetCallbackMask() const;
```

### <a name="return-value"></a>返回值

列表视图控件的回调掩码。

### <a name="remarks"></a>备注

"回调项" 是一个列表视图项，应用程序（而不是控件）存储文本和/或图标。 尽管列表视图控件可以存储这些属性，但如果您的应用程序已经维护了某些此类信息，您可能希望使用回叫项。 回调掩码指定应用程序维护的项状态位，并且它应用于整个控件而不是特定项。 回调掩码默认为零，这意味着控件将跟踪所有项状态。 如果应用程序使用回叫项或指定非零回调掩码，则它必须能够按需提供列表视图项特性。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetCallbackMask](#setcallbackmask)的示例。

## <a name="getcheck"></a>CListCtrl：： GetCheck

检索与项关联的状态图像的当前显示状态。

```
BOOL GetCheck(int nItem) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
列表控件项的从零开始的索引。

### <a name="return-value"></a>返回值

如果选择该项，则为非零; 否则为0。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetCheckState](/windows/win32/api/commctrl/nf-commctrl-listview_getcheckstate)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetCheck](#setcheck)的示例。

## <a name="getcolumn"></a>CListCtrl：： GetColumn

检索列表视图控件的列的属性。

```
BOOL GetColumn(
    int nCol,
    LVCOLUMN* pColumn) const;
```

### <a name="parameters"></a>parameters

*nCol*<br/>
要检索其属性的列的索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构的地址，它指定要检索的信息并接收有关列的信息。 `mask` 成员指定要检索的列属性。 如果 `mask` 成员指定 LVCF_TEXT 值，则 `pszText` 成员必须包含接收项文本的缓冲区的地址，并且 `cchTextMax` 成员必须指定缓冲区的大小。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVCOLUMN` 结构包含有关报表视图中的列的信息。

### <a name="example"></a>示例

```cpp
        LVCOLUMN col;

        col.mask = LVCF_WIDTH;

        // Double the column width of the first column.
        if (m_myListCtrl.GetColumn(0, &col))
        {
            col.cx *= 2;
            m_myListCtrl.SetColumn(0, &col);
        }
```

## <a name="getcolumnorderarray"></a>CListCtrl：： GetColumnOrderArray

检索列表视图控件的列顺序（从左到右）。

```
BOOL GetColumnOrderArray(
    LPINT piArray,
    int iCount = -1);
```

### <a name="parameters"></a>parameters

*piArray*<br/>
指向缓冲区的指针，该缓冲区将包含列表视图控件中列的索引值。 缓冲区必须足够大，以便包含列表视图控件中的总列数。

*iCount*<br/>
列表视图控件中的列数。 如果此参数为-1，则框架将自动检索列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_getcolumnorderarray)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // Reverse the order of the columns in the list view control
        // (i.e. make the first column the last, the last column
        // the first, and so on...).
        CHeaderCtrl* pHeaderCtrl = m_myListCtrl.GetHeaderCtrl();

        if (pHeaderCtrl != NULL)
        {
            int  nColumnCount = pHeaderCtrl->GetItemCount();
            LPINT pnOrder = (LPINT) malloc(nColumnCount*sizeof(int));
            ASSERT(pnOrder != NULL);
            m_myListCtrl.GetColumnOrderArray(pnOrder, nColumnCount);

            int i, j, nTemp;
            for (i = 0, j = nColumnCount-1; i < j; i++, j--)
            {
                nTemp = pnOrder[i];
                pnOrder[i] = pnOrder[j];
                pnOrder[j] = nTemp;
            }

            m_myListCtrl.SetColumnOrderArray(nColumnCount, pnOrder);
            free(pnOrder);
        }
```

## <a name="getcolumnwidth"></a>CListCtrl：： GetColumnWidth

检索报表视图或列表视图中列的宽度。

```
int GetColumnWidth(int nCol) const;
```

### <a name="parameters"></a>parameters

*nCol*<br/>
指定要检索其宽度的列的索引。

### <a name="return-value"></a>返回值

*NCol*指定的列的宽度（以像素为单位）。

### <a name="example"></a>示例

```cpp
        // Increase the column width of the second column by 20.
        int nWidth = m_myListCtrl.GetColumnWidth(1);
        m_myListCtrl.SetColumnWidth(1, 20 + nWidth);
```

## <a name="getcountperpage"></a>CListCtrl：： GetCountPerPage

在列表视图或报表视图中时，计算列表视图控件可见区域中可垂直容纳的项数。

```
int GetCountPerPage() const;
```

### <a name="return-value"></a>返回值

在列表视图或报表视图中时，列表视图控件可见区域中可垂直容纳的项数。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetTopIndex](#gettopindex)的示例。

## <a name="geteditcontrol"></a>CListCtrl：： GetEditControl

检索用于编辑列表视图项文本的编辑控件的句柄。

```
CEdit* GetEditControl() const;
```

### <a name="return-value"></a>返回值

如果成功，则为指向用于编辑项文本的[CEdit](cedit-class.md)对象的指针;否则为 NULL。

### <a name="example"></a>示例

```cpp
        // The string replacing the text in the edit control.
        LPCTSTR lpszmyString = _T("custom label!");

        // If possible, replace the text in the label edit control.
        CEdit* pEdit = m_myListCtrl.GetEditControl();

        if (pEdit != NULL)
        {
            pEdit->SetWindowText(lpszmyString);
        }
```

## <a name="getemptytext"></a>CListCtrl：： GetEmptyText

检索当前列表视图控件为空时要显示的字符串。

```
CString GetEmptyText() const;
```

### <a name="return-value"></a>返回值

一个[CString](../../atl-mfc-shared/reference/cstringt-class.md) ，其中包含控件为空时要显示的文本。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_GETEMPTYTEXT](/windows/win32/Controls/lvm-getemptytext)消息。

## <a name="getextendedstyle"></a>CListCtrl：： GetExtendedStyle

检索列表视图控件的当前扩展样式。

```
DWORD GetExtendedStyle();
```

### <a name="return-value"></a>返回值

列表视图控件当前正在使用的扩展样式的组合。 有关这些扩展样式的描述性列表，请参阅 Windows SDK 中的[扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)文章。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_getextendedlistviewstyle)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetExtendedStyle](#setextendedstyle)的示例。

## <a name="getfirstselecteditemposition"></a>CListCtrl：： GetFirstSelectedItemPosition

获取列表视图控件中第一个选定项的位置。

```
POSITION GetFirstSelectedItemPosition() const;
```

### <a name="return-value"></a>返回值

可用于迭代或对象指针检索的位置值;如果未选择任何项，则为 NULL。

### <a name="example"></a>示例

下面的代码示例演示了此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getfocusedgroup"></a>CListCtrl：： GetFocusedGroup

检索在当前列表视图控件中具有键盘焦点的组。

```
int GetFocusedGroup() const;
```

### <a name="return-value"></a>返回值

如果存在此类组，则为其状态为 LVGS_FOCUSED 的组的索引; 否则为。否则为-1。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_GETFOCUSEDGROUP](/windows/win32/Controls/lvm-getfocusedgroup)消息。 有关详细信息，请参阅[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的 `state` 成员的 LVGS_FOCUSED 值。

## <a name="getgroupcount"></a>CListCtrl：： GetGroupCount

检索当前列表视图控件中的组数。

```
int GetGroupCount()const;
```

### <a name="return-value"></a>返回值

列表视图控件中的组数。

### <a name="remarks"></a>备注

此方法发送 Windows SDK--> 中描述的[LVM_GETGROUPCOUNT](/windows/win32/Controls/lvm-getgroupcount)消息。

## <a name="getgroupinfo"></a>CListCtrl：： GetGroupInfo

获取列表视图控件的指定组的信息。

```
int GetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp) const;
```

### <a name="parameters"></a>parameters

*iGroupId*<br/>
要检索其信息的组的标识符。

*pgrp*<br/>
指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)的指针，该指针包含有关指定的组的信息。

### <a name="return-value"></a>返回值

如果成功，则返回组的 ID; 否则返回-1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETGROUPINFO](/windows/win32/Controls/lvm-getgroupinfo)消息的功能，如 Windows SDK 中所述。

## <a name="getgroupinfobyindex"></a>CListCtrl：： GetGroupInfoByIndex

检索有关当前列表视图控件中指定组的信息。

```
BOOL GetGroupInfoByIndex(
    int iIndex,
    PLVGROUP pGroup) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*iIndex*|中组的从零开始的索引。|
|*pGroup*|弄指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针，该结构接收*iIndex*参数指定的组的相关信息。<br /><br /> 调用方负责初始化[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的成员。 将 `cbSize` 成员设置为结构的大小，并将 `mask` 成员的标志设置为指定要检索的信息。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法发送 Windows SDK--> 中描述的[LVM_GETGROUPINFOBYINDEX](/windows/win32/controls/lvm-getgroupinfobyindex)消息。

### <a name="example"></a>示例

下面的代码示例定义了一个用于访问当前列表视图控件的变量 `m_listCtrl`。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示 `GetGroupInfoByIndex` 方法。 在此代码示例的前面部分中，我们创建了一个列表视图控件，该控件在报表视图中显示标题为 "ClientID" 和 "评分" 的两个列。 下面的代码示例检索有关其索引为0的组的信息（如果存在这样的组）。
```cpp
    // GetGroupInfoByIndex
    const int GROUP_HEADER_BUFFER_SIZE = 40;

// Initialize the structure
    LVGROUP gInfo = {0};
    gInfo.cbSize = sizeof(LVGROUP);
    wchar_t wstrHeadGet[GROUP_HEADER_BUFFER_SIZE] = {0};
    gInfo.cchHeader = GROUP_HEADER_BUFFER_SIZE;
    gInfo.pszHeader = wstrHeadGet;
    gInfo.mask = (LVGF_ALIGN | LVGF_STATE | LVGF_HEADER | LVGF_GROUPID);
    gInfo.state = LVGS_NORMAL;
    gInfo.uAlign  = LVGA_HEADER_LEFT;

    BOOL bRet = m_listCtrl.GetGroupInfoByIndex( 0, &gInfo );
    if (bRet == TRUE) {
        CString strHeader = CString( gInfo.pszHeader );
        CString str;
        str.Format(_T("Header: '%s'"), strHeader);
        AfxMessageBox(str, MB_ICONINFORMATION);
    }
    else
    {
        AfxMessageBox(_T("No group information was retrieved."));
    }
```

## <a name="getgroupmetrics"></a>CListCtrl：： GetGroupMetrics

检索组的度量值。

```
void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const;
```

### <a name="parameters"></a>parameters

*pGroupMetrics*<br/>
指向包含组度量值信息的[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)的指针。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETGROUPMETRICS](/windows/win32/Controls/lvm-getgroupmetrics)消息的功能，如 Windows SDK 中所述。

## <a name="getgrouprect"></a>CListCtrl：： GetGroupRect

检索当前列表视图控件中指定组的边框。

```
BOOL GetGroupRect(
    int iGroupId,
    LPRECT lpRect,
    int iCoords = LVGGR_GROUP) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*iGroupId*|中指定组。|
|*lpRect*|[in，out]指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针。 如果此方法成功，则结构将接收由*iGroupId*指定的组的矩形坐标。|
|*iCoords*|中指定要检索的矩形坐标。 使用以下值之一：<br /><br /> -LVGGR_GROUP （默认值）整个展开组的坐标。<br />-LVGGR_HEADER-仅标头（折叠组）的坐标。<br />-LVGGR_SUBSETLINK-仅限子集链接（标记子集）的坐标。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

调用方负责分配*pRect*参数指向的[RECT](/previous-versions/dd162897\(v=vs.85\))结构。

此方法发送 Windows SDK 中描述的[LVM_GETGROUPRECT](/windows/win32/Controls/lvm-getgrouprect)消息。

### <a name="example"></a>示例

下面的代码示例定义了一个用于访问当前列表视图控件的变量 `m_listCtrl`。 此变量将在下一个示例中使用。
```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示 `GetGroupRect` 方法。 在此代码示例的前面部分中，我们创建了一个列表视图控件，该控件在报表视图中显示标题为 "ClientID" 和 "评分" 的两个列。 下面的代码示例在其索引为0的组（如果存在这样的组）周围绘制一个三维矩形。

```cpp
    // GetGroupRect

    // Get the graphics rectangle that surrounds group 0.
    CRect rect;
    BOOL bRet = m_listCtrl.GetGroupRect( 0, &rect, LVGGR_GROUP);
    // Draw a blue rectangle around group 0.
    if (bRet == TRUE) {
        m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(0, 0, 255), RGB(0, 0, 255));
    }
    else {
        AfxMessageBox(_T("No group information was retrieved."), MB_ICONINFORMATION);
    }
```

## <a name="getgroupstate"></a>CListCtrl：： GetGroupState

检索当前列表视图控件中指定组的状态。

```
UINT GetGroupState(
    int iGroupId,
    DWORD dwMask) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*iGroupId*|中组的从零开始的索引。|
|*dwMask*|中掩码，指定要为指定组检索的状态值。 有关详细信息，请参阅[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的 `mask` 成员。|

### <a name="return-value"></a>返回值

指定组的请求状态; 如果找不到该组，则为0。

### <a name="remarks"></a>备注

返回值是对*dwMask*参数执行按位 "与" 运算的结果，以及表示当前列表视图控件的[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的 `state` 成员的值。

此方法发送 Windows SDK 中描述的[LVM_GETGROUPSTATE](/windows/win32/Controls/lvm-getgroupstate)消息。 有关详细信息，请参阅[ListView_GetGroupState](/windows/win32/api/commctrl/nf-commctrl-listview_getgroupstate)宏。

## <a name="getheaderctrl"></a>CListCtrl：： GetHeaderCtrl

检索列表视图控件的标题控件。

```
CHeaderCtrl* GetHeaderCtrl();
```

### <a name="return-value"></a>返回值

指向列表视图控件使用的标头控件的指针。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetHeader](/windows/win32/api/commctrl/nf-commctrl-listview_getheader)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的示例。

## <a name="gethotcursor"></a>CListCtrl：： GetHotCursor

检索对列表视图控件启用热跟踪时使用的光标。

```
HCURSOR GetHotCursor();
```

### <a name="return-value"></a>返回值

列表视图控件所使用的当前热光标资源的句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_gethotcursor)，如 Windows SDK 中所述。 当光标经过任何列表视图项时，将显示热光标（仅当启用悬停选项时可见）。 通过设置 LVS_EX_TRACKSELECT 扩展样式启用悬停选择。

### <a name="example"></a>示例

```cpp
        // Set the hot cursor to be the system app starting cursor.
        HCURSOR hCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
        m_myListCtrl.SetHotCursor(hCursor);
        ASSERT(m_myListCtrl.GetHotCursor() == hCursor);
```

## <a name="gethotitem"></a>CListCtrl：： GetHotItem

检索当前光标下的列表视图项。

```
int GetHotItem();
```

### <a name="return-value"></a>返回值

列表视图控件的当前热项的索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_gethotitem)，如 Windows SDK 中所述。 启用热跟踪（和悬停选择）时，热项定义为当前选定的项。

如果启用了热跟踪，则当用户暂停列表视图项时，项标签会自动突出显示，而不使用鼠标按钮。

### <a name="example"></a>示例

```cpp
    // Set the hot item to the first item only if no other item is
    // highlighted.
    if (m_myListCtrl.GetHotItem() == -1)
        m_myListCtrl.SetHotItem(0);
```

## <a name="gethovertime"></a>CListCtrl：： GetHoverTime

检索列表视图控件的当前悬停时间。

```
DWORD GetHoverTime() const;
```

### <a name="return-value"></a>返回值

返回在选定项之前鼠标光标必须悬停在该项上方的延迟（以毫秒为单位）。 如果返回值为-1，则悬停时间为默认悬停时间。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_gethovertime)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // If the hover time is the default set to 1 sec.
        DWORD dwTime = m_myListCtrl.GetHoverTime();
        if (dwTime == -1)
            m_myListCtrl.SetHoverTime(1000);
```

## <a name="getimagelist"></a>CListCtrl：： GetImageList

检索用于绘制列表视图项的图像列表的句柄。

```
CImageList* GetImageList(int nImageList) const;
```

### <a name="parameters"></a>parameters

*nImageList*<br/>
指定要检索的图像列表的值。 它可以是以下值之一：

- 带大图标 LVSIL_NORMAL 图像列表。

- 带有小图标 LVSIL_SMALL 图像列表。

- LVSIL_STATE 包含状态图像的图像列表。

### <a name="return-value"></a>返回值

一个指针，指向用于绘制列表视图项的图像列表。

### <a name="example"></a>示例

```cpp
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == NULL);
        m_myListCtrl.SetImageList(&m_lcImageList, LVSIL_NORMAL);
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == &m_lcImageList);
```

## <a name="getinsertmark"></a>CListCtrl：： GetInsertMark

检索插入标记的当前位置。

```
BOOL GetInsertMark(LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>parameters

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，该结构包含插入标记的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE; 否则返回 FALSE。 如果 `LVINSERTMARK` 结构的 `cbSize` 成员的大小不等于结构的实际大小，则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARK](/windows/win32/Controls/lvm-getinsertmark)消息的功能，如 Windows SDK 中所述。

## <a name="getinsertmarkcolor"></a>CListCtrl：： GetInsertMarkColor

检索插入标记的当前颜色。

```
COLORREF GetInsertMarkColor() const;
```

### <a name="return-value"></a>返回值

返回包含插入点颜色的[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARKCOLOR](/windows/win32/Controls/lvm-getinsertmarkcolor)消息的功能，如 Windows SDK 中所述。

## <a name="getinsertmarkrect"></a>CListCtrl：： GetInsertMarkRect

检索限定插入点的矩形。

```
int GetInsertMarkRect(LPRECT pRect) const;
```

### <a name="parameters"></a>parameters

*pRect*<br/>
指向 `RECT` 结构的指针，该结构包含绑定插入点的矩形的坐标。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**找不到插入点。

- 找到**1**个插入点。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETINSERTMARKRECT](/windows/win32/Controls/lvm-getinsertmarkrect)消息的功能，如 Windows SDK 中所述。

## <a name="getitem"></a>CListCtrl：： GetItem

检索列表视图项的部分或全部属性。

```
BOOL GetItem(LVITEM* pItem) const;
```

### <a name="parameters"></a>parameters

*pItem*<br/>
指向[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的指针，该结构接收项的特性。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVITEM` 结构指定或接收列表视图项的特性。

## <a name="getitemcount"></a>CListCtrl：： GetItemCount

检索列表视图控件中的项数。

```
int GetItemCount() const;
```

### <a name="return-value"></a>返回值

列表视图控件中的项数。

### <a name="example"></a>示例

请参阅[CListCtrl：:D eleteitem](#deleteitem)的示例。

## <a name="getitemdata"></a>CListCtrl：： GetItemData

检索与 `nItem`指定的项关联的特定于32位应用程序的值。

```
DWORD_PTR GetItemData(int nItem) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要检索其数据的列表项的索引。

### <a name="return-value"></a>返回值

与指定项关联的32位应用程序特定值。

### <a name="remarks"></a>备注

此值为[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的 `lParam` 成员，如 Windows SDK

### <a name="example"></a>示例

```cpp
    // If any item's data is equal to zero then reset it to -1.
    for (int i=0; i < m_myListCtrl.GetItemCount(); i++)
    {
        if (m_myListCtrl.GetItemData(i) == 0)
        {
            m_myListCtrl.SetItemData(i, (DWORD) -1);
        }
    }
```

## <a name="getitemindexrect"></a>CListCtrl：： GetItemIndexRect

检索当前列表视图控件中子项的全部或部分的边框。

```
BOOL GetItemIndexRect(
    PLVITEMINDEX pItemIndex,
    int iColumn,
    int rectType,
    LPRECT pRect) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*pItemIndex*|中指向子项的父项的[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针。<br /><br /> 调用方负责分配和设置[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的成员。 此参数不能为 NULL。|
|*iColumn*|中控件中列的从零开始的索引。|
|*rectType*|中要为其检索边框的列表视图子项的部分。 指定以下值之一：<br /><br /> LVIR_BOUNDS-返回整个子项的边框，包括图标和标签。<br /><br /> LVIR_ICON-返回子项的图标或小图标的边框。<br /><br /> LVIR_LABEL-返回子项文本的边框。|
|*pRect*|弄指向[RECT](/previous-versions/dd162897\(v=vs.85\))结构的指针，该结构接收有关子项的边框的信息。<br /><br /> 调用方负责分配[RECT](/previous-versions/dd162897\(v=vs.85\))结构。 此参数不能为 NULL。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_GETITEMINDEXRECT](/windows/win32/Controls/lvm-getitemindexrect)消息。 有关详细信息，请参阅[ListView_GetItemIndexRect 宏](/windows/win32/api/commctrl/nf-commctrl-listview_getitemindexrect)。

### <a name="example"></a>示例

下面的代码示例定义了一个用于访问当前列表视图控件的变量 `m_listCtrl`。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示 `GetGroupRect` 方法。 在输入此代码示例之前，我们创建了一个列表视图控件，该控件在报表视图中显示标题为 "ClientID" 和 "评分" 的两个列。 下面的代码示例在两个列中的第二个子项周围绘制一个三维矩形。

```cpp
    // GetItemIndexRect
    // Get the rectangle that bounds the second item in the first group.
    LVITEMINDEX lvItemIndex;
    lvItemIndex.iGroup = 0;
    lvItemIndex.iItem = 1;
    CRect rect;
    BOOL bRet = m_listCtrl.GetItemIndexRect(
        &lvItemIndex, 0, LVIR_BOUNDS, &rect);

    // Draw a red rectangle around the item.
    m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(255, 0, 0), RGB(255, 0, 0) );
```

## <a name="getitemposition"></a>CListCtrl：： GetItemPosition

检索列表视图项的位置。

```
BOOL GetItemPosition(
    int nItem,
    LPPOINT lpPoint) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要检索其位置的项的索引。

*lpPoint*<br/>
在视图坐标中接收项左上角位置的[点](/previous-versions/dd162805\(v=vs.85\))结构地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        POINT pt;

        // Move all items in the list control 100 pixels to the right.
        UINT i, nCount = m_myListCtrl.GetItemCount();

        for (i=0; i < nCount; i++)
        {
            m_myListCtrl.GetItemPosition(i, &pt);
            pt.x += 100;
            m_myListCtrl.SetItemPosition(i, pt);
        }
```

## <a name="getitemrect"></a>CListCtrl：： GetItemRect

检索当前视图中的所有或部分项的边框。

```
BOOL GetItemRect(
    int nItem,
    LPRECT lpRect,
    UINT nCode) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要检索其位置的项的索引。

*lpRect*<br/>
接收边框的[RECT](/previous-versions/dd162897\(v=vs.85\))结构的地址。

*nCode*<br/>
要为其检索边框的列表视图项的部分。 它可以是以下值之一：

- LVIR_BOUNDS 返回整个项的边框，包括图标和标签。

- LVIR_ICON 返回图标或小图标的边框。

- LVIR_LABEL 返回项文本的边框。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
// OnClick is the handler for the NM_CLICK notification
void CListCtrlDlg::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;

    // Get the current mouse location and convert it to client
    // coordinates.
    CPoint pos( ::GetMessagePos() );
    ScreenToClient(&pos);

    // Get indexes of the first and last visible items in
    // the listview control.
    int index = m_myListCtrl.GetTopIndex();
    int last_visible_index = index + m_myListCtrl.GetCountPerPage();
    if (last_visible_index > m_myListCtrl.GetItemCount())
        last_visible_index = m_myListCtrl.GetItemCount();

    // Loop until number visible items has been reached.
    while (index <= last_visible_index)
    {
        // Get the bounding rectangle of an item. If the mouse
        // location is within the bounding rectangle of the item,
        // you know you have found the item that was being clicked.
        CRect r;
        m_myListCtrl.GetItemRect(index, &r, LVIR_BOUNDS);
        if (r.PtInRect(pia->ptAction))
        {
            UINT flag = LVIS_SELECTED | LVIS_FOCUSED;
            m_myListCtrl.SetItemState(index, flag, flag);
            break;
        }

        // Get the next item in listview control.
        index++;
    }
}
```

## <a name="getitemspacing"></a>CListCtrl：： GetItemSpacing

计算当前列表视图控件中各项之间的间距。

```
BOOL GetItemSpacing(
    BOOL fSmall,
    int* pnHorzSpacing,
    int* pnVertSpacing) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*fSmall*|中要为其检索项间距的视图。 将小图标视图指定为 TRUE，或为图标视图指定 FALSE。|
|*pnHorzSpacing*|弄包含项之间的水平间距。|
|*pnVertSpacing*|弄包含项之间的垂直间距。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_GETITEMSPACING](/windows/win32/Controls/lvm-getitemspacing)消息。

## <a name="getitemstate"></a>CListCtrl：： GetItemState

检索列表视图项的状态。

```
UINT GetItemState(
    int nItem,
    UINT nMask) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要检索其状态的项的索引。

*nMask*<br/>
指定要返回的项的状态标志的掩码。

### <a name="return-value"></a>返回值

指定列表视图项的状态标志。

### <a name="remarks"></a>备注

项的状态由[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的 `state` 成员指定，如 Windows SDK 中所述。 指定或更改项的状态时，`stateMask` 成员指定要更改的状态位。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetTopIndex](#gettopindex)的示例。

## <a name="getitemtext"></a>CListCtrl：： GetItemText

检索列表视图项或子项的文本。

```
int GetItemText(
    int nItem,
    int nSubItem,
    LPTSTR lpszText,
    int nLen) const;

CString GetItemText(
    int nItem,
    int nSubItem) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要检索其文本的项的索引。

*nSubItem*<br/>
指定要检索其文本的子项。

*lpszText*<br/>
指向接收项文本的字符串的指针。

*nLen*<br/>
*LpszText*所指向的缓冲区的长度。

### <a name="return-value"></a>返回值

返回**int**的版本返回检索到的字符串的长度。

返回 `CString` 的版本返回项文本。

### <a name="remarks"></a>备注

如果*nSubItem*为零，则此函数检索项标签;如果*nSubItem*为非零，则将检索子项的文本。 有关子项参数的详细信息，请参阅 Windows SDK 中的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的讨论。

## <a name="getnextitem"></a>CListCtrl：： GetNextItem

搜索具有指定属性并且具有与给定项相关的指定关系的列表视图项。

```
int GetNextItem(
    int nItem,
    int nFlags) const;
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要开始搜索的项的索引，或者为-1，则查找与指定标志匹配的第一项。 指定的项本身将从搜索中排除。

*nFlags*<br/>
请求的项与指定项的几何关系，以及所请求项的状态。 几何关系可以是以下值之一：

- LVNI_ABOVE 搜索指定项之上的项。

- LVNI_ALL 按索引搜索后续项（默认值）。

- LVNI_BELOW 搜索指定项下面的项。

- LVNI_TOLEFT 搜索指定项左侧的项。

- LVNI_TORIGHT 在指定项的右侧搜索项。

状态可以是零，也可以是以下一个或多个值：

- LVNI_DROPHILITED 项设置了 LVIS_DROPHILITED 状态标志。

- LVNI_FOCUSED 项设置了 LVIS_FOCUSED 状态标志。

- LVNI_SELECTED 项设置了 LVIS_SELECTED 状态标志。

如果项未设置所有指定的状态标志，则搜索将继续下一项。

### <a name="return-value"></a>返回值

如果成功，则为下一个项的索引; 否则为-1。

## <a name="getnextitemindex"></a>CListCtrl：： GetNextItemIndex

检索当前列表视图控件中具有一组指定属性的项的索引。

```
BOOL GetNextItemIndex(
    PLVITEMINDEX pItemIndex,
    int nFlags) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*pItemIndex*|[in，out]指向[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针，该结构描述搜索开始处的项，或为-1 以查找与*nFlags*参数中的标志匹配的第一项。<br /><br /> 如果此方法成功，则 `LVITEMINDEX` 结构将描述搜索所找到的项。|
|*nFlags*|中标志的按位组合（OR），指定如何执行搜索。<br /><br /> 搜索可以依赖于目标项的索引、状态或外观，或者依赖于*pItemIndex*参数指定的项的目标项的物理位置。 有关详细信息，请参阅[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)消息中的*flags*参数。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

调用方负责分配和设置*pItemIndex*参数指向的 `LVITEMINDEX` 结构的成员。

此方法发送 Windows SDK 中描述的[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)消息。

## <a name="getnextselecteditem"></a>CListCtrl：： GetNextSelectedItem

获取由*pos*标识的列表项的索引，然后将*POS*设置为位置值。

```
int GetNextSelectedItem(POSITION& pos) const;
```

### <a name="parameters"></a>parameters

pos<br/>
对 `GetNextSelectedItem` 或 `GetFirstSelectedItemPosition`先前调用所返回的位置值的引用。 此调用会将值更新到下一个位置。

### <a name="return-value"></a>返回值

由*pos*标识的列表项的索引。

### <a name="remarks"></a>备注

如果使用对 `GetFirstSelectedItemPosition`的调用建立初始位置，则可以在向前迭代循环中使用 `GetNextSelectedItem`。

您必须确保您的位置值有效。 如果无效，则 Microsoft 基础类库断言的调试版本。

### <a name="example"></a>示例

下面的代码示例演示了此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getnumberofworkareas"></a>CListCtrl：： GetNumberOfWorkAreas

检索列表视图控件的当前工作区数。

```
UINT GetNumberOfWorkAreas() const;
```

### <a name="return-value"></a>返回值

目前不使用。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetNumberOfWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getnumberofworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        UINT i, uCount = m_myListCtrl.GetNumberOfWorkAreas();
        LPRECT lpRects = (LPRECT) malloc(uCount*sizeof(RECT));

        if (lpRects != NULL)
        {
            // Dump all of the work area dimensions.
            m_myListCtrl.GetWorkAreas(uCount, lpRects);

            for (i=0; i < uCount; i++)
            {
                TRACE(_T("Work area %d; left = %d, top = %d, right = %d, ")
                    _T("bottom = %d\r\n"),
                    i, lpRects[i].left, lpRects[i].top, lpRects[i].right,
                    lpRects[i].bottom);
            }

            free(lpRects);
        }
        else
        {
            TRACE(_T("Couldn't allocate enough memory!"));
        }
```

## <a name="getoutlinecolor"></a>CListCtrl：： GetOutlineColor

检索列表视图控件边框的颜色。

```
COLORREF GetOutlineColor() const;
```

### <a name="return-value"></a>返回值

返回包含轮廓颜色的[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETOUTLINECOLOR](/windows/win32/Controls/lvm-getoutlinecolor)消息的功能，如 Windows SDK 中所述。

## <a name="getorigin"></a>CListCtrl：： GetOrigin

检索列表视图控件的当前视图源。

```
BOOL GetOrigin(LPPOINT lpPoint) const;
```

### <a name="parameters"></a>parameters

*lpPoint*<br/>
接收视图原点的[点](/previous-versions/dd162805\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。 但是，如果控件在报表视图中，则返回值始终为零。

## <a name="getselectedcolumn"></a>CListCtrl：： GetSelectedColumn

检索列表控件中当前所选列的索引。

```
UINT GetSelectedColumn() const;
```

### <a name="return-value"></a>返回值

所选列的索引。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETSELECTEDCOLUMN](/windows/win32/Controls/lvm-getselectedcolumn)消息的功能，如 Windows SDK 中所述。

## <a name="getselectedcount"></a>CListCtrl：： GetSelectedCount

检索列表视图控件中选定项的数目。

```
UINT GetSelectedCount() const;
```

### <a name="return-value"></a>返回值

列表视图控件中选定项的数目。

### <a name="example"></a>示例

```cpp
        UINT i, uSelectedCount = m_myListCtrl.GetSelectedCount();
        int  nItem = -1;

        // Update all of the selected items.
        if (uSelectedCount > 0)
        {
            for (i=0; i < uSelectedCount; i++)
            {
                nItem = m_myListCtrl.GetNextItem(nItem, LVNI_SELECTED);
                ASSERT(nItem != -1);
                m_myListCtrl.Update(nItem);
            }
        }
```

## <a name="getselectionmark"></a>CListCtrl：： GetSelectionMark

检索列表视图控件的选择标记。

```
int GetSelectionMark();
```

### <a name="return-value"></a>返回值

从零开始的选择标记，如果没有选择标记，则为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_getselectionmark)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the selection mark to the first item only if no other item is
    // selected.
    if (m_myListCtrl.GetSelectionMark() == -1)
        m_myListCtrl.SetSelectionMark(0);
```

## <a name="getstringwidth"></a>CListCtrl：： GetStringWidth

确定显示给定字符串的所有所需的最小列宽。

```
int GetStringWidth(LPCTSTR lpsz) const;
```

### <a name="parameters"></a>parameters

*lpsz*<br/>
要确定其宽度的以 null 结尾的字符串的地址。

### <a name="return-value"></a>返回值

*Lpsz*指向的字符串的宽度（以像素为单位）。

### <a name="remarks"></a>备注

返回的宽度将考虑控件的当前字体和列边距，而不考虑小图标的宽度。

### <a name="example"></a>示例

```cpp
        CString strColumn;
        int nWidth;

        // Insert six columns in the list view control. Make the width of
        // the column be the width of the column header plus 50%.
        for (int i = 0; i < 6; i++)
        {
            strColumn.Format(_T("column %d"), i);
            nWidth = 3*m_myListCtrl.GetStringWidth(strColumn)/2;
            m_myListCtrl.InsertColumn(i, strColumn, LVCFMT_LEFT, nWidth);
        }
```

## <a name="getsubitemrect"></a>CListCtrl：： GetSubItemRect

检索列表视图控件中项的边框。

```
BOOL GetSubItemRect(
    int iItem,
    int iSubItem,
    int nArea,
    CRect& ref);
```

### <a name="parameters"></a>parameters

*iItem*<br/>
子项的父项的索引。

*iSubItem*<br/>
子项的从1开始的索引。

*nArea*<br/>
确定要检索的边框的部分（列表视图子项）。 通过对一个或多个以下值应用按位 "或" 运算符，指定边框的部分（图标、标签或两者）：

- LVIR_BOUNDS 返回整个项的边框，包括图标和标签。

- LVIR_ICON 返回图标或小图标的边框。

- LVIR_LABEL 返回整个项的边框，包括图标和标签。 这与 LVIR_BOUNDS 完全相同。

*ref*<br/>
对[CRect](../../atl-mfc-shared/reference/crect-class.md)对象的引用，该对象包含子项的边框的坐标。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetSubItemRect](/windows/win32/api/commctrl/nf-commctrl-listview_getsubitemrect)，如 Windows SDK 中所述。

## <a name="gettextbkcolor"></a>CListCtrl：： GetTextBkColor

检索列表视图控件的文本背景色。

```
COLORREF GetTextBkColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的32位值。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetTextBkColor](#settextbkcolor)的示例。

## <a name="gettextcolor"></a>CListCtrl：： GetTextColor

检索列表视图控件的文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

用于指定 RGB 颜色的32位值。

### <a name="example"></a>示例

请参阅[CListCtrl：： SetTextColor](#settextcolor)的示例。

## <a name="gettileinfo"></a>CListCtrl：： GetTileInfo

检索有关列表视图控件中的图块的信息。

```
BOOL GetTileInfo(PLVTILEINFO plvti) const;
```

### <a name="parameters"></a>parameters

*plvti*<br/>
指向接收磁贴信息的[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)结构的指针。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETTILEINFO](/windows/win32/Controls/lvm-gettileinfo)消息的功能，如 Windows SDK 中所述。

## <a name="gettileviewinfo"></a>CListCtrl：： GetTileViewInfo

检索有关磁贴视图中的列表视图控件的信息。

```
BOOL GetTileViewInfo(PLVTILEVIEWINFO ptvi) const;
```

### <a name="parameters"></a>parameters

*ptvi*<br/>
指向[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)结构的指针，该结构接收检索到的信息。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETTILEVIEWINFO](/windows/win32/Controls/lvm-gettileviewinfo)消息的功能，如 Windows SDK 中所述。

## <a name="gettooltips"></a>CListCtrl：： GetToolTips

检索列表视图控件用来显示工具提示的 tooltip 控件。

```
CToolTipCtrl* GetToolTips() const;
```

### <a name="return-value"></a>返回值

指向列表控件要使用的[CToolTipCtrl](ctooltipctrl-class.md)对象的指针。 如果[Create](#create)成员函数使用样式 LVS_NOTOOLTIPS，则不会使用任何工具提示，并返回 NULL。

### <a name="remarks"></a>备注

此成员函数实现 Win32 消息[LVM_GETTOOLTIPS](/windows/win32/Controls/lvm-gettooltips)的行为，如 Windows SDK 中所述。 `GetToolTips` 的 MFC 实现将返回一个 `CToolTipCtrl` 对象，此对象由列表控件使用，而不是工具提示控件的句柄。

### <a name="example"></a>示例

```cpp
        CToolTipCtrl* pTip = m_myListCtrl.GetToolTips();
        if (NULL != pTip)
        {
            pTip->UpdateTipText(_T("I'm a list view!"), &m_myListCtrl,
                IDD_MYLISTCTRL);
        }
```

## <a name="gettopindex"></a>CListCtrl：： GetTopIndex

在列表视图或报表视图中检索最顶层可见项的索引。

```
int GetTopIndex() const;
```

### <a name="return-value"></a>返回值

最顶部可见项的索引。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Select all of the items that are completely visible.
        int n = m_myListCtrl.GetTopIndex();
        int nLast = n + m_myListCtrl.GetCountPerPage();

        for (; n < nLast; n++)
        {
            m_myListCtrl.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
            ASSERT(m_myListCtrl.GetItemState(n, LVIS_SELECTED) == LVIS_SELECTED);
        }
```

## <a name="getview"></a>CListCtrl：： GetView

获取列表视图控件的视图。

```
DWORD GetView() const;
```

### <a name="return-value"></a>返回值

列表视图控件的当前视图。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_GETVIEW](/windows/win32/Controls/lvm-getview)消息的功能，如 Windows SDK 中所述。

## <a name="getviewrect"></a>CListCtrl：： GetViewRect

检索列表视图控件中所有项的边框。

```
BOOL GetViewRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>parameters

*lpRect*<br/>
[矩形](/previous-versions/dd162897\(v=vs.85\))结构的地址。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

列表视图必须是图标视图或小图标视图。

## <a name="getworkareas"></a>CListCtrl：： GetWorkAreas

检索列表视图控件的当前工作区。

```
void GetWorkAreas(
    int nWorkAreas,
    LPRECT pRect) const;
```

### <a name="parameters"></a>parameters

*nWorkAreas*<br/>
*PRect*数组中包含的 `RECT` 结构的数目。

*pRect*<br/>
一个指针，它指向接收列表视图控件的工作区的 `RECT` 结构（或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象）的数组。 这些结构中的值采用工作区坐标。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_GetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)的示例。

## <a name="hasgroup"></a>CListCtrl：： HasGroup

确定列表视图控件是否具有指定的组。

```
BOOL HasGroup(int iGroupId) const;
```

### <a name="parameters"></a>parameters

*iGroupId*<br/>
正在请求的组的标识符。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_HASGROUP](/windows/win32/Controls/lvm-hasgroup)消息的功能，如 Windows SDK 中所述。

## <a name="hittest"></a>CListCtrl：： System.windows.media.visualtreehelper.hittest

确定位于指定位置的列表视图项（如果有）。

```
int HitTest(LVHITTESTINFO* pHitTestInfo) const;

int HitTest(
    CPoint pt,
    UINT* pFlags = NULL) const;
```

### <a name="parameters"></a>parameters

*pHitTestInfo*<br/>
`LVHITTESTINFO` 结构的地址，该结构包含要进行命中测试的位置并接收有关命中测试结果的信息。

*pt*<br/>
要测试的点。

*pFlags*<br/>
指向一个整数的指针，该整数接收有关测试结果的信息。 请参阅 Windows SDK 中[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)结构的 `flags` 成员的说明。

### <a name="return-value"></a>返回值

位于*pHitTestInfo*指定的位置处的项的索引（如果有），否则为-1。

### <a name="remarks"></a>备注

您可以使用结构的 `flag` 成员的 LVHT_ABOVE、LVHT_BELOW、LVHT_TOLEFT 和 LVHT_TORIGHT 值来确定是否滚动列表视图控件的内容。 例如，如果位置在工作区的上方和左侧，则可以合并其中两个标志。

您可以测试结构的 `flag` 成员的 LVHT_ONITEM 值，以确定给定的位置是否在列表视图项之上。 此值是对结构的 `flag` 成员的 LVHT_ONITEMICON、LVHT_ONITEMLABEL 和 LVHT_ONITEMSTATEICON 值的按位 "或" 运算。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    CPoint point(pia->ptAction);

    // Select the item the user clicked on.
    UINT uFlags;
    int nItem = m_myListCtrl.HitTest(point, &uFlags);

    if (uFlags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItem(nItem, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED,
            LVIS_SELECTED, 0);
    }

    *pResult = 0;
}
```

## <a name="insertcolumn"></a>CListCtrl：： InsertColumn

在列表视图控件中插入新列。

```
int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,
    LPCTSTR lpszColumnHeading,
    int nFormat = LVCFMT_LEFT,
    int nWidth = -1,
    int nSubItem = -1);
```

### <a name="parameters"></a>parameters

*nCol*<br/>
新列的索引。

*pColumn*<br/>
包含新列的属性的 `LVCOLUMN` 结构的地址。

*lpszColumnHeading*<br/>
包含列标题的字符串的地址。

*nFormat*<br/>
整数，用于指定列的对齐方式。 可以是以下值之一： LVCFMT_LEFT、LVCFMT_RIGHT 或 LVCFMT_CENTER。

*nWidth*<br/>
列的宽度（以像素为单位）。 如果此参数为-1，则不设置列宽。

*nSubItem*<br/>
与该列关联的子项的索引。 如果此参数为-1，则没有子项与该列关联。

### <a name="return-value"></a>返回值

如果成功，则为新列的索引; 否则为-1。

### <a name="remarks"></a>备注

列表视图控件中最左边的列必须为左对齐。

[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构包含 "报表" 视图中列的属性。 它还用于接收有关列的信息。 此结构在 Windows SDK 中进行了介绍。

## <a name="insertgroup"></a>CListCtrl：： InsertGroup

将组插入到列表视图控件中。

```
LRESULT InsertGroup(
    int index,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>parameters

索引<br/>
要插入组的项的索引。

*pgrp*<br/>
指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针，该结构包含要添加的组。

### <a name="return-value"></a>返回值

返回组所添加到的项的索引; 如果操作失败，则返回-1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTGROUP](/windows/win32/Controls/lvm-insertgroup)消息的功能，如 Windows SDK 中所述。

## <a name="insertgroupsorted"></a>CListCtrl：： InsertGroupSorted

将指定的组插入组的有序列表。

```
LRESULT InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert);
```

### <a name="parameters"></a>parameters

*pStructInsert*<br/>
指向[LVINSERTGROUPSORTED](/windows/win32/api/commctrl/ns-commctrl-lvinsertgroupsorted)结构的指针，该结构包含要插入的组。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTGROUPSORTED](/windows/win32/Controls/lvm-insertgroupsorted)消息的功能，如 Windows SDK 中所述。

## <a name="insertitem"></a>CListCtrl：： InsertItem

向列表视图控件中插入项。

```
int InsertItem(const LVITEM* pItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem,
    int nImage);

int InsertItem(
    UINT nMask,
    int nItem,
    LPCTSTR lpszItem,
    UINT nState,
    UINT nStateMask,
    int nImage,
    LPARAM lParam);
```

### <a name="parameters"></a>parameters

*pItem*<br/>
指向[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的指针，该结构指定项的属性，如 Windows SDK 中所述。

*nItem*<br/>
要插入的项的索引。

*lpszItem*<br/>
包含项标签的字符串的地址，如果该项是回调项，则为 LPSTR_TEXTCALLBACK。 有关回调项的信息，请参阅[CListCtrl：： GetCallbackMask](#getcallbackmask)。

*n*<br/>
项的图像的索引，如果该项是回调项，则为 I_IMAGECALLBACK。 有关回调项的信息，请参阅[CListCtrl：： GetCallbackMask](#getcallbackmask)。

*nMask*<br/>
*NMask*参数指定作为参数传递的项属性是有效的。 它可以是 Windows SDK 中的[LVITEM 结构](/windows/win32/api/commctrl/ns-commctrl-lvitemw)中描述的一个或多个掩码值。 有效值可以与按位 "或" 运算符组合。

*nState*<br/>
指示项的状态、状态图像和覆盖图像。 有关详细信息，请参阅 Windows SDK 主题[LVITEM 结构](/windows/win32/api/commctrl/ns-commctrl-lvitemw)和[列表-查看](/windows/win32/Controls/list-view-item-states)有效标志列表的项状态。

*nStateMask*<br/>
指示将检索或修改状态成员的哪些位。 有关详细信息，请参阅 Windows SDK 中的[LVITEM 结构](/windows/win32/api/commctrl/ns-commctrl-lvitemw)。

*lParam*<br/>
与项关联的32位应用程序特定值。 如果指定此参数，则必须将*nMask*属性设置 LVIF_PARAM。

### <a name="return-value"></a>返回值

如果成功，则为新项的索引; 否则为-1。

### <a name="remarks"></a>备注

调用此方法可能会导致 LVM_INSERTITEM 消息发送到控件窗口。 控件的关联消息处理程序可能无法在某些情况下设置项文本（例如，使用诸如 LVS_OWNERDRAW 的窗口样式）。 有关这些条件的详细信息，请参阅 Windows SDK 中的[LVM_INSERTITEM](/windows/win32/Controls/lvm-insertitem) 。

### <a name="example"></a>示例

```cpp
        CString strText;
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Insert 10 items in the list view control.
        for (int i = 0; i < 10; i++)
        {
            strText.Format(TEXT("item %d"), i);

            // Insert the item, select every other item.
            m_myListCtrl.InsertItem(LVIF_TEXT | LVIF_STATE, i, strText,
                (i % 2) == 0 ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, 0);

            // Initialize the text of the subitems.
            for (int j = 1; j < nColumnCount; j++)
            {
                strText.Format(TEXT("sub-item %d %d"), i, j);
                m_myListCtrl.SetItemText(i, j, strText);
            }
        }
```

## <a name="insertmarkhittest"></a>CListCtrl：： InsertMarkHitTest

检索距离指定点最近的插入点。

```
int InsertMarkHitTest(
    LPPOINT pPoint,
    LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>parameters

*pPoint*<br/>
指向一个[点](/previous-versions/dd162805\(v=vs.85\))结构的指针，该结构包含命中测试坐标（相对于列表控件的工作区）。

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，该结构指定与 point 参数定义的坐标最接近的插入点。

### <a name="return-value"></a>返回值

离指定点最近的插入点。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_INSERTMARKHITTEST](/windows/win32/Controls/lvm-insertmarkhittest)消息的功能，如 Windows SDK 中所述。

## <a name="isgroupviewenabled"></a>CListCtrl：： IsGroupViewEnabled

确定是否为列表视图控件启用组视图。

```
BOOL IsGroupViewEnabled() const;
```

### <a name="return-value"></a>返回值

如果启用了组视图，则返回 TRUE; 否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_ISGROUPVIEWENABLED](/windows/win32/Controls/lvm-isgroupviewenabled)消息的功能，如 Windows SDK 中所述。

## <a name="isitemvisible"></a>CListCtrl：： IsItemVisible

指示当前列表视图控件中的指定项是否可见。

```
BOOL IsItemVisible(int index) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|索引|中当前列表视图控件中项的从零开始的索引。|

### <a name="return-value"></a>返回值

如果指定的项可见，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_ISITEMVISIBLE](/windows/win32/Controls/lvm-isitemvisible)消息。

## <a name="mapidtoindex"></a>CListCtrl：： MapIDToIndex

将当前列表视图控件中项的唯一 ID 映射到索引。

```
UINT MapIDToIndex(UINT id) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*id*|中项的唯一 ID。|

### <a name="return-value"></a>返回值

指定 ID 的当前索引。

### <a name="remarks"></a>备注

列表视图控件在内部按索引跟踪项。 这可能会出现问题，因为在控件的生存期内索引可能会更改。 当创建项时，列表视图控件可以使用 ID 标记项，您可以使用此 ID 来保证列表视图控件生存期内的唯一性。

请注意，在多线程环境中，仅在承载列表视图控件而不是在后台线程上的线程上确保索引。

此方法发送 Windows SDK 中描述的[LVM_MAPIDTOINDEX](/windows/win32/controls/lvm-mapidtoindex)消息。

## <a name="mapindextoid"></a>CListCtrl：： MapIndexToID

将当前列表视图控件中项的索引映射到唯一 ID。

```
UINT MapIndexToID(UINT index) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|索引|中项的从零开始的索引。|

### <a name="return-value"></a>返回值

指定项的唯一 ID。

### <a name="remarks"></a>备注

列表视图控件在内部按索引跟踪项。 这可能会出现问题，因为在控件的生存期内索引可能会更改。 创建项时，列表视图控件可以使用 ID 标记项。 您可以使用此 ID 来访问列表视图控件生存期的特定项。

请注意，在多线程环境中，仅在承载列表视图控件而不是在后台线程上的线程上确保索引。

此方法发送 Windows SDK 中描述的[LVM_MAPINDEXTOID](/windows/win32/Controls/lvm-mapindextoid)消息。

### <a name="example"></a>示例

下面的代码示例定义了一个用于访问当前列表视图控件的变量 `m_listCtrl`。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示 `MapIndexToID` 方法。 在此代码示例的前面部分中，我们创建了一个列表视图控件，该控件在报表视图中显示标题为 "ClientID" 和 "评分" 的两个列。 下面的示例将每个列表视图项的索引映射到标识号，然后检索每个标识号的索引。 最后，该示例报告是否检索了原始索引。

```cpp
    // MapIndexToID
    int iCount = m_listCtrl.GetItemCount();
    UINT nId = 0;
    UINT nIndex = 0;
    for (int iIndexOriginal = 0; iIndexOriginal < iCount; iIndexOriginal++)
    {
        // Map index to ID.
        nId = m_listCtrl.MapIndexToID((UINT)iIndexOriginal);

        // Map ID to index.
        nIndex = m_listCtrl.MapIDToIndex(nId);

        if (nIndex != (UINT)(iIndexOriginal))
        {
            CString str;
            str.Format(_T("Mapped index (%d) is not equal to original index (%d)"),
                nIndex, (UINT)(iIndexOriginal));
            AfxMessageBox(str);
            return;
        }
    }
    AfxMessageBox(_T("The mapped indexes and original indexes are equal."),
        MB_ICONINFORMATION);
```

## <a name="movegroup"></a>CListCtrl：： MoveGroup

将指定组移动到列表视图控件的指定的从零开始的索引。

```
LRESULT MoveGroup(
    int iGroupId,
    int toIndex);
```

### <a name="parameters"></a>parameters

*iGroupId*<br/>
要移动的组的标识符。

*toIndex*<br/>
要将组移动到的从零开始的索引。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_MOVEGROUP](/windows/win32/Controls/lvm-movegroup)消息的功能，如 Windows SDK 中所述。

## <a name="moveitemtogroup"></a>CListCtrl：： MoveItemToGroup

将指定的项移动到指定的组中。

```
void MoveItemToGroup(
    int idItemFrom,
    int idGroupTo);
```

### <a name="parameters"></a>parameters

*idItemFrom*<br/>
中要移动的项的索引。

*idGroupTo*<br/>
中项将移动到的组的标识符。

### <a name="remarks"></a>备注

> [!NOTE]
>  当前未实现此方法。

此方法模拟[LVM_MOVEITEMTOGROUP](/windows/win32/Controls/lvm-moveitemtogroup)消息的功能，如 Windows SDK 中所述。

## <a name="redrawitems"></a>CListCtrl：： RedrawItems

强制列表视图控件重绘一系列项。

```
BOOL RedrawItems(
    int nFirst,
    int nLast);
```

### <a name="parameters"></a>parameters

*nFirst*<br/>
要重新绘制的第一项的索引。

*nLast*<br/>
要重新绘制的最后一项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

在列表视图窗口收到 WM_PAINT 消息之前，不会实际重绘指定项。 若要立即重绘，请在使用此函数后调用 Windows [UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow)函数。

## <a name="removeallgroups"></a>CListCtrl：： RemoveAllGroups

从列表视图控件中删除所有组。

```
void RemoveAllGroups();
```

### <a name="remarks"></a>备注

此成员函数模拟[LVM_REMOVEALLGROUPS](/windows/win32/Controls/lvm-removeallgroups)消息的功能，如 Windows SDK 中所述。

## <a name="removegroup"></a>CListCtrl：： RemoveGroup

从列表视图控件中删除指定的组。

```
LRESULT RemoveGroup(int iGroupId);
```

### <a name="parameters"></a>parameters

*iGroupId*<br/>
要移除的组的标识符。

### <a name="return-value"></a>返回值

如果成功，则返回组的索引; 否则返回-1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_REMOVEGROUP](/windows/win32/Controls/lvm-removegroup)消息的功能，如 Windows SDK 中所述。

## <a name="scroll"></a>CListCtrl：： Scroll

滚动列表视图控件的内容。

```
BOOL Scroll(CSize size);
```

### <a name="parameters"></a>parameters

size<br/>
指定水平和垂直滚动量（以像素为单位）的 `CSize` 对象。 *Size*的 `y` 成员除以列表视图控件线条的高度（以像素为单位），并且控件按产生的行数滚动。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="setbkcolor"></a>CListCtrl：： SetBkColor

设置列表视图控件的背景色。

```
BOOL SetBkColor(COLORREF cr);
```

### <a name="parameters"></a>parameters

*回车*<br/>
要设置的背景色，或不 CLR_NONE 背景色的值。 具有背景色的列表视图控件的重绘方式明显快于那些没有背景色的控件。 有关信息，请参阅 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetBkColor() == crBkColor);
```

## <a name="setbkimage"></a>CListCtrl：： SetBkImage

设置列表视图控件的背景图像。

```
BOOL SetBkImage(LVBKIMAGE* plvbkImage);

BOOL SetBkImage(
    HBITMAP hBitmap,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);

BOOL SetBkImage(
    LPTSTR pszUrl,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);
```

### <a name="parameters"></a>parameters

*plvbkImage*<br/>
`LVBKIMAGE` 结构的地址，其中包含新的背景图像信息。

*hBitmap*<br/>
位图的句柄。

*pszUrl*<br/>
一个以 NULL 结尾的字符串，其中包含背景图像的 URL。

*fTile*<br/>
如果图像在列表视图控件的背景中平铺，则为非零值;否则为0。

*xOffsetPercent*<br/>
图像左边缘的偏移量（以像素为单位），从列表视图控件的原点开始。

*yOffsetPercent*<br/>
图像上边缘的偏移量（以像素为单位），从列表视图控件的原点开始。

### <a name="return-value"></a>返回值

如果成功，则返回非零; 否则返回零。

### <a name="remarks"></a>备注

> [!NOTE]
>  由于 `CListCtrl::SetBkImage` 使用 OLE COM 功能，因此必须先初始化 OLE 库，然后才能使用 `SetBkImage`。 最好在应用程序初始化时初始化 COM 库，并在应用程序终止时初始化库。 这会在使用 ActiveX 技术、OLE 自动化、OLE 链接/嵌入或 ODBC/DAO 操作的 MFC 应用程序中自动完成。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetBkImage](#getbkimage)的示例。

## <a name="setcallbackmask"></a>CListCtrl：： SetCallbackMask

设置列表视图控件的回调掩码。

```
BOOL SetCallbackMask(UINT nMask);
```

### <a name="parameters"></a>parameters

*nMask*<br/>
回调掩码的新值。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Set the callback mask so that only the selected and focused states
    // are stored for each item.
    m_myListCtrl.SetCallbackMask(LVIS_SELECTED|LVIS_FOCUSED);
    ASSERT(m_myListCtrl.GetCallbackMask() ==
        (LVIS_SELECTED|LVIS_FOCUSED));
```

## <a name="setcheck"></a>CListCtrl：： SetCheck

确定列表控件项的状态图像是否可见。

```
BOOL SetCheck(
    int nItem,
    BOOL fCheck = TRUE);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
列表控件项的从零开始的索引。

*查看*<br/>
指定项的状态图像是否应可见。 默认情况下，*查看*为 TRUE，状态图像可见。 如果*查看*为 FALSE，则不可见。

### <a name="return-value"></a>返回值

如果选中该项，则为非零; 否则为0。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();
        BOOL fCheck = FALSE;

        // Set the check state of every other item to TRUE and
        // all others to FALSE.
        for (int i = 0; i < nCount; i++)
        {
            m_myListCtrl.SetCheck(i, fCheck);
            ASSERT((m_myListCtrl.GetCheck(i) && fCheck) ||
                (!m_myListCtrl.GetCheck(i) && !fCheck));
            fCheck = !fCheck;
        }
```

## <a name="setcolumn"></a>CListCtrl：： SetColumn

设置列表视图列的属性。

```
BOOL SetColumn(
    int nCol,
    const LVCOLUMN* pColumn);
```

### <a name="parameters"></a>parameters

*nCol*<br/>
要设置其属性的列的索引。

*pColumn*<br/>
包含新列属性的[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)结构的地址，如 Windows SDK 中所述。 结构的 `mask` 成员指定要设置的列特性。 如果 `mask` 成员指定 LVCF_TEXT 值，则结构的 `pszText` 成员是以 null 结尾的字符串的地址，并且该结构的 `cchTextMax` 成员将被忽略。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetColumn](#getcolumn)的示例。

## <a name="setcolumnorderarray"></a>CListCtrl：： SetColumnOrderArray

设置列表视图控件的列顺序（从左到右）。

```
BOOL SetColumnOrderArray(
    int iCount,
    LPINT piArray);
```

### <a name="parameters"></a>parameters

*piArray*<br/>
指向缓冲区的指针，该缓冲区包含列表视图控件中列的索引值（从左到右）。 缓冲区必须足够大，以便包含列表视图控件中的总列数。

*iCount*<br/>
列表视图控件中的列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_setcolumnorderarray)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的示例。

## <a name="setcolumnwidth"></a>CListCtrl：： SetColumnWidth

更改报表视图或列表视图中列的宽度。

```
BOOL SetColumnWidth(
    int nCol,
    int cx);
```

### <a name="parameters"></a>parameters

*nCol*<br/>
要为其设置宽度的列的索引。 在列表视图中，此参数必须为0。

*cx*<br/>
列的新宽度。 可以是 LVSCW_AUTOSIZE 或 LVSCW_AUTOSIZE_USEHEADER，如 Windows SDK [LVM_SETCOLUMNWIDTH](/windows/win32/Controls/lvm-setcolumnwidth)中所述。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="setextendedstyle"></a>CListCtrl：： SetExtendedStyle

设置列表视图控件的当前扩展样式。

```
DWORD SetExtendedStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>parameters

*dwNewStyle*<br/>
要由列表视图控件使用的扩展样式的组合。 有关这些样式的描述性列表，请参阅 Windows SDK 中的[扩展列表视图样式](/windows/win32/Controls/extended-list-view-styles)主题。

### <a name="return-value"></a>返回值

列表视图控件使用的以前的扩展样式的组合。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_setextendedlistviewstyle)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Allow the header controls item to be movable by the user.
    m_myListCtrl.SetExtendedStyle
        (m_myListCtrl.GetExtendedStyle()|LVS_EX_HEADERDRAGDROP);
```

## <a name="setgroupinfo"></a>CListCtrl：： SetGroupInfo

设置描述当前列表视图控件的指定组的信息。

```
int SetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>parameters

*iGroupId*<br/>
设置其信息的组的标识符。

*pgrp*<br/>
指向[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)结构的指针，该结构包含要设置的信息。 调用方负责分配此结构并设置其成员。

### <a name="return-value"></a>返回值

如果方法成功，则为组的 ID;否则为-1。

### <a name="remarks"></a>备注

此方法发送 Windows SDK 中描述的[LVM_SETGROUPINFO](/windows/win32/Controls/lvm-setgroupinfo)消息。

## <a name="setgroupmetrics"></a>CListCtrl：： SetGroupMetrics

设置列表视图控件的组度量值。

```
void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics);
```

### <a name="parameters"></a>parameters

*pGroupMetrics*<br/>
指向[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)结构的指针，该结构包含要设置的组度量值信息。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETGROUPMETRICS](/windows/win32/Controls/lvm-setgroupmetrics)消息的功能，如 Windows SDK 中所述。

## <a name="sethotcursor"></a>CListCtrl：： SetHotCursor

设置为列表视图控件启用热跟踪时使用的光标。

```
HCURSOR SetHotCursor(HCURSOR hc);
```

### <a name="parameters"></a>parameters

*hc*<br/>
用于表示热光标的游标资源的句柄。

### <a name="return-value"></a>返回值

列表视图控件所使用的上一个热光标资源的句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_sethotcursor)，如 Windows SDK 中所述。

只有启用了悬停选项时，才会显示热光标，因为光标会传递到任何列表视图项。 通过设置 LVS_EX_TRACKSELECT 扩展样式启用悬停选择。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetHotCursor](#gethotcursor)的示例。

## <a name="sethotitem"></a>CListCtrl：： SetHotItem

设置列表视图控件的当前热项。

```
int SetHotItem(int iIndex);
```

### <a name="parameters"></a>parameters

*iIndex*<br/>
要设置为热项的项的从零开始的索引。

### <a name="return-value"></a>返回值

以前的热项的从零开始的索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_sethotitem)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetHotItem](#gethotitem)的示例。

## <a name="sethovertime"></a>CListCtrl：： SetHoverTime

设置列表视图控件的当前悬停时间。

```
DWORD SetHoverTime(DWORD dwHoverTime = (DWORD)-1);
```

### <a name="parameters"></a>parameters

*dwHoverTime*<br/>
在选定项之前，鼠标光标必须停留在该项上方的新延迟时间（以毫秒为单位）。 如果传递了默认值，则时间设置为默认悬停时间。

### <a name="return-value"></a>返回值

上一个悬停时间（以毫秒为单位）。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_sethovertime)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetHoverTime](#gethovertime)的示例。

## <a name="seticonspacing"></a>CListCtrl：： SetIconSpacing

设置列表视图控件中图标的间距。

```
CSize SetIconSpacing(
    int cx,
    int cy);

CSize SetIconSpacing(CSize size);
```

### <a name="parameters"></a>parameters

*cx*<br/>
X 轴上的图标之间的距离（以像素为单位）。

*cy*<br/>
Y 轴上的图标之间的距离（以像素为单位）。

size<br/>
一个 `CSize` 对象，该对象指定 x 轴和 y 轴上的图标之间的距离（以像素为单位）。

### <a name="return-value"></a>返回值

一个[CSize](../../atl-mfc-shared/reference/csize-class.md)对象，该对象包含图标间距以前的值。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetIconSpacing](/windows/win32/api/commctrl/nf-commctrl-listview_seticonspacing)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Leave lots of space between icons.
    m_myListCtrl.SetIconSpacing(CSize(100, 100));
```

## <a name="setimagelist"></a>CListCtrl：： SetImageList

将图像列表分配给列表视图控件。

```
CImageList* SetImageList(
    CImageList* pImageList,
    int nImageListType);
```

### <a name="parameters"></a>parameters

*pImageList*<br/>
指向要分配的图像列表的指针。

*nImageListType*<br/>
图像列表的类型。 它可以是以下值之一：

- 带大图标 LVSIL_NORMAL 图像列表。

- 带有小图标 LVSIL_SMALL 图像列表。

- LVSIL_STATE 包含状态图像的图像列表。

### <a name="return-value"></a>返回值

指向上一个图像列表的指针。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetImageList](#getimagelist)的示例。

## <a name="setinfotip"></a>CListCtrl：： SetInfoTip

设置工具提示文本。

```
BOOL SetInfoTip(PLVSETINFOTIP plvInfoTip);
```

### <a name="parameters"></a>parameters

*plvInfoTip*<br/>
指向[LVFSETINFOTIP](/windows/win32/api/commctrl/ns-commctrl-lvsetinfotip)结构的指针，该结构包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINFOTIP](/windows/win32/Controls/lvm-setinfotip)消息的功能，如 Windows SDK 中所述。

## <a name="setinsertmark"></a>CListCtrl：： SetInsertMark

将插入点设置为定义的位置。

```
BOOL SetInsertMark(LPLVINSERTMARK plvim);
```

### <a name="parameters"></a>parameters

*plvim*<br/>
指向[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)结构的指针，该结构指定在何处设置插入点。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE; 否则返回 FALSE。 如果 `LVINSERTMARK` 结构的 `cbSize` 成员的大小不等于结构的实际大小，或者在当前视图中不应用插入点，则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINSERTMARK](/windows/win32/Controls/lvm-setinsertmark)消息的功能，如 Windows SDK 中所述。

## <a name="setinsertmarkcolor"></a>CListCtrl：： SetInsertMarkColor

设置插入点的颜色。

```
COLORREF SetInsertMarkColor(COLORREF color);
```

### <a name="parameters"></a>parameters

*颜色*<br/>
一个[COLORREF](/windows/win32/gdi/colorref)结构，指定要设置插入点的颜色。

### <a name="return-value"></a>返回值

返回包含前一种颜色的 `COLORREF` 结构。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETINSERTMARKCOLOR](/windows/win32/Controls/lvm-setinsertmarkcolor)消息的功能，如 Windows SDK 中所述。

## <a name="setitem"></a>CListCtrl：： SetItem

设置列表视图项的部分或全部属性。

```
BOOL SetItem(const LVITEM* pItem);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam,
    int nIndent);
```

### <a name="parameters"></a>parameters

*pItem*<br/>
包含新项属性的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的地址，如 Windows SDK 中所述。 结构的 `iItem` 和 `iSubItem` 成员标识项或子项，结构的 `mask` 成员指定要设置的特性。 有关 `mask` 成员的详细信息，请参阅 "**备注**"。

*nItem*<br/>
要设置其属性的项的索引。

*nSubItem*<br/>
要设置其属性的子项的索引。

*nMask*<br/>
指定要设置的属性（请参见 "备注"）。

*lpszItem*<br/>
指定项标签的以 null 结尾的字符串的地址。

*n*<br/>
图像列表中项的图像的索引。

*nState*<br/>
指定要更改的状态的值（请参见 "备注"）。

*nStateMask*<br/>
指定要更改的状态（请参阅备注）。

*lParam*<br/>
要与项关联的特定于32位应用程序的值。

*nIndent*<br/>
缩进的宽度（以像素为单位）。 如果*nIndent*小于系统定义的最小宽度，则新的宽度设置为系统定义的最小值

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVITEM` 结构的 `iItem` 和 `iSubItem` 成员以及*nItem*和*nSubItem*参数标识要设置其属性的项和子项。

`LVITEM` 结构的 `mask` 成员和*nMask*参数指定要设置的项属性：

- LVIF_TEXT `pszText` 成员或*lpszItem*参数是以 null 结尾的字符串的地址;`cchTextMax` 成员将被忽略。

- LVIF_STATE `stateMask` 成员或*nStateMask*参数指定要更改的项目状态，并且 `state` 成员或*nState*参数包含这些状态的值。

### <a name="example"></a>示例

请参阅[CListCtrl：： system.windows.media.visualtreehelper.hittest](#hittest)的示例。

## <a name="setitemcount"></a>CListCtrl：： SetItemCount

准备用于添加大量项的列表视图控件。

```
void SetItemCount(int nItems);
```

### <a name="parameters"></a>parameters

*nItems*<br/>
控件最终将包含的项的数目。

### <a name="remarks"></a>备注

若要设置虚拟列表视图控件的项计数，请参阅[CListCtrl：： SetItemCountEx](#setitemcountex)。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetItemCount](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcount)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.
        m_myListCtrl.SetItemCount(1024);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemcountex"></a>CListCtrl：： SetItemCountEx

设置虚拟列表视图控件的项计数。

```
BOOL SetItemCountEx(
    int iCount,
    DWORD dwFlags = LVSICF_NOINVALIDATEALL);
```

### <a name="parameters"></a>parameters

*iCount*<br/>
控件最终将包含的项的数目。

dwFlags<br/>
指定重置项计数后列表视图控件的行为。 此值可以是以下各项的组合：

- LVSICF_NOINVALIDATEALL 除非当前正在查看受影响的项，否则不会重新绘制列表视图控件。 这是默认值。

- LVSICF_NOSCROLL 列表视图控件将不会更改项计数发生更改时的滚动位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetItemCountEx](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcountex)，如只应为虚拟列表视图调用 Windows SDKand 中所述。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.

        // Force my virtual list view control to allocate
        // enough memory for my 1024 items.
        m_myVirtualListCtrl.SetItemCountEx(1024, LVSICF_NOSCROLL|
            LVSICF_NOINVALIDATEALL);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myVirtualListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemdata"></a>CListCtrl：： SetItemData

设置与*nItem*指定的项关联的特定于32位应用程序的值。

```
BOOL SetItemData(int nItem, DWORD_PTR dwData);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要设置其数据的列表项的索引。

*dwData*<br/>
要与项关联的32位值。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

此值为[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的 `lParam` 成员，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the data of each item to be equal to its index.
    for (int i = 0; i < m_myListCtrl.GetItemCount(); i++)
    {
        m_myListCtrl.SetItemData(i, i);
    }
```

## <a name="setitemindexstate"></a>CListCtrl：： SetItemIndexState

设置当前列表视图控件中项的状态。

```
BOOL SetItemIndexState(
    PLVITEMINDEX pItemIndex,
    DWORD dwState,
    DWORD dwMask) const;
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*pItemIndex*|中指向描述项的[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)结构的指针。 调用方负责分配此结构并设置其成员。|
|*dwState*|中要设置项的状态，该项是[列表视图项状态](/windows/win32/Controls/list-view-item-states)的按位组合。 指定零以重置或设置一个状态。|
|*dwMask*|中*DwState*参数指定的状态的有效位的掩码。 指定[列表视图项状态](/windows/win32/Controls/list-view-item-states)的按位组合（OR）。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

有关*dwState*参数的详细信息，请参阅[列表视图项状态](/windows/win32/Controls/list-view-item-states)。

有关*dwMask*参数的详细信息，请参阅[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的*stateMask*成员。

此方法发送 Windows SDK 中描述的[LVM_SETITEMINDEXSTATE](/windows/win32/Controls/lvm-setitemindexstate)消息。

## <a name="setitemposition"></a>CListCtrl：： SetItemPosition

将项移动到列表视图控件中的指定位置。

```
BOOL SetItemPosition(
    int nItem,
    POINT pt);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要设置其位置的项的索引。

*pt*<br/>
一个[点](/previous-versions/dd162805\(v=vs.85\))结构，指定项左上角的新位置（以视图坐标表示）。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

控件必须为图标或小图标视图。

如果列表视图控件具有 LVS_AUTOARRANGE 样式，则在设置项的位置后，将排列列表视图。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetItemPosition](#getitemposition)的示例。

## <a name="setitemstate"></a>CListCtrl：： SetItemState

更改列表视图控件中项的状态。

```
BOOL SetItemState(
    int nItem,
    LVITEM* pItem);

BOOL SetItemState(
    int nItem,
    UINT nState,
    UINT nMask);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要设置其状态的项的索引。

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的地址，如 Windows SDK 中所述。 结构的 `stateMask` 成员指定要更改的状态位，结构的 `state` 成员包含这些位的新值。 将忽略其他成员。

*nState*<br/>
状态位的新值。 有关可能值的列表，请参阅[CListCtrl：： GetNextItem](#getnextitem)和[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) state 成员。

*nMask*<br/>
指定要更改的状态位的掩码。 此值对应于[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构的 stateMask 成员。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

项的 "状态" 为指定项的可用性、指示用户操作或以其他方式反映项状态的值。 列表视图控件更改某些状态位，例如当用户选择某项时。 应用程序可以更改其他状态位来禁用或隐藏该项，或者指定覆盖图像或状态图像。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetTopIndex](#gettopindex)的示例。

## <a name="setitemtext"></a>CListCtrl：： SetItemText

更改列表视图项或子项的文本。

```
BOOL SetItemText(
    int nItem,
    int nSubItem,
    LPCTSTR lpszText);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要设置其文本的项的索引。

*nSubItem*<br/>
子项的索引，或设置为零以设置项标签。

*lpszText*<br/>
指向包含新项文本的字符串的指针。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此方法不应与包含 LVS_OWNERDATA 窗口样式的控件一起使用（事实上，这将导致调试生成中的断言）。 有关此列表控件样式的详细信息，请参阅[列表视图控件概述](/windows/win32/Controls/list-view-controls-overview)。

### <a name="example"></a>示例

请参阅[CListCtrl：： InsertItem](#insertitem)的示例。

## <a name="setoutlinecolor"></a>CListCtrl：： SetOutlineColor

设置列表视图控件边框的颜色（如果设置了[LVS_EX_BORDERSELECT](/windows/win32/Controls/list-view-window-styles)扩展窗口样式）。

```
COLORREF SetOutlineColor(COLORREF color);
```

### <a name="parameters"></a>parameters

*颜色*<br/>
包含轮廓颜色的新[COLORREF](/windows/win32/gdi/colorref)结构。

### <a name="return-value"></a>返回值

包含轮廓颜色的上一个 `COLORREF` 结构

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETOUTLINECOLOR](/windows/win32/Controls/lvm-setoutlinecolor)消息的功能，如 Windows SDK 中所述。

## <a name="setselectedcolumn"></a>CListCtrl：： SetSelectedColumn

设置列表视图控件的选定列。

```
LRESULT SetSelectedColumn(int iCol);
```

### <a name="parameters"></a>parameters

*iCol*<br/>
要选择的列的索引。

### <a name="return-value"></a>返回值

不使用返回值。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETSELECTEDCOLUMN](/windows/win32/Controls/lvm-setselectedcolumn)消息的功能，如 Windows SDK 中所述。

## <a name="setselectionmark"></a>CListCtrl：： SetSelectionMark

设置列表视图控件的选择标记。

```
int SetSelectionMark(int iIndex);
```

### <a name="parameters"></a>parameters

*iIndex*<br/>
多选内容中第一项的从零开始的索引。

### <a name="return-value"></a>返回值

上一个选择标记，如果没有选择标记，则为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_setselectionmark)，如 Windows SDK 中所述。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetSelectionMark](#getselectionmark)的示例。

## <a name="settextbkcolor"></a>CListCtrl：： SetTextBkColor

设置列表视图控件中文本的背景色。

```
BOOL SetTextBkColor(COLORREF cr);
```

### <a name="parameters"></a>parameters

*回车*<br/>
一个 COLORREF，它指定新的文本背景色。 有关信息，请参阅 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetTextBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetTextBkColor() == crBkColor);
```

## <a name="settextcolor"></a>CListCtrl：： SetTextColor

设置列表视图控件的文本颜色。

```
BOOL SetTextColor(COLORREF cr);
```

### <a name="parameters"></a>parameters

*回车*<br/>
指定新文本颜色的 COLORREF。 有关信息，请参阅 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Use the window text color for
    // the item text of the list view control.
    COLORREF crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
    m_myListCtrl.SetTextColor(crTextColor);
    ASSERT(m_myListCtrl.GetTextColor() == crTextColor);
```

## <a name="settileinfo"></a>CListCtrl：： SetTileInfo

设置列表视图控件的图块的信息。

```
BOOL SetTileInfo(PLVTILEINFO pTileInfo);
```

### <a name="parameters"></a>parameters

*pTileInfo*<br/>
指向[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)结构的指针，该结构包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETTILEINFO](/windows/win32/Controls/lvm-settileinfo)消息的功能，如 Windows SDK 中所述。

## <a name="settileviewinfo"></a>CListCtrl：： SetTileViewInfo

设置列表视图控件在磁贴视图中使用的信息。

```
BOOL SetTileViewInfo(PLVTILEVIEWINFO ptvi);
```

### <a name="parameters"></a>parameters

*ptvi*<br/>
指向[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)结构的指针，该结构包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETTILEVIEWINFO](/windows/win32/Controls/lvm-settileviewinfo)消息的功能，如 Windows SDK 中所述。

## <a name="settooltips"></a>CListCtrl：： SetToolTips

设置列表视图控件将用于显示工具提示的 tooltip 控件。

```
CToolTipCtrl* SetToolTips(CToolTipCtrl* pWndTip);
```

### <a name="parameters"></a>parameters

*pWndTip*<br/>
指向列表控件将使用的 `CToolTipCtrl` 对象的指针。

### <a name="return-value"></a>返回值

指向[CToolTipCtrl](ctooltipctrl-class.md)对象的指针，该对象包含控件以前使用的工具提示; 如果以前未使用任何工具提示，则为 NULL。

### <a name="remarks"></a>备注

此成员函数实现 Win32 消息[LVM_SETTOOLTIPS](/windows/win32/Controls/lvm-settooltips)的行为，如 Windows SDK 中所述。

若要不使用工具提示，请在创建 `CListCtrl` 对象时指示 LVS_NOTOOLTIPS 样式。

## <a name="setview"></a>CListCtrl：： SetView

设置列表视图控件的视图。

```
DWORD SetView(int iView);
```

### <a name="parameters"></a>parameters

*iView*<br/>
要选择的视图。

### <a name="return-value"></a>返回值

如果成功，则返回 1; 否则返回-1。 例如，如果视图无效，则返回-1。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SETVIEW](/windows/win32/Controls/lvm-setview)消息的功能，如 Windows SDK 中所述。

## <a name="setworkareas"></a>CListCtrl：： SetWorkAreas

设置可在列表视图控件中显示图标的区域。

```
void SetWorkAreas(
    int nWorkAreas,
    LPRECT lpRect);
```

### <a name="parameters"></a>parameters

*nWorkAreas*<br/>
*LpRect*指向的数组中 `RECT` 结构（或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象）的数目。

*lpRect*<br/>
指定列表视图控件新工作区的 `RECT` 结构（或 `CRect` 对象）数组的地址。 必须在工作区坐标中指定这些区域。 如果此参数为 NULL，工作区域将设置为控件的工作区。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_setworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Remove all working areas.
    m_myListCtrl.SetWorkAreas(0, NULL);
```

## <a name="sortgroups"></a>CListCtrl：： SortGroups

使用应用程序定义的比较函数，按列表视图控件中的 ID 对组进行排序。

```
BOOL SortGroups(
    PFNLVGROUPCOMPARE _pfnGroupCompare,
    LPVOID _plv);
```

### <a name="parameters"></a>parameters

*_pfnGroupCompare*<br/>
指向组比较函数的指针。

*_plv*<br/>
Void 指针。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE，否则返回 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟[LVM_SORTGROUPS](/windows/win32/Controls/lvm-sortgroups)消息的功能，如 Windows SDK 中所述。

## <a name="sortitems"></a>CListCtrl：： SortItems

使用应用程序定义的比较函数对列表视图项进行排序。

```
BOOL SortItems(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>parameters

*pfnCompare*<br/>
中应用程序定义的比较函数的地址。

每次需要确定两个列表项的相对顺序时，排序操作都会调用比较函数。 比较函数必须是类的静态成员或不是任何类的成员的独立函数。

*dwData*<br/>
中传递到比较函数的应用程序定义的值。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法更改每个项的索引以反映新序列。

比较函数*pfnCompare*具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
如果第一个项应在第二个项之前，则该比较函数必须返回一个负值; 如果第一项应在第二个项之后，则为正值; 如果两个项相等，则为零。

*LParam1*参数是与比较的第一项关联的32位值，而*lParam2*参数是与第二项关联的值。 这些值是在项的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)结构插入到列表中时在它们的*lParam*成员中指定的值。 *LParamSort*参数与*dwData*值相同。

此方法发送 Windows SDK 中描述的[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)消息。

### <a name="example"></a>示例

下面是一个简单的比较函数，它会生成按其*lParam*值排序的项。

```cpp
// Sort items by associated lParam
int CALLBACK CListCtrlDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    UNREFERENCED_PARAMETER(lParamSort);
    return (int)(lParam1 - lParam2);
}
```

```cpp
// Sort the items by passing in the comparison function.
void CListCtrlDlg::Sort()
{
    m_myListCtrl.SortItems(&CListCtrlDlg::MyCompareProc, 0);
}
```

## <a name="sortitemsex"></a>CListCtrl：： SortItemsEx

使用应用程序定义的比较函数对当前列表视图控件中的项进行排序。

```
BOOL SortItemsEx(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>parameters

|参数|说明|
|---------------|-----------------|
|*pfnCompare*|中应用程序定义的比较函数的地址。<br /><br /> 每次需要确定两个列表项的相对顺序时，排序操作都会调用比较函数。 比较函数必须是类的静态成员或不是任何类的成员的独立函数。|
|*dwData*|中传递到比较函数的应用程序定义值。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

此方法更改每个项的索引以反映新序列。

比较函数*pfnCompare*具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
此消息与[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)（传递到比较函数的信息的类型除外）类似。 在[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)中， *lParam1*和*lParam2*是要比较的项的值。 在[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)中， *lParam1*是要比较的第一项的当前索引， *lParam2*是第二项的当前索引。 可以发送[LVM_GETITEMTEXT](/windows/win32/Controls/lvm-getitemtext)消息来检索有关项的详细信息。

如果第一个项应在第二个项之前，则该比较函数必须返回一个负值; 如果第一项应在第二个项之后，则为正值; 如果两个项相等，则为零。

> [!NOTE]
>  在排序过程中，列表视图内容不稳定。 如果回调函数将任何消息发送到[LVM_GETITEM](/windows/win32/Controls/lvm-getitem)以外的列表视图控件，则结果是不可预知的。

此方法发送 Windows SDK 中描述的[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)消息。

### <a name="example"></a>示例

下面的代码示例定义了一个用于访问当前列表视图控件的变量 `m_listCtrl`。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示 `SortItemEx` 方法。 在此代码示例的前面部分中，我们创建了一个列表视图控件，该控件在报表视图中显示标题为 "ClientID" 和 "评分" 的两个列。 下面的代码示例使用 "评分" 列中的值对表进行排序。

```cpp
// The ListCompareFunc() method is a global function used by SortItemEx().
int CALLBACK ListCompareFunc(
                             LPARAM lParam1,
                             LPARAM lParam2,
                             LPARAM lParamSort)
{
    CListCtrl* pListCtrl = (CListCtrl*) lParamSort;
    CString    strItem1 = pListCtrl->GetItemText(static_cast<int>(lParam1), 1);
    CString    strItem2 = pListCtrl->GetItemText(static_cast<int>(lParam2), 1)
    int x1 = _tstoi(strItem1.GetBuffer());
    int x2 = _tstoi(strItem2.GetBuffer());
    int result = 0;
    if ((x1 - x2) < 0)
        result = -1;
    else if ((x1 - x2) == 0)
        result = 0;
    else
        result = 1;

    return result;
}

void CCListCtrl_s2Dlg::OnBnClickedButton1()
{
    // SortItemsEx
    m_listCtrl.SortItemsEx( ListCompareFunc, (LPARAM)&m_listCtrl );
}
```

## <a name="subitemhittest"></a>CListCtrl：： SubItemHitTest

确定位于给定位置的列表视图项（如果有）。

```
int SubItemHitTest(LPLVHITTESTINFO pInfo);
```

### <a name="parameters"></a>parameters

*pInfo*<br/>
指向[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)结构的指针。

### <a name="return-value"></a>返回值

要测试的项或子项的从1开始的索引（如果有）; 否则为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为， [ListView_SubItemHitTest](/windows/win32/api/commctrl/nf-commctrl-listview_subitemhittest)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    LVHITTESTINFO lvhti;

    // Clear the subitem text the user clicked on.
    lvhti.pt = pia->ptAction;
    m_myListCtrl.SubItemHitTest(&lvhti);

    if (lvhti.flags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItemText(lvhti.iItem, lvhti.iSubItem, NULL);
    }
}
```

## <a name="update"></a>CListCtrl：： Update

强制列表视图控件重绘*nItem*指定的项。

```
BOOL Update(int nItem);
```

### <a name="parameters"></a>parameters

*nItem*<br/>
要更新的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如果列表视图控件具有 LVS_AUTOARRANGE 样式，此函数也会对其进行排列。

### <a name="example"></a>示例

请参阅[CListCtrl：： GetSelectedCount](#getselectedcount)的示例。

## <a name="see-also"></a>另请参阅

[MFC 示例 ROWLIST](../../overview/visual-cpp-samples.md)<br/>
[CWnd 类](cwnd-class.md)<br/>
[层次结构图](../hierarchy-chart.md)<br/>
[CImageList 类](cimagelist-class.md)
