---
title: CMDIFrameWndEx 类
ms.date: 11/04/2016
f1_keywords:
- CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ActiveItemRecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AddPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustClientArea
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustDockingLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AreMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ControlBarToTabbedDocument
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateDocumentWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateNewWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPaneLeftOf
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableAutoHidePanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableDocking
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMainMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableLoadDockState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabbedGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabsLastActiveActivation
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnablePaneMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetActivePopup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetDefaultResId
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMenuBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetRibbonBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetTearOffBars
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetToolbarButtonToolTipText
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::InsertPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMDITabbedGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMemberOfMDITabGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMenuBarAvailable
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPointNearDockSite
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPrintPreview
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabMoveToNextGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabNewGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::NegotiateBorderSpace
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseDockingPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnClosePopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCmdMsg
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuImage
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuLogo
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnEraseMDIClientBackground
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMenuButtonToolHitTest
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMoveMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSetPreviewMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowCustomizePane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowMDITabContextMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSizeMDIClient
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnTearOffMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnUpdateFrameMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::PaneFromPoint
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RemovePaneFromDockManager
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SaveMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetPrintPreviewFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetupToolbarMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::TabbedDocumentToControlBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateCaption
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateMDITabbedBarsIcons
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::WinHelp
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bDisableSetRedraw
helpviewer_keywords:
- CMDIFrameWndEx [MFC], ActiveItemRecalcLayout
- CMDIFrameWndEx [MFC], AddPane
- CMDIFrameWndEx [MFC], AdjustClientArea
- CMDIFrameWndEx [MFC], AdjustDockingLayout
- CMDIFrameWndEx [MFC], AreMDITabs
- CMDIFrameWndEx [MFC], CanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], ControlBarToTabbedDocument
- CMDIFrameWndEx [MFC], CreateDocumentWindow
- CMDIFrameWndEx [MFC], CreateNewWindow
- CMDIFrameWndEx [MFC], DockPane
- CMDIFrameWndEx [MFC], DockPaneLeftOf
- CMDIFrameWndEx [MFC], EnableAutoHidePanes
- CMDIFrameWndEx [MFC], EnableDocking
- CMDIFrameWndEx [MFC], EnableFullScreenMainMenu
- CMDIFrameWndEx [MFC], EnableFullScreenMode
- CMDIFrameWndEx [MFC], EnableLoadDockState
- CMDIFrameWndEx [MFC], EnableMDITabbedGroups
- CMDIFrameWndEx [MFC], EnableMDITabs
- CMDIFrameWndEx [MFC], EnableMDITabsLastActiveActivation
- CMDIFrameWndEx [MFC], EnablePaneMenu
- CMDIFrameWndEx [MFC], EnableWindowsDialog
- CMDIFrameWndEx [MFC], GetActivePopup
- CMDIFrameWndEx [MFC], GetPane
- CMDIFrameWndEx [MFC], GetDefaultResId
- CMDIFrameWndEx [MFC], GetMDITabGroups
- CMDIFrameWndEx [MFC], GetMDITabs
- CMDIFrameWndEx [MFC], GetMDITabsContextMenuAllowedItems
- CMDIFrameWndEx [MFC], GetMenuBar
- CMDIFrameWndEx [MFC], GetRibbonBar
- CMDIFrameWndEx [MFC], GetTearOffBars
- CMDIFrameWndEx [MFC], GetToolbarButtonToolTipText
- CMDIFrameWndEx [MFC], InsertPane
- CMDIFrameWndEx [MFC], IsFullScreen
- CMDIFrameWndEx [MFC], IsMDITabbedGroup
- CMDIFrameWndEx [MFC], IsMemberOfMDITabGroup
- CMDIFrameWndEx [MFC], IsMenuBarAvailable
- CMDIFrameWndEx [MFC], IsPointNearDockSite
- CMDIFrameWndEx [MFC], IsPrintPreview
- CMDIFrameWndEx [MFC], LoadFrame
- CMDIFrameWndEx [MFC], LoadMDIState
- CMDIFrameWndEx [MFC], MDITabMoveToNextGroup
- CMDIFrameWndEx [MFC], MDITabNewGroup
- CMDIFrameWndEx [MFC], NegotiateBorderSpace
- CMDIFrameWndEx [MFC], OnCloseDockingPane
- CMDIFrameWndEx [MFC], OnCloseMiniFrame
- CMDIFrameWndEx [MFC], OnClosePopupMenu
- CMDIFrameWndEx [MFC], OnCmdMsg
- CMDIFrameWndEx [MFC], OnDrawMenuImage
- CMDIFrameWndEx [MFC], OnDrawMenuLogo
- CMDIFrameWndEx [MFC], OnEraseMDIClientBackground
- CMDIFrameWndEx [MFC], OnMenuButtonToolHitTest
- CMDIFrameWndEx [MFC], OnMoveMiniFrame
- CMDIFrameWndEx [MFC], OnSetPreviewMode
- CMDIFrameWndEx [MFC], OnShowCustomizePane
- CMDIFrameWndEx [MFC], OnShowMDITabContextMenu
- CMDIFrameWndEx [MFC], OnShowPanes
- CMDIFrameWndEx [MFC], OnShowPopupMenu
- CMDIFrameWndEx [MFC], OnSizeMDIClient
- CMDIFrameWndEx [MFC], OnTearOffMenu
- CMDIFrameWndEx [MFC], OnUpdateFrameMenu
- CMDIFrameWndEx [MFC], PaneFromPoint
- CMDIFrameWndEx [MFC], RecalcLayout
- CMDIFrameWndEx [MFC], RemovePaneFromDockManager
- CMDIFrameWndEx [MFC], SaveMDIState
- CMDIFrameWndEx [MFC], SetPrintPreviewFrame
- CMDIFrameWndEx [MFC], SetupToolbarMenu
- CMDIFrameWndEx [MFC], ShowFullScreen
- CMDIFrameWndEx [MFC], ShowPane
- CMDIFrameWndEx [MFC], ShowWindowsDialog
- CMDIFrameWndEx [MFC], TabbedDocumentToControlBar
- CMDIFrameWndEx [MFC], UpdateCaption
- CMDIFrameWndEx [MFC], UpdateMDITabbedBarsIcons
- CMDIFrameWndEx [MFC], WinHelp
- CMDIFrameWndEx [MFC], m_bCanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], m_bDisableSetRedraw
ms.assetid: dbcafcb3-9a7a-4f11-9dfe-ba57565c81d0
ms.openlocfilehash: 22ea89231487f214b797938e2202c9eed01fcb6e
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/22/2020
ms.locfileid: "81754535"
---
# <a name="cmdiframewndex-class"></a>CMDIFrameWndEx 类

扩展[CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)的功能，Windows 多文档接口 （MDI） 框架窗口。

## <a name="syntax"></a>语法

```
class CMDIFrameWndEx : public CMDIFrameWnd
```

## <a name="members"></a>成员

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CMDIFramewndEx：：活动项目Recalc布局](#activeitemrecalclayout)|重新计算活动项的布局。|
|`CMDIFrameWndEx::AddDockSite`|未使用此方法。|
|[CMDIFramewndEx：：添加窗格](#addpane)|向停靠管理器注册窗格。|
|[CMDIFramewndEx：：调整客户区域](#adjustclientarea)|减小工作区以允许边框。|
|[CMDIFramewndEx：：调整扩展布局](#adjustdockinglayout)|重新计算所有停靠窗格的布局。|
|[CMDIFramewndEx：：AreMDITabs](#aremditabs)|确定是否启用了 MDI 选项卡功能或 MDI 选项卡组功能。|
|[CMDIframewndEx：：可隐藏控制巴托迪儿童](#cancovertcontrolbartomdichild)|框架调用以确定框架窗口是否可以将停靠窗格转换为选项卡式文档。|
|[CMDIFramewndEx：：控制巴托塔贝德文件](#controlbartotabbeddocument)|将指定的停靠窗格转换为选项卡式文档。|
|[CMDIFramewndEx：：创建文档窗口](#createdocumentwindow)|创建子文档窗口。|
|[CMDIFramewndEx：：创建新窗口](#createnewwindow)|由框架调用以创建新窗口。|
|`CMDIFrameWndEx::CreateObject`|由框架用于创建此类类型的动态实例。|
|[CMDIFramewndEx：:DockPane](#dockpane)|将指定的窗格停靠到框架窗口。|
|[CMDIframewndEx：:D奥克帕内左侧](#dockpaneleftof)|将一个窗格停靠到另一个窗格的左侧。|
|[CMDIFramewndEx：启用自动隐藏窗格](#enableautohidepanes)|当窗格停靠在主框架窗口的指定边时，为窗格启用自动隐藏模式。|
|[CMDIFramewndEx：：启用对接](#enabledocking)|启用属于 MDI 框架窗口的窗格的停靠。|
|[CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu)|在全屏模式下显示或隐藏主菜单。|
|[CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode)|为框架窗口启用全屏模式。|
|[CMDIFrameWndEx::EnableLoadDockState](#enableloaddockstate)|启用或禁用停靠状态的加载。|
|[CMDIFramewndEx：：启用MDITabbed组](#enablemditabbedgroups)|启用或禁用 MDI 选项卡式组功能。|
|[CMDIFramewndEx：启用MDITabs](#enablemditabs)|启用或禁用 MDI 选项卡功能。 启用后，框架窗口将显示每个 MDI 子窗口的选项卡。|
|[CMDIFramewndEx：启用MDITabs上次激活](#enablemditabslastactiveactivation)|指定在用户关闭当前选项卡时是否应激活最后一个活动选项卡。|
|[CMDIFramewndEx：：启用PaneMenu](#enablepanemenu)|启用或禁用自动创建和管理弹出式窗格菜单，该菜单显示应用程序窗格的列表。  .|
|[CMDIFramewndEx：：启用Windows对话](#enablewindowsdialog)|插入其命令 ID 调用[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)对话框的菜单项。|
|[CMDIFramewndEx：获取主动弹出](#getactivepopup)|返回一个指向当前显示的弹出菜单的指针。|
|[CMDIFramewndEx：：获取窗格](#getpane)|返回指向具有指定控件 ID 的窗格的指针。|
|[CMDIFramewndEx：获取默认 Resid](#getdefaultresid)|返回 MDI 框架窗口的共享资源的 ID。|
|[CMDIFramewndEx：getMDITab组](#getmditabgroups)|返回 MDI 选项卡式窗口的列表。|
|[CMDIFramewndEx：GetMDITabs](#getmditabs)|返回对带下划线选项卡窗口的引用。|
|[CMDIFramewndEx：获取MDITabs上下文菜单允许项目](#getmditabscontextmenualloweditems)|返回一个标志组合，确定启用 MDI 选项卡式组功能时，哪些上下文菜单项有效。|
|[CMDIFramewndEx：：获取菜单栏](#getmenubar)|返回指向附加到框架窗口的菜单栏对象的指针。|
|[CMDIFrameWndEx::GetRibbonBar](#getribbonbar)|检索框架的功能区条控件。|
|[CMDIFramewndEx：：获取关闭条形](#gettearoffbars)|返回处于拆解状态的[CPane](../../mfc/reference/cpane-class.md)派生对象的列表。|
|`CMDIFrameWndEx::GetThisClass`|由框架调用以获取指向与此类类型关联的[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)对象的指针。|
|[CMDIFrameWndEx::GetToolbarButtonToolTipText](#gettoolbarbuttontooltiptext)|当应用程序显示工具栏按钮的工具提示时，由框架调用。|
|[CMDIFramewndEx：：插入窗格](#insertpane)|向停靠管理器注册指定的窗格。|
|[CMDIFrameWndEx::IsFullScreen](#isfullscreen)|确定框架窗口是否处于全屏模式。|
|[CMDIFramewndEx：IsMDITab贝德集团](#ismditabbedgroup)|确定是否启用了 MDI 选项卡式组功能。|
|[CMDIframewndEx：是MDITab集团的成员](#ismemberofmditabgroup)|确定指定的选项卡式窗口是否位于 MDI 选项卡式组中的窗口列表中。|
|[CMDIFramewndEx：：IsMenuBar可用](#ismenubaravailable)|确定框架窗口是否具有菜单栏。|
|[CMDIFramewndEx：：IsPointNearDockSite](#ispointneardocksite)|确定指定点是否靠近停靠站点。|
|[CMDIFrameWndEx::IsPrintPreview](#isprintpreview)|确定框架窗口是否处于打印预览模式。|
|[CMDIFramewndEx：：加载帧](#loadframe)|从资源信息创建框架窗口。 （重写 `CMDIFrameWnd::LoadFrame`。）|
|[CMDIFramewndEx：：加载MDIState](#loadmdistate)|加载 MDI 选项卡组的指定布局和以前打开的文档列表。|
|[CMDIFramewndEx：：MDITabmoveToNextGroup](#mditabmovetonextgroup)|将活动选项卡从当前活动的选项卡式窗口移动到下一个或上一个选项卡式选项卡组。|
|[CMDIFramewndEx：：MDITabNewGroup](#mditabnewgroup)|创建具有单个窗口的新选项卡式组。|
|[CMDIFramewndEx：：谈判边界空间](#negotiateborderspace)|在 OLE 就地激活期间协商框架窗口中的边框空间。|
|[CMDIFramewndEx：：关闭对接窗格](#onclosedockingpane)|当用户单击可停靠窗格上的 **"关闭**"按钮时，由框架调用。|
|[CMDIFramewndEx：：在关闭迷你框架上](#oncloseminiframe)|当用户单击浮动迷你框架窗口中的 **"关闭**"按钮时，由框架调用。|
|[CMDIFramewndEx：：在关闭弹出菜单](#onclosepopupmenu)|当活动的弹出菜单处理 WM_DESTROY 消息时由框架调用。|
|[CMDIFramewndEx：：在CmdMsg上](#oncmdmsg)|由框架调用以路由和调度命令消息并更新命令用户界面对象。|
|[CMDIFramewndEx：：在画上菜单图像](#ondrawmenuimage)|当绘制与菜单项关联的图像时由框架调用。|
|[CMDIFramewndEx：：在DrawMenulogo上](#ondrawmenulogo)|当[CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)处理WM_PAINT消息时，由框架调用。|
|[CMDIFramewndEx：：在EraseMDI客户端背景上](#onerasemdiclientbackground)|当 MDI 帧窗口处理WM_ERASEBKGND消息时，由框架调用。|
|[CMDIFramewndEx：：在MenuButton工具命中测试](#onmenubuttontoolhittest)|当[CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)对象处理WM_NCHITTEST消息时，由框架调用。|
|[CMDIFramewndEx：：移动迷你框架](#onmoveminiframe)|由框架调用以移动微型框架窗口。|
|[CMDIFramewndEx：：打开预览模式](#onsetpreviewmode)|设置应用程序的主框架窗口打印预览模式。 （重写 [CFrameWnd::OnSetPreviewMode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode)。）|
|[CMDIFramewndEx：：在显示自定义窗格](#onshowcustomizepane)|激活"快速自定义"窗格时，由框架调用。|
|[CMDIFramewndEx：上秀MDITab上下文菜单](#onshowmditabcontextmenu)|当上下文菜单应显示在其中一个选项卡上时，由框架调用。 （仅适用于 MDI 选项卡式组。|
|[CMDIFramewndEx：：在显示窗格](#onshowpanes)|由框架调用以显示或隐藏窗格。|
|[CMDIFramewndEx：：在显示弹出菜单](#onshowpopupmenu)|当激活弹出菜单时由框架调用。|
|[CMDIFrameWndEx::OnSizeMDIClient](#onsizemdiclient)|当客户端 MDI 窗口的大小发生变化时，由框架调用。|
|[CMDIFramewndEx：：在TearoffMenu上](#ontearoffmenu)|当激活带有拖曳栏的菜单时由框架调用。|
|[CMDIFramewndEx：：更新框架菜单](#onupdateframemenu)|由框架调用以更新框架菜单。 （重写 `CMDIFrameWnd::OnUpdateFrameMenu`。）|
|[CMDIFramewndEx：:P从点](#panefrompoint)|返回包含指定点的停靠窗格。|
|`CMDIFrameWndEx::PreTranslateMessage`|类[CWinApp](../../mfc/reference/cwinapp-class.md)在窗口消息发送到[翻译消息](/windows/win32/api/winuser/nf-winuser-translatemessage)和[调度消息](/windows/win32/api/winuser/nf-winuser-dispatchmessage)窗口功能之前，用于转换窗口消息。  （重写 `CMDIFrameWnd::PreTranslateMessage`。）|
|[CMDIFramewndEx：recalclayout](#recalclayout)|由框架调用以重新计算框架窗口的布局。 （覆盖[CFramewnd：recalclayout](../../mfc/reference/cframewnd-class.md#recalclayout).）|
|[CMDIFramewndEx：：从Dock管理器中删除Pane](#removepanefromdockmanager)|取消注册窗格并从停靠管理器中删除它。|
|[CMDIFramewndEx：：保存MDIState](#savemdistate)|保存 MDI 选项卡组的当前布局和以前打开的文档列表。|
|[CMDIFrameWndEx::SetPrintPreviewFrame](#setprintpreviewframe)|设置打印预览框架窗口。|
|[CMDIFramewndEx：：设置工具栏菜单](#setuptoolbarmenu)|通过搜索虚拟项并将其替换为指定的用户定义项修改工具栏对象。|
|[CMDIFrameWndEx::ShowFullScreen](#showfullscreen)|将主帧从常规模式切换到全屏模式。|
|[CMDIFramewndEx：：显示窗格](#showpane)|显示或隐藏指定的窗格。|
|[CMDIFramewndEx：：显示窗口对话](#showwindowsdialog)|创建一个[CMFCWindowsManager对话框](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)并打开它。|
|[CMDIFramewndEx：：Tabbed文档到控制栏](#tabbeddocumenttocontrolbar)|将指定的选项卡式文档转换为停靠窗格。|
|[CMDIFrameWndEx::UpdateCaption](#updatecaption)|由框架调用以更新窗口框架标题。|
|[CMDIFramewndEx：：更新MDITab贝德巴图标](#updatemditabbedbarsicons)|设置每个 MDI 选项卡式窗格的图标。|
|[CMDIFramewndEx：：赢帮助](#winhelp)|由框架调用以启动 WinHelp 应用程序或上下文帮助。 （覆盖[CWnd：winHelp](../../mfc/reference/cwnd-class.md#winhelp).）|

### <a name="data-members"></a>数据成员

|名称|说明|
|----------|-----------------|
|[CMDIFramewndEx：：m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)|确定停靠窗格是否可以转换为 MDI 子窗口。|
|[CMDIFramewndEx：：m_bDisableSetRedraw](#m_bdisablesetredraw)|启用或禁用 MDI 子窗口的重绘优化。|

## <a name="remarks"></a>备注

要利用 MDI 应用程序中的扩展自定义功能，请从`CMDIFrameWndEx`而不是`CMDIFrameWnd`派生应用程序的 MDI 框架窗口类。

## <a name="example"></a>示例

下面的示例派生类来自`CMDIFrameWndEx`。 此代码段来自[DrawClient 示例：基于 MFC 功能区的 OLE 对象绘图应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_DrawClient#1](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_1.h)]

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CFrameWnd](../../mfc/reference/cframewnd-class.md)

[CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)

[CMDIFrameWndEx](../../mfc/reference/cmdiframewndex-class.md)

## <a name="requirements"></a>要求

**标题：** afxMDIFrameWndEx.h

## <a name="cmdiframewndexactiveitemrecalclayout"></a><a name="activeitemrecalclayout"></a>CMDIFramewndEx：：活动项目Recalc布局

重新计算活动项的布局。

```cpp
void ActiveItemRecalcLayout();
```

## <a name="cmdiframewndexaddpane"></a><a name="addpane"></a>CMDIFramewndEx：：添加窗格

向停靠管理器注册窗格。

```
BOOL AddPane(
    CBasePane* pControlBar,
    BOOL bTail=TRUE);
```

### <a name="parameters"></a>参数

*p控制栏*<br/>
[在]指向要注册的窗格。

*b泰尔*<br/>
[在]指定是否将此窗格添加到列表的末尾。

### <a name="return-value"></a>返回值

如果窗格已成功注册，则返回非零值。 如果窗格已注册到停靠管理器，则返回 0。

### <a name="remarks"></a>备注

每个窗格都必须注册到[CDockingManager 类](../../mfc/reference/cdockingmanager-class.md)，然后才能参与扩展布局。 使用此方法可通知停靠管理器要停靠特定窗格。 注册该窗格后，停靠管理器将根据其对齐设置和停靠管理器维护的窗格列表中的位置将其对齐。

## <a name="cmdiframewndexadjustclientarea"></a><a name="adjustclientarea"></a>CMDIFramewndEx：：调整客户区域

减小工作区以允许边框。

```
virtual void AdjustClientArea();
```

## <a name="cmdiframewndexadjustdockinglayout"></a><a name="adjustdockinglayout"></a>CMDIFramewndEx：：调整扩展布局

重新计算所有停靠窗格的布局。

```
virtual void AdjustDockingLayout(HDWP hdwp=NULL);
```

### <a name="parameters"></a>参数

*hdwp*<br/>
[在]标识多窗口位置结构。 您可以通过调用`BeginDeferWindowPos`获得此值。

### <a name="remarks"></a>备注

调用此成员函数以重新计算停靠到框架窗口的所有窗格的布局。

## <a name="cmdiframewndexaremditabs"></a><a name="aremditabs"></a>CMDIFramewndEx：：AreMDITabs

确定是否启用了 MDI 选项卡功能或 MDI 选项卡组功能。

```
BOOL AreMDITabs(int* pnMDITabsType=NULL) const;
```

### <a name="parameters"></a>参数

*pnMDITabs 类型*<br/>
[出]指向整数变量的指针，指示启用了哪些要素：

- 0： 禁用所有功能。

- 1： 启用 MDI 选项卡。

- 2： 启用 MDI 选项卡组。

### <a name="return-value"></a>返回值

如果启用了 MDI 选项卡或 MDI 选项卡组，则返回 TRUE。

如果未启用上述功能，则返回 FALSE。

### <a name="remarks"></a>备注

使用此函数可确定是否为框架窗口启用了 MDI 选项卡或 MDI 选项卡组。 使用[CMDIFrameWndEx：启用MDITabs](#enablemditabs)以启用或禁用 MDI 选项卡功能。

使用[CMDIFrameWndEx：：启用 MDI 标签组](#enablemditabbedgroups)以启用或禁用 MDI 选项卡式组功能。

## <a name="cmdiframewndexcancovertcontrolbartomdichild"></a><a name="cancovertcontrolbartomdichild"></a>CMDIframewndEx：：可隐藏控制巴托迪儿童

框架调用以确定框架窗口是否可以将停靠窗格转换为选项卡式文档

```
virtual BOOL CanCovertControlBarToMDIChild();
```

### <a name="return-value"></a>返回值

如果框架窗口可以将停靠窗格转换为选项卡式文档，则返回 TRUE;否则返回 FALSE。

### <a name="remarks"></a>备注

在派生类中重写此方法并返回 TRUE，以便将停靠窗格转换为选项卡式文档。 或者，您可以将[CMDIFrameWndEx：：：m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)设置为 TRUE。

## <a name="cmdiframewndexcontrolbartotabbeddocument"></a><a name="controlbartotabbeddocument"></a>CMDIFramewndEx：：控制巴托塔贝德文件

将指定的停靠窗格转换为选项卡式文档。

```
virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
```

### <a name="parameters"></a>参数

*pBar*<br/>
指向要转换的停靠窗格的指针。

### <a name="return-value"></a>返回值

返回指向包含停靠窗格的新 MDI 子窗口的指针。

### <a name="remarks"></a>备注

此方法将停靠窗格转换为选项卡式文档。 调用此方法时，框架将创建一个[CMDIChildWndEx 类](../../mfc/reference/cmdichildwndex-class.md)对象，从停靠管理器中删除停靠窗格，并将停靠窗格添加到新的 MDI 子窗口。 MDI 子窗口调整停靠窗格的大小以覆盖整个工作区

## <a name="cmdiframewndexcreatedocumentwindow"></a><a name="createdocumentwindow"></a>CMDIFramewndEx：：创建文档窗口

创建子文档窗口。

```
virtual CMDIChildWndEx* CreateDocumentWindow(
    LPCTSTR lpcszDocName,
    CObject* pObj);
```

### <a name="parameters"></a>参数

*lpcszDoc名称*<br/>
[在]包含文档标识符的文本字符串。 通常，它是文档文件的完整路径。

*pObj*<br/>
[在]指向用户定义对象的指针。 例如，开发人员可以创建描述文档的应用程序特定数据结构，并告诉如何在启动时初始化文档。

### <a name="return-value"></a>返回值

一个指向 `CMDIChildWndEx` 的指针。

### <a name="remarks"></a>备注

当框架加载以前保存在注册表中的文档列表时，它将调用此方法。

重写此方法，以便在从注册表加载文档时创建文档。

### <a name="example"></a>示例

下面的示例显示了如何在`CreateDocumentWindow` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

在此示例中，`g_strStartViewName`可以是实际上不是从磁盘文件加载的"虚拟文档"（例如"起始页"）的名称。 因此，我们需要特殊处理来处理这种情况。

[!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]

## <a name="cmdiframewndexcreatenewwindow"></a><a name="createnewwindow"></a>CMDIFramewndEx：：创建新窗口

由框架调用以创建新窗口。

```
virtual CMDIChildWndEx* CreateNewWindow(
    LPCTSTR lpcszDocName,
    CObject* pObj);
```

### <a name="parameters"></a>参数

*lpcszDoc名称*<br/>
[在]文档名称。

*pObj*<br/>
[在]保留以供将来使用。

### <a name="return-value"></a>返回值

指向新窗口的指针。

## <a name="cmdiframewndexdockpane"></a><a name="dockpane"></a>CMDIFramewndEx：:DockPane

将指定的窗格停靠到框架窗口。

```cpp
void DockPane(
    CBasePane* pBar,
    UINT nDockBarID=0,
    LPCRECT lpRect=NULL);
```

### <a name="parameters"></a>参数

*pBar*<br/>
[在]指向要停靠的窗格的指针。

*nDockBarID*<br/>
[在]指定要停靠的帧窗口的哪一侧。

*lpRect*<br/>
[在]未使用。

### <a name="remarks"></a>备注

此方法将指定的窗格停靠到框架窗口的一侧，该边是在[CBasePane：：启用停靠](../../mfc/reference/cbasepane-class.md#enabledocking)和[CMDIFrameWndEx：：启用停靠](#enabledocking)时指定的。

### <a name="example"></a>示例

下面的示例演示 `DockPane` 方法的用法。 此代码段来自[VisualStudioDemo 示例：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#4](../../mfc/codesnippet/cpp/cmdiframewndex-class_3.cpp)]

## <a name="cmdiframewndexdockpaneleftof"></a><a name="dockpaneleftof"></a>CMDIframewndEx：:D奥克帕内左侧

将一个窗格停靠到另一个窗格的左侧。

```
BOOL DockPaneLeftOf(
    CPane* pBar,
    CPane* pLeftOf);
```

### <a name="parameters"></a>参数

*pBar*<br/>
[在]指向停靠窗格的指针。

*左撇子*<br/>
[在]指向用作停靠站点的窗格的指针。 .

### <a name="return-value"></a>返回值

如果操作成功，则返回 TRUE。 否则返回 FALSE。

### <a name="remarks"></a>备注

调用此方法以预定义的顺序停靠多个窗格对象。 此方法将*pBar*指定的窗格停靠到*pLeftOf*指定的窗格的左侧。

### <a name="example"></a>示例

下面的示例显示了如何在`DockPaneLeftOf`[VisualStudioDemo 示例：MFC 可视化工作室应用程序中](../../overview/visual-cpp-samples.md)使用该方法。

[!code-cpp[NVC_MFC_VisualStudioDemo#5](../../mfc/codesnippet/cpp/cmdiframewndex-class_4.cpp)]

## <a name="cmdiframewndexenableautohidepanes"></a><a name="enableautohidepanes"></a>CMDIFramewndEx：启用自动隐藏窗格

当窗格停靠在主框架窗口的指定边时，为窗格启用自动隐藏模式。

```
BOOL EnableAutoHidePanes(DWORD dwDockStyle);
```

### <a name="parameters"></a>参数

*dwDock风格*<br/>
[在]指定将启用的主框架窗口的两侧。 使用以下一个或多个标志。

- CBRS_ALIGN_LEFT

- CBRS_ALIGN_RIGHT

- CBRS_ALIGN_TOP

- CBRS_ALIGN_BOTTOM

### <a name="return-value"></a>返回值

调用此函数，以便在窗格停靠在主框架窗口的指定边时启用自动隐藏模式。

### <a name="example"></a>示例

下面的示例显示了如何在`EnableAutoHidePanes`[VisualStudioDemo 示例：MFC 可视化工作室应用程序中](../../overview/visual-cpp-samples.md)使用该方法。

[!code-cpp[NVC_MFC_VisualStudioDemo#6](../../mfc/codesnippet/cpp/cmdiframewndex-class_5.cpp)]

### <a name="remarks"></a>备注

## <a name="cmdiframewndexenabledocking"></a><a name="enabledocking"></a>CMDIFramewndEx：：启用对接

启用属于 MDI 框架窗口的窗格的停靠。

```
BOOL EnableDocking(DWORD dwDockStyle);
```

### <a name="parameters"></a>参数

*dwDock风格*<br/>
[在]指定要应用的停靠样式。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

调用此函数以启用属于对象的窗格的`CMDIFrameWndEx`停靠。

### <a name="example"></a>示例

下面的示例显示了如何在`EnableDocking`[VisualStudioDemo 示例：MFC 可视化工作室应用程序中](../../overview/visual-cpp-samples.md)使用该方法。

[!code-cpp[NVC_MFC_VisualStudioDemo#7](../../mfc/codesnippet/cpp/cmdiframewndex-class_6.cpp)]

## <a name="cmdiframewndexenablefullscreenmainmenu"></a><a name="enablefullscreenmainmenu"></a>CMDIFramewndEx：启用全屏主菜单

在全屏模式下显示或隐藏主菜单。

```cpp
void EnableFullScreenMainMenu(BOOL bEnableMenu);
```

### <a name="parameters"></a>参数

*b启用菜单*<br/>
[在]TRUE 以全屏模式显示主菜单，或 FALSE 以隐藏主菜单。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexenablefullscreenmode"></a><a name="enablefullscreenmode"></a>CMDIFramewndEx：：启用全屏模式

为框架窗口启用全屏模式。

```cpp
void EnableFullScreenMode(UINT uiFullScreenCmd);
```

### <a name="parameters"></a>参数

*ui 全屏幕Cmd*<br/>
[在]启用或禁用全屏模式的命令的 ID。

### <a name="remarks"></a>备注

在全屏模式下，所有停靠控制栏、工具栏和菜单都隐藏，活动视图将调整大小以占据全屏。启用全屏模式时，必须指定启用或禁用该命令的命令的 ID。 可以从主框架`EnableFullScreenMode`的功能`OnCreate`调用。 当框架窗口切换到全屏模式时，框架将创建一个浮动工具栏，其中一个按钮具有指定的命令 ID。如果要将主菜单保留在屏幕上，请致电[CMDIFrameWndEx：：启用全屏幕主菜单](#enablefullscreenmainmenu)。

## <a name="cmdiframewndexenableloaddockstate"></a><a name="enableloaddockstate"></a>CMDIFramewndEx：：启用LoadDockState

启用或禁用停靠状态的加载。

```cpp
void EnableLoadDockState(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
[在]TRUE 要启用停靠状态的加载，FALSE 将禁用停靠状态的加载。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexenablemditabbedgroups"></a><a name="enablemditabbedgroups"></a>CMDIFramewndEx：：启用MDITabbed组

启用或禁用框架窗口的 MDI 选项卡式组功能。

```cpp
void EnableMDITabbedGroups(
    BOOL bEnable,
    const CMDITabInfo& params);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
[在]如果为 TRUE，则启用 MDI 选项卡式组功能;如果为 TRUE，则启用 MDI 选项卡式组功能。如果 FALSE，则禁用 MDI 选项卡式组功能。

*params*<br/>
[在]指定框架应用于在 MDI 工作区中创建的子窗口的参数。

### <a name="remarks"></a>备注

使用此方法可启用或禁用 MDI 选项卡式组功能。 此功能使 MDI 应用程序能够将子窗口显示为在 MDI 工作区内垂直或水平对齐的选项卡式窗口。 将用拆分器分隔选项卡式窗口组。 用户可以使用拆分器调整选项卡式组的大小。

- 用户可以：

- 在组之间拖动单个选项卡。

- 将各个选项卡拖动到窗口边缘以创建新组。

- 使用快捷菜单移动选项卡或创建新组。

- 应用程序可以保存选项卡式窗口的当前布局和当前打开的文档列表。

如果将此方法称为*bEnable 设置为*FALSE，则*将忽略参数*。

即使已启用 MDI 选项卡式组，您也可以再次调用此方法以修改子窗口的设置。 将*bEnable*设置为 TRUE 的方法调用该方法，并修改`CMDITabInfo`*参数*参数指定的对象成员。

有关如何使用 MDI 选项卡式组的详细信息，请参阅[MDI 选项卡式组](../../mfc/mdi-tabbed-groups.md)。

### <a name="example"></a>示例

下面的示例显示了如何在`EnableMDITabbedGroups` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#8](../../mfc/codesnippet/cpp/cmdiframewndex-class_7.cpp)]

## <a name="cmdiframewndexenablemditabs"></a><a name="enablemditabs"></a>CMDIFramewndEx：启用MDITabs

启用或禁用 MDI 框架窗口的 MDI 选项卡功能。 启用后，框架窗口将显示每个 MDI 子窗口的选项卡。

```cpp
void EnableMDITabs(
    BOOL bEnable=TRUE,
    BOOL bIcons=TRUE,
    CMFCTabCtrl::Location tabLocation=CMFCTabCtrl::LOCATION_BOTTOM,
    BOOL bTabCloseButton=FALSE,
    CMFCTabCtrl::Style style=CMFCTabCtrl::STYLE_3D_SCROLLED,
    BOOL bTabCustomTooltips=FALSE,
    BOOL bActiveTabCloseButton=FALSE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
指定是否启用了选项卡。

*b图标*<br/>
指定是否应在选项卡上显示图标。

*选项卡位置*<br/>
指定选项卡标签的位置。

*bTab关闭按钮*<br/>
指定是否显示选项卡关闭按钮。

style <br/>
指定选项卡的样式。 对常规选项卡或 STYLE_3D_ONENOTE对 Microsoft OneNote 选项卡使用STYLE_3D_SCROLLED。

*bTab自定义工具提示*<br/>
指定是否启用了自定义工具提示。

*b 活动标签关闭按钮*<br/>
如果为 TRUE，则"**关闭**"按钮将显示在活动选项卡上，而不是选项卡区域的右角。

### <a name="remarks"></a>备注

调用此方法以启用或禁用 MDI 框架窗口的 MDI 选项卡功能。 启用后，所有子窗口都显示为选项卡。

选项卡标签可以位于框架的顶部或底部，具体取决于参数*选项卡"位置"* 的设置。 您可以指定`CMFCTabCtrl::LOCATION_BOTTOM`（默认设置）或`CMFCTabCtrl::LOCATION_TOP`。

如果*bTabCustomTool 提示*为 TRUE，则会向主框架窗口发送AFX_WM_ON_GET_TAB_TOOLTIP消息。 您的代码可以处理此消息，并为框架提供 MDI 选项卡的自定义工具提示。

### <a name="example"></a>示例

下面的示例显示了如何在`EnableMDITabs` [MDITabsDemo 示例中使用：MFC 选项卡式 MDI 应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_MDITabsDemo#3](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_8.cpp)]

## <a name="cmdiframewndexenablemditabslastactiveactivation"></a><a name="enablemditabslastactiveactivation"></a>CMDIFramewndEx：启用MDITabs上次激活

指定在用户关闭当前选项卡时是否应打开最后一个活动选项卡。

```cpp
void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab=TRUE);
```

### <a name="parameters"></a>参数

*bLastActiveTab*<br/>
[在]如果为 TRUE，则启用激活最后一个活动选项卡。如果 FALSE，则禁用最后一个活动选项卡的激活。

### <a name="remarks"></a>备注

关闭活动选项卡时，有两种方法可以打开选项卡：

- 激活下一个选项卡。

- 激活以前处于活动状态的选项卡。

默认实现使用第一种方式。

用于`EnableMDITabsLastActiveActivation`启用第二种选项卡激活方式。 它模拟 Windows 打开 MDI 子窗口的方式。

## <a name="cmdiframewndexenablepanemenu"></a><a name="enablepanemenu"></a>CMDIFramewndEx：：启用PaneMenu

启用或禁用自动创建和管理弹出式窗格菜单，该菜单显示应用程序窗格的列表。

```cpp
void EnablePaneMenu(
    BOOL bEnable,
    UINT uiCustomizeCmd,
    const CString& strCustomizeLabel,
    UINT uiViewToolbarsMenuEntryID,
    BOOL bContextMenuShowsToolbarsOnly=FALSE,
    BOOL bViewMenuShowsToolbarsOnly=FALSE);
```

### <a name="parameters"></a>参数

*b 启用*<br/>
[在]如果为 TRUE，则启用窗格菜单的自动处理;如果为 TRUE，则启用窗格菜单的自动处理。如果 FALSE，则禁用自动处理。

*ui 定制Cmd*<br/>
[在]**"自定义"** 菜单项的命令 ID。 此菜单项通常添加到窗格列表的末尾。

*str定制标签*<br/>
[在]要为 **"自定义"** 菜单项（用于本地化）显示的文本。

*uiView工具栏菜单入口ID*<br/>
[在]指定打开窗格菜单的工具栏菜单项的 ID。 通常这是 **"视图"** 菜单的**工具栏**子菜单。

*bContextMenu 仅显示工具栏*<br/>
[在]如果为 TRUE，窗格菜单仅显示工具栏列表。 如果 FALSE，菜单将显示工具栏和停靠条的列表。

*b 只查看菜单显示工具栏*<br/>
[在]如果为 TRUE，窗格菜单仅显示工具栏列表。 如果 FALSE，菜单将显示工具栏和停靠条的列表。

### <a name="remarks"></a>备注

弹出窗格菜单显示应用程序窗格的列表，并允许用户显示或隐藏单个窗格。

### <a name="example"></a>示例

下面的示例显示了如何在`EnablePaneMenu` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#9](../../mfc/codesnippet/cpp/cmdiframewndex-class_9.cpp)]

## <a name="cmdiframewndexenablewindowsdialog"></a><a name="enablewindowsdialog"></a>CMDIFramewndEx：：启用Windows对话

插入其命令 ID 调用[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)对话框的菜单项。

```cpp
void EnableWindowsDialog(
    UINT uiMenuId,
    LPCTSTR lpszMenuText,
    BOOL bShowAllways=FALSE,
    BOOL bShowHelpButton=FALSE);

void EnableWindowsDialog(
    UINT uiMenuId,
    UINT uiMenuTextResId,
    BOOL bShowAllways=FALSE,
    BOOL bShowHelpButton=FALSE);
```

### <a name="parameters"></a>参数

*乌伊梅奈*<br/>
[在]指定菜单的资源 ID。

*lpszMenuText*<br/>
[在]指定项目的文本。

*b 显示帮助按钮*<br/>
[在]指定是否在窗口管理对话框上显示 **"帮助**"按钮。

*uiMenuTextResId*<br/>
[在]包含项文本字符串的字符串资源标识符。

### <a name="remarks"></a>备注

使用此方法插入其命令调用 MDI 子窗口管理对话框[（CMFCWindowsManagerDialog 类](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)） 的菜单项。 新项目将插入到*uiMenuId*指定的菜单中。 处理`EnableWindowsDialog`WM_CREATE消息时调用。

### <a name="example"></a>示例

下面的示例显示了如何在`EnableWindowsDialog` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#10](../../mfc/codesnippet/cpp/cmdiframewndex-class_10.cpp)]

## <a name="cmdiframewndexgetactivepopup"></a><a name="getactivepopup"></a>CMDIFramewndEx：获取主动弹出

返回一个指向当前显示的弹出菜单的指针。

```
CMFCPopupMenu* GetActivePopup() const;
```

### <a name="return-value"></a>返回值

指向活动弹出菜单的指针;如果没有弹出窗口菜单处于活动状态，则为 NULL。

### <a name="remarks"></a>备注

使用此函数可以获取指向当前显示的[CMFCPopupMenu 类](../../mfc/reference/cmfcpopupmenu-class.md)对象的指针。

## <a name="cmdiframewndexgetdefaultresid"></a><a name="getdefaultresid"></a>CMDIFramewndEx：获取默认 Resid

返回 MDI 框架窗口的共享资源的 ID。

```
UINT GetDefaultResId() const;
```

### <a name="return-value"></a>返回值

资源 ID 值。 如果框架窗口没有菜单栏，则为 0。

### <a name="remarks"></a>备注

此方法返回 CFramewnd 加载 MDI 帧窗口时指定的资源[ID：：LoadFrame](../../mfc/reference/cframewnd-class.md#loadframe)。

## <a name="cmdiframewndexgetmditabgroups"></a><a name="getmditabgroups"></a>CMDIFramewndEx：getMDITab组

返回 MDI 选项卡式窗口的列表。

```
const CObList& GetMDITabGroups() const;
```

### <a name="return-value"></a>返回值

对包含选项卡式窗口列表的[CObList 类](../../mfc/reference/coblist-class.md)对象的引用。 不要存储或修改列表。

### <a name="remarks"></a>备注

使用此方法可以访问选项卡式窗口的列表。 如果要更改或查询各个选项卡式窗口的某些参数，则可能会有所帮助。

## <a name="cmdiframewndexgetmditabs"></a><a name="getmditabs"></a>CMDIFramewndEx：GetMDITabs

返回对带下划线选项卡窗口的引用。

```
CMFCTabCtrl& GetMDITabs();
```

### <a name="return-value"></a>返回值

对带下划线选项卡窗口的引用。

## <a name="cmdiframewndexgetmditabscontextmenualloweditems"></a><a name="getmditabscontextmenualloweditems"></a>CMDIFramewndEx：获取MDITabs上下文菜单允许项目

返回一个标志组合，确定启用 MDI 选项卡式组功能时哪些操作有效。

```
DWORD GetMDITabsContextMenuAllowedItems();
```

### <a name="return-value"></a>返回值

以下标志的位-OR 组合：

- BCGP_MDI_CREATE_VERT_GROUP - 可以创建垂直选项卡组。

- BCGP_MDI_CREATE_HORZ_GROUP - 可以创建水平选项卡组。

- BCGP_MDI_CAN_MOVE_PREV - 可以将选项卡移动到上一个选项卡组。

- BCGP_MDI_CAN_MOVE_NEXT - 可以将选项卡移动到下一个选项卡组。

### <a name="remarks"></a>备注

启用 MDI 选项卡组功能后，必须知道特定窗口的选项卡上允许执行哪些操作。 此方法分析选项卡式窗口的当前布局，并返回可用于生成快捷菜单的标志组合。

当所有选项卡式窗口垂直对齐或只有一个选项卡式窗口时，可以创建新的垂直选项卡组。

当所有选项卡式窗口水平对齐时，或者只有一个选项卡式窗口时，可以创建新的水平选项卡组。

仅当选项卡式窗口中有多个选项卡时，才能将选项卡移动到前一个组。

仅当选项卡式窗口中有多个选项卡时，才能将选项卡移动到下一个组。

## <a name="cmdiframewndexgetmenubar"></a><a name="getmenubar"></a>CMDIFramewndEx：：获取菜单栏

返回指向附加到框架窗口的菜单栏对象的指针。

```
const CMFCMenuBar* GetMenuBar() const;
```

### <a name="return-value"></a>返回值

指向菜单栏对象的指针。

## <a name="cmdiframewndexgetpane"></a><a name="getpane"></a>CMDIFramewndEx：：获取窗格

返回指向具有指定控件 ID 的窗格的指针。

```
CBasePane* GetPane(UINT nID);
```

### <a name="parameters"></a>参数

*nID*<br/>
[在]控件 ID。

### <a name="return-value"></a>返回值

指向具有指定控件 ID 的窗格的指针（如果存在）。 否则，NULL。

## <a name="cmdiframewndexgetribbonbar"></a><a name="getribbonbar"></a>CMDIFramewndEx：获取带状栏

检索框架的功能区条控件。

```
CMFCRibbonBar* GetRibbonBar();
```

### <a name="return-value"></a>返回值

指向框架的[CMFCRibbonBar 类](../../mfc/reference/cmfcribbonbar-class.md)。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexgettearoffbars"></a><a name="gettearoffbars"></a>CMDIFramewndEx：：获取关闭条形

返回撕下菜单的列表。

```
const CObList& GetTearOffBars() const;
```

### <a name="return-value"></a>返回值

对[CObList 类](../../mfc/reference/coblist-class.md)对象的引用，该对象包含指向`CPane`处于分泪状态的派生对象的指针集合。

### <a name="remarks"></a>备注

`CMDIFrameWndEx`维护撕掉菜单的集合。 使用此方法检索对此列表的引用。

## <a name="cmdiframewndexgettoolbarbuttontooltiptext"></a><a name="gettoolbarbuttontooltiptext"></a>CMDIFramewndEx：：获取工具栏按钮工具提示文本

当应用程序显示工具栏按钮的工具提示时，由框架调用。

```
virtual BOOL GetToolbarButtonToolTipText(
    CMFCToolBarButton* pButton,
    CString& strTTText);
```

### <a name="parameters"></a>参数

*pButton*<br/>
[在]指向工具栏按钮的指针。

*斯特特文本*<br/>
[在]要显示按钮的工具提示文本。

### <a name="return-value"></a>返回值

如果已显示工具提示，则为 TRUE。 否则。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexinsertpane"></a><a name="insertpane"></a>CMDIFramewndEx：：插入窗格

向停靠管理器注册指定的窗格。

```
BOOL InsertPane(
    CBasePane* pControlBar,
    CBasePane* pTarget,
    BOOL bAfter=TRUE);
```

### <a name="parameters"></a>参数

*p控制栏*<br/>
[在]指向要插入的窗格的指针。

*p目标*<br/>
[在]指向窗格之前或之后插入窗格的指针。

*b 后*<br/>
[在]如果为 TRUE，则*pControlBar*在*pTarget*后插入。 如果 FALSE，则在*pTarget*之前插入*pControlBar。*

### <a name="return-value"></a>返回值

如果该方法成功注册窗格，则为 TRUE，如果窗格已注册到停靠管理器，则 FALSE。

### <a name="remarks"></a>备注

使用此方法可以告诉停靠管理器*pControlBar*指定的窗格。 停靠管理器将根据窗格的对齐方式和停靠管理器内部列表中的位置对齐此窗格。

## <a name="cmdiframewndexisfullscreen"></a><a name="isfullscreen"></a>CMDIFramewndEx：是全屏

确定框架窗口是否处于全屏模式。

```
BOOL IsFullScreen() const;
```

### <a name="return-value"></a>返回值

如果帧窗口处于全屏模式，则为 TRUE;如果帧窗口处于全屏模式，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

您可以通过调用[CMDIFrameWndEx：：启用全屏模式](#enablefullscreenmode)方法来设置全屏模式。

## <a name="cmdiframewndexismditabbedgroup"></a><a name="ismditabbedgroup"></a>CMDIFramewndEx：IsMDITab贝德集团

指定是否启用 MDI 选项卡式组功能。

```
BOOL IsMDITabbedGroup() const;
```

### <a name="return-value"></a>返回值

如果启用了 MDI 选项卡式组功能，则为 TRUE;如果启用了 MDI 选项卡式组功能，则为 TRUE。否则 FALSE。

### <a name="remarks"></a>备注

要确定是否启用了常规 MDI 选项卡或 MDI 选项卡组功能，请使用[CMDIFrameWndEx：：areMDITabs](#aremditabs)。

## <a name="cmdiframewndexismemberofmditabgroup"></a><a name="ismemberofmditabgroup"></a>CMDIframewndEx：是MDITab集团的成员

确定指定的选项卡式窗口是否位于 MDI 选项卡式组中的窗口列表中。

```
BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
[在]指向选项卡式窗口的指针。

### <a name="return-value"></a>返回值

如果指定的选项卡式窗口位于构成 MDI 选项卡式组的选项卡式窗口列表中，则为 TRUE。 否则，FALSE。

## <a name="cmdiframewndexismenubaravailable"></a><a name="ismenubaravailable"></a>CMDIFramewndEx：：IsMenuBar可用

确定框架窗口是否具有菜单栏。

```
BOOL IsMenuBarAvailable() const;
```

### <a name="return-value"></a>返回值

如果指向菜单栏对象的指针不是 NULL，则为 TRUE;如果指向菜单栏对象的指针为 NULL，则为 TRUE。否则 FALSE。

## <a name="cmdiframewndexispointneardocksite"></a><a name="ispointneardocksite"></a>CMDIFramewndEx：：IsPointNearDockSite

确定指定点是否靠近停靠站点。

```
BOOL IsPointNearDockSite(
    CPoint point,
    DWORD& dwBarAlignment,
    BOOL& bOuterEdge) const;
```

### <a name="parameters"></a>参数

*点*<br/>
[在]屏幕坐标中的指定点。

*dwBaralignment*<br/>
[在]指定点附近的边。 可能的值是CBRS_ALIGN_LEFT、CBRS_ALIGN_RIGHT、CBRS_ALIGN_TOP 和CBRS_ALIGN_BOTTOM

*bouterEdge*<br/>
[在]如果点靠近停靠站点的外部边界，则为 TRUE;否则。

### <a name="return-value"></a>返回值

如果点靠近停靠站点，则为 TRUE;否则 FALSE。

### <a name="remarks"></a>备注

当点位于停靠管理器中设置的灵敏度内时，该点位于停靠站点附近。 默认灵敏度为 15 像素。

## <a name="cmdiframewndexisprintpreview"></a><a name="isprintpreview"></a>CMDIFramewndEx：：是打印预览

确定框架窗口是否处于打印预览模式。

```
BOOL IsPrintPreview();
```

### <a name="return-value"></a>返回值

如果帧窗口处于打印预览模式，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexloadframe"></a><a name="loadframe"></a>CMDIFramewndEx：：加载帧

从资源信息创建框架窗口。

```
virtual BOOL LoadFrame(
    UINT nIDResource,
    DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
    CWnd* pParentWnd = NULL,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*nID资源*<br/>
[在]与框架窗口关联的共享资源的 ID。

*dwDefault样式*<br/>
[在]框架窗口的样式。

*pparentwnd*<br/>
[在]指向帧父级的指针。

*pContext*<br/>
[在]指向[CCreateContext 结构](../../mfc/reference/ccreatecontext-structure.md)的指针。 此参数可以是 NULL。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE，否则为 FALSE。

## <a name="cmdiframewndexloadmdistate"></a><a name="loadmdistate"></a>CMDIFramewndEx：：加载MDIState

加载 MDI 选项卡组的指定布局和以前打开的文档列表。

```
virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
```

### <a name="parameters"></a>参数

*lpsz配置文件名称*<br/>
[在]指定配置文件名称。

### <a name="return-value"></a>返回值

如果负载成功，则为 TRUE;如果负载失败或没有要加载的数据，则 FALSE。

### <a name="remarks"></a>备注

要加载或保存 MDI 选项卡和组的状态以及打开的文档列表，执行以下操作：

- 调用[CMDIFrameWndEx：：](#savemdistate)在主框架关闭时保存MDIState

- 调用[CMDIFrameWndEx：：创建主帧时加载MDIState。](#loadmdistate) 此调用的建议位置是首次在主帧显示之前。 在`CWinAppEx::EnableLoadWindowPlacement``(FALSE);`调用`pMainFrame->LoadFrame (IDR_MAINFRAME);.`后`CBCGPWorkspace::ReloadWindowPlacement``(pMainFrame);`添加以`LoadMDIState`在注册表中存储的位置显示主帧。

- 如果`GetDocumentName`应用程序显示`CMDIChildWndEx`的文档未存储为文件，则在 派生类中覆盖。 返回的字符串将作为文档标识符保存在注册表中。 [CMDIChildWndEx 的基本实现：获取文档名称](../../mfc/reference/cmdichildwndex-class.md#getdocumentname)返回从[CDocument 获取的值：：获取PathName](../../mfc/reference/cdocument-class.md#getpathname)。

- 覆盖[CMDIFrameWndEx：创建文档窗口](#createdocumentwindow)，以在从注册表加载文档时正确创建文档。 第一个参数是返回的`GetDocumentName`字符串。

### <a name="example"></a>示例

下面的示例显示了如何在`LoadMDIState` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#11](../../mfc/codesnippet/cpp/cmdiframewndex-class_11.cpp)]

## <a name="cmdiframewndexmditabmovetonextgroup"></a><a name="mditabmovetonextgroup"></a>CMDIFramewndEx：：MDITabmoveToNextGroup

将活动选项卡从当前活动的选项卡式窗口移动到下一个或上一个选项卡式选项卡组。

```cpp
void MDITabMoveToNextGroup(BOOL bNext=TRUE);
```

### <a name="parameters"></a>参数

*b下一个*<br/>
[在]如果为 TRUE，则将选项卡移动到下一个选项卡式组。 如果 FALSE，则将其移动到以前的选项卡式组。

## <a name="cmdiframewndexmditabnewgroup"></a><a name="mditabnewgroup"></a>CMDIFramewndEx：：MDITabNewGroup

创建具有单个窗口的新选项卡式组。

```cpp
void MDITabNewGroup(BOOL bVert=TRUE);
```

### <a name="parameters"></a>参数

*bVert*<br/>
[在]指定新的组对齐方式。 如果为 TRUE，则新组垂直对齐。 如果 FALSE，则新组水平对齐。

### <a name="remarks"></a>备注

使用此函数可以创建新的选项卡式窗口（新的选项卡式组），并将第一个选项卡添加到该窗口。

### <a name="example"></a>示例

下面的示例显示了如何在`MDITabNewGroup` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#12](../../mfc/codesnippet/cpp/cmdiframewndex-class_12.cpp)]

## <a name="cmdiframewndexm_bcancovertcontrolbartomdichild"></a><a name="m_bcancovertcontrolbartomdichild"></a>CMDIFramewndEx：：m_bCanCovertControlBarToMDIChild

指定停靠窗格是否可以转换为 MDI 子窗口。

```
BOOL m_bCanCovertControlBarToMDIChild;
```

### <a name="remarks"></a>备注

指示停靠控制条是否可以转换为 MDI 子窗口。 如果此标志为 TRUE，则当用户选择 **"选项卡式文档"** 命令时，框架将自动处理转换。 标志受到保护，您必须通过在`m_bCanCovertControlBarToMDIChild``CMDIFrameWndEx`派生类的构造函数中设置或重写`CanConvertControlBarToMDIChild`来显式启用此选项。

默认值为 `FALSE`。

### <a name="example"></a>示例

下面的示例显示了如何在`m_bCanCovertControlBarToMDIChild` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]

## <a name="cmdiframewndexm_bdisablesetredraw"></a><a name="m_bdisablesetredraw"></a>CMDIFramewndEx：：m_bDisableSetRedraw

启用或禁用 MDI 子窗口的重绘优化。

```
AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;
```

### <a name="remarks"></a>备注

默认值为 TRUE。

如果要优化 MDI 子级的重新绘制，将此标志设置为 FALSE。 在这种情况下，当应用程序更改活动选项卡`SetRedraw (FALSE)`时，框架将调用主框架。

此标志可能会导致不需要的效果（例如，变得可见的后台应用程序）。 因此，我们建议您仅在 MDI 选项卡激活期间遇到明显的闪烁时才更改默认值。

## <a name="cmdiframewndexnegotiateborderspace"></a><a name="negotiateborderspace"></a>CMDIFramewndEx：：谈判边界空间

在 OLE 就地激活期间协商框架窗口中的边框空间。

```
virtual BOOL NegotiateBorderSpace(
    UINT nBorderCmd,
    LPRECT lpRectBorder);
```

### <a name="parameters"></a>参数

*nBorderCmd*<br/>
[在]包含枚举`CFrameWnd::BorderCmd`中的以下值之一：

- `borderGet` = 1

- `borderRequest` = 2

- `borderSet` = 3

*lprect边框*<br/>
[进出]指向[RECT 结构](/windows/win32/api/windef/ns-windef-rect)或指定边框坐标的[CRect 类](../../atl-mfc-shared/reference/crect-class.md)对象的指针。

### <a name="return-value"></a>返回值

如果方法成功，则非零;否则 0。

### <a name="remarks"></a>备注

该方法是OLE边界空间谈判的实现。

## <a name="cmdiframewndexonclosedockingpane"></a><a name="onclosedockingpane"></a>CMDIFramewndEx：：关闭对接窗格

当用户单击可停靠窗格上的 **"关闭**"按钮时，由框架调用。

```
virtual BOOL OnCloseDockingPane(CDockablePane* pWnd);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
[在]指向正在关闭的窗格的指针。

### <a name="return-value"></a>返回值

如果可以关闭停靠窗格，则为 TRUE。 否则为 FALSE。

### <a name="remarks"></a>备注

重写此方法以处理停靠窗格的隐藏。 如果要防止隐藏停靠窗格，则返回 FALSE。

默认实现不执行任何操作，并返回 TRUE。

## <a name="cmdiframewndexoncloseminiframe"></a><a name="oncloseminiframe"></a>CMDIFramewndEx：：在关闭迷你框架上

当用户单击浮动小型框架窗口中的 **"关闭**"按钮时，由框架调用。

```
virtual BOOL OnCloseMiniFrame(CPaneFrameWnd*);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
[在]指向正在关闭的微型框架窗口的指针。

### <a name="return-value"></a>返回值

如果可以关闭浮动小型框架窗口，则为 TRUE。 否则为 FALSE。

### <a name="remarks"></a>备注

重写此方法以处理浮动小型框架窗口的隐藏。 如果要防止隐藏浮动的微型框架窗口，则返回 FALSE。

默认实现不执行任何操作，并返回 TRUE。

## <a name="cmdiframewndexonclosepopupmenu"></a><a name="onclosepopupmenu"></a>CMDIFramewndEx：：在关闭弹出菜单

当活动的弹出菜单处理 WM_DESTROY 消息时由框架调用。

```
virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
```

### <a name="parameters"></a>参数

*pMenuPopup*<br/>
[在]指向弹出式菜单的指针。

### <a name="remarks"></a>备注

如果要处理来自[CMFCPopupMenu 类](../../mfc/reference/cmfcpopupmenu-class.md)对象的通知，这些对象处理WM_DESTROY消息时，将重写此方法。

## <a name="cmdiframewndexoncmdmsg"></a><a name="oncmdmsg"></a>CMDIFramewndEx：：在CmdMsg上

由框架调用以路由和调度命令消息并更新命令用户界面对象。

```
virtual BOOL OnCmdMsg(
    UINT nID,
    int nCode,
    void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo);
```

### <a name="parameters"></a>参数

*nID*<br/>
[在]命令 ID。

*n代码*<br/>
[在]标识命令通知代码。 有关*nCode*的值的详细信息，请参阅[CMDTarget：onCmdMsg。](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)

*pExtra*<br/>
[在]根据*nCode*的值使用。 有关*pExtra*的更多信息，请参阅[CMDTarget：onCmdMsg。](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)

*pHandlerInfo*<br/>
[进出]通常，此参数应为 NULL。如果不是 NULL，`OnCmdMsg`请填写*pHandlerInfo*结构 的`pTarget`和`pmf`成员，而不是调度命令。

### <a name="return-value"></a>返回值

处理消息时非零;否则 0。

## <a name="cmdiframewndexondrawmenuimage"></a><a name="ondrawmenuimage"></a>CMDIFramewndEx：：在画上菜单图像

当绘制与菜单项关联的图像时由框架调用。

```
virtual BOOL OnDrawMenuImage(
    CDC* pDC,
    const CMFCToolBarMenuButton* pMenuButton,
    const CRect& rectImage);
```

### <a name="parameters"></a>参数

*pDC*<br/>
[在]指向设备上下文的指针。

*pMenu按钮*<br/>
[在]指向菜单按钮。

*rectImage*<br/>
[在]图像的边界矩形。

### <a name="return-value"></a>返回值

如果方法绘制图像，则为 TRUE。 默认实现返回 FALSE。

### <a name="remarks"></a>备注

如果要为属于`CMDIFrameWndEx`派生对象拥有的菜单栏的菜单项自定义图像渲染，请重写此方法。 默认实现不执行任何操作。

## <a name="cmdiframewndexondrawmenulogo"></a><a name="ondrawmenulogo"></a>CMDIFramewndEx：：在DrawMenulogo上

当[CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)处理WM_PAINT消息时，由框架调用。

```
virtual void OnDrawMenuLogo(
    CDC*,
    CMFCPopupMenu*,
    const CRect&);
```

### <a name="remarks"></a>备注

重写此函数，在属于`CMDIFrameWndEx`派生对象的菜单栏的弹出式菜单上显示徽标。 默认实现不执行任何操作。

## <a name="cmdiframewndexonerasemdiclientbackground"></a><a name="onerasemdiclientbackground"></a>CMDIFramewndEx：：在EraseMDI客户端背景上

当 MDI 帧窗口处理WM_ERASEBKGND消息时，由框架调用。

```
virtual BOOL OnEraseMDIClientBackground(CDC*);
```

### <a name="return-value"></a>返回值

如果应用程序处理消息并擦除背景，则为 TRUE。

### <a name="remarks"></a>备注

如果要在`CMDIFrameWndEx`派生类中处理WM_ERASEBKGND消息，则重写此成员函数。

## <a name="cmdiframewndexonmenubuttontoolhittest"></a><a name="onmenubuttontoolhittest"></a>CMDIFramewndEx：：在MenuButton工具命中测试

当[CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)对象处理WM_NCHITTEST消息时，由框架调用。

```
virtual BOOL OnMenuButtonToolHitTest(
    CMFCToolBarButton* pButton,
    TOOLINFO* pTI);
```

### <a name="parameters"></a>参数

*pButton*<br/>
[在]工具栏按钮。

*Pti*<br/>
[出]指向[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)结构的指针。

### <a name="return-value"></a>返回值

如果应用程序填充*pTI*参数，则为 TRUE。 默认实现返回 FALSE。

### <a name="remarks"></a>备注

如果要向工具提示提供有关特定菜单项的信息，请重写此方法。 默认实现不执行任何操作。

## <a name="cmdiframewndexonmoveminiframe"></a><a name="onmoveminiframe"></a>CMDIFramewndEx：：移动迷你框架

由框架调用以移动微型框架窗口。

```
virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
```

### <a name="parameters"></a>参数

*pFrame*<br/>
[在]指向微型框架窗口的指针。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE，否则为 FALSE。

## <a name="cmdiframewndexonsetpreviewmode"></a><a name="onsetpreviewmode"></a>CMDIFramewndEx：：打开预览模式

设置应用程序的主框架窗口打印预览模式。

```
virtual void OnSetPreviewMode(
    BOOL bPreview,
    CPrintPreviewState* pState);
```

### <a name="parameters"></a>参数

*b预览*<br/>
[在]如果为 TRUE，则设置打印预览模式。 如果 FALSE，则取消预览模式。

*pState*<br/>
[在]指向结构的`CPrintPreviewState`指针。

### <a name="remarks"></a>备注

此方法重写[CFramewnd：：OnSet预览模式](../../mfc/reference/cframewnd-class.md#onsetpreviewmode)。

## <a name="cmdiframewndexonshowcustomizepane"></a><a name="onshowcustomizepane"></a>CMDIFramewndEx：：在显示自定义窗格

激活"快速自定义"窗格时，由框架调用。

```
virtual BOOL OnShowCustomizePane(
    CMFCPopupMenu* pMenuPane,
    UINT uiToolbarID);
```

### <a name="parameters"></a>参数

*pMenuPane*<br/>
[在]指向"快速自定义"窗格的指针。

*uiToolbarID*<br/>
[在]要自定义工具栏的控制 ID。

### <a name="return-value"></a>返回值

此方法始终返回 TRUE。

### <a name="remarks"></a>备注

"快速自定义"窗格是当用户单击工具栏上的 **"自定义"** 时打开的菜单。

在派生类中重写此方法，在"快速自定义"窗格中进行更改。

## <a name="cmdiframewndexonshowmditabcontextmenu"></a><a name="onshowmditabcontextmenu"></a>CMDIFramewndEx：上秀MDITab上下文菜单

在其中一个选项卡上显示快捷菜单之前，由框架调用。 仅适用于 MDI 选项卡式组。

```
virtual BOOL OnShowMDITabContextMenu(
    CPoint point,
    DWORD dwAllowedItems,
    BOOL bTabDrop);
```

### <a name="parameters"></a>参数

*点*<br/>
[在]菜单在屏幕坐标中的位置。

*可被项目*<br/>
[在]指示当前选项卡允许执行的操作的标志的位-OR 组合：

- BCGP_MDI_CREATE_VERT_GROUP - 可以创建垂直选项卡组。

- BCGP_MDI_CREATE_HORZ_GROUP - 可以创建水平选项卡组。

- BCGP_MDI_CAN_MOVE_PREV - 可以将选项卡移动到上一个选项卡组。

- BCGP_MDI_CAN_MOVE_NEXT - 可以将选项卡移动到下一个选项卡组。

- BCGP_MDI_CAN_BE_DOCKED - 将选项卡式文档切换到停靠状态（仅与选项卡式文档相关）。

*bTabDrop*<br/>
[在]TRUE 显示菜单，因为将选项卡拖动到另一个选项卡组。 FALSE 将菜单显示为当前活动选项卡上的快捷菜单。

### <a name="return-value"></a>返回值

在[CBCGGPMDIFramewnd](../../mfc/reference/cmdiframewndex-class.md)派生类中重写此方法。

### <a name="remarks"></a>备注

如果不处理`OnShowMDITabContextMenu`，将不会显示快捷菜单。 启用 MDI 选项卡组功能时 **，MFC 应用程序向导**会生成此功能。

### <a name="example"></a>示例

下面的示例显示了如何在`OnShowMDITabContextMenu` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#14](../../mfc/codesnippet/cpp/cmdiframewndex-class_13.cpp)]

## <a name="cmdiframewndexonshowpanes"></a><a name="onshowpanes"></a>CMDIFramewndEx：：在显示窗格

由框架调用以显示或隐藏窗格。

```
virtual BOOL OnShowPanes(BOOL bShow);
```

### <a name="parameters"></a>参数

*b显示*<br/>
[在]TRUE 显示窗格，FALSE 以隐藏窗格。

### <a name="return-value"></a>返回值

如果窗格的状态因调用此方法而发生更改，则 FALSE 如果窗格已处于*bShow*指定的状态。 例如，如果窗格是隐藏的，并且*bShow*是 FALSE，则返回值为 FALSE。

### <a name="remarks"></a>备注

默认实现从顶层框架窗口中删除工具栏。

如果[CDockingManager：m_bHideDockingBarsInContainerMode](../../mfc/reference/cdockingmanager-class.md#m_bhidedockingbarsincontainermode)为 TRUE（默认值），则所有停靠窗格都将隐藏。

## <a name="cmdiframewndexonshowpopupmenu"></a><a name="onshowpopupmenu"></a>CMDIFramewndEx：：在显示弹出菜单

框架在打开弹出式菜单时调用它。

```
virtual BOOL OnShowPopupMenu(CMFCPopupMenu*);
```

### <a name="return-value"></a>返回值

如果要显示弹出式菜单，则为 TRUE。 否则为 FALSE。 默认实现返回 TRUE。

### <a name="remarks"></a>备注

如果要在弹出菜单激活时实现特殊处理，请重写此方法。 例如，如果要将常规菜单项更改为颜色菜单按钮，则设置撕线，等等。

默认实现不执行任何操作。

## <a name="cmdiframewndexonsizemdiclient"></a><a name="onsizemdiclient"></a>CMDIFramewndEx：onsizeMDIClient

当客户端 MDI 窗口的大小发生变化时，由框架调用。

```
virtual void OnSizeMDIClient(
    const CRect& rectOld,
    const CRect& rectNew);
```

### <a name="parameters"></a>参数

*rectOld*<br/>
[在]MDI 客户端窗口的当前大小。

*重新*<br/>
[在]MDI 客户端窗口的新大小。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexontearoffmenu"></a><a name="ontearoffmenu"></a>CMDIFramewndEx：：在TearoffMenu上

当激活带有拖曳栏的菜单时由框架调用。

```
virtual BOOL OnTearOffMenu(
    CMFCPopupMenu* pMenuPopup,
    CPane* pBar);
```

### <a name="parameters"></a>参数

*pMenuPopup*<br/>
[在]指向弹出菜单的指针。

*pBar*<br/>
[在]指向撕裂条的指针。

### <a name="return-value"></a>返回值

TRUE 允许激活带有撕开栏的弹出式菜单;否则 FALSE。 默认值为 TRUE。

### <a name="remarks"></a>备注

如果要实现撕开条的特殊设置，则重写此功能。 默认实现不执行任何操作。

## <a name="cmdiframewndexonupdateframemenu"></a><a name="onupdateframemenu"></a>CMDIFramewndEx：：更新框架菜单

由框架调用以更新框架菜单。

```
virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
```

### <a name="parameters"></a>参数

*哈梅内阿尔特*<br/>
[在]菜单的句柄。

## <a name="cmdiframewndexpanefrompoint"></a><a name="panefrompoint"></a>CMDIFramewndEx：:P从点

返回包含指定点的停靠窗格。

```
CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    bool bExactBar,
    CRuntimeClass* pRTCBarType) const;

CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    DWORD& dwAlignment,
    CRuntimeClass* pRTCBarType) const;
```

### <a name="parameters"></a>参数

*点*<br/>
[在]点（在屏幕坐标中）。

*nSensitivity*<br/>
[在]此值在所有方向上放大每个选中窗格的窗口矩形。

*bExactBar*<br/>
[在]如果为 TRUE，则忽略*nSensitivity*参数。

*pRTCBar类型*<br/>
[在]如果非 NULL，则该方法仅在指定类型的窗格上遍网。

*dwalignment*<br/>
[出]如果找到窗格，此参数将指定窗格的哪一侧最接近指定点。

### <a name="return-value"></a>返回值

指向停靠窗格的指针，如果没有控件包含*点*指定的点，则为 NULL。

### <a name="remarks"></a>备注

呼叫被重定向到[CDockingManager 类](../../mfc/reference/cdockingmanager-class.md)。 有关详细信息[，请参阅 CDockingManager：控制栏从点](../../mfc/reference/cdockingmanager-class.md#panefrompoint)。

## <a name="cmdiframewndexrecalclayout"></a><a name="recalclayout"></a>CMDIFramewndEx：recalclayout

由框架调用以重新计算框架窗口的布局。

```
virtual void RecalcLayout(BOOL bNotify = TRUE);
```

### <a name="parameters"></a>参数

*b 通知*<br/>
[在]确定框架窗口的活动就地项目是否接收布局更改通知。 如果为 TRUE，则会通知该项目;如果为 TRUE，则通知该项目。否则 FALSE。

### <a name="remarks"></a>备注

此方法重写[CFramewnd：：recalcLayout](../../mfc/reference/cframewnd-class.md#recalclayout)。

## <a name="cmdiframewndexremovepanefromdockmanager"></a><a name="removepanefromdockmanager"></a>CMDIFramewndEx：：从Dock管理器中删除Pane

取消注册窗格并从停靠管理器中删除它。

```cpp
void RemovePaneFromDockManager(
    CBasePane* pControlBar,
    BOOL bDestroy,
    BOOL bAdjustLayout,
    BOOL bAutoHide,
    CBasePane* pBarReplacement);
```

### <a name="parameters"></a>参数

*p控制栏*<br/>
[在]指向要删除的窗格的指针。

*b破坏*<br/>
[在]TRUE 以销毁已删除的窗格。 不摧毁它。

*b 调整布局*<br/>
[在]TRUE 可立即调整停靠布局。 如果 FALSE，则仅当由于其他原因（用户调整窗口大小、拖动主框架等）而发生重绘事件时才会进行调整。

*bAutoHide*<br/>
[在]TRUE 从自动隐藏窗格列表中删除窗格。 FALSE 从常规窗格列表中删除窗格。

*pBar 替换*<br/>
[在]指向替换已删除窗格的窗格的指针。

### <a name="remarks"></a>备注

您必须向停靠管理器注册每个窗格才能参与停靠布局。 使用[CMDIFrameWndEx：：添加窗格](#addpane)或[CMDIFramewndEx：：插入窗格](#insertpane)以注册窗格。

当窗格不再是框架窗口的停靠布局的一部分时，请使用此方法。

## <a name="cmdiframewndexsavemdistate"></a><a name="savemdistate"></a>CMDIFramewndEx：：保存MDIState

保存 MDI 选项卡组的当前布局和以前打开的文档列表。

```
virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);
```

### <a name="parameters"></a>参数

*lpsz配置文件名称*<br/>
[在]指定配置文件名称。

### <a name="return-value"></a>返回值

如果保存成功，则为 TRUE;如果保存失败，则 FALSE。

### <a name="remarks"></a>备注

要加载或保存 MDI 选项卡和组的状态以及打开的文档列表，执行以下操作：

- 主`SaveMDIState`框架关闭时呼叫

- 调用[CMDIFrameWndEx：：创建主帧时加载MDIState。](#loadmdistate) 此调用的建议位置是首次在显示主帧之前。

- 之前`CWinAppEx::EnableLoadWindowPlacement(FALSE);`致电`pMainFrame->LoadFrame (IDR_MAINFRAME);`

- 之后`CWinAppEx::ReloadWindowPlacement(pMainFrame)``LoadMDIState`调用以在注册表中存储的位置显示主框架。

- 如果`GetDocumentName`应用程序显示`CMDIChildWndEx`的文档未存储为文件，则在 派生类中覆盖。 返回的字符串将作为文档标识符保存在注册表中。 有关详细信息，请参阅[CMDIChildwndEx：：获取文档名称](../../mfc/reference/cmdichildwndex-class.md#getdocumentname)。

- 覆盖[CMDIFrameWndEx：创建文档窗口](#createdocumentwindow)，以便从注册表加载文档时正确创建文档。 的参数`CreateDocumentWindow`是前面返回的`GetDocumentName`字符串。

### <a name="example"></a>示例

下面的示例显示了如何在`SaveMDIState` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#15](../../mfc/codesnippet/cpp/cmdiframewndex-class_14.cpp)]

## <a name="cmdiframewndexsetprintpreviewframe"></a><a name="setprintpreviewframe"></a>CMDIFramewndEx：：设置打印预览框架

设置打印预览框架窗口。

```cpp
void SetPrintPreviewFrame(CFrameWnd* pWnd);
```

### <a name="parameters"></a>参数

*pwnd*<br/>
[在]指向打印预览框架窗口的指针。

### <a name="remarks"></a>备注

## <a name="cmdiframewndexsetuptoolbarmenu"></a><a name="setuptoolbarmenu"></a>CMDIFramewndEx：：设置工具栏菜单

通过将虚拟项目替换为用户定义的项来修改工具栏对象。

```cpp
void SetupToolbarMenu(
    CMenu& menu,
    const UINT uiViewUserToolbarCmdFirst,
    const UINT uiViewUserToolbarCmdLast);
```

### <a name="parameters"></a>参数

*菜单*<br/>
[在]对要修改的[CMenu 类](../../mfc/reference/cmenu-class.md)对象的引用。

*uiViewUserToolbarCmdFirst*<br/>
[在]指定第一个用户定义的命令。

*uiViewUserToolbarCmdLast*<br/>
[在]指定最后一个用户定义的命令。

## <a name="cmdiframewndexshowfullscreen"></a><a name="showfullscreen"></a>CMDIFramewndEx：：显示全屏

将主帧从常规模式切换到全屏模式。

```cpp
void ShowFullScreen();
```

### <a name="remarks"></a>备注

## <a name="cmdiframewndexshowpane"></a><a name="showpane"></a>CMDIFramewndEx：：显示窗格

显示或隐藏指定的窗格。

```cpp
void ShowPane(
    CBasePane* pBar,
    BOOL bShow,
    BOOL bDelay,
    BOOL bActivate);
```

### <a name="parameters"></a>参数

*pBar*<br/>
[在]指向要显示或隐藏的窗格的指针。

*b显示*<br/>
[在]TRUE 以显示窗格。 FALSE 以隐藏窗格。

*bDelay*<br/>
[在]TRUE 以延迟停靠布局的重新计算。 FALSE 可立即重新计算停靠布局。

*b 激活*<br/>
[在]TRUE 以显示窗格应为活动。 FALSE 将窗格显示为非活动状态。

### <a name="remarks"></a>备注

调用此方法以显示或隐藏窗格。 请勿用于`ShowWindow`停靠窗格。

### <a name="example"></a>示例

下面的示例显示了如何在`ShowPane` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#16](../../mfc/codesnippet/cpp/cmdiframewndex-class_15.cpp)]

## <a name="cmdiframewndexshowwindowsdialog"></a><a name="showwindowsdialog"></a>CMDIFramewndEx：：显示窗口对话

创建一个[CMFCWindowsManager对话框](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)并打开它。

```cpp
void ShowWindowsDialog();
```

### <a name="example"></a>示例

下面的示例显示了如何在`ShowWindowsDialog` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#18](../../mfc/codesnippet/cpp/cmdiframewndex-class_16.cpp)]

## <a name="cmdiframewndextabbeddocumenttocontrolbar"></a><a name="tabbeddocumenttocontrolbar"></a>CMDIFramewndEx：：Tabbed文档到控制栏

将指定的选项卡式文档转换为停靠窗格。

```
virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);
```

### <a name="parameters"></a>参数

*pMDIChildwnd*<br/>
指向包含停靠窗格的 MDI 子窗口的指针。

### <a name="return-value"></a>返回值

如果方法成功，则为 TRUE，失败时为 FALSE。

### <a name="remarks"></a>备注

使用此方法可将选项卡式文档转换为停靠窗格。 选项卡式文档必须使用[CMDIFrameWndEx：：：控制栏标签文档](#controlbartotabbeddocument)创建。

### <a name="example"></a>示例

下面的示例显示了如何在`TabbedDocumentToControlBar` [VisualStudioDemo 示例中使用：MFC 可视化工作室应用程序](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#19](../../mfc/codesnippet/cpp/cmdiframewndex-class_17.cpp)]

## <a name="cmdiframewndexupdatecaption"></a><a name="updatecaption"></a>CMDIFramewndEx：：更新标题

由框架调用以更新窗口框架标题。

```cpp
void UpdateCaption();
```

### <a name="remarks"></a>备注

## <a name="cmdiframewndexupdatemditabbedbarsicons"></a><a name="updatemditabbedbarsicons"></a>CMDIFramewndEx：：更新MDITab贝德巴图标

设置每个 MDI 选项卡式窗格的图标。

```cpp
void UpdateMDITabbedBarsIcons();
```

## <a name="cmdiframewndexwinhelp"></a><a name="winhelp"></a>CMDIFramewndEx：：赢帮助

由框架调用以启动 WinHelp 应用程序或上下文帮助。

```
virtual void WinHelp(
    DWORD dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>参数

*dwData*<br/>
[在]指定*nCmd*指定的帮助类型所需的数据。

*nCmd*<br/>
[在]指定请求的帮助类型。 有关可能值的列表及其如何影响*dwData*参数，请参阅 Windows SDK 中的[WinHelp 函数](/windows/win32/api/winuser/nf-winuser-winhelpw)。

### <a name="remarks"></a>备注

此方法重写 [CWnd::WinHelp](../../mfc/reference/cwnd-class.md#winhelp)。

## <a name="see-also"></a>请参阅

[层次结构图表](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)<br/>
[CMDIChildWndEx 类](../../mfc/reference/cmdichildwndex-class.md)
