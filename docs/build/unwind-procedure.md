---
title: 展开过程 |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 82c5d0ca-70be-4d1a-a306-bfe01c29159f
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 294353baf8c15818ba836bd3093226a78aa6e44c
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/17/2018
ms.locfileid: "45700645"
---
# <a name="unwind-procedure"></a>展开过程

展开代码数组按降序排列。 异常发生时，上下文记录中的操作系统存储完整的上下文。 然后调用异常调度逻辑，它将重复执行以下步骤以查找异常处理程序。

1. 使用存储在上下文记录当前 RIP 搜索 runtime_function 结构表条目描述当前函数 （或函数部分，在链接 unwind_info 结构项的情况下）。

1. 如果未找到函数表条目，则在叶函数中，并 RSP 将直接解决返回的指针。 [RSP] 处的返回指针存储在更新后的上下文中，模拟的 RSP 加 8，并且重复步骤 1。

1. 如果找到函数表条目，则翻录后可以位于 a） 在 epilog、 b） 在序言中，或 c） 可能受异常处理程序的代码中的三个区域内。

   - 大小写) 如果 RIP 在 epilog 中，则控件正在退出函数，可能没有与此函数中，此异常关联的异常处理程序并且必须继续执行的 epilog 影响来计算调用方函数的上下文。 若要确定 RIP 是否在 epilog 中，从 RIP 代码流上检查。 如果可以与合法 epilog 的尾部匹配该代码流，则在 epilog 中，并且模拟的 epilog 的剩余部分，使用更新为每个指令的上下文记录进行处理。 在此之后，重复步骤 1。

   - 案例 b） 如果 RIP 内序言，则控件不具有进入函数可以有任何与此函数中，此异常关联的异常处理程序，必须撤消序言的效果，以便计算调用方函数的上下文。 RIP 位于序言中，如果从函数开始进行翻录的距离小于或等于 prolog 大小展开信息进行编码。 序言的效果是展开前扫描通过的偏移量小于或等于从函数开始翻录的偏移量的第一项的展开代码数组然后撤消展开代码数组中的所有剩余项的效果。 然后重复步骤 1。

   - 案例 c) 如果 RIP 不在 prolog 或 epilog 和函数内具有 （设置 UNW_FLAG_EHANDLER） 异常处理程序，则语言特定的处理程序调用。 该处理程序扫描其数据，并调用筛选器作为相应的函数。 语言特定的处理程序可以返回异常已得到处理或搜索将可继续运行。 它还可以直接启动展开代码。

1. 如果语言特定的处理程序返回处理的状态，则继续执行使用原始上下文记录。

1. 如果没有语言特定的处理程序，或者处理程序返回"继续搜索"状态，则上下文记录必须展开到调用方的状态。 这是通过所有撤消的每个效果的展开代码数组元素的处理实现的。 然后重复步骤 1。

链式展开信息所涉及，仍然遵循以下基本步骤。 唯一的区别是，要展开序言的效果，一旦达到数组末尾的展开代码数组的每个步骤，它被链接到父展开信息而遍历整个展开代码数组可在此处找到。 此链接将继续，直到到达展开信息，而无需 UNW_CHAINED_INFO 标志并完成其展开代码数组的每个步骤。

最小集展开数据为 8 个字节。 这表示仅分配 128 个字节的堆栈或更低，并可能保存了一个非易失寄存器的函数。 这也是大小的链式展开信息结构与未展开代码长度为零的 prolog。

## <a name="see-also"></a>请参阅

[异常处理 (x64)](../build/exception-handling-x64.md)