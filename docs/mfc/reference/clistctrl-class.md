---
title: CListCtrl 类
ms.date: 11/04/2016
f1_keywords:
- CListCtrl
- AFXCMN/CListCtrl
- AFXCMN/CListCtrl::CListCtrl
- AFXCMN/CListCtrl::ApproximateViewRect
- AFXCMN/CListCtrl::Arrange
- AFXCMN/CListCtrl::CancelEditLabel
- AFXCMN/CListCtrl::Create
- AFXCMN/CListCtrl::CreateDragImage
- AFXCMN/CListCtrl::CreateEx
- AFXCMN/CListCtrl::DeleteAllItems
- AFXCMN/CListCtrl::DeleteColumn
- AFXCMN/CListCtrl::DeleteItem
- AFXCMN/CListCtrl::DrawItem
- AFXCMN/CListCtrl::EditLabel
- AFXCMN/CListCtrl::EnableGroupView
- AFXCMN/CListCtrl::EnsureVisible
- AFXCMN/CListCtrl::FindItem
- AFXCMN/CListCtrl::GetBkColor
- AFXCMN/CListCtrl::GetBkImage
- AFXCMN/CListCtrl::GetCallbackMask
- AFXCMN/CListCtrl::GetCheck
- AFXCMN/CListCtrl::GetColumn
- AFXCMN/CListCtrl::GetColumnOrderArray
- AFXCMN/CListCtrl::GetColumnWidth
- AFXCMN/CListCtrl::GetCountPerPage
- AFXCMN/CListCtrl::GetEditControl
- AFXCMN/CListCtrl::GetEmptyText
- AFXCMN/CListCtrl::GetExtendedStyle
- AFXCMN/CListCtrl::GetFirstSelectedItemPosition
- AFXCMN/CListCtrl::GetFocusedGroup
- AFXCMN/CListCtrl::GetGroupCount
- AFXCMN/CListCtrl::GetGroupInfo
- AFXCMN/CListCtrl::GetGroupInfoByIndex
- AFXCMN/CListCtrl::GetGroupMetrics
- AFXCMN/CListCtrl::GetGroupRect
- AFXCMN/CListCtrl::GetGroupState
- AFXCMN/CListCtrl::GetHeaderCtrl
- AFXCMN/CListCtrl::GetHotCursor
- AFXCMN/CListCtrl::GetHotItem
- AFXCMN/CListCtrl::GetHoverTime
- AFXCMN/CListCtrl::GetImageList
- AFXCMN/CListCtrl::GetInsertMark
- AFXCMN/CListCtrl::GetInsertMarkColor
- AFXCMN/CListCtrl::GetInsertMarkRect
- AFXCMN/CListCtrl::GetItem
- AFXCMN/CListCtrl::GetItemCount
- AFXCMN/CListCtrl::GetItemData
- AFXCMN/CListCtrl::GetItemIndexRect
- AFXCMN/CListCtrl::GetItemPosition
- AFXCMN/CListCtrl::GetItemRect
- AFXCMN/CListCtrl::GetItemSpacing
- AFXCMN/CListCtrl::GetItemState
- AFXCMN/CListCtrl::GetItemText
- AFXCMN/CListCtrl::GetNextItem
- AFXCMN/CListCtrl::GetNextItemIndex
- AFXCMN/CListCtrl::GetNextSelectedItem
- AFXCMN/CListCtrl::GetNumberOfWorkAreas
- AFXCMN/CListCtrl::GetOrigin
- AFXCMN/CListCtrl::GetOutlineColor
- AFXCMN/CListCtrl::GetSelectedColumn
- AFXCMN/CListCtrl::GetSelectedCount
- AFXCMN/CListCtrl::GetSelectionMark
- AFXCMN/CListCtrl::GetStringWidth
- AFXCMN/CListCtrl::GetSubItemRect
- AFXCMN/CListCtrl::GetTextBkColor
- AFXCMN/CListCtrl::GetTextColor
- AFXCMN/CListCtrl::GetTileInfo
- AFXCMN/CListCtrl::GetTileViewInfo
- AFXCMN/CListCtrl::GetToolTips
- AFXCMN/CListCtrl::GetTopIndex
- AFXCMN/CListCtrl::GetView
- AFXCMN/CListCtrl::GetViewRect
- AFXCMN/CListCtrl::GetWorkAreas
- AFXCMN/CListCtrl::HasGroup
- AFXCMN/CListCtrl::HitTest
- AFXCMN/CListCtrl::InsertColumn
- AFXCMN/CListCtrl::InsertGroup
- AFXCMN/CListCtrl::InsertGroupSorted
- AFXCMN/CListCtrl::InsertItem
- AFXCMN/CListCtrl::InsertMarkHitTest
- AFXCMN/CListCtrl::IsGroupViewEnabled
- AFXCMN/CListCtrl::IsItemVisible
- AFXCMN/CListCtrl::MapIDToIndex
- AFXCMN/CListCtrl::MapIndexToID
- AFXCMN/CListCtrl::MoveGroup
- AFXCMN/CListCtrl::MoveItemToGroup
- AFXCMN/CListCtrl::RedrawItems
- AFXCMN/CListCtrl::RemoveAllGroups
- AFXCMN/CListCtrl::RemoveGroup
- AFXCMN/CListCtrl::Scroll
- AFXCMN/CListCtrl::SetBkColor
- AFXCMN/CListCtrl::SetBkImage
- AFXCMN/CListCtrl::SetCallbackMask
- AFXCMN/CListCtrl::SetCheck
- AFXCMN/CListCtrl::SetColumn
- AFXCMN/CListCtrl::SetColumnOrderArray
- AFXCMN/CListCtrl::SetColumnWidth
- AFXCMN/CListCtrl::SetExtendedStyle
- AFXCMN/CListCtrl::SetGroupInfo
- AFXCMN/CListCtrl::SetGroupMetrics
- AFXCMN/CListCtrl::SetHotCursor
- AFXCMN/CListCtrl::SetHotItem
- AFXCMN/CListCtrl::SetHoverTime
- AFXCMN/CListCtrl::SetIconSpacing
- AFXCMN/CListCtrl::SetImageList
- AFXCMN/CListCtrl::SetInfoTip
- AFXCMN/CListCtrl::SetInsertMark
- AFXCMN/CListCtrl::SetInsertMarkColor
- AFXCMN/CListCtrl::SetItem
- AFXCMN/CListCtrl::SetItemCount
- AFXCMN/CListCtrl::SetItemCountEx
- AFXCMN/CListCtrl::SetItemData
- AFXCMN/CListCtrl::SetItemIndexState
- AFXCMN/CListCtrl::SetItemPosition
- AFXCMN/CListCtrl::SetItemState
- AFXCMN/CListCtrl::SetItemText
- AFXCMN/CListCtrl::SetOutlineColor
- AFXCMN/CListCtrl::SetSelectedColumn
- AFXCMN/CListCtrl::SetSelectionMark
- AFXCMN/CListCtrl::SetTextBkColor
- AFXCMN/CListCtrl::SetTextColor
- AFXCMN/CListCtrl::SetTileInfo
- AFXCMN/CListCtrl::SetTileViewInfo
- AFXCMN/CListCtrl::SetToolTips
- AFXCMN/CListCtrl::SetView
- AFXCMN/CListCtrl::SetWorkAreas
- AFXCMN/CListCtrl::SortGroups
- AFXCMN/CListCtrl::SortItems
- AFXCMN/CListCtrl::SortItemsEx
- AFXCMN/CListCtrl::SubItemHitTest
- AFXCMN/CListCtrl::Update
helpviewer_keywords:
- CListCtrl [MFC], CListCtrl
- CListCtrl [MFC], ApproximateViewRect
- CListCtrl [MFC], Arrange
- CListCtrl [MFC], CancelEditLabel
- CListCtrl [MFC], Create
- CListCtrl [MFC], CreateDragImage
- CListCtrl [MFC], CreateEx
- CListCtrl [MFC], DeleteAllItems
- CListCtrl [MFC], DeleteColumn
- CListCtrl [MFC], DeleteItem
- CListCtrl [MFC], DrawItem
- CListCtrl [MFC], EditLabel
- CListCtrl [MFC], EnableGroupView
- CListCtrl [MFC], EnsureVisible
- CListCtrl [MFC], FindItem
- CListCtrl [MFC], GetBkColor
- CListCtrl [MFC], GetBkImage
- CListCtrl [MFC], GetCallbackMask
- CListCtrl [MFC], GetCheck
- CListCtrl [MFC], GetColumn
- CListCtrl [MFC], GetColumnOrderArray
- CListCtrl [MFC], GetColumnWidth
- CListCtrl [MFC], GetCountPerPage
- CListCtrl [MFC], GetEditControl
- CListCtrl [MFC], GetEmptyText
- CListCtrl [MFC], GetExtendedStyle
- CListCtrl [MFC], GetFirstSelectedItemPosition
- CListCtrl [MFC], GetFocusedGroup
- CListCtrl [MFC], GetGroupCount
- CListCtrl [MFC], GetGroupInfo
- CListCtrl [MFC], GetGroupInfoByIndex
- CListCtrl [MFC], GetGroupMetrics
- CListCtrl [MFC], GetGroupRect
- CListCtrl [MFC], GetGroupState
- CListCtrl [MFC], GetHeaderCtrl
- CListCtrl [MFC], GetHotCursor
- CListCtrl [MFC], GetHotItem
- CListCtrl [MFC], GetHoverTime
- CListCtrl [MFC], GetImageList
- CListCtrl [MFC], GetInsertMark
- CListCtrl [MFC], GetInsertMarkColor
- CListCtrl [MFC], GetInsertMarkRect
- CListCtrl [MFC], GetItem
- CListCtrl [MFC], GetItemCount
- CListCtrl [MFC], GetItemData
- CListCtrl [MFC], GetItemIndexRect
- CListCtrl [MFC], GetItemPosition
- CListCtrl [MFC], GetItemRect
- CListCtrl [MFC], GetItemSpacing
- CListCtrl [MFC], GetItemState
- CListCtrl [MFC], GetItemText
- CListCtrl [MFC], GetNextItem
- CListCtrl [MFC], GetNextItemIndex
- CListCtrl [MFC], GetNextSelectedItem
- CListCtrl [MFC], GetNumberOfWorkAreas
- CListCtrl [MFC], GetOrigin
- CListCtrl [MFC], GetOutlineColor
- CListCtrl [MFC], GetSelectedColumn
- CListCtrl [MFC], GetSelectedCount
- CListCtrl [MFC], GetSelectionMark
- CListCtrl [MFC], GetStringWidth
- CListCtrl [MFC], GetSubItemRect
- CListCtrl [MFC], GetTextBkColor
- CListCtrl [MFC], GetTextColor
- CListCtrl [MFC], GetTileInfo
- CListCtrl [MFC], GetTileViewInfo
- CListCtrl [MFC], GetToolTips
- CListCtrl [MFC], GetTopIndex
- CListCtrl [MFC], GetView
- CListCtrl [MFC], GetViewRect
- CListCtrl [MFC], GetWorkAreas
- CListCtrl [MFC], HasGroup
- CListCtrl [MFC], HitTest
- CListCtrl [MFC], InsertColumn
- CListCtrl [MFC], InsertGroup
- CListCtrl [MFC], InsertGroupSorted
- CListCtrl [MFC], InsertItem
- CListCtrl [MFC], InsertMarkHitTest
- CListCtrl [MFC], IsGroupViewEnabled
- CListCtrl [MFC], IsItemVisible
- CListCtrl [MFC], MapIDToIndex
- CListCtrl [MFC], MapIndexToID
- CListCtrl [MFC], MoveGroup
- CListCtrl [MFC], MoveItemToGroup
- CListCtrl [MFC], RedrawItems
- CListCtrl [MFC], RemoveAllGroups
- CListCtrl [MFC], RemoveGroup
- CListCtrl [MFC], Scroll
- CListCtrl [MFC], SetBkColor
- CListCtrl [MFC], SetBkImage
- CListCtrl [MFC], SetCallbackMask
- CListCtrl [MFC], SetCheck
- CListCtrl [MFC], SetColumn
- CListCtrl [MFC], SetColumnOrderArray
- CListCtrl [MFC], SetColumnWidth
- CListCtrl [MFC], SetExtendedStyle
- CListCtrl [MFC], SetGroupInfo
- CListCtrl [MFC], SetGroupMetrics
- CListCtrl [MFC], SetHotCursor
- CListCtrl [MFC], SetHotItem
- CListCtrl [MFC], SetHoverTime
- CListCtrl [MFC], SetIconSpacing
- CListCtrl [MFC], SetImageList
- CListCtrl [MFC], SetInfoTip
- CListCtrl [MFC], SetInsertMark
- CListCtrl [MFC], SetInsertMarkColor
- CListCtrl [MFC], SetItem
- CListCtrl [MFC], SetItemCount
- CListCtrl [MFC], SetItemCountEx
- CListCtrl [MFC], SetItemData
- CListCtrl [MFC], SetItemIndexState
- CListCtrl [MFC], SetItemPosition
- CListCtrl [MFC], SetItemState
- CListCtrl [MFC], SetItemText
- CListCtrl [MFC], SetOutlineColor
- CListCtrl [MFC], SetSelectedColumn
- CListCtrl [MFC], SetSelectionMark
- CListCtrl [MFC], SetTextBkColor
- CListCtrl [MFC], SetTextColor
- CListCtrl [MFC], SetTileInfo
- CListCtrl [MFC], SetTileViewInfo
- CListCtrl [MFC], SetToolTips
- CListCtrl [MFC], SetView
- CListCtrl [MFC], SetWorkAreas
- CListCtrl [MFC], SortGroups
- CListCtrl [MFC], SortItems
- CListCtrl [MFC], SortItemsEx
- CListCtrl [MFC], SubItemHitTest
- CListCtrl [MFC], Update
ms.assetid: fe08a1ca-4b05-4ff7-a12a-ee4c765a2197
ms.openlocfilehash: 4bc50a8a77a4964cf92d003ed1e06213398f401c
ms.sourcegitcommit: afd6fac7c519dbc47a4befaece14a919d4e0a8a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2018
ms.locfileid: "51525543"
---
# <a name="clistctrl-class"></a>CListCtrl 类

封装显示一组项的“列表视图控件”功能，每一项均包含一个图标（来自图像列表）和标签。

## <a name="syntax"></a>语法

```
class CListCtrl : public CWnd
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|[CListCtrl::CListCtrl](#clistctrl)|构造 `CListCtrl` 对象。|

### <a name="public-methods"></a>公共方法

|名称|描述|
|----------|-----------------|
|[CListCtrl::ApproximateViewRect](#approximateviewrect)|确定的宽度和高度所需显示列表视图控件的项。|
|[CListCtrl::Arrange](#arrange)|对齐网格上的项。|
|[CListCtrl::CancelEditLabel](#canceleditlabel)|取消编辑操作的项文本。|
|[CListCtrl::Create](#create)|创建列表控件，并将其附加到`CListCtrl`对象。|
|[CListCtrl::CreateDragImage](#createdragimage)|创建一个拖动图像列表的指定项。|
|[CListCtrl::CreateEx](#createex)|使用指定的 Windows 扩展样式创建列表控件，并将其附加到`CListCtrl`对象。|
|[CListCtrl::DeleteAllItems](#deleteallitems)|从控件中删除所有项。|
|[CListCtrl::DeleteColumn](#deletecolumn)|从列表视图控件中删除某一列。|
|[CListCtrl::DeleteItem](#deleteitem)|从控件中删除的项。|
|[CListCtrl::DrawItem](#drawitem)|当所有者描述控件发生更改的可视方面时调用。|
|[CListCtrl::EditLabel](#editlabel)|开始在就地编辑的项的文本。|
|[CListCtrl::EnableGroupView](#enablegroupview)|启用或禁用是否在列表视图控件中的项显示为组。|
|[CListCtrl::EnsureVisible](#ensurevisible)|确保项可见。|
|[CListCtrl::FindItem](#finditem)|搜索具有指定特征的列表视图项。|
|[CListCtrl::GetBkColor](#getbkcolor)|检索列表视图控件的背景色。|
|[CListCtrl::GetBkImage](#getbkimage)|检索当前的背景图像的列表视图控件。|
|[Clistctrl:: Getcallbackmask](#getcallbackmask)|检索列表视图控件的回调掩码。|
|[CListCtrl::GetCheck](#getcheck)|检索与项关联的状态图像的当前显示状态。|
|[CListCtrl::GetColumn](#getcolumn)|检索控件的列的属性。|
|[CListCtrl::GetColumnOrderArray](#getcolumnorderarray)|检索列表视图控件的列顺序 （从左到右）。|
|[CListCtrl::GetColumnWidth](#getcolumnwidth)|检索在报表视图或列表视图中列的宽度。|
|[CListCtrl::GetCountPerPage](#getcountperpage)|计算的列表视图控件中可垂直容纳的项数。|
|[CListCtrl::GetEditControl](#geteditcontrol)|检索用来编辑项的文本编辑控件的句柄。|
|[CListCtrl::GetEmptyText](#getemptytext)|检索要显示当前的列表视图控件是否为空的字符串。|
|[CListCtrl::GetExtendedStyle](#getextendedstyle)|检索列表视图控件的当前扩展的样式。|
|[CListCtrl::GetFirstSelectedItemPosition](#getfirstselecteditemposition)|检索第一个选定的列表视图项的列表视图控件中的位置。|
|[CListCtrl::GetFocusedGroup](#getfocusedgroup)|检索具有键盘焦点在当前的列表视图控件中的组。|
|[CListCtrl::GetGroupCount](#getgroupcount)|检索当前的列表视图控件中的组数。|
|[CListCtrl::GetGroupInfo](#getgroupinfo)|获取指定的列表视图控件组的信息。|
|[CListCtrl::GetGroupInfoByIndex](#getgroupinfobyindex)|检索有关当前列表视图控件中的指定组的信息。|
|[CListCtrl::GetGroupMetrics](#getgroupmetrics)|检索组的度量值。|
|[CListCtrl::GetGroupRect](#getgrouprect)|检索当前的列表视图控件中的指定组的边界矩形。|
|[CListCtrl::GetGroupState](#getgroupstate)|检索当前的列表视图控件中的指定组的状态。|
|[CListCtrl::GetHeaderCtrl](#getheaderctrl)|检索列表视图控件的标头控件。|
|[CListCtrl::GetHotCursor](#gethotcursor)|检索用于列表视图控件启用热跟踪时使用的光标。|
|[CListCtrl::GetHotItem](#gethotitem)|检索当前光标下的列表视图项。|
|[CListCtrl::GetHoverTime](#gethovertime)|检索当前的悬停时间的列表视图控件。|
|[CListCtrl::GetImageList](#getimagelist)|检索用于绘图的列表视图项的图像列表的句柄。|
|[CListCtrl::GetInsertMark](#getinsertmark)|检索插入标记的当前位置。|
|[CListCtrl::GetInsertMarkColor](#getinsertmarkcolor)|检索插入标记的当前颜色。|
|[CListCtrl::GetInsertMarkRect](#getinsertmarkrect)|检索绑定的插入点的矩形。|
|[Clistctrl:: Getitem](#getitem)|检索列表视图项的属性。|
|[CListCtrl::GetItemCount](#getitemcount)|检索在列表视图控件中的项的数目。|
|[CListCtrl::GetItemData](#getitemdata)|检索与项相关联的特定于应用程序的值。|
|[CListCtrl::GetItemIndexRect](#getitemindexrect)|检索当前的列表视图控件中的子项的全部或部分的边框。|
|[CListCtrl::GetItemPosition](#getitemposition)|检索的列表视图项的位置。|
|[CListCtrl::GetItemRect](#getitemrect)|检索项的边框。|
|[CListCtrl::GetItemSpacing](#getitemspacing)|计算当前的列表视图控件中的项之间的间距。|
|[CListCtrl::GetItemState](#getitemstate)|检索的列表视图项的状态。|
|[CListCtrl::GetItemText](#getitemtext)|检索列表视图项或子项的文本。|
|[CListCtrl::GetNextItem](#getnextitem)|使用指定的属性和与给定项目的指定关系的列表视图项的搜索。|
|[CListCtrl::GetNextItemIndex](#getnextitemindex)|检索具有一组指定的属性的当前列表视图控件中项的索引。|
|[CListCtrl::GetNextSelectedItem](#getnextselecteditem)|检索列表视图项的位置，并循环访问的下一步所选的列表视图项的位置的索引。|
|[CListCtrl::GetNumberOfWorkAreas](#getnumberofworkareas)|检索列表视图控件的工作区的当前数目。|
|[CListCtrl::GetOrigin](#getorigin)|检索为列表视图控件的当前视图原点。|
|[CListCtrl::GetOutlineColor](#getoutlinecolor)|检索列表视图控件的边框的颜色。|
|[CListCtrl::GetSelectedColumn](#getselectedcolumn)|检索列表控件中的当前所选列的索引。|
|[CListCtrl::GetSelectedCount](#getselectedcount)|检索列表视图控件中选定项的数目。|
|[CListCtrl::GetSelectionMark](#getselectionmark)|检索列表视图控件的选择内容标记。|
|[CListCtrl::GetStringWidth](#getstringwidth)|确定显示给定字符串的所有所需的最小列宽度。|
|[CListCtrl::GetSubItemRect](#getsubitemrect)|检索列表视图控件中的项的边框。|
|[CListCtrl::GetTextBkColor](#gettextbkcolor)|检索列表视图控件的文本背景色。|
|[CListCtrl::GetTextColor](#gettextcolor)|检索列表视图控件的文本颜色。|
|[CListCtrl::GetTileInfo](#gettileinfo)|检索有关列表视图控件中的磁贴的信息。|
|[CListCtrl::GetTileViewInfo](#gettileviewinfo)|检索有关磁贴视图中的列表视图控件的信息。|
|[CListCtrl::GetToolTips](#gettooltips)|检索列表视图控件用于显示工具提示的工具提示控件。|
|[CListCtrl::GetTopIndex](#gettopindex)|检索最顶层的可见项的索引。|
|[CListCtrl::GetView](#getview)|获取列表视图控件的视图。|
|[CListCtrl::GetViewRect](#getviewrect)|检索列表视图控件中的所有项的边框。|
|[CListCtrl::GetWorkAreas](#getworkareas)|检索列表视图控件的当前工作区。|
|[CListCtrl::HasGroup](#hasgroup)|确定列表视图控件是否具有指定的组。|
|[CListCtrl::HitTest](#hittest)|确定哪个列表视图项位于指定位置。|
|[CListCtrl::InsertColumn](#insertcolumn)|在列表视图控件中插入一个新列。|
|[CListCtrl::InsertGroup](#insertgroup)|将组插入到列表视图控件。|
|[CListCtrl::InsertGroupSorted](#insertgroupsorted)|将指定的组插入到的组的排序列表。|
|[CListCtrl::InsertItem](#insertitem)|在列表视图控件中插入新项。|
|[CListCtrl::InsertMarkHitTest](#insertmarkhittest)|检索与指定点最接近的插入点。|
|[CListCtrl::IsGroupViewEnabled](#isgroupviewenabled)|确定是否为列表视图控件启用组视图。|
|[CListCtrl::IsItemVisible](#isitemvisible)|指示当前的列表视图控件中的指定的项是否可见。|
|[CListCtrl::MapIDToIndex](#mapidtoindex)|映射到索引的当前列表视图控件中的项的唯一 ID。|
|[CListCtrl::MapIndexToID](#mapindextoid)|将当前的列表视图控件中的项的索引映射到唯一的 id。|
|[CListCtrl::MoveGroup](#movegroup)|将指定的组移动。|
|[CListCtrl::MoveItemToGroup](#moveitemtogroup)|将移动指定分组到指定列表视图控件的零开始的索引。|
|[CListCtrl::RedrawItems](#redrawitems)|强制重新绘制的项的范围的列表视图控件。|
|[CListCtrl::RemoveAllGroups](#removeallgroups)|从列表视图控件中移除所有组。|
|[CListCtrl::RemoveGroup](#removegroup)|从列表视图控件中移除指定的组。|
|[CListCtrl::Scroll](#scroll)|将列表视图控件的内容滚动。|
|[CListCtrl::SetBkColor](#setbkcolor)|设置列表视图控件的背景的色。|
|[CListCtrl::SetBkImage](#setbkimage)|设置当前的背景图像的列表视图控件。|
|[Clistctrl:: Setcallbackmask](#setcallbackmask)|设置列表视图控件的回调掩码。|
|[CListCtrl::SetCheck](#setcheck)|设置当前显示的与项关联的状态图像的状态。|
|[CListCtrl::SetColumn](#setcolumn)|设置列表视图列的属性。|
|[CListCtrl::SetColumnOrderArray](#setcolumnorderarray)|设置列表视图控件的列顺序 （从左到右）。|
|[CListCtrl::SetColumnWidth](#setcolumnwidth)|更改报表视图或列表视图中的列的宽度。|
|[CListCtrl::SetExtendedStyle](#setextendedstyle)|设置列表视图控件的当前扩展的样式。|
|[CListCtrl::SetGroupInfo](#setgroupinfo)|设置列表视图控件的指定组的信息。|
|[CListCtrl::SetGroupMetrics](#setgroupmetrics)|设置列表视图控件的组度量值。|
|[CListCtrl::SetHotCursor](#sethotcursor)|设置为列表视图控件启用热跟踪时使用的光标。|
|[CListCtrl::SetHotItem](#sethotitem)|设置当前热列表视图控件的项。|
|[CListCtrl::SetHoverTime](#sethovertime)|设置列表视图控件的当前悬停时间。|
|[CListCtrl::SetIconSpacing](#seticonspacing)|设置列表视图控件中的图标之间的间距。|
|[CListCtrl::SetImageList](#setimagelist)|将图像列表分配到列表视图控件。|
|[CListCtrl::SetInfoTip](#setinfotip)|设置工具提示文本。|
|[CListCtrl::SetInsertMark](#setinsertmark)|将插入点设置为定义的位置。|
|[CListCtrl::SetInsertMarkColor](#setinsertmarkcolor)|设置插入点的颜色。|
|[Clistctrl:: Setitem](#setitem)|设置某些或所有列表视图项的特性。|
|[CListCtrl::SetItemCount](#setitemcount)|准备添加大量项的列表视图控件。|
|[CListCtrl::SetItemCountEx](#setitemcountex)|设置虚拟列表视图控件的项计数。|
|[CListCtrl::SetItemData](#setitemdata)|设置项的特定于应用程序的值。|
|[CListCtrl::SetItemIndexState](#setitemindexstate)|设置当前的列表视图控件中项的状态。|
|[CListCtrl::SetItemPosition](#setitemposition)|将项移动到列表视图控件中的指定位置。|
|[CListCtrl::SetItemState](#setitemstate)|更改列表视图控件中的项的状态。|
|[CListCtrl::SetItemText](#setitemtext)|更改列表视图项或子项的文本。|
|[CListCtrl::SetOutlineColor](#setoutlinecolor)|设置列表视图控件的边框的颜色。|
|[CListCtrl::SetSelectedColumn](#setselectedcolumn)|设置列表视图控件的所选的列。|
|[CListCtrl::SetSelectionMark](#setselectionmark)|设置列表视图控件的选择内容标记。|
|[CListCtrl::SetTextBkColor](#settextbkcolor)|在列表视图控件中设置文本的背景色。|
|[CListCtrl::SetTextColor](#settextcolor)|设置列表视图控件的文本的颜色。|
|[CListCtrl::SetTileInfo](#settileinfo)|设置磁贴的列表视图控件的信息。|
|[CListCtrl::SetTileViewInfo](#settileviewinfo)|设置磁贴视图中使用列表视图控件的信息。|
|[CListCtrl::SetToolTips](#settooltips)|设置列表视图控件用来显示工具提示的工具提示控件。|
|[CListCtrl::SetView](#setview)|设置列表视图控件的视图。|
|[CListCtrl::SetWorkAreas](#setworkareas)|设置图标可以显示在列表视图控件中的区域。|
|[CListCtrl::SortGroups](#sortgroups)|排序的组列表视图控件的用户定义函数。|
|[CListCtrl::SortItems](#sortitems)|使用应用程序定义比较函数的列表视图项进行排序。|
|[CListCtrl::SortItemsEx](#sortitemsex)|使用应用程序定义比较函数的列表视图项进行排序。|
|[CListCtrl::SubItemHitTest](#subitemhittest)|确定哪个列表视图项，如果任何，在给定位置。|
|[CListCtrl::Update](#update)|强制控件重绘指定的项。|

## <a name="remarks"></a>备注

除了一个图标和标签，每个项可以有图标和标签的右侧列中显示的信息。 此控件 (并因此`CListCtrl`类) 仅适用于 Windows 95/98 和 Windows NT 版本 3.51 下运行的程序和更高版本。

下面是简要概述`CListCtrl`类。 有关详细的概念介绍，请参阅[使用 CListCtrl](../../mfc/using-clistctrl.md)并[控件](../../mfc/controls-mfc.md)。

## <a name="views"></a>视图

列表视图控件可以显示其内容中四种不同的方式，称为"视图"。

- 图标视图

   每个项都显示为它下面有一个标签尺寸图标 （32 x 32 像素为单位）。 用户可以将项拖到列表视图窗口中的任何位置。

- 小图标视图

   每个项都与右侧的标签显示为小图标 （16 x 16 像素为单位）。 用户可以将项拖到列表视图窗口中的任何位置。

- 列表视图

   每个项都显示为带一个标签的右侧的小图标。 项排列在列中，不能拖到列表视图窗口中的任何位置。

- 报表视图

   每个项将显示在其自己的行，在右侧列中排列的其他信息。 最左侧列包含的小图标和标签，并且后续列都包含由应用程序指定的子项。 内嵌的标题控件 (类[CHeaderCtrl](../../mfc/reference/cheaderctrl-class.md)) 实现这些列。 标头控件和报表视图中的列的详细信息，请参阅[使用 CListCtrl： 控件 （报表视图） 中添加列](../../mfc/adding-columns-to-the-control-report-view.md)。

控件的当前列表视图的样式确定当前的视图。 这些样式和其使用情况的详细信息，请参阅[使用 CListCtrl： 更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="extended-styles"></a>扩展的样式

除了标准列表样式，类`CListCtrl`支持大量的扩展样式，提供丰富的功能。 此功能的一些示例包括：

- 将鼠标悬停在所选内容

   启用时，允许自动选择了某个项时游标的项上保持一段时间。

- 虚拟列表视图

   启用时，使得控件可以支持多达 DWORD 项。 这是通过将放置管理项的应用程序数据的开销。 除了项选择和焦点的信息，必须由应用程序管理项的所有信息。 有关详细信息，请参阅[使用 CListCtrl： 虚拟列表控件](../../mfc/virtual-list-controls.md)。

- 点击和两个激活

   如果启用，将允许 （自动突出显示的项文本） 的热跟踪和突出显示的项的一个或两次单击激活。

- 拖放到列排序

   如果启用，将允许拖放重新排序的列表视图控件中的列。 仅在报表视图中可用。

有关使用这些新的信息扩展样式，请参阅[使用 CListCtrl： 更改列表控件样式](../../mfc/changing-list-control-styles.md)。

## <a name="items-and-subitems"></a>项及其子项

在列表视图控件中的每个项由一个图标 （来自图像列表）、 标签、 当前状态和应用程序定义的值 （称为"项数据"） 组成。 一个或多个子项也可以与相关联的每个项。 "子项"是一个字符串，在报表视图中，可以显示在右侧的项的图标和标签列中。 列表视图控件中的所有项都必须都具有相同的子项数。

类`CListCtrl`提供以下用于插入、 删除、 查找和修改这些项函数。 有关详细信息，请参阅[clistctrl:: Getitem](#getitem)， [CListCtrl::InsertItem](#insertitem)，并[CListCtrl::FindItem](#finditem)，[将项添加到控件](../adding-items-to-the-control.md)，并[滚动、 排列、 排序和查找列表控件中](../scrolling-arranging-sorting-and-finding-in-list-controls.md)。

默认情况下，列表视图控件负责存储项的图标和文本特性。 但是，这些项类型，除了类`CListCtrl`支持"回调项"。 "回调项"是列表视图项为其应用程序，而不是控件 — 存储文本、 图标或两者。 回调掩码用于指定哪些项目属性 （文本和/或图标） 提供的应用程序。 如果应用程序使用回调项，它必须能够提供按需的文本和/或图标属性。 应用程序已保留其中某些信息时，回调项很有用。 有关详细信息，请参阅[使用 CListCtrl： 回调项和回调掩码](../callback-items-and-the-callback-mask.md)。

## <a name="image-lists"></a>图像列表

图标、 标头项图像和应用程序-为列表视图项包含在多个图像列表定义状态 (由类实现[CImageList](cimagelist-class.md))，可以创建并分配到列表视图控件。 每个列表视图控件可以具有最多四个不同类型的图像列表：

- 大图标

   在图标视图中使用的全尺寸图标。

- 小图标

   用在小图标、 列表和报告视图的较小图标视图中使用的图标版本。

- 应用程序定义的状态

   包含项的图标，以指示应用程序定义的状态旁边显示的状态图像。

- 标头项

   在报表视图用于显示每个标头控件项中的小图像。

默认情况下，列表视图控件销毁时销毁; 分配给它的映像列表但是，开发人员可以通过每个图像列表时销毁不再使用，由应用程序自定义此行为。 有关详细信息，请参阅[使用 CListCtrl： 列表项和图像列表](../list-items-and-image-lists.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](cobject-class.md)

[CCmdTarget](ccmdtarget-class.md)

[CWnd](cwnd-class.md)

`CListCtrl`

## <a name="requirements"></a>要求

**标头：** afxcmn.h

## <a name="approximateviewrect"></a>  CListCtrl::ApproximateViewRect

确定的宽度和高度所需显示列表视图控件的项。

```
CSize ApproximateViewRect(
    CSize sz = CSize(-1,
-1),
    int iCount = -1) const;
```

### <a name="parameters"></a>参数

*sz*<br/>
控件，以像素为单位的建议的尺寸。 如果未指定维度，框架将使用该控件的当前宽度或高度值。

*iCount*<br/>
若要在控件中显示的项目数。 如果此参数为-1，框架将使用总的项数当前控件中。

### <a name="return-value"></a>返回值

一个`CSize`包含的大致宽度和高度显示的项，以像素为单位所需的对象。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_ApproximateViewRect](/windows/desktop/api/commctrl/nf-commctrl-listview_approximateviewrect)，如 Windows SDK 中所述。

## <a name="arrange"></a>  CListCtrl::Arrange

重新定位在图标视图中的项，以便它们在网格上对齐。

```
BOOL Arrange(UINT nCode);
```

### <a name="parameters"></a>参数

*nCode*<br/>
指定项的对齐样式。 它可以是下列值之一：

- LVA_ALIGNLEFT 对齐项沿左边缘的窗口。

- LVA_ALIGNTOP 对齐项沿上边缘的窗口。

- LVA_DEFAULT 对齐项根据列表视图的当前对齐样式 （默认值）。

- LVA_SNAPTOGRID 将所有图标都对齐到最近的网格位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

*NCode*参数指定的对齐样式。

### <a name="example"></a>示例

```cpp
    // Align all of the list view control items along the top
    // of the window (the list view control must be in icon or
    // small icon mode).
    m_myListCtrl.Arrange(LVA_ALIGNTOP);
```

## <a name="canceleditlabel"></a>  CListCtrl::CancelEditLabel

取消编辑操作的项文本。

```
void CancelEditLabel();
```

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_CANCELEDITLABEL](/windows/desktop/Controls/lvm-canceleditlabel)消息，如 Windows SDK 中所述。

## <a name="clistctrl"></a>  CListCtrl::CListCtrl

构造 `CListCtrl` 对象。

```
CListCtrl();
```

## <a name="create"></a>  CListCtrl::Create

创建列表控件，并将其附加到`CListCtrl`对象。

```
virtual BOOL Create(
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>参数

*dwStyle*<br/>
指定列表控件的样式。 应用于控件的列表控件样式的任意组合。 请参阅[列表视图的窗口样式](/windows/desktop/Controls/list-view-window-styles)有关的完整列表，这些样式的 Windows SDK 中。 设置扩展样式特定于控件使用[SetExtendedStyle](#setextendedstyle)。

*rect*<br/>
指定列表控件的大小和位置。 它可以是`CRect`对象或[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构。

*pParentWnd*<br/>
指定列表控件的父窗口中，通常`CDialog`。 它不能为 NULL。

*nID*<br/>
指定列表控件的 id。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

构造`CListCtrl`中两个步骤。 首先，调用构造函数，然后调用`Create`，它创建列表视图控件并将其附加到`CListCtrl`对象。

若要将扩展的 Windows 样式应用于列表控件对象，调用[CreateEx](#createex)而不是`Create`。

### <a name="example"></a>示例

```cpp
    m_myListCtrl.Create(
        WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_EDITLABELS,
        CRect(10,10,400,200), pParentWnd, IDD_MYLISTCTRL);
```

## <a name="createex"></a>  CListCtrl::CreateEx

创建控件 （子窗口），并将其与`CListCtrl`对象。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>参数

*dwExStyle*<br/>
指定要创建的控件的扩展的样式。 扩展 Windows 样式的列表，请参阅*dwExStyle*参数[CreateWindowEx](/windows/desktop/api/winuser/nf-winuser-createwindowexa) Windows SDK 中。

*dwStyle*<br/>
指定列表控件的样式。 应用于控件的列表控件样式的任意组合。 这些样式的完整列表，请参阅[列表视图的窗口样式](/windows/desktop/Controls/list-view-window-styles)Windows SDK 中。

*rect*<br/>
对引用[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构的结构描述的大小和窗口的工作区中创建的位置*pParentWnd*。

*pParentWnd*<br/>
指向控件的父级的窗口的指针。

*nID*<br/>
控件的子窗口 id。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

使用`CreateEx`而不是[创建](#create)若要将应用扩展的 Windows 样式，指定的 Windows 扩展的样式加**WS_EX_**。

`CreateEx` 创建使用指定的扩展 Windows 样式的控件*dwExStyle*。 若要设置特定于控件的扩展的样式，请调用[SetExtendedStyle](#setextendedstyle)。 例如，使用`CreateEx`来将此类样式设置为 WS_EX_CONTEXTHELP，但使用`SetExtendedStyle`若要将此类样式设置为 LVS_EX_FULLROWSELECT。 有关详细信息，请参阅本主题中所述的样式[扩展列表视图样式](/windows/desktop/Controls/extended-list-view-styles)Windows SDK 中。

## <a name="createdragimage"></a>  CListCtrl::CreateDragImage

创建由指定的项拖动图像列表*nItem*。

```
CImageList* CreateDragImage(
    int nItem,
    LPPOINT lpPoint);
```

### <a name="parameters"></a>参数

*nItem*<br/>
若要创建的拖动图像列表的项的索引。

*lpPoint*<br/>
地址[点](https://msdn.microsoft.com/library/windows/desktop/dd162805)接收的图像的左上角的初始位置的结构视图中协调。

### <a name="return-value"></a>返回值

拖动图像列表中，如果成功，则指向的指针否则为，为 NULL。

### <a name="remarks"></a>备注

`CImageList`对象是永久性的并且必须将其完成后删除。 例如：

```cpp
        CImageList* pImageList = m_myListCtrl.CreateDragImage(nItem, &point);

        // do something

        delete pImageList;
```

## <a name="deleteallitems"></a>  CListCtrl::DeleteAllItems

从列表视图控件中删除所有项。

```
BOOL DeleteAllItems();
```

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Delete all of the items from the list view control.
    m_myListCtrl.DeleteAllItems();
    ASSERT(m_myListCtrl.GetItemCount() == 0);
```

## <a name="deletecolumn"></a>  CListCtrl::DeleteColumn

从列表视图控件中删除某一列。

```
BOOL DeleteColumn(int nCol);
```

### <a name="parameters"></a>参数

*nCol*<br/>
要删除的列的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Delete all of the columns.
        for (int i=0; i < nColumnCount; i++)
        {
            m_myListCtrl.DeleteColumn(0);
        }
```

## <a name="deleteitem"></a>  CListCtrl::DeleteItem

从列表视图控件中删除项。

```
BOOL DeleteItem(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
指定要删除的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();

        // Delete all of the items from the list view control.
        for (int i=0; i < nCount; i++)
        {
            m_myListCtrl.DeleteItem(0);
        }
```

## <a name="drawitem"></a>  CListCtrl::DrawItem

由框架在所有者描述列表视图控件更改的可视方面时调用。

```
virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>参数

*lpDrawItemStruct*<br/>
指向的长指针`DRAWITEMSTRUCT`结构，其中包含有关绘图所需的类型的信息。

### <a name="remarks"></a>备注

`itemAction`的成员[DRAWITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagdrawitemstruct)结构定义要执行的绘制操作。

默认情况下，此成员函数没有任何影响。 重写此成员函数以实现绘制所有者描述的`CListCtrl`对象。

应用程序应还原所有图形设备接口 (GDI) 对象的显示上下文中提供选定*lpDrawItemStruct*之前此成员函数将终止。

## <a name="editlabel"></a>  CListCtrl::EditLabel

开始在就地编辑的项的文本。

```
CEdit* EditLabel(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要编辑的列表视图项的索引。

### <a name="return-value"></a>返回值

如果成功，一个指向`CEdit`用于编辑项文本的对象; 否则为 NULL。

### <a name="remarks"></a>备注

具有 LVS_EDITLABELS 窗口样式的列表视图控件，用户可编辑位置中的项目标签。 用户开始编辑通过单击具有焦点的项的标签。

使用此函数以开始进行就地编辑的指定的列表视图项的文本。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Show the edit control on the label of the first
        // item in the list view control.
        CEdit* pmyEdit = m_myListCtrl.EditLabel(1);
        ASSERT(pmyEdit != NULL);
```

## <a name="enablegroupview"></a>  CListCtrl::EnableGroupView

启用或禁用是否在列表视图控件中的项显示为组。

```
LRESULT EnableGroupView(BOOL fEnable);
```

### <a name="parameters"></a>参数

*fEnable*<br/>
指示是否启用到组的 listview 控件显示的项。 如果启用了分组，则为如果为 FALSE 来禁用它。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**能够显示列表视图项为一组已启用或禁用。

- **1**已成功更改控件的状态。

- **-1**操作失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_ENABLEGROUPVIEW](/windows/desktop/Controls/lvm-enablegroupview)消息，如 Windows SDK 中所述。

## <a name="ensurevisible"></a>  CListCtrl::EnsureVisible

确保至少部分可见的列表视图项。

```
BOOL EnsureVisible(
    int nItem,
    BOOL bPartialOK);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要显示的列表视图项的索引。

*bPartialOK*<br/>
指定是否可接受部分可见性。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如有必要，滚动列表视图控件。 如果*bPartialOK*参数为非零值时，不会发生滚动项是否部分可见。

### <a name="example"></a>示例

```cpp
        // Ensure that the last item is visible.
        int nCount = m_myListCtrl.GetItemCount();
        if (nCount > 0)
            m_myListCtrl.EnsureVisible(nCount-1, FALSE);
```

## <a name="finditem"></a>  CListCtrl::FindItem

搜索具有指定特征的列表视图项。

```
int FindItem(
    LVFINDINFO* pFindInfo,
    int nStart = -1) const;
```

### <a name="parameters"></a>参数

*pFindInfo*<br/>
一个指向[LVFINDINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvfindinfoa)结构，它包含有关要在其中搜索的项的信息。

*n 开始*<br/>
此项开始搜索，则为-1 以从头开始的索引。 处的项*n 开始*如果从搜索中排除*n 开始*不等于-1。

### <a name="return-value"></a>返回值

如果成功，则项或否则为-1 的索引。

### <a name="remarks"></a>备注

*PFindInfo*参数指向`LVFINDINFO`结构，其中包含用于搜索的列表视图项的信息。

### <a name="example"></a>示例

```cpp
        LVFINDINFO info;
        int nIndex;

        info.flags = LVFI_PARTIAL|LVFI_STRING;
        info.psz = _T("item");

        // Delete all of the items that begin with the string.
        while ((nIndex = m_myListCtrl.FindItem(&info)) != -1)
        {
            m_myListCtrl.DeleteItem(nIndex);
        }
```

## <a name="getbkcolor"></a>  CListCtrl::GetBkColor

检索列表视图控件的背景色。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>返回值

用指定的 RGB 颜色的 32 位值。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::SetBkColor](#setbkcolor)。

## <a name="getbkimage"></a>  CListCtrl::GetBkImage

检索当前的背景图像的列表视图控件。

```
BOOL GetBkImage(LVBKIMAGE* plvbkImage) const;
```

### <a name="parameters"></a>参数

*plvbkImage*<br/>
一个指向`LVBKIMAGE`结构，它包含当前的背景图像的列表视图。

### <a name="return-value"></a>返回值

返回非零，如果成功，或者以其他方式的零。

### <a name="remarks"></a>备注

此方法实现 Win32 宏的行为[ListView_GetBkImage](/windows/desktop/api/commctrl/nf-commctrl-listview_getbkimage)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        LVBKIMAGE bki;

        // If no background image is set for the list view control use
        // the Microsoft homepage image as the background image.
        if (m_myListCtrl.GetBkImage(&bki) && (bki.ulFlags == LVBKIF_SOURCE_NONE))
        {
            m_myListCtrl.SetBkImage(
                _T("http://www.microsoft.com/library/images/gifs/homepage/microsoft.gif"),
                TRUE);
        }
```

## <a name="getcallbackmask"></a>  Clistctrl:: Getcallbackmask

检索列表视图控件的回调掩码。

```
UINT GetCallbackMask() const;
```

### <a name="return-value"></a>返回值

列表视图控件的回调掩码。

### <a name="remarks"></a>备注

"回调项"是列表视图项为其应用程序，而不是控件 — 存储文本、 图标或两者。 虽然列表视图控件可以为您存储这些属性，可能想要使用回调项，如果应用程序已维护其中一些信息。 回调掩码指定哪些项状态位维护的应用程序，并应用于整个控件，而不是特定项。 回调掩码默认为零，这意味着控件将跟踪所有项状态。 如果应用程序使用回调项，或指定非零值的回调掩码，它必须能够提供按需列表视图项特性。

### <a name="example"></a>示例

  有关示例，请参阅[clistctrl:: Setcallbackmask](#setcallbackmask)。

## <a name="getcheck"></a>  CListCtrl::GetCheck

检索与项相关联的状态图像的当前显示状态。

```
BOOL GetCheck(int nItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
列表控件项的从零开始的索引。

### <a name="return-value"></a>返回值

非零，如果选择该项，否则为 0。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetCheckState](/windows/desktop/api/commctrl/nf-commctrl-listview_getcheckstate)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::SetCheck](#setcheck)。

## <a name="getcolumn"></a>  CListCtrl::GetColumn

检索列表视图控件的列的属性。

```
BOOL GetColumn(
    int nCol,
    LVCOLUMN* pColumn) const;
```

### <a name="parameters"></a>参数

*nCol*<br/>
要检索其属性的列的索引。

*pColumn*<br/>
地址[LVCOLUMN](/windows/desktop/api/commctrl/ns-commctrl-taglvcolumna)结构，它指定要检索的信息并接收有关列的信息。 `mask`成员指定要检索的列属性。 如果`mask`成员指定 LVCF_TEXT 值`pszText`成员必须包含接收项文本的缓冲区的地址和`cchTextMax`成员必须指定缓冲区的大小。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVCOLUMN`结构包含在报表视图中列的相关信息。

### <a name="example"></a>示例

```cpp
        LVCOLUMN col;

        col.mask = LVCF_WIDTH;

        // Double the column width of the first column.
        if (m_myListCtrl.GetColumn(0, &col))
        {
            col.cx *= 2;
            m_myListCtrl.SetColumn(0, &col);
        }
```

## <a name="getcolumnorderarray"></a>  CListCtrl::GetColumnOrderArray

检索列表视图控件的列顺序 （从左到右）。

```
BOOL GetColumnOrderArray(
    LPINT piArray,
    int iCount = -1);
```

### <a name="parameters"></a>参数

*piArray*<br/>
指向将包含在列表视图控件中列的索引值的缓冲区的指针。 缓冲区必须足够大以包含在列表视图控件中的列的总数。

*iCount*<br/>
在列表视图控件中的列数。 如果此参数为-1，由框架自动检索的列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetColumnOrderArray](/windows/desktop/api/commctrl/nf-commctrl-listview_getcolumnorderarray)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // Reverse the order of the columns in the list view control
        // (i.e. make the first column the last, the last column
        // the first, and so on...).
        CHeaderCtrl* pHeaderCtrl = m_myListCtrl.GetHeaderCtrl();

        if (pHeaderCtrl != NULL)
        {
            int  nColumnCount = pHeaderCtrl->GetItemCount();
            LPINT pnOrder = (LPINT) malloc(nColumnCount*sizeof(int));
            ASSERT(pnOrder != NULL);
m_myListCtrl.GetColumnOrderArray(pnOrder, nColumnCount);

            int i, j, nTemp;
            for (i = 0, j = nColumnCount-1; i < j; i++, j--)
            {
                nTemp = pnOrder[i];
                pnOrder[i] = pnOrder[j];
                pnOrder[j] = nTemp;
            }

            m_myListCtrl.SetColumnOrderArray(nColumnCount, pnOrder);
            free(pnOrder);
        }
```

## <a name="getcolumnwidth"></a>  CListCtrl::GetColumnWidth

检索在报表视图或列表视图中列的宽度。

```
int GetColumnWidth(int nCol) const;
```

### <a name="parameters"></a>参数

*nCol*<br/>
指定要检索其宽度的列的索引。

### <a name="return-value"></a>返回值

宽度，以像素为单位指定的列*nCol*。

### <a name="example"></a>示例

```cpp
        // Increase the column width of the second column by 20.
        int nWidth = m_myListCtrl.GetColumnWidth(1);
        m_myListCtrl.SetColumnWidth(1, 20 + nWidth);
```

## <a name="getcountperpage"></a>  CListCtrl::GetCountPerPage

计算可容纳垂直列表视图控件的可视区域中时在列表视图或报表视图中的项的数目。

```
int GetCountPerPage() const;
```

### <a name="return-value"></a>返回值

可容纳垂直列表视图控件的可视区域中时在列表视图或报表视图中的项的数目。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetTopIndex](#gettopindex)。

## <a name="geteditcontrol"></a>  CListCtrl::GetEditControl

检索用来编辑列表视图项的文本编辑控件的句柄。

```
CEdit* GetEditControl() const;
```

### <a name="return-value"></a>返回值

如果成功，一个指向[CEdit](cedit-class.md)用于编辑项文本的对象; 否则为 NULL。

### <a name="example"></a>示例

```cpp
        // The string replacing the text in the edit control.
        LPCTSTR lpszmyString = _T("custom label!");

        // If possible, replace the text in the label edit control.
        CEdit* pEdit = m_myListCtrl.GetEditControl();

        if (pEdit != NULL)
        {
            pEdit->SetWindowText(lpszmyString);
        }
```

## <a name="getemptytext"></a>  CListCtrl::GetEmptyText

检索要显示当前的列表视图控件是否为空的字符串。

```
CString GetEmptyText() const;
```

### <a name="return-value"></a>返回值

一个[CString](../../atl-mfc-shared/reference/cstringt-class.md) ，其中包含要显示该控件是否为空的文本。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETEMPTYTEXT](/windows/desktop/Controls/lvm-getemptytext)消息，Windows SDK 中所述。

## <a name="getextendedstyle"></a>  CListCtrl::GetExtendedStyle

检索列表视图控件的当前扩展的样式。

```
DWORD GetExtendedStyle();
```

### <a name="return-value"></a>返回值

当前正在使用列表的扩展样式的组合视图控件。 有关这些扩展样式的描述性列表，请参阅[扩展的列表视图样式](/windows/desktop/Controls/extended-list-view-styles)Windows SDK 中的主题。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetExtendedListViewStyle](/windows/desktop/api/commctrl/nf-commctrl-listview_getextendedlistviewstyle)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::SetExtendedStyle](#setextendedstyle)。

## <a name="getfirstselecteditemposition"></a>  CListCtrl::GetFirstSelectedItemPosition

获取第一个选定项的列表视图控件中的位置。

```
POSITION GetFirstSelectedItemPosition() const;
```

### <a name="return-value"></a>返回值

可用于迭代或检索对象指针; 一个位置值如果没有选定的项，则为 NULL。

### <a name="example"></a>示例

下面的代码示例演示此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getfocusedgroup"></a>  CListCtrl::GetFocusedGroup

检索具有键盘焦点在当前的列表视图控件中的组。

```
int GetFocusedGroup() const;
```

### <a name="return-value"></a>返回值

其状态是 LVGS_FOCUSED，如果没有此类组; 的组的索引否则为-1。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETFOCUSEDGROUP](/windows/desktop/Controls/lvm-getfocusedgroup)消息，Windows SDK 中所述。 有关详细信息，请参阅的 LVGS_FOCUSED 值`state`的成员[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构。

## <a name="getgroupcount"></a>  CListCtrl::GetGroupCount

检索当前的列表视图控件中的组数。

```
int GetGroupCount()const;
```

### <a name="return-value"></a>返回值

在列表视图控件中的组数。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETGROUPCOUNT](/windows/desktop/Controls/lvm-getgroupcount) --> 消息，Windows SDK 中所述。

## <a name="getgroupinfo"></a>  CListCtrl::GetGroupInfo

获取指定的列表视图控件组的信息。

```
int GetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp) const;
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要检索其信息的组的标识符。

*pgrp*<br/>
一个指向[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)包含有关指定组的信息。

### <a name="return-value"></a>返回值

否则返回的组，如果成功，则为-1 的 ID。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETGROUPINFO](/windows/desktop/Controls/lvm-getgroupinfo)消息，如 Windows SDK 中所述。

## <a name="getgroupinfobyindex"></a>  CListCtrl::GetGroupInfoByIndex

检索有关当前列表视图控件中的指定组的信息。

```
BOOL GetGroupInfoByIndex(
    int iIndex,
    PLVGROUP pGroup) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*iIndex*|[in]组的从零开始的索引。|
|*pGroup*|[out]指向[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构，它接收由指定的组的相关信息*iIndex*参数。<br /><br /> 调用方负责初始化的成员[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构。 设置`cbSize`成员添加到结构的大小和所用的标志`mask`成员来指定要检索的信息。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETGROUPINFOBYINDEX](https://msdn.microsoft.com/library/windows/desktop/bb774933) --> 消息，Windows SDK 中所述。

### <a name="example"></a>示例

下面的代码示例定义一个变量， `m_listCtrl`，即用于访问当前的列表视图控件。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示了`GetGroupInfoByIndex`方法。 在此代码的前面部分中我们创建的列表视图控件的示例显示两个列标题"ClientID"和"等级"为报告视图中。 下面的代码示例检索有关其索引为 0，组的信息，如果存在此类的组。
```cpp
    // GetGroupInfoByIndex
    const int GROUP_HEADER_BUFFER_SIZE = 40;

// Initialize the structure
    LVGROUP gInfo = {0};
    gInfo.cbSize = sizeof(LVGROUP);
    wchar_t wstrHeadGet[GROUP_HEADER_BUFFER_SIZE] = {0};
    gInfo.cchHeader = GROUP_HEADER_BUFFER_SIZE;
    gInfo.pszHeader = wstrHeadGet;
    gInfo.mask = (LVGF_ALIGN | LVGF_STATE | LVGF_HEADER | LVGF_GROUPID);
    gInfo.state = LVGS_NORMAL;
    gInfo.uAlign  = LVGA_HEADER_LEFT;

    BOOL bRet = m_listCtrl.GetGroupInfoByIndex( 0, &gInfo );
    if (bRet == TRUE) {
        CString strHeader = CString( gInfo.pszHeader );
        CString str;
        str.Format(_T("Header: '%s'"), strHeader);
        AfxMessageBox(str, MB_ICONINFORMATION);
    }
    else
    {
        AfxMessageBox(_T("No group information was retrieved."));
    }
```

## <a name="getgroupmetrics"></a>  CListCtrl::GetGroupMetrics

检索组的度量值。

```
void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const;
```

### <a name="parameters"></a>参数

*pGroupMetrics*<br/>
一个指向[LVGROUPMETRICS](/windows/desktop/api/commctrl/ns-commctrl-taglvgroupmetrics)包含组度量值信息。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETGROUPMETRICS](/windows/desktop/Controls/lvm-getgroupmetrics)消息，如 Windows SDK 中所述。

## <a name="getgrouprect"></a>  CListCtrl::GetGroupRect

检索当前的列表视图控件中的指定组的边界矩形。

```
BOOL GetGroupRect(
    int iGroupId,
    LPRECT lpRect,
    int iCoords = LVGGR_GROUP) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*iGroupId*|[in]指定一组。|
|*lpRect*|[in、 out]指向[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构。 如果此方法成功，该结构接收由指定的组的矩形坐标*iGroupId*。|
|*iCoords*|[in]指定要检索的矩形坐标。 使用下列值之一：<br /><br /> -LVGGR_GROUP-整个展开组 （默认值） 坐标。<br />-LVGGR_HEADER-仅标头 （已折叠组） 的坐标。<br />-LVGGR_SUBSETLINK-坐标仅子集链接 （标记子集）。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

调用方负责分配[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)指向结构*pRect*参数。

此方法将发送[LVM_GETGROUPRECT](/windows/desktop/Controls/lvm-getgrouprect)消息，Windows SDK 中所述。

### <a name="example"></a>示例

下面的代码示例定义一个变量， `m_listCtrl`，即用于访问当前的列表视图控件。 此变量将在下一个示例中使用。
```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示了`GetGroupRect`方法。 此代码示例的前面部分，我们将创建显示标题"ClientID"和"等级"为报告视图中的两个列的列表视图控件。 如果存在此类的组，下面的代码示例绘制其索引为 0，组周围三维矩形。

```cpp
    // GetGroupRect

    // Get the graphics rectangle that surrounds group 0.
    CRect rect;
    BOOL bRet = m_listCtrl.GetGroupRect( 0, &rect, LVGGR_GROUP);
    // Draw a blue rectangle around group 0.
    if (bRet == TRUE) {
        m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(0, 0, 255), RGB(0, 0, 255));
    }
    else {
        AfxMessageBox(_T("No group information was retrieved."), MB_ICONINFORMATION);
    }
```

## <a name="getgroupstate"></a>  CListCtrl::GetGroupState

检索当前的列表视图控件中的指定组的状态。

```
UINT GetGroupState(
    int iGroupId,
    DWORD dwMask) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*iGroupId*|[in]组的从零开始的索引。|
|*dwMask*|[in]指定要检索有关指定组的状态值的掩码。 有关详细信息，请参阅`mask`的成员[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构。|

### <a name="return-value"></a>返回值

请求的状态为指定的组或如果找不到组，则为 0。

### <a name="remarks"></a>备注

返回值的按位 AND 运算结果位于*dwMask*参数和的值`state`的成员[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构，它表示当前的列表视图控件。

此方法将发送[LVM_GETGROUPSTATE](/windows/desktop/Controls/lvm-getgroupstate)消息，Windows SDK 中所述。 有关详细信息，请参阅[ListView_GetGroupState](/windows/desktop/api/commctrl/nf-commctrl-listview_getgroupstate)宏。

## <a name="getheaderctrl"></a>  CListCtrl::GetHeaderCtrl

检索列表视图控件的标头控件。

```
CHeaderCtrl* GetHeaderCtrl();
```

### <a name="return-value"></a>返回值

指向使用列表视图控件的标头控件的指针。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetHeader](/windows/desktop/api/commctrl/nf-commctrl-listview_getheader)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetColumnOrderArray](#getcolumnorderarray)。

## <a name="gethotcursor"></a>  CListCtrl::GetHotCursor

检索用于列表视图控件启用热跟踪时使用的光标。

```
HCURSOR GetHotCursor();
```

### <a name="return-value"></a>返回值

到当前正由列表视图控件的热游标资源句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetHotCursor](/windows/desktop/api/commctrl/nf-commctrl-listview_gethotcursor)，如 Windows SDK 中所述。 热光标，仅在可见时启用了悬停选择，将显示当光标经过任何列表视图项。 通过设置扩展样式 LVS_EX_TRACKSELECT 启用悬停选择。

### <a name="example"></a>示例

```cpp
        // Set the hot cursor to be the system app starting cursor.
        HCURSOR hCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
        m_myListCtrl.SetHotCursor(hCursor);
        ASSERT(m_myListCtrl.GetHotCursor() == hCursor);
```

## <a name="gethotitem"></a>  CListCtrl::GetHotItem

检索当前光标下的列表视图项。

```
int GetHotItem();
```

### <a name="return-value"></a>返回值

列表视图控件的当前热项的索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetHotItem](/windows/desktop/api/commctrl/nf-commctrl-listview_gethotitem)，如 Windows SDK 中所述。 热项的定义如下启用热跟踪 （和将鼠标悬停在所选内容） 时的当前选定的项。

如果启用热跟踪后，当用户悬停在列表视图项上时，无需使用鼠标按钮自动突出显示的项标签。

### <a name="example"></a>示例

```cpp
    // Set the hot item to the first item only if no other item is
    // highlighted.
    if (m_myListCtrl.GetHotItem() == -1)
        m_myListCtrl.SetHotItem(0);
```

## <a name="gethovertime"></a>  CListCtrl::GetHoverTime

检索当前的悬停时间的列表视图控件。

```
DWORD GetHoverTime() const;
```

### <a name="return-value"></a>返回值

返回延迟，以毫秒为单位，鼠标光标必须将鼠标指针悬停在某个项目上之前处于选中状态。 如果返回值为-1，然后悬停时间是默认悬停时间。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetHoverTime](/windows/desktop/api/commctrl/nf-commctrl-listview_gethovertime)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        // If the hover time is the default set to 1 sec.
        DWORD dwTime = m_myListCtrl.GetHoverTime();
        if (dwTime == -1)
            m_myListCtrl.SetHoverTime(1000);
```

## <a name="getimagelist"></a>  CListCtrl::GetImageList

检索用于绘图的列表视图项的图像列表的句柄。

```
CImageList* GetImageList(int nImageList) const;
```

### <a name="parameters"></a>参数

*nImageList*<br/>
值，该值指定要检索的图像列表。 它可以是下列值之一：

- 使用大图标 LVSIL_NORMAL 图像列表。

- 使用小图标 LVSIL_SMALL 图像列表。

- 状态图像的 LVSIL_STATE 图像列表。

### <a name="return-value"></a>返回值

指向用于绘制列表视图项的图像列表的指针。

### <a name="example"></a>示例

```cpp
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == NULL);
m_myListCtrl.SetImageList(&m_lcImageList, LVSIL_NORMAL);
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == &m_lcImageList);
```

## <a name="getinsertmark"></a>  CListCtrl::GetInsertMark

检索插入标记的当前位置。

```
BOOL GetInsertMark(LPLVINSERTMARK lvim) const;
```

### <a name="parameters"></a>参数

*lvim*<br/>
一个指向[LVINSERTMARK](/windows/desktop/api/commctrl/ns-commctrl-lvinsertmark)结构，它包含插入标记的信息。

### <a name="return-value"></a>返回值

否则返回如果成功，则为 TRUE 或 FALSE。 如果返回 FALSE 的大小以`cbSize`的成员`LVINSERTMARK`结构不等于该结构的实际大小。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETINSERTMARK](/windows/desktop/Controls/lvm-getinsertmark)消息，如 Windows SDK 中所述。

## <a name="getinsertmarkcolor"></a>  CListCtrl::GetInsertMarkColor

检索插入标记的当前颜色。

```
COLORREF GetInsertMarkColor() const;
```

### <a name="return-value"></a>返回值

返回[COLORREF](/windows/desktop/gdi/colorref)结构，其中包含插入点的颜色。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETINSERTMARKCOLOR](/windows/desktop/Controls/lvm-getinsertmarkcolor)消息，如 Windows SDK 中所述。

## <a name="getinsertmarkrect"></a>  CListCtrl::GetInsertMarkRect

检索绑定的插入点的矩形。

```
int GetInsertMarkRect(LPRECT pRect) const;
```

### <a name="parameters"></a>参数

*pRect*<br/>
指向`RECT`结构，其中包含绑定的插入点的矩形的坐标。

### <a name="return-value"></a>返回值

返回以下值之一：

- **0**未找到插入点。

- **1**找到插入点。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETINSERTMARKRECT](/windows/desktop/Controls/lvm-getinsertmarkrect)消息，如 Windows SDK 中所述。

## <a name="getitem"></a>  Clistctrl:: Getitem

检索某些或所有列表视图项的特性。

```
BOOL GetItem(LVITEM* pItem) const;
```

### <a name="parameters"></a>参数

*pItem*<br/>
指向[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)接收项的特性的结构。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`LVITEM`结构指定或接收的列表视图项的属性。

## <a name="getitemcount"></a>  CListCtrl::GetItemCount

检索在列表视图控件中的项的数目。

```
int GetItemCount() const;
```

### <a name="return-value"></a>返回值

在列表视图控件中的项的数目。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::DeleteItem](#deleteitem)。

## <a name="getitemdata"></a>  CListCtrl::GetItemData

检索与指定的项关联的 32 位应用程序特定值`nItem`。

```
DWORD_PTR GetItemData(int nItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其数据的列表项的索引。

### <a name="return-value"></a>返回值

与指定项关联一个 32 位应用程序特定值。

### <a name="remarks"></a>备注

此值是`lParam`的成员[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，如 Windows SDK 中所述

### <a name="example"></a>示例

```cpp
    // If any item's data is equal to zero then reset it to -1.
    for (int i=0; i < m_myListCtrl.GetItemCount(); i++)
    {
        if (m_myListCtrl.GetItemData(i) == 0)
        {
            m_myListCtrl.SetItemData(i, (DWORD) -1);
        }
    }
```

## <a name="getitemindexrect"></a>  CListCtrl::GetItemIndexRect

检索当前的列表视图控件中的子项的全部或部分的边框。

```
BOOL GetItemIndexRect(
    PLVITEMINDEX pItemIndex,
    int iColumn,
    int rectType,
    LPRECT pRect) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*pItemIndex*|[in]指向[LVITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb774762)子项的父项的结构。<br /><br /> 调用方负责分配和设置的成员[LVITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb774762)结构。 此参数不能为 NULL。|
|*iColumn*|[in]在控件中列的从零开始的索引。|
|*rectType*|[in]为其检索边框的列表视图子项的部分。 指定下列值之一：<br /><br /> LVIR_BOUNDS-返回整个子项，包括图标和标签的边框。<br /><br /> LVIR_ICON-返回的图标或小图标的子项的边框。<br /><br /> LVIR_LABEL-返回子项文本的边框。|
|*pRect*|[out]指向[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)接收该子项的边框的相关信息的结构。<br /><br /> 调用方负责分配[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构。 此参数不能为 NULL。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETITEMINDEXRECT](/windows/desktop/Controls/lvm-getitemindexrect)消息，Windows SDK 中所述。 有关详细信息，请参阅[ListView_GetItemIndexRect 宏](/windows/desktop/api/commctrl/nf-commctrl-listview_getitemindexrect)。

### <a name="example"></a>示例

下面的代码示例定义一个变量， `m_listCtrl`，即用于访问当前的列表视图控件。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示了`GetGroupRect`方法。 在输入此代码之前我们创建的列表视图控件的示例显示两个列标题"ClientID"和"等级"为报告视图中。 下面的代码示例绘制这两个列中的第二个子项周围三维矩形。

```cpp
    // GetItemIndexRect
    // Get the rectangle that bounds the second item in the first group.
    LVITEMINDEX lvItemIndex;
    lvItemIndex.iGroup = 0;
    lvItemIndex.iItem = 1;
    CRect rect;
    BOOL bRet = m_listCtrl.GetItemIndexRect(
        &lvItemIndex, 0, LVIR_BOUNDS, &rect);

    // Draw a red rectangle around the item.
    m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(255, 0, 0), RGB(255, 0, 0) );
```

## <a name="getitemposition"></a>  CListCtrl::GetItemPosition

检索的列表视图项的位置。

```
BOOL GetItemPosition(
    int nItem,
    LPPOINT lpPoint) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其位置的项的索引。

*lpPoint*<br/>
地址[点](https://msdn.microsoft.com/library/windows/desktop/dd162805)接收项的左上角的位置的结构视图中协调。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        POINT pt;

        // Move all items in the list control 100 pixels to the right.
        UINT i, nCount = m_myListCtrl.GetItemCount();

        for (i=0; i < nCount; i++)
        {
            m_myListCtrl.GetItemPosition(i, &pt);
            pt.x += 100;
            m_myListCtrl.SetItemPosition(i, pt);
        }
```

## <a name="getitemrect"></a>  CListCtrl::GetItemRect

检索当前视图中的项的全部或部分的边框。

```
BOOL GetItemRect(
    int nItem,
    LPRECT lpRect,
    UINT nCode) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其位置的项的索引。

*lpRect*<br/>
地址[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构，它接收的边框。

*nCode*<br/>
要为其检索边框的列表视图项的一部分。 它可以是下列值之一：

- LVIR_BOUNDS 返回整个项，包括图标和标签的边框。

- LVIR_ICON 返回的图标或小图标的边框。

- LVIR_LABEL 返回项文本的边框。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
// OnClick is the handler for the NM_CLICK notification
void CListCtrlDlg::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;

    // Get the current mouse location and convert it to client
    // coordinates.
    CPoint pos( ::GetMessagePos() );
    ScreenToClient(&pos);

    // Get indexes of the first and last visible items in
    // the listview control.
    int index = m_myListCtrl.GetTopIndex();
    int last_visible_index = index + m_myListCtrl.GetCountPerPage();
    if (last_visible_index > m_myListCtrl.GetItemCount())
        last_visible_index = m_myListCtrl.GetItemCount();

    // Loop until number visible items has been reached.
    while (index <= last_visible_index)
    {
        // Get the bounding rectangle of an item. If the mouse
        // location is within the bounding rectangle of the item,
        // you know you have found the item that was being clicked.
        CRect r;
        m_myListCtrl.GetItemRect(index, &r, LVIR_BOUNDS);
        if (r.PtInRect(pia->ptAction))
        {
            UINT flag = LVIS_SELECTED | LVIS_FOCUSED;
            m_myListCtrl.SetItemState(index, flag, flag);
            break;
        }

        // Get the next item in listview control.
        index++;
    }
}
```

## <a name="getitemspacing"></a>  CListCtrl::GetItemSpacing

计算当前的列表视图控件中的项之间的间距。

```
BOOL GetItemSpacing(
    BOOL fSmall,
    int* pnHorzSpacing,
    int* pnVertSpacing) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*fSmall*|[in]要为其检索项间距的视图。 为小图标视图中，或 FALSE 的图标视图指定为 TRUE。|
|*pnHorzSpacing*|[out]包含项之间的水平间距。|
|*pnVertSpacing*|[out]包含项之间的垂直间距。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法将发送[LVM_GETITEMSPACING](/windows/desktop/Controls/lvm-getitemspacing)消息，Windows SDK 中所述。

## <a name="getitemstate"></a>  CListCtrl::GetItemState

检索的列表视图项的状态。

```
UINT GetItemState(
    int nItem,
    UINT nMask) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其状态的项的索引。

*nMask*<br/>
指定用于返回的项的状态标志的掩码。

### <a name="return-value"></a>返回值

指定列表的状态标志查看项。

### <a name="remarks"></a>备注

通过指定项的状态`state`的成员[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，如 Windows SDK 中所述。 指定或更改项的状态时`stateMask`成员指定你想要更改的状态位。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetTopIndex](#gettopindex)。

## <a name="getitemtext"></a>  CListCtrl::GetItemText

检索列表视图项或子项的文本。

```
int GetItemText(
    int nItem,
    int nSubItem,
    LPTSTR lpszText,
    int nLen) const;

CString GetItemText(
    int nItem,
    int nSubItem) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要检索其文本的项的索引。

*nSubItem*<br/>
指定要检索其文本的子项。

*lpszText*<br/>
要接收的项文本的字符串指针。

*nLen*<br/>
指向缓冲区的长度*lpszText*。

### <a name="return-value"></a>返回值

返回的版本**int**返回检索到的字符串的长度。

返回的版本`CString`返回项文本。

### <a name="remarks"></a>备注

如果*nSubItem*为零，此函数可检索的项标签; 如果*nSubItem*为非零值，它将检索该子项的文本。 有关子项参数的详细信息，请参阅的讨论[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema) Windows SDK 中的结构。

## <a name="getnextitem"></a>  CListCtrl::GetNextItem

搜索列表查看具有指定的属性并且具有与给定项的指定的关系的项。

```
int GetNextItem(
    int nItem,
    int nFlags) const;
```

### <a name="parameters"></a>参数

*nItem*<br/>
要开始使用，搜索的项，则为-1 以查找与指定的标志相匹配的第一项的索引。 从搜索中排除指定的项本身。

*nFlags*<br/>
几何之间关系的指定的项和请求项的状态请求的项。 几何关系可以是下列值之一：

- LVNI_ABOVE 搜索高于指定的项的项。

- 按索引 （默认值） 的后续项 LVNI_ALL 搜索。

- 低于指定的项的项的 LVNI_BELOW 搜索。

- LVNI_TOLEFT 搜索指定项的左侧的项。

- LVNI_TORIGHT 搜索指定项的右侧的项。

该状态可以是零，也可以是一个或多个值：

- LVNI_DROPHILITED 该项不具有 LVIS_DROPHILITED 状态标志设置。

- LVNI_FOCUSED 该项不具有 LVIS_FOCUSED 状态标志设置。

- LVNI_SELECTED 该项不具有 LVIS_SELECTED 状态标志设置。

如果项不具有所有指定的状态标志设置，继续搜索下一个项。

### <a name="return-value"></a>返回值

如果成功，下一项或否则为-1 的索引。

## <a name="getnextitemindex"></a>  CListCtrl::GetNextItemIndex

检索具有一组指定的属性的当前列表视图控件中项的索引。

```
BOOL GetNextItemIndex(
    PLVITEMINDEX pItemIndex,
    int nFlags) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*pItemIndex*|[in、 out]指向[LVITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb774762)结构，它描述的项开始执行搜索，则为-1 以查找匹配中的标志的第一项*nFlags*参数。<br /><br /> 如果此方法成功，`LVITEMINDEX`结构描述通过搜索找到的项。|
|*nFlags*|[in]按位组合 (OR) 标志，用于指定如何执行搜索。<br /><br /> 搜索可以依赖索引、 状态或目标项的外观或由指定的目标项的物理位置相对于项*pItemIndex*参数。 有关详细信息，请参阅*标志*中的参数[LVM_GETNEXTITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb761059)消息。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

调用方负责分配和设置的成员`LVITEMINDEX`指向结构*pItemIndex*参数。

此方法将发送[LVM_GETNEXTITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb761059)消息，Windows SDK 中所述。

## <a name="getnextselecteditem"></a>  CListCtrl::GetNextSelectedItem

获取由标识的列表项的索引*pos*，然后设置*pos*为位置值。

```
int GetNextSelectedItem(POSITION& pos) const;
```

### <a name="parameters"></a>参数

*pos*<br/>
对以前调用返回的位置值的引用`GetNextSelectedItem`或`GetFirstSelectedItemPosition`。 通过此调用到下一个位置更新的值。

### <a name="return-value"></a>返回值

由标识的列表项的索引*pos*。

### <a name="remarks"></a>备注

可以使用`GetNextSelectedItem`如果建立调用一次的初始位置的向前迭代循环中`GetFirstSelectedItemPosition`。

您必须确保你的位置值有效。 如果无效，Microsoft 基础类库的调试版本断言。

### <a name="example"></a>示例

下面的代码示例演示此函数的用法。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getnumberofworkareas"></a>  CListCtrl::GetNumberOfWorkAreas

检索列表视图控件的工作区的当前数目。

```
UINT GetNumberOfWorkAreas() const;
```

### <a name="return-value"></a>返回值

不使用这一次。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetNumberOfWorkAreas](/windows/desktop/api/commctrl/nf-commctrl-listview_getnumberofworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        UINT i, uCount = m_myListCtrl.GetNumberOfWorkAreas();
        LPRECT lpRects = (LPRECT) malloc(uCount*sizeof(RECT));

        if (lpRects != NULL)
        {
            // Dump all of the work area dimensions.
            m_myListCtrl.GetWorkAreas(uCount, lpRects);

            for (i=0; i < uCount; i++)
            {
                TRACE(_T("Work area %d; left = %d, top = %d, right = %d, ")
                    _T("bottom = %d\r\n"),
                    i, lpRects[i].left, lpRects[i].top, lpRects[i].right,
                    lpRects[i].bottom);
            }

            free(lpRects);
        }
        else
        {
            TRACE(_T("Couldn't allocate enough memory!"));
        }
```

## <a name="getoutlinecolor"></a>  CListCtrl::GetOutlineColor

检索列表视图控件的边框的颜色。

```
COLORREF GetOutlineColor() const;
```

### <a name="return-value"></a>返回值

返回[COLORREF](/windows/desktop/gdi/colorref)结构，它包含轮廓颜色。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETOUTLINECOLOR](/windows/desktop/Controls/lvm-getoutlinecolor)消息，如 Windows SDK 中所述。

## <a name="getorigin"></a>  CListCtrl::GetOrigin

检索为列表视图控件的当前视图原点。

```
BOOL GetOrigin(LPPOINT lpPoint) const;
```

### <a name="parameters"></a>参数

*lpPoint*<br/>
地址[点](https://msdn.microsoft.com/library/windows/desktop/dd162805)接收视图原点的结构。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。 但是，如果控件位于报表视图中，返回值始终为零。

## <a name="getselectedcolumn"></a>  CListCtrl::GetSelectedColumn

检索列表控件中当前所选列的索引。

```
UINT GetSelectedColumn() const;
```

### <a name="return-value"></a>返回值

所选列的索引。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETSELECTEDCOLUMN](/windows/desktop/Controls/lvm-getselectedcolumn)消息，如 Windows SDK 中所述。

## <a name="getselectedcount"></a>  CListCtrl::GetSelectedCount

检索列表视图控件中选定项的数目。

```
UINT GetSelectedCount() const;
```

### <a name="return-value"></a>返回值

在列表视图控件中选定项的数目。

### <a name="example"></a>示例

```cpp
        UINT i, uSelectedCount = m_myListCtrl.GetSelectedCount();
        int  nItem = -1;

        // Update all of the selected items.
        if (uSelectedCount > 0)
        {
            for (i=0; i < uSelectedCount; i++)
            {
                nItem = m_myListCtrl.GetNextItem(nItem, LVNI_SELECTED);
                ASSERT(nItem != -1);
                m_myListCtrl.Update(nItem);
            }
        }
```

## <a name="getselectionmark"></a>  CListCtrl::GetSelectionMark

检索列表视图控件的选择内容标记。

```
int GetSelectionMark();
```

### <a name="return-value"></a>返回值

从零开始的选择内容标记或则没有选择内容标记为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetSelectionMark](/windows/desktop/api/commctrl/nf-commctrl-listview_getselectionmark)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the selection mark to the first item only if no other item is
    // selected.
    if (m_myListCtrl.GetSelectionMark() == -1)
        m_myListCtrl.SetSelectionMark(0);
```

## <a name="getstringwidth"></a>  CListCtrl::GetStringWidth

确定显示给定字符串的所有所需的最小列宽度。

```
int GetStringWidth(LPCTSTR lpsz) const;
```

### <a name="parameters"></a>参数

*lpsz*<br/>
要确定其宽度的以 null 结尾的字符串的地址。

### <a name="return-value"></a>返回值

宽度，以像素为单位通过指向的字符串*lpsz*。

### <a name="remarks"></a>备注

返回的宽度会考虑控件的当前字体和列边距，但不是小图标的宽度。

### <a name="example"></a>示例

```cpp
        CString strColumn;
        int nWidth;

        // Insert six columns in the list view control. Make the width of
        // the column be the width of the column header plus 50%.
        for (int i = 0; i < 6; i++)
        {
            strColumn.Format(_T("column %d"), i);
            nWidth = 3*m_myListCtrl.GetStringWidth(strColumn)/2;
            m_myListCtrl.InsertColumn(i, strColumn, LVCFMT_LEFT, nWidth);
        }
```

## <a name="getsubitemrect"></a>  CListCtrl::GetSubItemRect

检索列表视图控件中的项的边框。

```
BOOL GetSubItemRect(
    int iItem,
    int iSubItem,
    int nArea,
    CRect& ref);
```

### <a name="parameters"></a>参数

*iItem*<br/>
子项的父项的索引。

*iSubItem*<br/>
该子项 1 开始的索引。

*nArea*<br/>
确定的边界矩形 （列表视图子项） 的一部分来检索。 边界矩形的部分 （图标、 标签，或两者） 指定的按位 OR 运算符应用到一个或多个以下值：

- LVIR_BOUNDS 返回整个项，包括图标和标签的边框。

- LVIR_ICON 返回的图标或小图标的边框。

- LVIR_LABEL 返回整个项，包括图标和标签的边框。 这等同于 LVIR_BOUNDS。

*ref*<br/>
引用[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，它包含子项的坐标的边框。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetSubItemRect](/windows/desktop/api/commctrl/nf-commctrl-listview_getsubitemrect)，如 Windows SDK 中所述。

## <a name="gettextbkcolor"></a>  CListCtrl::GetTextBkColor

检索列表视图控件的文本背景色。

```
COLORREF GetTextBkColor() const;
```

### <a name="return-value"></a>返回值

用指定的 RGB 颜色的 32 位值。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::SetTextBkColor](#settextbkcolor)。

## <a name="gettextcolor"></a>  CListCtrl::GetTextColor

检索列表视图控件的文本颜色。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>返回值

用指定的 RGB 颜色的 32 位值。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::SetTextColor](#settextcolor)。

## <a name="gettileinfo"></a>  CListCtrl::GetTileInfo

检索有关列表视图控件中的磁贴的信息。

```
BOOL GetTileInfo(PLVTILEINFO pti) const;
```

### <a name="parameters"></a>参数

*pti*<br/>
一个指向[LVTILEINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvtileinfo)接收磁贴信息的结构。

### <a name="return-value"></a>返回值

不使用返回的值。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETTILEINFO](/windows/desktop/Controls/lvm-gettileinfo)消息，如 Windows SDK 中所述。

## <a name="gettileviewinfo"></a>  CListCtrl::GetTileViewInfo

检索有关磁贴视图中的列表视图控件的信息。

```
BOOL GetTileViewInfo(PLVTILEVIEWINFO ptvi) const;
```

### <a name="parameters"></a>参数

*ptvi*<br/>
一个指向[LVTILEVIEWINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvtileviewinfo)接收检索到的信息的结构。

### <a name="return-value"></a>返回值

不使用返回的值。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETTILEVIEWINFO](/windows/desktop/Controls/lvm-gettileviewinfo)消息，如 Windows SDK 中所述。

## <a name="gettooltips"></a>  CListCtrl::GetToolTips

检索列表视图控件用于显示工具提示的工具提示控件。

```
CToolTipCtrl* GetToolTips() const;
```

### <a name="return-value"></a>返回值

一个指向[CToolTipCtrl](ctooltipctrl-class.md)对象将由列表控件。 如果[创建](#create)成员函数使用的样式 LVS_NOTOOLTIPS、 使用任何工具提示，并返回 NULL。

### <a name="remarks"></a>备注

此成员函数可实现 Win32 消息的行为[LVM_GETTOOLTIPS](/windows/desktop/Controls/lvm-gettooltips)，如 Windows SDK 中所述。 MFC 实现`GetToolTips`返回`CToolTipCtrl`对象，由列表控件，而不是工具提示控件的句柄。

### <a name="example"></a>示例

```cpp
        CToolTipCtrl* pTip = m_myListCtrl.GetToolTips();
        if (NULL != pTip)
        {
            pTip->UpdateTipText(_T("I'm a list view!"), &m_myListCtrl,
                IDD_MYLISTCTRL);
        }
```

## <a name="gettopindex"></a>  CListCtrl::GetTopIndex

当在列表视图或报表视图中检索的最顶层的可见项的索引。

```
int GetTopIndex() const;
```

### <a name="return-value"></a>返回值

最顶层的可见项的索引。

### <a name="example"></a>示例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Select all of the items that are completely visible.
        int n = m_myListCtrl.GetTopIndex();
        int nLast = n + m_myListCtrl.GetCountPerPage();

        for (; n < nLast; n++)
        {
            m_myListCtrl.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
            ASSERT(m_myListCtrl.GetItemState(n, LVIS_SELECTED) == LVIS_SELECTED);
        }
```

## <a name="getview"></a>  CListCtrl::GetView

获取列表视图控件的视图。

```
DWORD GetView() const;
```

### <a name="return-value"></a>返回值

在列表视图控件的当前视图。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_GETVIEW](/windows/desktop/Controls/lvm-getview)消息，如 Windows SDK 中所述。

## <a name="getviewrect"></a>  CListCtrl::GetViewRect

检索列表视图控件中的所有项的边框。

```
BOOL GetViewRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>参数

*lpRect*<br/>
地址[RECT](https://msdn.microsoft.com/library/windows/desktop/dd162897)结构。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

列表视图必须在图标视图或小图标视图中。

## <a name="getworkareas"></a>  CListCtrl::GetWorkAreas

检索列表视图控件的当前工作区。

```
void GetWorkAreas(
    int nWorkAreas,
    LPRECT prc) const;
```

### <a name="parameters"></a>参数

*nWorkAreas*<br/>
数`RECT`结构中包含*中国*数组。

*中华人民共和国*<br/>
指向数组的指针`RECT`结构 (或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象) 的接收工作区域的列表视图控件。 这些结构中的值是在工作区坐标。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_GetWorkAreas](/windows/desktop/api/commctrl/nf-commctrl-listview_getworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetNumberOfWorkAreas](#getnumberofworkareas)。

## <a name="hasgroup"></a>  CListCtrl::HasGroup

确定列表视图控件是否具有指定的组。

```
BOOL HasGroup(int iGroupId) const;
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
所请求的组的标识符。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE FALSE 失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_HASGROUP](/windows/desktop/Controls/lvm-hasgroup)消息，如 Windows SDK 中所述。

## <a name="hittest"></a>  CListCtrl::HitTest

确定哪个列表视图项，如果任何，在指定位置。

```
int HitTest(LVHITTESTINFO* pHitTestInfo) const;

int HitTest(
    CPoint pt,
    UINT* pFlags = NULL) const;
```

### <a name="parameters"></a>参数

*pHitTestInfo*<br/>
地址`LVHITTESTINFO`结构，其中包含要进行命中测试和该位置接收的命中测试结果的相关信息。

*pt*<br/>
要测试的点。

*pFlags*<br/>
指向接收有关测试的结果的整数。 请参阅的说明`flags`的成员[LVHITTESTINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvhittestinfo) Windows SDK 中的结构。

### <a name="return-value"></a>返回值

指定的位置处的项的索引*pHitTestInfo*(如果有） 则否则为-1。

### <a name="remarks"></a>备注

可以使用该结构的 LVHT_ABOVE、 LVHT_BELOW、 LVHT_TOLEFT 和 LVHT_TORIGHT 值`flag`成员以确定是否滚动列表视图控件的内容。 两个这些标志可以组合使用，例如，如果位置上方和客户端区域的左侧。

你可以测试该结构的 LVHT_ONITEM 值`flag`成员以确定给定的位置是否位于列表视图项。 此值是该结构的 LVHT_ONITEMICON、 LVHT_ONITEMLABEL 和 LVHT_ONITEMSTATEICON 值的按位 OR 操作`flag`成员。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    CPoint point(pia->ptAction);

    // Select the item the user clicked on.
    UINT uFlags;
    int nItem = m_myListCtrl.HitTest(point, &uFlags);

    if (uFlags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItem(nItem, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED,
            LVIS_SELECTED, 0);
    }

    *pResult = 0;
}
```

## <a name="insertcolumn"></a>  CListCtrl::InsertColumn

在列表视图控件中插入一个新列。

```
int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,
    LPCTSTR lpszColumnHeading,
    int nFormat = LVCFMT_LEFT,
    int nWidth = -1,
    int nSubItem = -1);
```

### <a name="parameters"></a>参数

*nCol*<br/>
新的列的索引。

*pColumn*<br/>
地址`LVCOLUMN`结构，其中包含新列的属性。

*lpszColumnHeading*<br/>
包含列的标题的字符串的地址。

*nFormat*<br/>
整数，指定的列的对齐方式。 它可以是下列值之一： LVCFMT_LEFT、 LVCFMT_RIGHT 或 LVCFMT_CENTER。

*nWidth*<br/>
列中，以像素为单位的宽度。 如果此参数为-1，未设置列的宽度。

*nSubItem*<br/>
与列关联的子项的索引。 如果此参数为-1，则没有子项是与列相关联。

### <a name="return-value"></a>返回值

如果成功，则新列或否则为-1 的索引。

### <a name="remarks"></a>备注

在列表视图控件中的最左侧列必须是左对齐。

[LVCOLUMN](/windows/desktop/api/commctrl/ns-commctrl-taglvcolumna)结构包含在报表视图中的列的属性。 它还用于接收有关列的信息。 此结构是 Windows SDK 中所述。

## <a name="insertgroup"></a>  CListCtrl::InsertGroup

将组插入到列表视图控件。

```
LRESULT InsertGroup(
    int index,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>参数

*index*<br/>
在组很要插入的项的索引。

*pgrp*<br/>
一个指向[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构，它包含要添加的组。

### <a name="return-value"></a>返回值

如果操作失败，则返回的项的组添加到，则为-1 的索引。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_INSERTGROUP](/windows/desktop/Controls/lvm-insertgroup)消息，如 Windows SDK 中所述。

## <a name="insertgroupsorted"></a>  CListCtrl::InsertGroupSorted

将指定的组插入到的组的排序列表。

```
LRESULT InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert);
```

### <a name="parameters"></a>参数

*pStructInsert*<br/>
一个指向[LVINSERTGROUPSORTED](/windows/desktop/api/commctrl/ns-commctrl-taglvinsertgroupsorted)结构，其中包含要插入的组。

### <a name="return-value"></a>返回值

不使用返回的值。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_INSERTGROUPSORTED](/windows/desktop/Controls/lvm-insertgroupsorted)消息，如 Windows SDK 中所述。

## <a name="insertitem"></a>  CListCtrl::InsertItem

将项插入到列表视图控件。

```
int InsertItem(const LVITEM* pItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem,
    int nImage);

int InsertItem(
    UINT nMask,
    int nItem,
    LPCTSTR lpszItem,
    UINT nState,
    UINT nStateMask,
    int nImage,
    LPARAM lParam);
```

### <a name="parameters"></a>参数

*pItem*<br/>
指向[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，它指定项的特性，如 Windows SDK 中所述。

*nItem*<br/>
要插入的项的索引。

*lpszItem*<br/>
包含项的标签或 LPSTR_TEXTCALLBACK，如果项是回调项的字符串的地址。 有关回调项的信息，请参阅[clistctrl:: Getcallbackmask](#getcallbackmask)。

*nImage*<br/>
项的图像或 I_IMAGECALLBACK 如果项是回调项的索引。 有关回调项的信息，请参阅[clistctrl:: Getcallbackmask](#getcallbackmask)。

*nMask*<br/>
*NMask*参数指定哪一项作为参数传递的属性都有效。 它可以是一个或多个掩码值中所述[LVITEM 结构](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)Windows SDK 中。 可以使用按位 OR 运算符组合的有效值。

*nState*<br/>
指示项的状态、 状态图像和覆盖图像。 请参阅 Windows SDK 主题[LVITEM 结构](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)有关详细信息和[列表视图项状态](/windows/desktop/Controls/list-view-item-states)有关有效的标志的列表。

*nStateMask*<br/>
指示将检索或修改状态成员的哪些位。 请参阅[LVITEM 结构](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)Windows SDK for 的详细信息中。

*lParam*<br/>
与项关联一个 32 位应用程序特定值。 如果指定此参数，则必须设置*nMask*属性 LVIF_PARAM。

### <a name="return-value"></a>返回值

如果成功，则新的项或否则为-1 的索引。

### <a name="remarks"></a>备注

调用此方法可能会导致 LVM_INSERTITEM 消息要发送到控件窗口。 该控件相关联的消息处理程序可能无法设置某些条件 （如使用的窗口样式，如 LVS_OWNERDRAW） 下的项文本。 有关这些条件的详细信息，请参阅[LVM_INSERTITEM](/windows/desktop/Controls/lvm-insertitem) Windows SDK 中。

### <a name="example"></a>示例

```cpp
        CString strText;
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Insert 10 items in the list view control.
        for (int i = 0; i < 10; i++)
        {
            strText.Format(TEXT("item %d"), i);

            // Insert the item, select every other item.
            m_myListCtrl.InsertItem(LVIF_TEXT | LVIF_STATE, i, strText,
                (i % 2) == 0 ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, 0);

            // Initialize the text of the subitems.
            for (int j = 1; j < nColumnCount; j++)
            {
                strText.Format(TEXT("sub-item %d %d"), i, j);
                m_myListCtrl.SetItemText(i, j, strText);
            }
        }
```

## <a name="insertmarkhittest"></a>  CListCtrl::InsertMarkHitTest

检索与指定点最接近的插入点。

```
int InsertMarkHitTest(
    LPPOINT pPoint,
    LPLVINSERTMARK lvim) const;
```

### <a name="parameters"></a>参数

*pPoint*<br/>
一个指向[点](https://msdn.microsoft.com/library/windows/desktop/dd162805)结构，其中包含了点击的测试协调，相对于列表控件的客户端区域。

*lvim*<br/>
一个指向[LVINSERTMARK](/windows/desktop/api/commctrl/ns-commctrl-lvinsertmark)结构，它指定为坐标点参数定义的最近的插入点。

### <a name="return-value"></a>返回值

最近的插入点到指定点。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_INSERTMARKHITTEST](/windows/desktop/Controls/lvm-insertmarkhittest)消息，如 Windows SDK 中所述。

## <a name="isgroupviewenabled"></a>  CListCtrl::IsGroupViewEnabled

确定是否为列表视图控件启用组视图。

```
BOOL IsGroupViewEnabled() const;
```

### <a name="return-value"></a>返回值

否则返回如果启用了组视图，则为 TRUE 或 FALSE。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_ISGROUPVIEWENABLED](/windows/desktop/Controls/lvm-isgroupviewenabled)消息，如 Windows SDK 中所述。

## <a name="isitemvisible"></a>  CListCtrl::IsItemVisible

指示当前的列表视图控件中的指定的项是否可见。

```
BOOL IsItemVisible(int index) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*index*|[in]当前列表视图控件中的项的从零开始索引。|

### <a name="return-value"></a>返回值

如果指定的项为可见; 否则为 FALSE，则为 TRUE。

### <a name="remarks"></a>备注

此方法将发送[LVM_ISITEMVISIBLE](/windows/desktop/Controls/lvm-isitemvisible)消息，Windows SDK 中所述。

## <a name="mapidtoindex"></a>  CListCtrl::MapIDToIndex

映射到索引的当前列表视图控件中的项的唯一 ID。

```
UINT MapIDToIndex(UINT id) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*id*|[in]项的唯一 ID。|

### <a name="return-value"></a>返回值

当前索引为指定的 id。 的

### <a name="remarks"></a>备注

列表视图控件在内部跟踪由索引的项。 这可以出现的问题，因为索引可以在控件的生存期内更改。 在列表视图控件可以标记 id 的项时创建项时，您可以使用此 ID 在列表视图控件的生命周期内保证唯一性。

请注意在多线程环境中保证的索引是仅在承载列表视图控件，不在后台线程的线程上。

此方法将发送[LVM_MAPIDTOINDEX](https://msdn.microsoft.com/library/windows/desktop/bb761137)消息，Windows SDK 中所述。

## <a name="mapindextoid"></a>  CListCtrl::MapIndexToID

将当前的列表视图控件中的项的索引映射到唯一的 id。

```
UINT MapIndexToID(UINT index) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*index*|[in]项的从零开始的索引。|

### <a name="return-value"></a>返回值

指定项的唯一 ID。

### <a name="remarks"></a>备注

列表视图控件在内部跟踪由索引的项。 这可以出现的问题，因为索引可以在控件的生存期内更改。 当创建项时，列表视图控件可以标记 id 的项。 此 ID 可用于在列表视图控件的生存期内访问特定项。

请注意在多线程环境中保证的索引是仅在承载列表视图控件，不在后台线程的线程上。

此方法将发送[LVM_MAPINDEXTOID](/windows/desktop/Controls/lvm-mapindextoid)消息，Windows SDK 中所述。

### <a name="example"></a>示例

下面的代码示例定义一个变量， `m_listCtrl`，即用于访问当前的列表视图控件。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示了`MapIndexToID`方法。 此代码示例的前面部分，我们将创建显示标题"ClientID"和"等级"为报告视图中的两个列的列表视图控件。 下面的示例将每个列表视图项的索引映射到一个标识号，然后检索每个标识号的索引。 最后，示例将报告是否已检索原始索引。

```cpp
    // MapIndexToID
    int iCount = m_listCtrl.GetItemCount();
    UINT nId = 0;
    UINT nIndex = 0;
    for (int iIndexOriginal = 0; iIndexOriginal < iCount; iIndexOriginal++)
    {
        // Map index to ID.
        nId = m_listCtrl.MapIndexToID((UINT)iIndexOriginal);

        // Map ID to index.
        nIndex = m_listCtrl.MapIDToIndex(nId);

        if (nIndex != (UINT)(iIndexOriginal))
        {
            CString str;
            str.Format(_T("Mapped index (%d) is not equal to original index (%d)"),
                nIndex, (UINT)(iIndexOriginal));
            AfxMessageBox(str);
            return;
        }
    }
    AfxMessageBox(_T("The mapped indexes and original indexes are equal."),
        MB_ICONINFORMATION);
```

## <a name="movegroup"></a>  CListCtrl::MoveGroup

将移动指定分组到指定列表视图控件的零开始的索引。

```
LRESULT MoveGroup(
    int iGroupId,
    int toIndex);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要移动的组的标识符。

*toIndex*<br/>
从零开始的索引，组都是要移动。

### <a name="return-value"></a>返回值

不使用返回的值。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_MOVEGROUP](/windows/desktop/Controls/lvm-movegroup)消息，如 Windows SDK 中所述。

## <a name="moveitemtogroup"></a>  CListCtrl::MoveItemToGroup

将指定的项移动到指定的组。

```
void MoveItemToGroup(
    int idItemFrom,
    int idGroupTo);
```

### <a name="parameters"></a>参数

*idItemFrom*<br/>
[in]要移动的项的索引。

*idGroupTo*<br/>
[in]项将移到的组的标识符。

### <a name="remarks"></a>备注

> [!NOTE]
>  当前未实现此方法。

此方法来模拟的功能[LVM_MOVEITEMTOGROUP](/windows/desktop/Controls/lvm-moveitemtogroup)消息，如 Windows SDK 中所述。

## <a name="redrawitems"></a>  CListCtrl::RedrawItems

强制重新绘制的项的范围的列表视图控件。

```
BOOL RedrawItems(
    int nFirst,
    int nLast);
```

### <a name="parameters"></a>参数

*nFirst*<br/>
要进行重新绘制的第一项的索引。

*n 上次*<br/>
要进行重新绘制的最后一项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

列表视图窗口收到 WM_PAINT 消息之前，指定的项不是实际重新绘制。 若要立即重绘，调用 Windows [UpdateWindow](/windows/desktop/api/winuser/nf-winuser-updatewindow)函数之后，使用此函数。

## <a name="removeallgroups"></a>  CListCtrl::RemoveAllGroups

从列表视图控件中移除所有组。

```
void RemoveAllGroups();
```

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_REMOVEALLGROUPS](/windows/desktop/Controls/lvm-removeallgroups)消息，如 Windows SDK 中所述。

## <a name="removegroup"></a>  CListCtrl::RemoveGroup

从列表视图控件中移除指定的组。

```
LRESULT RemoveGroup(int iGroupId);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
要删除的组的标识符。

### <a name="return-value"></a>返回值

否则返回的组，如果成功，则为-1 的索引。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_REMOVEGROUP](/windows/desktop/Controls/lvm-removegroup)消息，如 Windows SDK 中所述。

## <a name="scroll"></a>  CListCtrl::Scroll

将列表视图控件的内容滚动。

```
BOOL Scroll(CSize size);
```

### <a name="parameters"></a>参数

*size*<br/>
一个`CSize`对象，指定的水平和垂直滚动，以像素为单位量。 `y`的成员*大小*除以高度 （像素） 列表视图控件的行，并通过所产生的行数将控件滚动。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="setbkcolor"></a>  CListCtrl::SetBkColor

设置列表视图控件的背景的色。

```
BOOL SetBkColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*cr*<br/>
背景色设置或没有背景色的 CLR_NONE 值。 使用背景颜色的列表视图控件重绘自身明显快于不带背景颜色。 有关信息，请参阅[COLORREF](/windows/desktop/gdi/colorref) Windows SDK 中。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetBkColor() == crBkColor);
```

## <a name="setbkimage"></a>  CListCtrl::SetBkImage

设置列表视图控件的背景图像。

```
BOOL SetBkImage(LVBKIMAGE* plvbkImage);

BOOL SetBkImage(
    HBITMAP hbm,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);

BOOL SetBkImage(
    LPTSTR pszUrl,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);
```

### <a name="parameters"></a>参数

*plvbkImage*<br/>
地址`LVBKIMAGE`包含新的背景图像信息的结构。

*hbm*<br/>
位图的句柄。

*pszUrl*<br/>
以 NULL 结尾的字符串，其中包含的背景图像的 URL。

*fTile*<br/>
如果图像平铺列表视图控件中; 在后台，非零值否则为 0。

*xOffsetPercent*<br/>
中的偏移量，以像素为单位的图像的左边缘，从列表视图控件的原点。

*yOffsetPercent*<br/>
中的偏移量，以像素为单位的图像的上边缘，从列表视图控件的原点。

### <a name="return-value"></a>返回值

返回非零，如果成功，或者以其他方式的零。

### <a name="remarks"></a>备注

> [!NOTE]
>  因为`CListCtrl::SetBkImage`使用的 OLE COM 功能，必须在使用之前初始化 OLE 库`SetBkImage`。 最好是初始化应用程序时初始化 COM 库和应用程序终止时取消初始化库。 这将自动完成在 MFC 中进行的应用程序使用的 ActiveX 技术、 OLE 自动化、 OLE 链接/嵌入或 ODBC/DAO 操作。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetBkImage](#getbkimage)。

## <a name="setcallbackmask"></a>  Clistctrl:: Setcallbackmask

设置列表视图控件的回调掩码。

```
BOOL SetCallbackMask(UINT nMask);
```

### <a name="parameters"></a>参数

*nMask*<br/>
回调掩码的新值。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Set the callback mask so that only the selected and focused states
    // are stored for each item.
    m_myListCtrl.SetCallbackMask(LVIS_SELECTED|LVIS_FOCUSED);
    ASSERT(m_myListCtrl.GetCallbackMask() ==
        (LVIS_SELECTED|LVIS_FOCUSED));
```

## <a name="setcheck"></a>  CListCtrl::SetCheck

确定列表控件项的状态图像是否可见。

```
BOOL SetCheck(
    int nItem,
    BOOL fCheck = TRUE);
```

### <a name="parameters"></a>参数

*nItem*<br/>
列表控件项的从零开始的索引。

*fCheck*<br/>
指定是否与否，项的状态图像应为可见。 默认情况下*fCheck*为 TRUE 并且状态图像是否可见。 如果*fCheck*为 FALSE 时，它不可见。

### <a name="return-value"></a>返回值

非零，如果选中该项，否则为 0。

### <a name="example"></a>示例

```cpp
        int nCount = m_myListCtrl.GetItemCount();
        BOOL fCheck = FALSE;

        // Set the check state of every other item to TRUE and
        // all others to FALSE.
        for (int i = 0; i < nCount; i++)
        {
            m_myListCtrl.SetCheck(i, fCheck);
            ASSERT((m_myListCtrl.GetCheck(i) && fCheck) ||
                (!m_myListCtrl.GetCheck(i) && !fCheck));
            fCheck = !fCheck;
        }
```

## <a name="setcolumn"></a>  CListCtrl::SetColumn

设置列表视图列的属性。

```
BOOL SetColumn(
    int nCol,
    const LVCOLUMN* pColumn);
```

### <a name="parameters"></a>参数

*nCol*<br/>
若要设置其属性的列的索引。

*pColumn*<br/>
地址[LVCOLUMN](/windows/desktop/api/commctrl/ns-commctrl-taglvcolumna)结构，其中包含新的列属性，如 Windows SDK 中所述。 该结构的`mask`成员指定哪一列属性设置。 如果`mask`成员指定 LVCF_TEXT 值，该结构的`pszText`成员是一个以 null 结尾的字符串和结构的地址`cchTextMax`成员将被忽略。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetColumn](#getcolumn)。

## <a name="setcolumnorderarray"></a>  CListCtrl::SetColumnOrderArray

设置列表视图控件的列顺序 （从左到右）。

```
BOOL SetColumnOrderArray(
    int iCount,
    LPINT piArray);
```

### <a name="parameters"></a>参数

*piArray*<br/>
指向包含 （从左到右） 在列表视图控件中列的索引值的缓冲区的指针。 缓冲区必须足够大以包含在列表视图控件中的列的总数。

*iCount*<br/>
在列表视图控件中的列数。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetColumnOrderArray](/windows/desktop/api/commctrl/nf-commctrl-listview_setcolumnorderarray)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetColumnOrderArray](#getcolumnorderarray)。

## <a name="setcolumnwidth"></a>  CListCtrl::SetColumnWidth

更改报表视图或列表视图中的列的宽度。

```
BOOL SetColumnWidth(
    int nCol,
    int cx);
```

### <a name="parameters"></a>参数

*nCol*<br/>
为设置宽度的列的索引。 在列表视图中，此参数必须为 0。

*cx*<br/>
新的列的宽度。 可以是 LVSCW_AUTOSIZE 或 LVSCW_AUTOSIZE_USEHEADER，如中所述[LVM_SETCOLUMNWIDTH](/windows/desktop/Controls/lvm-setcolumnwidth) Windows SDK 中。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

## <a name="setextendedstyle"></a>  CListCtrl::SetExtendedStyle

设置列表视图控件的当前扩展的样式。

```
DWORD SetExtendedStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>参数

*dwNewStyle*<br/>
若要使用列表视图控件的扩展样式的组合。 这些样式的描述性列表，请参阅[扩展列表视图样式](/windows/desktop/Controls/extended-list-view-styles)Windows SDK 中的主题。

### <a name="return-value"></a>返回值

使用列表视图控件的上一个扩展样式的组合。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetExtendedListViewStyle](/windows/desktop/api/commctrl/nf-commctrl-listview_setextendedlistviewstyle)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Allow the header controls item to be movable by the user.
    m_myListCtrl.SetExtendedStyle
        (m_myListCtrl.GetExtendedStyle()|LVS_EX_HEADERDRAGDROP);
```

## <a name="setgroupinfo"></a>  CListCtrl::SetGroupInfo

设置描述当前列表视图控件的指定的组的信息。

```
int SetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>参数

*iGroupId*<br/>
设置其信息的组的标识符。

*pgrp*<br/>
指向[LVGROUP](/windows/desktop/api/commctrl/ns-commctrl-taglvgroup)结构，其中包含要设置的信息。 调用方负责分配此结构并设置其成员。

### <a name="return-value"></a>返回值

如果此方法成功，则组的 ID否则为-1。

### <a name="remarks"></a>备注

此方法将发送[LVM_SETGROUPINFO](/windows/desktop/Controls/lvm-setgroupinfo)消息，Windows SDK 中所述。

## <a name="setgroupmetrics"></a>  CListCtrl::SetGroupMetrics

设置列表视图控件的组度量值。

```
void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics);
```

### <a name="parameters"></a>参数

*pGroupMetrics*<br/>
一个指向[LVGROUPMETRICS](/windows/desktop/api/commctrl/ns-commctrl-taglvgroupmetrics)结构，它包含要设置的组度量值信息。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETGROUPMETRICS](/windows/desktop/Controls/lvm-setgroupmetrics)消息，如 Windows SDK 中所述。

## <a name="sethotcursor"></a>  CListCtrl::SetHotCursor

设置为列表视图控件启用热跟踪时使用的光标。

```
HCURSOR SetHotCursor(HCURSOR hc);
```

### <a name="parameters"></a>参数

*混合连接*<br/>
游标资源，用于表示热光标的句柄。

### <a name="return-value"></a>返回值

到上一个正由列表视图控件的热游标资源句柄。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetHotCursor](/windows/desktop/api/commctrl/nf-commctrl-listview_sethotcursor)，如 Windows SDK 中所述。

此时将显示热的游标时启用了悬停选择，仅显示，如光标经过任何列表视图项。 通过设置扩展样式 LVS_EX_TRACKSELECT 启用悬停选择。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetHotCursor](#gethotcursor)。

## <a name="sethotitem"></a>  CListCtrl::SetHotItem

设置当前热列表视图控件的项。

```
int SetHotItem(int iIndex);
```

### <a name="parameters"></a>参数

*iIndex*<br/>
要设置为热项的项的从零开始索引。

### <a name="return-value"></a>返回值

以前热项的从零开始索引。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetHotItem](/windows/desktop/api/commctrl/nf-commctrl-listview_sethotitem)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetHotItem](#gethotitem)。

## <a name="sethovertime"></a>  CListCtrl::SetHoverTime

设置列表视图控件的当前悬停时间。

```
DWORD SetHoverTime(DWORD dwHoverTime = (DWORD)-1);
```

### <a name="parameters"></a>参数

*dwHoverTime*<br/>
新的延迟，以毫秒为单位，鼠标光标必须将鼠标指针悬停在某个项目上之前处于选中状态。 如果传递的默认值，则时间设置为默认悬停时间。

### <a name="return-value"></a>返回值

上一悬停时间，以毫秒为单位。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetHoverTime](/windows/desktop/api/commctrl/nf-commctrl-listview_sethovertime)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetHoverTime](#gethovertime)。

## <a name="seticonspacing"></a>  CListCtrl::SetIconSpacing

设置列表视图控件中的图标之间的间距。

```
CSize SetIconSpacing(
    int cx,
    int cy);

CSize SetIconSpacing(CSize size);
```

### <a name="parameters"></a>参数

*cx*<br/>
在 x 轴上的图标之间的距离 （以像素为单位）。

*cy*<br/>
在 y 轴上的图标之间的距离 （以像素为单位）。

*size*<br/>
一个`CSize`对象，它指定图标在 x 轴和 y 轴之间的距离 （以像素为单位）。

### <a name="return-value"></a>返回值

一个[CSize](../../atl-mfc-shared/reference/csize-class.md)对象，其中包含图标间距以前的值。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetIconSpacing](/windows/desktop/api/commctrl/nf-commctrl-listview_seticonspacing)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Leave lots of space between icons.
    m_myListCtrl.SetIconSpacing(CSize(100, 100));
```

## <a name="setimagelist"></a>  CListCtrl::SetImageList

将图像列表分配到列表视图控件。

```
CImageList* SetImageList(
    CImageList* pImageList,
    int nImageListType);
```

### <a name="parameters"></a>参数

*pImageList*<br/>
指向要分配的图像列表的指针。

*nImageListType*<br/>
图像列表的类型。 它可以是下列值之一：

- 使用大图标 LVSIL_NORMAL 图像列表。

- 使用小图标 LVSIL_SMALL 图像列表。

- 状态图像的 LVSIL_STATE 图像列表。

### <a name="return-value"></a>返回值

指向上一个图像列表的指针。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetImageList](#getimagelist)。

## <a name="setinfotip"></a>  CListCtrl::SetInfoTip

设置工具提示文本。

```
BOOL SetInfoTip(PLVSETINFOTIP plvInfoTip);
```

### <a name="parameters"></a>参数

*plvInfoTip*<br/>
一个指向[LVFSETINFOTIP](/windows/desktop/api/commctrl/ns-commctrl-taglvsetinfotip)结构，它包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE FALSE 失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETINFOTIP](/windows/desktop/Controls/lvm-setinfotip)消息，如 Windows SDK 中所述。

## <a name="setinsertmark"></a>  CListCtrl::SetInsertMark

将插入点设置为定义的位置。

```
BOOL SetInsertMark(LPLVINSERTMARK lvim);
```

### <a name="parameters"></a>参数

*lvim*<br/>
一个指向[LVINSERTMARK](/windows/desktop/api/commctrl/ns-commctrl-lvinsertmark)结构，它指定在何处设置插入点。

### <a name="return-value"></a>返回值

否则返回如果成功，则为 TRUE 或 FALSE。 如果返回 FALSE 的大小以`cbSize`的成员`LVINSERTMARK`结构不等于实际大小的结构，或当插入点不适用于当前视图中。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETINSERTMARK](/windows/desktop/Controls/lvm-setinsertmark)消息，如 Windows SDK 中所述。

## <a name="setinsertmarkcolor"></a>  CListCtrl::SetInsertMarkColor

设置插入点的颜色。

```
COLORREF SetInsertMarkColor(COLORREF color);
```

### <a name="parameters"></a>参数

*颜色*<br/>
一个[COLORREF](/windows/desktop/gdi/colorref)结构，它指定要设置插入点的颜色。

### <a name="return-value"></a>返回值

返回`COLORREF`结构，它包含以前的颜色。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETINSERTMARKCOLOR](/windows/desktop/Controls/lvm-setinsertmarkcolor)消息，如 Windows SDK 中所述。

## <a name="setitem"></a>  Clistctrl:: Setitem

设置某些或所有列表视图项的特性。

```
BOOL SetItem(const LVITEM* pItem);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam,
    int nIndent);
```

### <a name="parameters"></a>参数

*pItem*<br/>
地址[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，其中包含新的项属性，如 Windows SDK 中所述。 该结构的`iItem`并`iSubItem`成员标识的项或子项，并且该结构的`mask`成员指定要设置的属性。 有关详细信息`mask`成员，请参阅**备注**。

*nItem*<br/>
若要设置其属性的项的索引。

*nSubItem*<br/>
要设置其属性的子项的索引。

*nMask*<br/>
指定要设置 （请参阅备注） 的属性。

*lpszItem*<br/>
一个以 null 结尾的字符串，指定项的标签的地址。

*nImage*<br/>
图像列表中的项的图像的索引。

*nState*<br/>
指定的状态更改 （请参阅备注） 的值。

*nStateMask*<br/>
指定要进行更改 （请参阅备注） 的状态。

*lParam*<br/>
要与项相关联 32 位应用程序特定值。

*nIndent*<br/>
以像素为单位，缩进的宽度。 如果*nIndent*小于系统定义的最小宽度，新的宽度设置为系统定义的最小值

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

`iItem`并`iSubItem`的成员`LVITEM`结构和*nItem*并*nSubItem*参数标识的项和子项要设置其属性。

`mask`的成员`LVITEM`结构并*nMask*参数指定哪一项属性是设置：

- LVIF_TEXT`pszText`成员或*lpszItem*参数是以 null 结尾的字符串的地址;`cchTextMax`成员将被忽略。

- LVIF_STATE`stateMask`成员或*nStateMask*参数指定哪一项状态更改和`state`成员或*nState*参数包含这些状态的值。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::HitTest](#hittest)。

## <a name="setitemcount"></a>  CListCtrl::SetItemCount

准备添加大量项的列表视图控件。

```
void SetItemCount(int nItems);
```

### <a name="parameters"></a>参数

*nItems*<br/>
最终将包含该控件的项目数。

### <a name="remarks"></a>备注

若要设置的虚拟列表视图控件的项计数，请参阅[CListCtrl::SetItemCountEx](#setitemcountex)。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetItemCount](/windows/desktop/api/commctrl/nf-commctrl-listview_setitemcount)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.
        m_myListCtrl.SetItemCount(1024);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemcountex"></a>  CListCtrl::SetItemCountEx

设置虚拟列表视图控件的项计数。

```
BOOL SetItemCountEx(
    int iCount,
    DWORD dwFlags = LVSICF_NOINVALIDATEALL);
```

### <a name="parameters"></a>参数

*iCount*<br/>
最终将包含该控件的项目数。

*dwFlags*<br/>
指定项的计数重置后列表视图控件的行为。 此值可以是以下组合：

- LVSICF_NOINVALIDATEALL 列表视图控件不会重新绘制除非受影响的项目当前视图中。 这是默认值。

- 当项计数的更改，LVSICF_NOSCROLL 列表视图控件不会更改滚动位置。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetItemCountEx](/windows/desktop/api/commctrl/nf-commctrl-listview_setitemcountex)，如中所述在 Windows SDKand，只应虚拟列表视图的调用。

### <a name="example"></a>示例

```cpp
        CString str;

        // Add 1024 items to the list view control.

        // Force my virtual list view control to allocate
        // enough memory for my 1024 items.
        m_myVirtualListCtrl.SetItemCountEx(1024, LVSICF_NOSCROLL|
            LVSICF_NOINVALIDATEALL);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myVirtualListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemdata"></a>  CListCtrl::SetItemData

设置与由指定的项关联的 32 位应用程序特定值*nItem*。

```
BOOL SetItemData(int nItem, DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

*nItem*<br/>
数据将设置的列表项的索引。

*dwData*<br/>
32 位值将与项相关联。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

此值是`lParam`的成员[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Set the data of each item to be equal to its index.
    for (int i = 0; i < m_myListCtrl.GetItemCount(); i++)
    {
        m_myListCtrl.SetItemData(i, i);
    }
```

## <a name="setitemindexstate"></a>  CListCtrl::SetItemIndexState

设置当前的列表视图控件中项的状态。

```
BOOL SetItemIndexState(
    PLVITEMINDEX pItemIndex,
    DWORD dwState,
    DWORD dwMask) const;
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*pItemIndex*|[in]指向[LVITEMINDEX](https://msdn.microsoft.com/library/windows/desktop/bb774762)描述项的结构。 调用方负责分配此结构并设置其成员。|
|*dwState*|[in]要设置的项的状态即的按位组合[列表视图项状态](/windows/desktop/Controls/list-view-item-states)。 指定零到重置，或另一个用于设置状态。|
|*dwMask*|[in]指定的状态的有效位掩码*dwState*参数。 指定的按位组合 (OR)[列表视图项状态](/windows/desktop/Controls/list-view-item-states)。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息*dwState*参数，请参阅[列表视图项状态](/windows/desktop/Controls/list-view-item-states)。

有关详细信息*dwMask*参数，请参阅*stateMask*的成员[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构。

此方法将发送[LVM_SETITEMINDEXSTATE](/windows/desktop/Controls/lvm-setitemindexstate)消息，Windows SDK 中所述。

## <a name="setitemposition"></a>  CListCtrl::SetItemPosition

将项移动到列表视图控件中的指定位置。

```
BOOL SetItemPosition(
    int nItem,
    POINT pt);
```

### <a name="parameters"></a>参数

*nItem*<br/>
若要设置其位置的项的索引。

*pt*<br/>
一个[点](https://msdn.microsoft.com/library/windows/desktop/dd162805)结构，它指定视图中的新位置的项的左上角坐标。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

控件必须为图标或小图标视图中。

如果列表视图控件具有 LVS_AUTOARRANGE 样式，列表视图中排列后设置项的位置。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetItemPosition](#getitemposition)。

## <a name="setitemstate"></a>  CListCtrl::SetItemState

更改列表视图控件中的项的状态。

```
BOOL SetItemState(
    int nItem,
    LVITEM* pItem);

BOOL SetItemState(
    int nItem,
    UINT nState,
    UINT nMask);
```

### <a name="parameters"></a>参数

*nItem*<br/>
若要设置其状态的项的索引。

*pItem*<br/>
地址[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构，如 Windows SDK 中所述。 该结构的`stateMask`成员指定的状态更改，和结构的位`state`成员包含这些位的新值。 其他成员将被忽略。

*nState*<br/>
状态位的新值。 有关可能的值的列表，请参阅[CListCtrl::GetNextItem](#getnextitem)并[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)状态成员。

*nMask*<br/>
指定的状态更改的位掩码。 此值对应于 stateMask 隶属[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

项的"状态"是一个值，指定项的可用性，该值指示用户操作或否则反映了项的状态。 列表视图控件更改某些状态位，如当用户选择某个项。 应用程序可能会更改其他状态位禁用或隐藏项，或指定覆盖图像或状态图像。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetTopIndex](#gettopindex)。

## <a name="setitemtext"></a>  CListCtrl::SetItemText

更改列表视图项或子项的文本。

```
BOOL SetItemText(
    int nItem,
    int nSubItem,
    LPCTSTR lpszText);
```

### <a name="parameters"></a>参数

*nItem*<br/>
若要设置其文本的项的索引。

*nSubItem*<br/>
若要设置的项标签子项，则为零的索引。

*lpszText*<br/>
包含新的项文本的字符串指针。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

此方法不应使用与包含 LVS_OWNERDATA 窗口样式的控件 （事实上，这将导致断言中的调试版本）。 有关此列表控件样式的详细信息，请参阅[列表视图控件概述](/windows/desktop/Controls/list-view-controls-overview)。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::InsertItem](#insertitem)。

## <a name="setoutlinecolor"></a>  CListCtrl::SetOutlineColor

如果设置的列表视图控件的边框颜色[LVS_EX_BORDERSELECT](/windows/desktop/Controls/list-view-window-styles)设置扩展的窗口样式。

```
COLORREF SetOutlineColor(COLORREF color);
```

### <a name="parameters"></a>参数

*颜色*<br/>
新[COLORREF](/windows/desktop/gdi/colorref)结构，它包含轮廓颜色。

### <a name="return-value"></a>返回值

上一个`COLORREF`结构，它包含轮廓颜色

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETOUTLINECOLOR](/windows/desktop/Controls/lvm-setoutlinecolor)消息，如 Windows SDK 中所述。

## <a name="setselectedcolumn"></a>  CListCtrl::SetSelectedColumn

设置列表视图控件的所选的列。

```
LRESULT SetSelectedColumn(int iCol);
```

### <a name="parameters"></a>参数

*iCol*<br/>
若要选择的列的索引。

### <a name="return-value"></a>返回值

不使用返回的值。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETSELECTEDCOLUMN](/windows/desktop/Controls/lvm-setselectedcolumn)消息，如 Windows SDK 中所述。

## <a name="setselectionmark"></a>  CListCtrl::SetSelectionMark

设置列表视图控件的选择内容标记。

```
int SetSelectionMark(int iIndex);
```

### <a name="parameters"></a>参数

*iIndex*<br/>
多个所选内容中的第一项的从零开始的索引。

### <a name="return-value"></a>返回值

以前的选择内容标记或如果时没有选择内容标记为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetSelectionMark](/windows/desktop/api/commctrl/nf-commctrl-listview_setselectionmark)，如 Windows SDK 中所述。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetSelectionMark](#getselectionmark)。

## <a name="settextbkcolor"></a>  CListCtrl::SetTextBkColor

在列表视图控件中设置文本的背景色。

```
BOOL SetTextBkColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*cr*<br/>
指定新的文本背景色 COLORREF。 有关信息，请参阅[COLORREF](/windows/desktop/gdi/colorref) Windows SDK 中。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetTextBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetTextBkColor() == crBkColor);
```

## <a name="settextcolor"></a>  CListCtrl::SetTextColor

设置列表视图控件的文本的颜色。

```
BOOL SetTextColor(COLORREF cr);
```

### <a name="parameters"></a>参数

*cr*<br/>
指定新的文本颜色 COLORREF。 有关信息，请参阅[COLORREF](/windows/desktop/gdi/colorref) Windows SDK 中。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="example"></a>示例

```cpp
    // Use the window text color for
    // the item text of the list view control.
    COLORREF crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
    m_myListCtrl.SetTextColor(crTextColor);
    ASSERT(m_myListCtrl.GetTextColor() == crTextColor);
```

## <a name="settileinfo"></a>  CListCtrl::SetTileInfo

设置磁贴的列表视图控件的信息。

```
BOOL SetTileInfo(PLVTILEINFO pti);
```

### <a name="parameters"></a>参数

*pti*<br/>
一个指向[LVTILEINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvtileinfo)结构，它包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE FALSE 失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETTILEINFO](/windows/desktop/Controls/lvm-settileinfo)消息，如 Windows SDK 中所述。

## <a name="settileviewinfo"></a>  CListCtrl::SetTileViewInfo

设置磁贴视图中使用列表视图控件的信息。

```
BOOL SetTileViewInfo(PLVTILEVIEWINFO ptvi);
```

### <a name="parameters"></a>参数

*ptvi*<br/>
一个指向[LVTILEVIEWINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvtileviewinfo)结构，它包含要设置的信息。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE FALSE 失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETTILEVIEWINFO](/windows/desktop/Controls/lvm-settileviewinfo)消息，如 Windows SDK 中所述。

## <a name="settooltips"></a>  CListCtrl::SetToolTips

设置列表视图控件用来显示工具提示的工具提示控件。

```
CToolTipCtrl* SetToolTips(CToolTipCtrl* pWndTip);
```

### <a name="parameters"></a>参数

*pWndTip*<br/>
一个指向`CToolTipCtrl`对象，将使用列表控件。

### <a name="return-value"></a>返回值

一个指向[CToolTipCtrl](ctooltipctrl-class.md)对象，其中包含以前使用控件，则为 NULL，如果没有工具提示以前使用的工具提示。

### <a name="remarks"></a>备注

此成员函数可实现 Win32 消息的行为[LVM_SETTOOLTIPS](/windows/desktop/Controls/lvm-settooltips)，如 Windows SDK 中所述。

若要不使用工具提示，指示 LVS_NOTOOLTIPS 样式创建时`CListCtrl`对象。

## <a name="setview"></a>  CListCtrl::SetView

设置列表视图控件的视图。

```
DWORD SetView(int iView);
```

### <a name="parameters"></a>参数

*iView*<br/>
要选择的视图。

### <a name="return-value"></a>返回值

否则返回 1; 如果成功，则为-1。 例如，如果视图为无效，则返回-1。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SETVIEW](/windows/desktop/Controls/lvm-setview)消息，如 Windows SDK 中所述。

## <a name="setworkareas"></a>  CListCtrl::SetWorkAreas

设置图标可以显示在列表视图控件中的区域。

```
void SetWorkAreas(
    int nWorkAreas,
    LPRECT lpRect);
```

### <a name="parameters"></a>参数

*nWorkAreas*<br/>
数`RECT`结构 (或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象) 中通过指向数组*lpRect*。

*lpRect*<br/>
一个数组的地址`RECT`结构 (或`CRect`对象)，用于指定列表视图控件的新的工作区域。 必须在客户端坐标中指定这些区域。 如果此参数为 NULL，则在工作区将设置为控件的客户端区域。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SetWorkAreas](/windows/desktop/api/commctrl/nf-commctrl-listview_setworkareas)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
    // Remove all working areas.
    m_myListCtrl.SetWorkAreas(0, NULL);
```

## <a name="sortgroups"></a>  CListCtrl::SortGroups

使用应用程序定义比较函数按 ID 列表视图控件中的组进行排序。

```
BOOL SortGroups(
    PFNLVGROUPCOMPARE _pfnGroupCompare,
    LPVOID _plv);
```

### <a name="parameters"></a>参数

*_pfnGroupCompare*<br/>
指向组比较函数的指针。

*_plv*<br/>
Void 指针的指针。

### <a name="return-value"></a>返回值

如果成功，则返回 TRUE FALSE 失败。

### <a name="remarks"></a>备注

此成员函数模拟的功能[LVM_SORTGROUPS](/windows/desktop/Controls/lvm-sortgroups)消息，如 Windows SDK 中所述。

## <a name="sortitems"></a>  CListCtrl::SortItems

使用应用程序定义比较函数对排序列表视图项。

```
BOOL SortItems(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

*pfnCompare*<br/>
[in]应用程序定义比较函数的地址。

排序操作调用比较函数每次需要确定两个列表项的相对顺序。 比较函数必须是独立的函数不是任何类的成员或类的静态成员。

*dwData*<br/>
[in]传递给比较函数的应用程序定义的值。

### <a name="return-value"></a>返回值

如果成功，则该方法否则为 FALSE。

### <a name="remarks"></a>备注

此方法将更改以反映新的序列每个项的索引。

比较函数中， *pfnCompare*，具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
比较函数必须返回一个负值，如果第一项应位于第二个，如果第一项应遵循第二个或为零正值的两个项相等。

*LParam1*参数是与进行比较的第一项关联的 32 位值和*lParam2*参数是与第二个项相关联的值。 以下是中指定的列的值*lParam*的项的成员[LVITEM](/windows/desktop/api/commctrl/ns-commctrl-taglvitema)结构时它们已插入到列表。 *LParamSort*参数是作为相同*dwData*值。

此方法将发送[LVM_SORTITEMS](/windows/desktop/Controls/lvm-sortitems)消息，Windows SDK 中所述。

### <a name="example"></a>示例

以下是一个简单的比较函数，导致项正在按其*lParam*值。

```cpp
// Sort items by associated lParam
int CALLBACK CListCtrlDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    UNREFERENCED_PARAMETER(lParamSort);
return (int)(lParam1 - lParam2);
}
```

```cpp
// Sort the items by passing in the comparison function.
void CListCtrlDlg::Sort()
{
    m_myListCtrl.SortItems(&CListCtrlDlg::MyCompareProc, 0);
}
```

## <a name="sortitemsex"></a>  CListCtrl::SortItemsEx

当前列表视图控件的项进行排序通过使用应用程序定义比较函数。

```
BOOL SortItemsEx(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>参数

|参数|描述|
|---------------|-----------------|
|*pfnCompare*|[in]应用程序定义比较函数的地址。<br /><br /> 排序操作调用比较函数每次需要确定两个列表项的相对顺序。 比较函数必须是独立的函数不是任何类的成员或类的静态成员。|
|*dwData*|[in]应用程序定义的值传递给比较函数。|

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法将更改以反映新的序列每个项的索引。

比较函数中， *pfnCompare*，具有以下形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
此消息就像[LVM_SORTITEMS](/windows/desktop/Controls/lvm-sortitems)，除外的信息的类型传递给比较函数。 在中[LVM_SORTITEMS](/windows/desktop/Controls/lvm-sortitems)， *lParam1*并*lParam2*是要进行比较的项的值。 在中[LVM_SORTITEMSEX](/windows/desktop/Controls/lvm-sortitemsex)， *lParam1*是要比较的第一个项的当前索引和*lParam2*是第二个项的当前索引。 可以发送[LVM_GETITEMTEXT](/windows/desktop/Controls/lvm-getitemtext)消息来检索有关某个项的详细信息。

比较函数必须返回一个负值，如果第一项应位于第二个，如果第一项应遵循第二个或为零正值的两个项相等。

> [!NOTE]
>  在排序过程中，列表视图内容不稳定。 如果回调函数将所有消息而不都发送到列表视图控件[LVM_GETITEM](/windows/desktop/Controls/lvm-getitem)，则结果不可预知。

此方法将发送[LVM_SORTITEMSEX](/windows/desktop/Controls/lvm-sortitemsex)消息，Windows SDK 中所述。

### <a name="example"></a>示例

下面的代码示例定义一个变量， `m_listCtrl`，即用于访问当前的列表视图控件。 此变量将在下一个示例中使用。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>示例

下面的代码示例演示了`SortItemEx`方法。 此代码示例的前面部分，我们将创建显示标题"ClientID"和"等级"为报告视图中的两个列的列表视图控件。 下面的代码示例对表排序通过使用"评分"列中的值。

```cpp
// The ListCompareFunc() method is a global function used by SortItemEx().
int CALLBACK ListCompareFunc(
                             LPARAM lParam1,
                             LPARAM lParam2,
                             LPARAM lParamSort)
{
    CListCtrl* pListCtrl = (CListCtrl*) lParamSort;
    CString    strItem1 = pListCtrl->GetItemText(static_cast<int>(lParam1), 1);
    CString    strItem2 = pListCtrl->GetItemText(static_cast<int>(lParam2), 1)
    int x1 = _tstoi(strItem1.GetBuffer());
    int x2 = _tstoi(strItem2.GetBuffer());
    int result = 0;
    if ((x1 - x2) < 0)
        result = -1;
    else if ((x1 - x2) == 0)
        result = 0;
    else
        result = 1;

    return result;
}

void CCListCtrl_s2Dlg::OnBnClickedButton1()
{
    // SortItemsEx
    m_listCtrl.SortItemsEx( ListCompareFunc, (LPARAM)&m_listCtrl );
}
```

## <a name="subitemhittest"></a>  CListCtrl::SubItemHitTest

确定哪个列表视图项，如果任何，在给定位置。

```
int SubItemHitTest(LPLVHITTESTINFO pInfo);
```

### <a name="parameters"></a>参数

*pInfo*<br/>
一个指向[LVHITTESTINFO](/windows/desktop/api/commctrl/ns-commctrl-taglvhittestinfo)结构。

### <a name="return-value"></a>返回值

1 开始的索引项，或子项、 所测试 （如果有），则否则为-1。

### <a name="remarks"></a>备注

此成员函数实现 Win32 宏的行为[ListView_SubItemHitTest](/windows/desktop/api/commctrl/nf-commctrl-listview_subitemhittest)，如 Windows SDK 中所述。

### <a name="example"></a>示例

```cpp
void CListCtrlDlg::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    LVHITTESTINFO lvhti;

    // Clear the subitem text the user clicked on.
    lvhti.pt = pia->ptAction;
    m_myListCtrl.SubItemHitTest(&lvhti);

    if (lvhti.flags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItemText(lvhti.iItem, lvhti.iSubItem, NULL);
    }
}
```

## <a name="update"></a>  CListCtrl::Update

强制重新绘制由指定的项在列表视图控件*nItem*。

```
BOOL Update(int nItem);
```

### <a name="parameters"></a>参数

*nItem*<br/>
要更新的项的索引。

### <a name="return-value"></a>返回值

如果成功，则不为零，否则为零。

### <a name="remarks"></a>备注

如果它具有 LVS_AUTOARRANGE 样式，此函数还排列列表视图控件。

### <a name="example"></a>示例

  有关示例，请参阅[CListCtrl::GetSelectedCount](#getselectedcount)。

## <a name="see-also"></a>请参阅

[MFC 示例 ROWLIST](../../visual-cpp-samples.md)<br/>
[CWnd 类](cwnd-class.md)<br/>
[层次结构图](../hierarchy-chart.md)<br/>
[CImageList 类](cimagelist-class.md)

