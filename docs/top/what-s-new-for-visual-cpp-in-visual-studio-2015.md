---
title: "What&#39;s New for Visual C++ in Visual Studio 2015 | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 1cc09fad-85a2-43c2-b022-bb99f5fe0ad7
caps.latest.revision: 101
caps.handback.revision: 101
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
---
# What&#39;s New for Visual C++ in Visual Studio 2015
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

在 Visual Studio 2015 中，C\+\+ 编译器和标准库已使用针对 C\+\+11 的增强支持和针对某些 C\+\+14 功能的初始支持进行了更新。  它们还包括针对 C\+\+17 标准中预计会具有的某些功能的初步支持。  
  
 我们还添加了用于在 [Android 和 iOS](../Topic/Visual%20C++%20for%20Cross-Platform%20Mobile%20Development.md) 上进行跨平台多设备开发的项目模板、用各种方式改进了[诊断](#BK_Diagnostics)和提高了[工作效率](#BK_IDE)并显著缩短了[生成时间](#BK_FasterBuildTimes)。  
  
> [!WARNING]
>  在 Visual Studio 2015 中，不默认安装 Visual C\+\+。  安装时，请确保选择**“自定义”**安装，然后选择所需的 C\+\+ 组件。  或者，如果已安装 Visual Studio，则选择**“文件”&#124;“新建”&#124;“项目”&#124;“C\+\+”**，系统将提示你安装必要的组件。  
  
 有关 Visual Studio 2015 中的其他添加内容的信息，请参阅 [Visual Studio 2015 中的新增功能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)。  
  
 在本主题中：  
  
1.  [编译器](#BK_Compiler)  
  
2.  [C++ 标准库](#BK_CppStdLib)  
  
3.  [C 运行库](#BK_CRT)  
  
4.  [生成时间更短](#BK_FasterBuildTimes)  
  
5.  [性能和代码质量](#BK_PerfCodeQuality)  
  
6.  [工作效率、调试和诊断](#BK_IDE)  
  
    1.  [单个文件 IntelliSense](#BK_SingleFileIntelliSense)  
  
    2.  [重构](#BK_Refactoring)  
  
    3.  [程序数据库增强功能](#BK_PDB)  
  
    4.  [诊断](#BK_Diagnostics)  
  
7.  [面向 Windows 10](#BK_Win10)  
  
8.  [图形诊断](#BK_GraphicsDiagnostics)  
  
9. [新的 GPU 使用情况工具](#BK_GPUUsage)  
  
10. [新的 MFC 功能](#BK_MFC)  
  
## ISO C\/C\+\+ 标准支持  
  
###  <a name="BK_Compiler"></a> 编译器  
  
-   **可恢复函数 \(resume\/await\)** resume 和 await 关键字为异步编程提供语言级别支持并启用可恢复函数。  当前，此功能仍处于试验阶段且只能用于 x64 目标。  **（建议用于 C\+\+17 \[N3858\]）**  
  
-   **泛型（多态）Lambda 表达式** 现在可以使用 auto 指定 Lambda 函数参数类型；编译器会在此上下文中解释 auto 以表示闭包的函数调用运算符是成员函数模板，并且 lambda 表达式中的每次 auto 使用都对应于不同的模板类型参数。  **\(C\+\+14 \)**  
  
-   **通用 Lambda 捕获表达式** 也称为初始捕获。  现在可以将任意表达式的结果分配给 lambda 的 capture 子句中的变量。  这使得可以通过值捕获仅移动类型，并使 lambda 表达式可以在其闭包对象中定义任意数据成员。  **\(C\+\+14\)**  
  
-   **二进制文本** 现在支持二进制文本。  这类文本具有前缀 0B 或 0b，仅由数字 0 和 1 组成。  **\(C\+\+14\)**  
  
-   **返回类型推导** 现在可以推导普通函数的返回类型，包括具有多个返回语句的函数和递归函数。  这类函数定义前面带有 auto 关键字（如同带有尾随返回类型的函数定义），但是会省略尾随返回类型。  **\(C\+\+14\)**  
  
-   **decltype\(auto\)** 使用 auto 关键字初始化表达式的类型推导会从表达式中去除引用限定符和顶级 cv 限定符。  decltype\(auto\) 保留引用和 cv 限定符，现在可以在可使用 auto 的任何位置使用（除了用于引入具有推断或尾随返回类型的函数）。  **\(C\+\+14\)**  
  
-   **移动特殊成员函数的隐式生成** 移动构造函数和移动赋值运算现在可在条件允许时隐式生成，从而使编译器完全符合 C\+\+11 右值引用。  **\(C\+\+11\)**  
  
-   **继承构造函数** 派生类现在可以通过在其定义中包含使用 Base::Base; 的语句，来指定它将继承其基类 Base 的构造函数。  派生类只能继承其基类的所有构造函数，无法仅继承特定基构造函数。  派生类无法从构造函数具有相同签名的多个基类继承，派生类也无法定义签名与其任何继承的构造函数相同的构造函数。  **\(C\+\+11\)**  
  
-   **对齐方式查询和控制** 变量的对齐方式可以使用 alignof\(\) 运算符进行查询，并使用 alignas\(\) 说明符进行控制。  alignof\(\) 返回必须在其上分配该类型的实例的字节边界；对于引用，它返回引用的类型的对齐方式，对于数组，它返回元素类型的对齐方式。  alignas\(\) 控制变量的对齐方式；它采用常量或类型，其中类型是 alignas\(alignof\(type\)\) 的速记形式。  **\(C\+\+11\)**  
  
-   **调整了大小的释放**现在可以重载全局  `void operator delete(void *, std::size_t) noexcept` 和 `void operator delete[](void *, std::size_t) noexcept`  
  
-   **扩展 sizeof** 现在可以使用 sizeof\(\)，在没有类或结构的实例的情况下确定类或结构成员变量的大小。**\(C\+\+11\)**  
  
-   **属性**提供一种无需定义新关键字便可扩展函数、变量、类型和其他程序元素上的语法的方法。**\(C\+\+11\)**  
  
-   **constexpr** 创建编译时常量变量、函数和用户定义类型。  **\(C\+\+11\)**  
  
-   **用户定义文本 \(UDL\)** 现在可以将有意义的后缀追加到数值和字符串以便为它们提供特定语义。  编译器会将后缀文本解释为对适当 UDL 运算符的调用。  **\(C\+\+11\)**  
  
-   **线程安全的“神奇”静态对象** 静态局部变量现在以线程安全的方式进行初始化，无需手动同步。  只有初始化是线程安全的，多个线程对静态局部变量的使用仍必须手动同步。  可以通过使用 \/Zc:threadSafeInit\- 标志避免对 CRT 形成依赖，来禁用线程安全的静态对象功能。  **\(C\+\+11\)**  
  
-   **线程本地存储** 使用 thread\_local 关键字可声明应为每个线程创建一个独立对象。  **\(C\+\+11\)**  
  
-   **noexcept** noexcept 运算符现在可以用于检查表达式是否可能引发异常。  noexcept 说明符现在可以用于指定函数不会引发异常。  **\(C\+\+11\)**  
  
-   **内联命名空间** 命名空间现在可以指定为内联以将其内容提升到封闭命名空间中。  内联命名空间可以用于创建在默认情况下公开其最新版本的受版本控制的库，不过仍显式提供以前的 API 版本。  **\(C\+\+11\)**  
  
-   **无限制的联合** 联合类型现在可以包含具有重要构造函数的类型。  必须定义此类联合的构造函数。  **\(C\+\+11\)**  
  
-   **新字符类型和 Unicode 文本** 现在支持 UTF\-8、UTF\-16 和 UTF\-32 中的字符文本和字符串，并引入了新字符类型 char16\_t 和 char32\_t。  字符文本可以具有前缀 u8 \(UTF\-8\)、u \(UTF\-16\) 或 U \(UTF\-32\)（如 U'a），而字符串还可以使用原始字符串等效项 u8R（UTF\-8 原始字符串）、uR（UTF\-16 原始字符串）或 UR（UTF\-32 原始字符串）作为前缀。  通用字符名可以在 unicode 文本中随意使用（如 u'\\u00EF'、u8"\\u00EF is i" 和 u"\\U000000ef is I"）。  **\(C\+\+11\)**  
  
-   **数字分隔符**可以按固定的间隔插入单引号，以便更易于读取长数字文本： `int x = 1'000'000;` **C\+\+14**  
  
-   **\_\_func\_\_** 预定义标识符 \_\_func\_\_ 隐式定义为包含封闭函数的未限定和未修饰名称的字符串。  
  
-   **\_\_restrict \_\_**限制现在可以应用于引用。  
  
###  <a name="BK_CppStdLib"></a> C\+\+ 标准库  
  
-   **标准库类型的用户定义文本 \(UDL\)** 为方便起见，\<chrono\>、\<string\> 和 \<complex\> 标头现在提供 UDL 运算符。  例如，123ms 表示 std::chrono::milliseconds\(123\)，"hello"s 表示 std::string\("hello"\)，而 3.14i 表示 std::complex\(0.0, 3.14\)。  
  
-   **Null 前向迭代器** 标准库现在允许创建不引用容器实例的前向迭代器。  此类迭代器进行值初始化，并比较是否等于特定容器类型。  将进行值初始化的迭代器与不进行值初始化的迭代器进行比较是不明确的。  **\(C\+\+14\)**  
  
-   **quoted\(\)** 标准库现在支持 quoted\(\) 函数，从而可以更方便地使用带引号的字符串值和 I\/O。  借助 quoted\(\)，会将整个带引号的字符串视为单个实体（因为非空格字符组成的字符串处于 I\/O 流中）；此外，可通过 I\/O 操作保留转义序列。  **\(C\+\+14\)**  
  
-   **异类关联查找** 标准库现在支持用于关联容器的异类查找函数。  此类函数实现按 key\_type 以外的类型进行查找（只要该类型可与 key\_type 进行比较）。  **\(C\+\+14\)**  
  
-   **编译时整数序列** 标准库现在支持 integer\_sequence 类型，该类型表示可以在编译时进行计算的一系列整数值，以便可以更方便地使用参数包并简化某些模板编程模式。  **\(C\+\+14\)**  
  
-   **exchange\(\)** 标准库现在支持 std::exchange\(\) 实用工具函数，用于将新值分配给对象并返回其旧值。  对于复杂类型，exchange\(\) 可避免在移动构造函数可用时复制旧值、避免在新值是临时值或进行移动时复制新值并接受任何类型作为新值，从而利用任何转换赋值运算法。  **\(C\+\+14\)**  
  
-   **双范围 equal\(\)、is\_permutation\(\)、mismatch\(\)** 标准库现在支持接受两个范围的 std::equal\(\)、std::is\_permutation\(\) 和 std::mismatch\(\) 重载。  这些重载检查两个序列是否长度相同（使调用代码无需承担此职责）；对于不支持随机迭代器要求的序列，这些重载在比较元素时检查长度（这样更高效）。  **\(C\+\+14\)**  
  
-   **get\<T\>\(\)** 标准库现在支持 get\<T\>\(\) 模板函数，以允许通过其类型对元组元素进行寻址。  如果元组包含两个或更多具有相同类型 get\<T\>\(\) 的元素，则无法通过该类型对元组进行寻址，但仍可以对其他唯一类型的元素进行寻址。  **\(C\+\+14\)**  
  
-   **tuple\_element\_t** 标准库现在支持 tuple\_element\_t\<I, T\> 类型别名，这是类型名 tuple\_element\<I, T\>::type 的别名。  这可为模板程序员提供一些便利（类似于 \<type\_traits\> 中的其他 metafunction 类型别名）。  **\(C\+\+14\)**  
  
-   **文件系统“V3”技术规范** 包含的文件系统技术规范实现已更新为该规范的版本 3。  \[N3940\]  
  
-   **最小分配器** 标准库现在始终支持最小分配器接口；值得注意的修复包括 std::function、shared\_ptr、allocate\_shared\(\) 和 basic\_string。  **\(C\+\+11\)**  
  
-   **\<chrono\>** chrono 类型 high\_resolution\_clock 和 steady\_clock 已修复。  **\(C\+\+11\)**  
  
-   **N2761 信号处理程序中的原子化 \(C\+\+11\)**  
  
-   **N3922 针对自动使用大括号内的初始值设定项列表的新建规则。 \(C\+\+17\)**  
  
-   **N4051 模板\-参数模板的类型名称， \(C\+\+17\)**  
  
-   **N4259 std::uncaught\_exceptions\(\)**  
  
-   **N4266 命名空间和枚举器的特性**  
  
-   **N4267 u8 字符文本**  
  
###  <a name="BK_CRT"></a> C 运行库  
 **CRT 库重构**CRT 已被重构为两个部分。  **通用 CRT** 包含实现标准 C 运行库的代码。  Vcruntime140.dll（或 .lib）包含进程启动和异常处理的特定于版本的代码。  通用 CRT 有一个稳定的 API，因此无需更改 Visual Studio 的每个版本中的版本号就可使用它。  它现在是由 Windows Update 提供服务的 Windows 操作系统组件。  它已在 Windows 10 中安装。  通过使用 Visual C\+\+ 可再发行组件包 \(vcredist\)，可以将其与 Windows 早期版本的应用程序一起分发。  
  
 **C99 一致性** [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)]完全实现 C99 标准库，但依赖于 Visual C\+\+ 编译器尚不支持的编译器功能的任何库功能除外（例如，未实现 \<tgmath.h\>）。  
  
 **性能**许多库已被重构以优化和简化头文件宏使用。  这可以加快编译和 IntelliSense 功能，并提高可读性。  此外，许多 stdio 函数都已被重新编写，为了标准合规性和改进性能。  
  
### 重大更改  
 对 ISO C\/C\+\+ 标准的改进支持可能需要对现有代码进行更改，从而符合 C\+\+11 和 C99 并在 Visual Studio 2015 中正确编译。  有关详细信息，请参阅[Visual C\+\+ 2015 中的重大更改](../porting/visual-cpp-change-history-2003-20151.md)。  
  
 ppltasks.h 中的 concurrency::task 类和相关类型不再基于 ConcRT 运行时。  它们现在使用 Windows 线程池作为其计划程序。  这仅影响在 concurrency:: task 操作中使用 ConcRT 同步基元的代码。  此类代码应改为使用 Windows 同步基元。  
  
 STL 中的同步基元也不再基于 ConcRT。  为避免死锁，请不要在 **concurrency::parallel\_for** 这类函数中使用 STL 同步基元，或是将这些基元与 PPL 异步代理类型一起使用。  
  
##  <a name="BK_FasterBuildTimes"></a> 生成时间更短  
  
-   **增量链接时间代码生成 \(LTCG\)** 增量链接现在可以与 LTCG 一起使用，以减少使用 LTCG 的应用程序的链接时间。  可使用 \/LTCG:incremental 和 \/LTCG:incremental\_rebuild 链接器开关激活此功能。  \\  
  
-   **静态库的增量链接** 对其他代码模块引用的静态库的更改现在以增量方式进行链接。  
  
-   **\/Debug:FastLink** 使用新的 PDB 创建技术显著减少链接时间。  
  
-   对链接器进行了算法改进以减少链接时间。  
  
-   进行了允许更快生成使用大量模板的代码的改进。  
  
-   **快速的按配置优化 \(PGO\) 检测** PGO 中引入了用于游戏和实时系统的新的、轻量级检测模式。  你现在可以在使用 PGO（与其他新功能一起，通过 \/GENPROFILE 和 \/FASTGETPROFILE 链接器开关提供）时平衡代码质量与生成速度。  
  
-   **对象文件大小缩减** 编译器和 C\+\+ 标准库增强功能使对象文件和静态库显著减小。  这些增强功能不影响动态链接库 \(DLL\) 或可执行文件 \(EXE\) 的大小，因为从历史上看链接器已删除了冗余代码。  
  
##  <a name="BK_PerfCodeQuality"></a> 性能和代码质量  
  
-   **对自动矢量化的改进** 现在包括控制流 \(if\-then\-else\) 的矢量化、在 \/O1 下编译时（最大程度减小大小）的矢量化以及对整体矢量代码质量的改进，其中包括支持并行 STL、向量化更多基于范围的 for 循环以及支持 \#pragma loop\(ivdep\)。  
  
-   **对标量优化的改进** 针对位测试操作、控制流合并和优化 \(loop\-if switching\) 以及其他标量优化（例如，针对 std::min 和 std::max 的更好的代码生成）的更好的代码生成。  
  
-   **按配置优化 \(PGO\)** 对 PGO 进行了一些增强，其中包括改进了引用集、更好的数据布局功能以及能够重复使用以前进行的内联、速度与  大小和布局决策。  
  
##  <a name="BK_IDE"></a> 工作效率、调试和诊断  
  
###  <a name="BK_SingleFileIntelliSense"></a> 单个文件 IntelliSense  
 现在，在编辑器中打开单个源代码文件时，可获取 IntelliSense，而无需打开任何项目文件。  
  
###  <a name="BK_Refactoring"></a> 重构  
 我们通过以下功能针对 C\+\+ 添加了重构支持：  
  
-   **重命名符号** 将符号的所有匹配项更改为新名称。  
  
-   **函数提取** 将所选代码移动到其自己的函数中。  此重构在 Visual Studio 库中作为 Visual Studio 扩展提供。  
  
-   **实现纯虚函数** 为类或结构继承的纯虚函数生成函数定义。  支持多个和递归继承。  从继承类定义激活此重构可实现所有继承的纯虚函数，从基类说明符激活可仅从该基类实现纯虚函数。  
  
-   **创建声明或定义** 从现有定义生成声明，或从现有声明生成默认定义。  从现有声明或定义，或是从 LightBulb 指示器访问此重构。  
  
-   **移动函数定义** 在源代码与头文件之间移动函数体。  从函数的签名激活此重构。  
  
-   **转换为原始字符串** 将包含转义序列的字符串转换为原始字符串。  支持的转移序列有 \\\\（反斜杠）、\\n（换行符）、\\t（制表符）、\\'（单引号）、\\"（双引号）和 \\?  （问号）。  通过在字符串中的任意位置右键单击来激活此功能。  
  
 通过使后续结果可以追加到以前的结果，改进了文件中查找；可以删除累积的结果。  
  
 **IntelliSense 可读性改进** 复杂模板实例化和 typedef 在参数帮助和快速信息中进行了简化，以使它们更易于阅读。  
  
###  <a name="BK_PDB"></a> 程序数据库增强功能  
  
-   解决方案扫描速度得到了提高，尤其是对于大型解决方案。  
  
-   在解决方案扫描过程中，不会再阻止“转到定义”这类操作（除了在首次打开新解决方案时的初始解决方案扫描过程中）。  
  
##  <a name="BK_Diagnostics"></a> 诊断  
  
1.  **调试器可视化** 向 Visual Studio 项目添加了 Natvis 调试器可视化，以便方便地进行管理和源代码管理集成。  可以在调试会话期间编辑并保存 Natvis 文件，调试器将自动选取更改。  有关详细信息，请参阅此[博客文章](http://blogs.msdn.com/b/vcblog/archive/2014/06/12/project-support-for-natvis.aspx)。  
  
2.  **本机内存诊断**  
  
    1.  **内存诊断会话** \(Ctrl\+Alt\+F2\) 使你可以在调试会话期间监视本机应用程序的实时内存使用情况。  
  
    2.  **内存快照** 捕获应用程序堆内容的瞬间映像。  可以通过比较两个内存快照来检查堆状态中的差异。  停止应用程序之后，查看每个实例的对象类型、实例值和分配调用堆栈。  通过每个快照的堆栈帧来查看调用树。  
  
3.  **改进了死锁检测和恢复** 从“监视”和“即时”窗口调用 C\+\+ 函数时。  
  
4.  **改进了编译器诊断** 编译器提供有关可疑代码的增强警告。  添加了新警告（例如，隐藏的变量和不匹配的 printf 格式字符串）。  使现有警告消息更清楚明白。  
  
5.  **\/Wv 标志** 可以使用 \/Wv:XX.YY.ZZZZ 标志禁用特定编译器版本 XX.YY.ZZZZ 之后引入的警告。。  除了通过 \/Wv 标志指定的警告之外，还可以专门禁用其他警告。  
  
6.  **改进了对调试优化代码的支持** 在启用了 \/Zi、\/Zo 或 \/Z7 标志的情况下调试代码。  
  
##  <a name="BK_Win10"></a> 面向 Windows 10  
 Visual Studio 现在支持在 C\+\+ 中面向 Windows 10。  适用于通用 Windows 应用开发的新项目模板支持面向 Windows 10 的设备，例如台式计算机、移动电话、平板电脑、HoloLens 和其他设备。  有关详细信息，请参阅[在 Windows 10 中创建“hello world”应用](https://msdn.microsoft.com/en-us/library/windows/apps/dn996906.aspx)。  
  
##  <a name="BK_GraphicsDiagnostics"></a> 图形诊断  
 通过以下功能改进了图形诊断：  
  
-   **图形诊断支持 DirectX12。** Visual Studio 图形诊断工具现在支持调试 DirectX12 应用程序中的呈现问题。  
  
-   **连续捕获** 通过一次捕获可最多捕获 30 个连续帧。  
  
-   **编程捕获** 以编程方式启动帧捕获。  编程捕获对于从不调用 Present 的程序中的调试计算着色器尤其有用，或者当呈现问题难以手动捕获，但是可以通过运行时的应用状态以编程方式进行预测时也尤其有用。  
  
-   **增强的图形事件列表** 添加了一个新的绘图调用视图，该视图会在按绘图调用组织的层次结构中显示捕获的事件及其状态。  你可以展开绘图调用以显示绘图调用时当前所处的设备状态；你可以进一步展开每种状态以显示设置其值的事件。  
  
-   **支持 Windows Phone 8.1** 图形诊断现在完全支持在 Phone 仿真程序中或在受限的 Phone 上调试 Windows Phone 8.1 应用。  
  
-   **图形帧分析** 此工具收集有关捕获的帧的性能度量；此外，它还执行一组预定义试验，通过这些试验可深入了解应用各种纹理技术时会如何影响性能。  帧分析还从硬件收集性能计数器。  
  
-   **图形分析的专用 UI** 新的 Visual Studio 图形分析器窗口是一个用于用于分析图形帧的专用工作区。  
  
-   **着色器编辑和应用** 在捕获的日志中查看着色器代码更改的影响，而无需重新运行应用。  
  
-   可在“工具”\-\>“选项”\-\>“图形诊断”中配置捕获选项。  
  
-   用于捕获和播放帧的命令行工具。  
  
 有关详细信息，请参阅[图形诊断（调试 DirectX 图形）](../Topic/Visual%20Studio%20Graphics%20Diagnostics.md)。  
  
##  <a name="BK_GPUUsage"></a> 新的 GPU 使用情况工具  
 Visual Studio 2015 中的 GPU 使用情况工具可用于了解 DirectX 应用程序的 GPU 使用情况。  实时运行应用程序期间，可以使用帧时间、帧速率和 GPU 使用率图表。  此外，通过收集和分析详细 GPU 使用情况数据，此工具可以提供对各个 DirectX 事件的 CPU 和 GPU 执行时间的深入了解，因此可以用于确定 CPU 或 GPU 是否为性能瓶颈。  请参阅 [GPU 使用情况](../Topic/GPU%20Usage.md)。  
  
##  <a name="BK_MFC"></a> 新的 MFC 功能  
 现在可以指定控件在用户更改对话框的大小时如何自动调整大小并移动。  有关详细信息，请参阅[动态布局](../mfc/dynamic-layout.md)。  
  
## 请参阅  
 [Visual Studio 2015 中的新增功能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)   
 [Visual C\+\+ 团队博客](http://blogs.msdn.com/b/vcblog/)