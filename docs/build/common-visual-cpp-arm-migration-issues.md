---
title: Visual C++ ARM 迁移的常见问题
ms.date: 11/04/2016
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: a39e1d5e26a62cafa093067bb42f33178a1af6af
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/14/2019
ms.locfileid: "57816251"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 迁移的常见问题

使用 Microsoft Visual c + + (MSVC)，相同的 c + + 源代码可能会比在 x86 或 x64 体系结构上生成 ARM 体系结构不同的结果。

## <a name="sources-of-migration-issues"></a>迁移问题的来源

将代码从 x86 或 x64 体系结构迁移到 ARM 体系结构时可能遇到的许多问题与可能调用未定义的、 实现自定义的或未指定操作的源代码构造。

*未定义的行为*是 c + + 标准没有定义的行为，并由具有不合理的结果的操作导致： 例如，将浮点值转换为无符号整数，或移位值的位置数这为负或超过其提升的类型中的位数。

*实现定义的行为*是 c + + 标准要求编译器供应商联系，以定义和文档的行为。 即使这样做因此可能不是可移植，程序可以安全地依赖于实现定义的行为。 实现定义的行为的示例包括内置数据类型和其对齐要求的大小。 实现定义的行为可能会影响运算的一个示例访问变量参数列表。

*未指定行为*是 c + + 标准离开有意不确定的行为。 尽管行为被视为非确定性的但未指定的行为的特定调用由编译器实现决定。 但是，编译器供应商以预先确定的结果或保证一致的行为类似调用之间没有要求，并且没有任何要求有关的文档。 未指定的一个示例是行为的包括函数调用的参数的子表达式的计算顺序。

其他迁移问题可归因于 ARM 和 x86 或 x64 体系结构，以不同的方式与 c + + 标准进行交互的硬件差异。 例如，x86 和 x64 体系结构的强内存模型向`volatile`-限定变量已用于简化某些类型在过去的线程间通信的一些附加属性。 但 ARM 体系结构的弱内存模型不支持此使用，也不会 c + + 标准要求它。

> [!IMPORTANT]
>  尽管`volatile`提升可用于 x86 和 x64，这些附加属性上实现线程间的通信的有限的形式某些属性没有足够权限来实现线程间的通信通常情况下。 C + + 标准建议，而是使用适当的同步基元实现此类通信。

因为不同的平台可能以不同的方式表达这些类型的行为，将软件平台之间移植会非常困难并易于产生 bug 如果它依赖于特定平台的行为。 但许多这些类型的行为，可以观察到，并可能会出现稳定，依赖于它们是至少不可移植的并在未定义或未指定行为的情况下，也是错误的。 甚至在此文档中引用的行为不应将其上，并可能在将来更改，编译器或 CPU 的实现。

## <a name="example-migration-issues"></a>示例迁移问题

本文档其余部分介绍了这些 c + + 语言元素不同的行为如何生成不同的平台上不同的结果。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>为无符号整数的浮点转换

ARM 体系结构，到 32 位整数的浮点值转换为整数的浮点值是否可以表示整数的范围之外可以表示最接近值尽量充满。 在 x86 和 x64 体系结构中，转换将环绕如果整数是无符号整数，或如果已签名整数设置为介于-2147483648。 任何这些体系结构都不直接支持浮点值的转换为较小的整数类型;相反，到 32 位执行的转换，并将结果截断为较小的大小。

对于 ARM 体系结构，饱和度和截断的组合意味着，转换为无符号类型正确尽量充满较小的无符号的类型时它会使更饱满的 32 位整数，但生成的值大于截断后的结果较小类型可以表示太小，但要饱和的全 32 位整数。 转换还会使更饱满正确对于 32 位有符号整数，但的饱和，带符号整数中的截断导致产生积极的满负荷值-1 和 0 表示负面饱和值。 转换为一个较小的带符号整数会产生不可预知的截断的结果。

适用于 x86 和 x64 体系结构中，组合的无符号的整数转换回绕的行为与在溢出时，截断，以及有符号的整数转换为显式估值使大多数班次的结果不可预测，如果它们是太大。

在处理 NaN （非数字） 转换为整数类型的方式也存在差异这些平台。 在 ARM，NaN 将转换为 0x00000000;在 x86 和 x64 上，它将转换为 0x80000000。

如果您知道的值是转换为整数类型的范围内，则仅可以依赖于浮点转换。

### <a name="shift-operator---behavior"></a>移位运算符 (\< \< >>) 行为

ARM 体系结构，值可以被向左或靠右最多 255 位模式开始重复之前。 在 x86 和 x64 体系结构上模式重复在每个多为 32 个除非模式的源是 64 位变量，例如：在这种情况下，在每个多 64 在 x64 和每个使用软件实现的在 x86 上的 256 个字节的多个重复该模式。 例如，对于 32 位变量具有 32 位置向左移动 1 的值，ARM 上的结果为 0、 在 x86 上则结果为 1，和在 x64 上则结果也为 1。 但是，如果值的源是 64 位变量，然后在所有三个平台上的结果为 4294967296，并且值不会"环绕"直到它已将 64 位置移动 x64 或 ARM 上的 256 位置和 x86 上。

超出了中的源类型的位的移位运算的结果是不确定的因为编译器不需要在所有情况下具有一致的行为。 例如，如果在编译时已知的 shift 两个操作数，编译器可能： 使用内部例程预先计算移位的结果，然后替换代替移位运算结果优化程序。 如果位移量太大，或者负，内部例程的结果可能不同于相同的 shift 表达式的结果由 CPU 执行。

### <a name="variable-arguments-varargs-behavior"></a>变量参数 (varargs) 的行为

在 ARM 体系结构中，从变量参数列表在堆栈传递的参数受到对齐方式。 例如，在 64 位边界上对齐的 64 位参数。 在 x86 和 x64 上，在堆栈传递的参数不受影响的对齐方式和包紧密。 这种差异可能会导致所示的可变参数函数`printf`读取已用作填充的 ARM 如果预期变量参数列表的布局不完全匹配，即使它可能在 x86 上运行的某些值的子集的内存地址或 x64 体系结构。 请看以下示例：

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

在这种情况下，可以通过确保使用正确的格式规范，以便被视为自变量的对齐方式修复 bug。 此代码是正确的：

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>自变量计算顺序

由于 ARM、 x86 和 x64 处理器的差别，因此，它们可以提供不同的要求编译器实现，而且还需要其他优化机会。 以及其他因素，例如调用约定和优化的设置，因此，编译器可能评估顺序上不同的体系结构或更改其他因素时不同的函数自变量。 这会导致依赖于特定评估顺序意外更改的应用的行为。

当函数的自变量产生副作用，影响在相同的调用函数的其他自变量，则会发生这种错误。 此类依赖项通常是可以轻松避免，但它可以有时会被遮盖通过依赖项很难识别，或通过运算符重载。 请考虑此代码示例：

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

这将显示明确定义，但是，如果`->`和`*`都重载的运算符，则此代码将转换为与此类似的内容：

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

和之间的依赖关系是否`operator->(memory_handle)`和`operator*(p)`，代码可能依赖于特定的计算顺序，即使原始代码看起来像没有任何可能的依赖关系。

### <a name="volatile-keyword-default-behavior"></a>易失关键字默认行为

MSVC 编译器支持两种不同的解释`volatile`存储可以通过使用编译器开关指定的限定符。 [/Volatile: ms](reference/volatile-volatile-keyword-interpretation.md)开关用于选择 Microsoft 扩展易失性保证强排序的语义，因为由于这些体系结构上强内存模型已针对 x86 和 x64 传统的用例。 [/Volatile: iso](reference/volatile-volatile-keyword-interpretation.md)开关用于选择严格 c + + 标准可变语义，不能保证强排序。

在 ARM 体系结构中，默认值是 **/volatile: iso**由于 ARM 处理器具有弱排序内存模型，而且因为 ARM 软件不依赖于扩展的语义的旧版 **/volatile: ms** ，通常没有与执行的软件进行交互。 但是，它是仍有时方便或甚至需要编译 ARM 程序以使用扩展的语义。 例如，可能会以端口的程序，使用 ISO c + + 语义，成本过高或驱动程序软件可能需要遵守的传统的语义，才能正常工作。 在这些情况下，你可以使用 **/volatile: ms**交换机; 但是，若要重新创建在 ARM 目标上的传统可变语义，编译器必须将插入围绕每个读取或写入的内存屏障`volatile`变量以强制实施强排序，这会对性能产生负面影响。

在 x86 和 x64 体系结构中，默认值是 **/volatile: ms**因为很多的软件的已创建为这些体系结构使用 MSVC 依赖于它们。 在编译 x86 和 x64 的程序时，可以指定 **/volatile: iso**开关来帮助避免不必要依赖传统的易失性语义，并将提升可移植性。

## <a name="see-also"></a>请参阅

[为 ARM 处理器配置 Visual C++](configuring-programs-for-arm-processors-visual-cpp.md)
