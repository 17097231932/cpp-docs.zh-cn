---
title: Visual C++ ARM 迁移的常见问题
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 2c29b4ffa5344b309622314970ce52c47a0ebd05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328800"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 迁移的常见问题

使用 Microsoft C++ 编译器 （MSVC） 时，相同的C++源代码在 ARM 体系结构上产生的结果可能与 x86 或 x64 体系结构的结果不同。

## <a name="sources-of-migration-issues"></a>移徙问题的根源

将代码从 x86 或 x64 体系结构迁移到 ARM 体系结构时可能会遇到许多问题都与可能调用未定义、实现定义或未指定行为的源代码构造相关。

*未定义的行为*是C++标准未定义的行为，是由没有合理结果的操作引起的：例如，将浮点值转换为未签名整数，或将值按若干位置移动，这些位置为负或超过其升级类型中的位数。

*实现定义的行为*是C++标准要求编译器供应商定义和记录的行为。 程序可以安全地依赖于实现定义的行为，即使这样做可能不是可移植的。 实现定义行为的示例包括内置数据类型的大小及其对齐要求。 可能受实现定义行为影响的操作的一个示例是访问变量参数列表。

*未指定的行为*是C++标准故意留下非确定性的行为。 尽管该行为被视为非确定性行为，但未指定行为的特定调用由编译器实现决定。 但是，编译器供应商不需要预先确定结果或保证可比调用之间的一致行为，也不需要文档。 未指定行为的一个示例是计算子表达式（包括函数调用的参数）的顺序。

其他迁移问题可归因于 ARM 和 x86 或 x64 体系结构之间的硬件差异，这些体系结构与C++标准交互的方式不同。 例如，x86 和 x64 体系结构的强内存模型提供了`volatile`一些附加属性，这些属性过去曾用于促进某些类型的线程间通信。 但是 ARM 体系结构的弱内存模型不支持此用途，C++标准也不要求它。

> [!IMPORTANT]
> 尽管`volatile`获得了一些可用于在 x86 和 x64 上实现有限形式的线程间通信的属性，但这些附加属性通常不足以实现线程间通信。 C++标准建议使用适当的同步基元来实现此类通信。

由于不同的平台可能会以不同的方式表达此类行为，因此，如果依赖于特定平台的行为，则在平台之间移植软件可能很困难且容易出错。 尽管可以观察到许多此类行为，并且可能保持稳定，但依赖它们至少不可移植，在未定义或未指定行为的情况下，也是一个错误。 即使本文档中引用的行为也不应依赖，并且将来的编译器或 CPU 实现可能会发生变化。

## <a name="example-migration-issues"></a>迁移问题示例

本文档的其余部分介绍这些C++语言元素的不同行为如何在不同的平台上产生不同的结果。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>将浮点转换为未签名整数

在 ARM 体系结构上，将浮点值转换为 32 位整数饱和到最接近的值，如果浮点值超出整数可以表示的范围，则整数可以表示该值。 在 x86 和 x64 体系结构上，如果整数未签名，则转换将环绕，或者如果对整数进行了签名，则转换设置为 -2147483648。 这些体系结构都没有直接支持将浮点值转换为较小的整数类型;相反，转换将执行到 32 位，结果被截断为较小的大小。

对于 ARM 体系结构，饱和度和截断的组合意味着，当 32 位整数饱和时，转换为未签名类型会正确饱和较小的无符号类型，但对于大于较小类型可以表示但太小且无法饱和完整 32 位整数的值，将生成截断结果。 转换对于 32 位签名整数也正确饱和，但饱和、已签名整数的截断会导致正饱和值为 -1，负饱和值为 0。 转换为较小的签名整数会产生不可预知的截断结果。

对于 x86 和 x64 体系结构，未签名整数转换的环绕行为和溢出上签名整数转换的明确评估以及截断相结合，使大多数移位的结果如果太大，则会导致无法预测的结果。

这些平台在处理 NaN（非数字）转换为整数类型的方式上也有所不同。 在 ARM 上，NaN 转换为 0x00000000;在 ARM 上，NaN 转换为 0x00000000;在 x86 和 x64 上，它转换为 0x800000000。

只有当您知道该值在要转换为的整数类型范围内时，才能依赖浮点转换。

### <a name="shift-operator---behavior"></a>移位操作员\<\<（ >>）行为

在 ARM 体系结构上，在模式开始重复之前，可以将值向左或向右移动最多 255 位。 在 x86 和 x64 体系结构上，模式在 32 的每个倍数上重复，除非模式的源是 64 位变量;否则模式的源为 64 位变量。在这种情况下，模式在 x64 上每 64 个倍数重复，在 x86 上重复每个 256 的倍数，其中使用了软件实现。 例如，对于值为 1 左移动 32 个位置的 32 位变量，在 ARM 上，结果为 0，在 x86 上，结果为 1，在 x64 上，结果也是 1。 但是，如果值的来源是 64 位变量，则所有三个平台上的结果为 4294967296，并且该值在 x64 上移动 64 个位置或 ARM 和 x86 上的 256 位置之前不会"环绕"。

由于超过源类型中位数的移位操作的结果未定义，因此编译器不需要在所有情况下具有一致的行为。 例如，如果在编译时知道移位的两个操作数，编译器可以使用内部例程预先计算移位结果，然后替换结果来代替移位操作来优化程序。 如果移位量过大或负数，则内部例程的结果可能与 CPU 执行的相同移位表达式的结果不同。

### <a name="variable-arguments-varargs-behavior"></a>变量参数（参数）行为

在 ARM 体系结构上，在堆栈上传递的变量参数列表中的参数需要对齐。 例如，64 位参数在 64 位边界上对齐。 在 x86 和 x64 上，在堆栈上传递的参数不受对齐和打包的约束。 如果变量参数列表的预期布局不完全匹配，则`printf`此差异可能导致类似于读取用于 ARM 上的填充的内存地址等可变函数，即使它可能适用于 x86 或 x64 体系结构上某些值的子集。 请看以下示例：

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

在这种情况下，可以通过确保使用正确的格式规范来修复 Bug，以便考虑参数的对齐方式。 此代码正确：

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>参数评估顺序

由于 ARM、x86 和 x64 处理器非常不同，因此它们可以为编译器实现提出不同的要求，也可以提供不同的优化机会。 因此，与调用约定和优化设置等其他因素一起，编译器可能会在不同的体系结构上或当其他因素发生更改时，以不同顺序计算函数参数。 这可能导致依赖于特定评估顺序的应用的行为意外更改。

当函数的参数具有影响同一调用中函数的其他参数的副作用时，可能会出现此类错误。 通常，这种依赖性很容易避免，但有时可能会被难以识别的依赖项或运算符重载所掩盖。 请考虑以下代码示例：

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

这似乎定义良好，但如果`->`和`*`运算符过载，则此代码将转换为类似于这种情况的内容：

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

如果 和`operator->(memory_handle)``operator*(p)`之间存在依赖项，则代码可能依赖于特定的评估顺序，即使原始代码看起来没有可能的依赖项。

### <a name="volatile-keyword-default-behavior"></a>易失性关键字默认行为

MSVC 编译器支持存储限定符的`volatile`两种不同的解释，您可以使用编译器开关来指定这些解释。 [/volatile：ms](reference/volatile-volatile-keyword-interpretation.md)开关选择 Microsoft 扩展的易失性语义，保证强大的排序，x86 和 x64 的传统情况就是一样，因为这些体系结构上的强内存模型。 [/volatile：iso](reference/volatile-volatile-keyword-interpretation.md)开关选择严格C++标准易失性语义，这些语义不能保证强排序。

在 ARM 体系结构上，默认值为 **/volatile：iso，** 因为 ARM 处理器的内存模型顺序较弱，而且 ARM 软件没有依赖 **/volatile：ms**的扩展语义的传统，并且通常不必与该软件接口。 但是，编译 ARM 程序以使用扩展语义有时仍然很方便，甚至需要。 例如，移植程序以使用 ISO C++语义可能成本太高，或者驱动程序软件可能必须遵守传统语义才能正常运行。 在这些情况下，可以使用 **/volatile：ms**开关;但是，要在 ARM 目标上重新创建传统的易失性语义，编译器必须在`volatile`变量的每个读取或写入周围插入内存障碍，以强制实施强排序，这可能会对性能产生负面影响。

在 x86 和 x64 体系结构上，默认值为 **/volatile：ms，** 因为通过使用 MSVC 已经为这些体系结构创建的许多软件都依赖于它们。 编译 x86 和 x64 程序时，可以指定 **/volatile：iso**开关，以帮助避免不必要地依赖传统的易失性语义，并促进可移植性。

## <a name="see-also"></a>另请参阅

[为 ARM 处理器配置 Visual C++](configuring-programs-for-arm-processors-visual-cpp.md)
