---
title: CPane Class
ms.date: 11/04/2016
f1_keywords:
- CPane
- AFXPANE/CPane
- AFXPANE/CPane::AdjustSizeImmediate
- AFXPANE/CPane::AllocElements
- AFXPANE/CPane::AllowShowOnPaneMenu
- AFXPANE/CPane::CalcAvailableSize
- AFXPANE/CPane::CalcInsideRect
- AFXPANE/CPane::CalcRecentDockedRect
- AFXPANE/CPane::CalcSize
- AFXPANE/CPane::CanBeDocked
- AFXPANE/CPane::CanBeTabbedDocument
- AFXPANE/CPane::ConvertToTabbedDocument
- AFXPANE/CPane::CopyState
- AFXPANE/CPane::Create
- AFXPANE/CPane::CreateDefaultMiniframe
- AFXPANE/CPane::CreateEx
- AFXPANE/CPane::DockByMouse
- AFXPANE/CPane::DockPane
- AFXPANE/CPane::DockPaneStandard
- AFXPANE/CPane::DockToFrameWindow
- AFXPANE/CPane::DoesAllowSiblingBars
- AFXPANE/CPane::FloatPane
- AFXPANE/CPane::GetAvailableExpandSize
- AFXPANE/CPane::GetAvailableStretchSize
- AFXPANE/CPane::GetBorders
- AFXPANE/CPane::GetClientHotSpot
- AFXPANE/CPane::GetDockSiteRow
- AFXPANE/CPane::GetExclusiveRowMode
- AFXPANE/CPane::GetHotSpot
- AFXPANE/CPane::GetMinSize
- AFXPANE/CPane::GetPaneName
- AFXPANE/CPane::GetVirtualRect
- AFXPANE/CPane::IsChangeState
- AFXPANE/CPane::IsDragMode
- AFXPANE/CPane::IsInFloatingMultiPaneFrameWnd
- AFXPANE/CPane::IsLeftOf
- AFXPANE/CPane::IsResizable
- AFXPANE/CPane::IsTabbed
- AFXPANE/CPane::LoadState
- AFXPANE/CPane::MoveByAlignment
- AFXPANE/CPane::MovePane
- AFXPANE/CPane::OnAfterChangeParent
- AFXPANE/CPane::OnBeforeChangeParent
- AFXPANE/CPane::OnPressCloseButton
- AFXPANE/CPane::OnShowControlBarMenu
- AFXPANE/CPane::RecalcLayout
- AFXPANE/CPane::SaveState
- AFXPANE/CPane::SetActiveInGroup
- AFXPANE/CPane::SetBorders
- AFXPANE/CPane::SetClientHotSpot
- AFXPANE/CPane::SetDockState
- AFXPANE/CPane::SetExclusiveRowMode
- AFXPANE/CPane::SetMiniFrameRTC
- AFXPANE/CPane::SetMinSize
- AFXPANE/CPane::SetVirtualRect
- AFXPANE/CPane::StretchPaneDeferWndPos
- AFXPANE/CPane::ToggleAutoHide
- AFXPANE/CPane::UndockPane
- AFXPANE/CPane::UpdateVirtualRect
- AFXPANE/CPane::OnAfterDock
- AFXPANE/CPane::OnAfterFloat
- AFXPANE/CPane::OnBeforeDock
- AFXPANE/CPane::OnBeforeFloat
- AFXPANE/CPane::m_bHandleMinSize
- AFXPANE/CPane::m_recentDockInfo
helpviewer_keywords:
- CPane [MFC], AdjustSizeImmediate
- CPane [MFC], AllocElements
- CPane [MFC], AllowShowOnPaneMenu
- CPane [MFC], CalcAvailableSize
- CPane [MFC], CalcInsideRect
- CPane [MFC], CalcRecentDockedRect
- CPane [MFC], CalcSize
- CPane [MFC], CanBeDocked
- CPane [MFC], CanBeTabbedDocument
- CPane [MFC], ConvertToTabbedDocument
- CPane [MFC], CopyState
- CPane [MFC], Create
- CPane [MFC], CreateDefaultMiniframe
- CPane [MFC], CreateEx
- CPane [MFC], DockByMouse
- CPane [MFC], DockPane
- CPane [MFC], DockPaneStandard
- CPane [MFC], DockToFrameWindow
- CPane [MFC], DoesAllowSiblingBars
- CPane [MFC], FloatPane
- CPane [MFC], GetAvailableExpandSize
- CPane [MFC], GetAvailableStretchSize
- CPane [MFC], GetBorders
- CPane [MFC], GetClientHotSpot
- CPane [MFC], GetDockSiteRow
- CPane [MFC], GetExclusiveRowMode
- CPane [MFC], GetHotSpot
- CPane [MFC], GetMinSize
- CPane [MFC], GetPaneName
- CPane [MFC], GetVirtualRect
- CPane [MFC], IsChangeState
- CPane [MFC], IsDragMode
- CPane [MFC], IsInFloatingMultiPaneFrameWnd
- CPane [MFC], IsLeftOf
- CPane [MFC], IsResizable
- CPane [MFC], IsTabbed
- CPane [MFC], LoadState
- CPane [MFC], MoveByAlignment
- CPane [MFC], MovePane
- CPane [MFC], OnAfterChangeParent
- CPane [MFC], OnBeforeChangeParent
- CPane [MFC], OnPressCloseButton
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], RecalcLayout
- CPane [MFC], SaveState
- CPane [MFC], SetActiveInGroup
- CPane [MFC], SetBorders
- CPane [MFC], SetClientHotSpot
- CPane [MFC], SetDockState
- CPane [MFC], SetExclusiveRowMode
- CPane [MFC], SetMiniFrameRTC
- CPane [MFC], SetMinSize
- CPane [MFC], SetVirtualRect
- CPane [MFC], StretchPaneDeferWndPos
- CPane [MFC], ToggleAutoHide
- CPane [MFC], UndockPane
- CPane [MFC], UpdateVirtualRect
- CPane [MFC], OnAfterDock
- CPane [MFC], OnAfterFloat
- CPane [MFC], OnBeforeDock
- CPane [MFC], OnBeforeFloat
- CPane [MFC], m_bHandleMinSize
- CPane [MFC], m_recentDockInfo
ms.assetid: 5c651a64-3c79-4d94-9676-45f6402a6bc5
ms.openlocfilehash: 7b2c5db976af832b1f1570dd431374c9e15520ad
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81364167"
---
# <a name="cpane-class"></a>CPane Class

该`CPane`类是[CControlBar 类](../../mfc/reference/ccontrolbar-class.md)的增强。 如果要升级现有的 MFC 项目，请将 的所有`CControlBar`匹配项替换为`CPane`。

## <a name="syntax"></a>语法

```
class CPane : public CBasePane
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|说明|
|----------|-----------------|
|`CPane::~CPane`|析构函数。|

### <a name="public-methods"></a>公共方法

|名称|说明|
|----------|-----------------|
|[CPane：：立即调整大小](#adjustsizeimmediate)|立即重新计算窗格的布局。|
|[CPane：Alloc元素](#allocelements)|分配存储供内部使用。|
|[CPane：：允许显示上帕内菜单](#allowshowonpanemenu)|指定窗格是否列在应用程序的运行时生成的窗格列表中。|
|[CPane：：计算可获取大小](#calcavailablesize)|计算指定矩形和当前窗口矩形之间的大小差异。|
|[CPane：：卡内卡雷茨](#calcinsiderect)|计算窗格的内部矩形，并考虑边框和夹持器。|
|[CPane：：卡塞雷德多克雷茨](#calcrecentdockedrect)|计算最近停靠的矩形。|
|[CPane：：计算](#calcsize)|计算窗格的大小。|
|[CPane：可以多克](#canbedocked)|确定窗格是否可以停靠在指定的基本窗格中。|
|[CPane：：可标签文档](#canbetabbeddocument)|确定是否可以将窗格转换为选项卡式文档。|
|[CPane：：转换到选项卡文档](#converttotabbeddocument)|将可停靠窗格转换为选项卡式文档。|
|[CPane：复制状态](#copystate)|复制窗格的状态。 （覆盖[CBasePane：复制状态](../../mfc/reference/cbasepane-class.md#copystate).）|
|[CPane：：创建](#create)|创建控制栏并将其附加到`CPane`对象。|
|[CPane：：创建默认Mini框架](#createdefaultminiframe)|为浮动窗格创建微型框架窗口。|
|[CPane：：创建Ex](#createex)|创建控制栏并将其附加到`CPane`对象。|
|`CPane::CreateObject`|由框架用于创建此类类型的动态实例。|
|[CPane：:DockbyMouse](#dockbymouse)|使用鼠标停靠方法停靠窗格。|
|[CPane：:DockPane](#dockpane)|将浮动窗格停靠到基本窗格。|
|[CPane：:D](#dockpanestandard)|使用轮廓（标准）停靠来停靠窗格。|
|[CPane：:Docktoframe窗口](#docktoframewindow)|将可停靠窗格停靠到框架。 （重写 `CBasePane::DockToFrameWindow`。）|
|[CPane：:D允许同级条形](#doesallowsiblingbars)|指示是否可以将另一个窗格停靠在当前窗格停靠的同一行上。|
|[CPane：浮动窗格](#floatpane)|浮动窗格。|
|[CPane：：获取可用扩展大小](#getavailableexpandsize)|返回窗格可以展开的金额（以像素为单位）。|
|[CPane：获取可用拉伸大小](#getavailablestretchsize)|返回窗格可以收缩的金额（以像素为单位）。|
|[CPane：获取边框](#getborders)|返回窗格边框的宽度。|
|[CPane：获取客户热点](#getclienthotspot)|返回窗格*hot spot*的热点。|
|[CPane：获取 DockSiteRow](#getdocksiterow)|返回窗格停靠的停靠行。|
|[CPane：获取独占行模式](#getexclusiverowmode)|确定窗格是否处于独占行模式。|
|[CPane：获取热点](#gethotspot)|返回存储在基础`CMFCDragFrameImpl`对象中的热点。|
|[CPane：获取最小值](#getminsize)|检索窗格的最小允许大小。|
|[CPane：获取窗格名称](#getpanename)|检索窗格的标题。|
|`CPane::GetResizeStep`|内部使用。|
|`CPane::GetThisClass`|框架用于获取指向与此类类型关联的[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)对象的指针。|
|[CPane：获取虚拟重新](#getvirtualrect)|检索窗格的*虚拟矩形*。|
|[CPane：isChangeState](#ischangestate)|移动窗格时，此方法分析窗格相对于其他窗格、停靠行和微型框架窗口的位置，并返回相应的AFX_CS_STATUS值。|
|[CPane：：是德拉格模式](#isdragmode)|指定是否正在拖动窗格。|
|[CPane：：在漂浮的多窗格框架](#isinfloatingmultipaneframewnd)|指定窗格是否位于多窗格框架窗口中。 （重写 `CBasePane::IsInFloatingMultiPaneFrameWnd`。）|
|[CPane：：是](#isleftof)|确定窗格是否位于指定矩形的左侧（或上方）。|
|[CPane：可调整大小](#isresizable)|确定是否可以调整窗格的大小。 （覆盖[CBasePane：可调整大小](../../mfc/reference/cbasepane-class.md#isresizable).|
|[CPane：：已选项卡](#istabbed)|确定窗格是否已插入选项卡式窗口的选项卡控件中。 （覆盖[CBasePane：已选项卡](../../mfc/reference/cbasepane-class.md#istabbed)。）|
|[CPane：加载状态](#loadstate)|从注册表加载窗格的状态。 （覆盖[CBasePane：：加载状态](../../mfc/reference/cbasepane-class.md#loadstate).）|
|[CPane：移动](#movebyalignment)|按指定数量移动窗格和虚拟矩形。|
|[CPane：移动窗格](#movepane)|将窗格移动到指定的矩形。|
|[CPane：在更改后打开父级](#onafterchangeparent)|当窗格的父级已更改时由框架调用。|
|[CPane：在更改父级之前打开](#onbeforechangeparent)|当窗格的父级即将更改时，由框架调用。|
|[CPane：打开按钮](#onpressclosebutton)|当用户选择窗格标题上的"关闭"按钮时，由框架调用。|
|`CPane::OnProcessDblClk`|内部使用。|
|[CPane：在显示控制栏菜单](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|[CPane：在显示控制栏菜单](#onshowcontrolbarmenu)|当即将显示特殊窗格菜单时由框架调用。|
|`CPane::PrepareToDock`|内部使用。|
|[CPane：Recalclayout](#recalclayout)|重新计算窗格的布局信息。 （覆盖[CBasePane：recalclayout](../../mfc/reference/cbasepane-class.md#recalclayout).）|
|[CPane：保存状态](#savestate)|将窗格的状态保存到注册表。 （覆盖[CBasePane：：保存状态](../../mfc/reference/cbasepane-class.md#savestate).）|
|[CPane：设置活动组](#setactiveingroup)|将窗格标记为活动窗格。|
|[CPane：设置边框](#setborders)|设置窗格的边框值。|
|[CPane：设置客户端热点](#setclienthotspot)|设置窗格的热点。|
|[CPane：setDockState](#setdockstate)|还原窗格的停靠状态信息。|
|[CPane：设置独占行模式](#setexclusiverowmode)|启用或禁用独占行模式。|
|[CPane：设置MiniFrameRTC](#setminiframertc)|设置默认小型框架窗口的运行时类信息。|
|[CPane：设置最小值](#setminsize)|设置窗格的最小允许大小。|
|[CPane：设置虚拟重新](#setvirtualrect)|设置窗格的*虚拟矩形*。|
|[CPane：：拉伸帕内德温德波斯](#stretchpanedeferwndpos)|根据停靠样式垂直或水平拉伸窗格。|
|[CPane：：切换自动隐藏](#toggleautohide)|切换自动隐藏模式。|
|[CPane：取消板块窗格](#undockpane)|从当前停靠的停靠站点、默认滑块或微型框架窗口中删除窗格。 （覆盖[CBasePane：取消停靠窗格](../../mfc/reference/cbasepane-class.md#undockpane).）|
|[CPane：更新虚拟重新](#updatevirtualrect)|更新虚拟矩形。|

### <a name="protected-methods"></a>受保护的方法

|名称|说明|
|----------|-----------------|
|[CPane：在后头](#onafterdock)|当窗格已停靠时由框架调用。|
|[CPane：在以后浮动](#onafterfloat)|浮动窗格时由框架调用。|
|[CPane：：在Dock前](#onbeforedock)|当窗格即将停靠时，由框架调用。|
|[CPane：在漂浮前打开](#onbeforefloat)|当窗格即将浮动时，由框架调用。|

### <a name="data-members"></a>数据成员

|名称|说明|
|----------|-----------------|
|[CPane：：m_bHandleMinSize](#m_bhandleminsize)|支持对窗格的最小大小的一致处理。|
|[CPane：m_recentDockInfo](#m_recentdockinfo)|包含最近的停靠信息。|

## <a name="remarks"></a>备注

通常，`CPane`对象不会直接实例化。 如果需要具有停靠功能的窗格，请从[CDockablePane](../../mfc/reference/cdockablepane-class.md)派生对象。 如果需要工具栏功能，请从[CMFCToolBar](../../mfc/reference/cmfctoolbar-class.md)派生对象。

当您从`CPane`派生类时，它可以停靠在[CDockSite](../../mfc/reference/cdocksite-class.md)中，并且它可以浮动在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)中。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

[CPane](../../mfc/reference/cpane-class.md)

## <a name="requirements"></a>要求

**标题：** afxPane.h

## <a name="cpaneadjustsizeimmediate"></a><a name="adjustsizeimmediate"></a>CPane：：立即调整大小

立即重新计算窗格的布局。

```
virtual void AdjustSizeImmediate(BOOL bRecalcLayout = TRUE);
```

### <a name="parameters"></a>参数

*bRecalcLayout*<br/>
[在]TRUE 自动重新计算窗格的布局;否则，FALSE。

### <a name="remarks"></a>备注

动态更改窗格的布局时调用此方法。 例如，在隐藏或显示工具栏按钮时，您可能希望调用此方法。

## <a name="cpaneallocelements"></a><a name="allocelements"></a>CPane：Alloc元素

分配存储供内部使用。

```
BOOL AllocElements(
    int nElements,
    int cbElement);
```

### <a name="parameters"></a>参数

*n元素*<br/>
[在]为其分配存储的元素数。

*cb元素*<br/>
[在]元素的大小（以字节为单位）。

### <a name="return-value"></a>返回值

如果内存分配失败，则 FALSE;否则，真实。

## <a name="cpaneallowshowonpanemenu"></a><a name="allowshowonpanemenu"></a>CPane：：允许显示上帕内菜单

指定窗格是否列在应用程序的运行时生成的窗格列表中。

```
virtual BOOL AllowShowOnPaneMenu() const;
```

### <a name="return-value"></a>返回值

如果窗格显示在列表中，则为 TRUE;如果窗格显示在列表中，则为 TRUE。否则，FALSE。 基本实现始终返回 TRUE。

### <a name="remarks"></a>备注

AppWizard 生成的应用程序包含一个菜单选项，该选项列出了它包含的窗格。 此方法确定窗格是否显示在列表中。

## <a name="cpanecalcavailablesize"></a><a name="calcavailablesize"></a>CPane：：计算可获取大小

计算指定矩形和当前窗口矩形之间的大小差异。

```
virtual CSize CalcAvailableSize(CRect rectRequired);
```

### <a name="parameters"></a>参数

*rect要求*<br/>
[在]所需的矩形。

### <a name="return-value"></a>返回值

*rect需要*和当前窗口矩形之间的宽度和高度差异。

## <a name="cpanecalcinsiderect"></a><a name="calcinsiderect"></a>CPane：：卡内卡雷茨

计算窗格的内部矩形，包括边框和夹持器。

```
void CalcInsideRect(
    CRect& rect,
    BOOL bHorz) const;
```

### <a name="parameters"></a>参数

*矩形*<br/>
[出]包含窗格工作区的大小和偏移量。

*布霍兹*<br/>
[在]如果窗格是水平方向的，则为 TRUE;如果窗格是水平方向的，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

当框架必须重新计算窗格的布局时，框架会调用此方法。 *rect*参数填充窗格的工作区的大小和偏移量。 这包括其边界和夹持器。

## <a name="cpanecalcrecentdockedrect"></a><a name="calcrecentdockedrect"></a>CPane：：卡塞雷德多克雷茨

计算最近停靠的矩形。

```
void CalcRecentDockedRect();
```

### <a name="remarks"></a>备注

此方法更新[CPane：：m_recentDockInfo](#m_recentdockinfo)。

## <a name="cpanecalcsize"></a><a name="calcsize"></a>CPane：：计算

计算窗格的大小。

```
virtual CSize CalcSize(BOOL bVertDock);
```

### <a name="parameters"></a>参数

*bVertDock*<br/>
[在]如果窗格垂直停靠，则为 TRUE，否则为 FALSE。

### <a name="return-value"></a>返回值

此方法的默认实现返回大小 （0， 0）。

### <a name="remarks"></a>备注

派生类应重写此方法。

## <a name="cpanecanbedocked"></a><a name="canbedocked"></a>CPane：可以多克

确定窗格是否可以停靠在指定的基本窗格中。

```
virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[在]指定要停靠此窗格的窗格。

### <a name="return-value"></a>返回值

如果此窗格可以停靠在指定的停靠窗格中，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

框架通常调用此方法来确定窗格是否可以停靠在指定的停靠窗格中。 要确定是否可以停靠窗格，该方法将评估窗格当前启用的停靠对齐方式。

通过调用[CBasePane：：启用停靠](../../mfc/reference/cbasepane-class.md#enabledocking)，可以启用与框架窗口各个面的停靠。

## <a name="cpanecanbetabbeddocument"></a><a name="canbetabbeddocument"></a>CPane：：可标签文档

确定窗格是否可以转换为选项卡式文档。

```
virtual BOOL CanBeTabbedDocument() const;
```

### <a name="return-value"></a>返回值

如果窗格可以转换为选项卡式文档，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

如果要阻止将窗格转换为选项卡式文档，则在派生类中重写此方法并返回 FALSE。 选项卡式文档将不会在"窗口位置"菜单中列出。

## <a name="cpaneconverttotabbeddocument"></a><a name="converttotabbeddocument"></a>CPane：：转换到选项卡文档

将可停靠窗格转换为选项卡式文档。

```
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```

### <a name="parameters"></a>参数

*b 活动标签*<br/>
[在]未在`CPane::ConvertToTabbedDocument`中使用。

### <a name="remarks"></a>备注

只能将可停靠的窗格转换为选项卡式文档。 有关详细信息，请参阅[可停靠窗格：：转换到选项卡文档](../../mfc/reference/cdockablepane-class.md#converttotabbeddocument)。

## <a name="cpanecopystate"></a><a name="copystate"></a>CPane：复制状态

复制窗格的状态。

```
virtual void CopyState(CPane* pOrgBar);
```

### <a name="parameters"></a>参数

*pOrgBar*<br/>
[在]指向窗格的指针。

### <a name="remarks"></a>备注

此方法将*pOrgBar*的状态复制到当前窗格。

## <a name="cpanecreate"></a><a name="create"></a>CPane：：创建

创建控制栏并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*lpszClass名称*<br/>
[在]指定 Windows 类的名称。

*dwStyle*<br/>
[在]指定窗口样式属性。 有关详细信息，请参阅[窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*矩形*<br/>
[在]在客户端坐标中指定*pParentWnd*窗口的初始大小和位置。

*pparentwnd*<br/>
[进出]指定此窗格的父窗口。

*nID*<br/>
[在]指定窗格的 ID。

*dwControlBar样式*<br/>
[在]指定窗格的样式。 有关详细信息，请参阅[CBasePane：：创建Ex](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[进出]指定窗格的创建上下文。

### <a name="return-value"></a>返回值

如果窗格已成功创建，则为 TRUE;如果窗格已成功创建，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

此方法创建 Windows 窗格并将其附加到`CPane`对象。

如果在调用`Create`之前没有明确初始化[CPane：：m_recentDockInfo，](#m_recentdockinfo)则在浮动或停靠窗格时，参数*rect*将用作矩形。

## <a name="cpanecreatedefaultminiframe"></a><a name="createdefaultminiframe"></a>CPane：：创建默认Mini框架

为浮动窗格创建微型框架窗口。

```
virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);
```

### <a name="parameters"></a>参数

*重新初始化*<br/>
[在]指定要创建的微型框架窗口的初始大小和位置（在屏幕坐标中）。

### <a name="return-value"></a>返回值

新创建的微型框架窗口。

### <a name="remarks"></a>备注

框架调用此方法，在浮动窗格时创建微型框架窗口。 迷你框架窗口可以是[CPaneFramewnd](../../mfc/reference/cpaneframewnd-class.md)类型，也可以是[CMultiPaneFramewnd](../../mfc/reference/cmultipaneframewnd-class.md)类型。 如果窗格具有AFX_CBRS_FLOAT_MULTI样式，则创建多微型框架窗口。

小型框架窗口的运行时类信息存储在成员中`CPane::m_pMiniFrameRTC`。 如果您决定创建自定义的微型框架窗口，则可以使用派生类设置此成员。

## <a name="cpanecreateex"></a><a name="createex"></a>CPane：：创建Ex

创建控制栏并将其附加到[CPane](../../mfc/reference/cpane-class.md)对象。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*dwStyleEx*<br/>
[在]指定扩展的窗口样式属性。 有关详细信息，请参阅[扩展窗口样式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

*lpszClass名称*<br/>
[在]指定 Windows 类的名称。

*dwStyle*<br/>
[在]指定窗口样式属性。 有关详细信息，请参阅[窗口样式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*矩形*<br/>
[在]在客户端坐标中指定*pParentWnd*窗口的初始大小和位置。

*pparentwnd*<br/>
[进出]指定此窗格的父窗口。

*nID*<br/>
[在]指定窗格的 ID。

*dwControlBar样式*<br/>
[在]指定窗格的样式。 有关详细信息，请参阅[CBasePane：：创建Ex](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[进出]指定窗格的创建上下文。

### <a name="return-value"></a>返回值

如果窗格已成功创建，则为 TRUE;如果窗格已成功创建，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

此方法创建 Windows 窗格并将其附加到`CPane`对象。

如果在调用`CreateEx`之前没有明确初始化[CPane：：m_recentDockInfo，](#m_recentdockinfo)则在浮动或停靠窗格时，参数*rect*将用作矩形。

## <a name="cpanedockbymouse"></a><a name="dockbymouse"></a>CPane：:DockbyMouse

使用鼠标停靠窗格。

```
virtual BOOL DockByMouse(CBasePane* pDockBar);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[在]指定要停靠此窗格的基础窗格。

### <a name="return-value"></a>返回值

如果窗格已成功停靠，则为 TRUE;如果窗格已成功停靠。否则，FALSE。

## <a name="cpanedockpane"></a><a name="dockpane"></a>CPane：:DockPane

将浮动窗格停靠到基本窗格。

```
virtual BOOL DockPane(
    CBasePane* pDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pDockBar*<br/>
[进出]指定要将此窗格停靠到的基本窗格。

*lpRect*<br/>
[在]指定要停靠此窗格的基础窗格上的矩形。

*基方法*<br/>
[在]指定要使用的停靠方法。 可用选项如下：

|选项|说明|
|------------|-----------------|
|DM_UNKNOWN|当停靠方法未知时，框架使用此选项。 窗格不存储其最新的浮动位置。 当不必存储最近的浮动位置时，还可以使用此选项以编程方式停靠窗格。|
|DM_MOUSE|内部使用。|
|DM_DBL_CLICK|双击夹持器时，使用此选项。 窗格将重新定位到其最近的停靠位置。 如果通过双击取消停靠窗格，则窗格将重新定位到其最近的浮动位置。|
|DM_SHOW|此选项可用于以编程方式停靠窗格。 窗格存储其最新的浮动位置。|
|DM_RECT|窗格停靠在*由 lpRect*指定的区域中。|
|DM_STANDARD|使用此选项时，框架在移动窗格时将窗格绘制为轮廓框架。|

### <a name="return-value"></a>返回值

如果窗格已成功停靠，则为 TRUE;如果窗格已成功停靠。否则，FALSE。

### <a name="remarks"></a>备注

此方法将窗格停靠到*pDockBar*参数指定的基本窗格。 您必须首先通过调用[CBasePane：：启用停靠](../../mfc/reference/cbasepane-class.md#enabledocking)来启用停靠。

## <a name="cpanedockpanestandard"></a><a name="dockpanestandard"></a>CPane：:D

使用轮廓（标准）停靠来停靠窗格。

```
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```

### <a name="parameters"></a>参数

*bWasdocked*<br/>
[在]如果窗格已成功停靠，则为 TRUE;如果窗格已成功停靠否则，FALSE。

### <a name="return-value"></a>返回值

此方法始终返回**此**指针。

### <a name="remarks"></a>备注

此方法仅用于派生自[CDockablePane 类的窗格](../../mfc/reference/cdockablepane-class.md)。 有关详细信息，请参阅[可多克窗格：:DockPane标准](../../mfc/reference/cdockablepane-class.md#dockpanestandard)。

## <a name="cpanedocktoframewindow"></a><a name="docktoframewindow"></a>CPane：:Docktoframe窗口

将可停靠窗格停靠到框架。

```
virtual BOOL DockToFrameWindow(
    DWORD dwAlignment,
    LPCRECT lpRect = NULL,
    DWORD dwDockFlags = DT_DOCK_LAST,
    CBasePane* pRelativeBar = NULL,
    int nRelativeIndex = -1,
    BOOL bOuterEdge = FALSE);
```

### <a name="parameters"></a>参数

*dwalignment*<br/>
[在]要将窗格停靠到的父框架的一侧。

*lpRect*<br/>
[在]指定的大小。

*dwDockFlags*<br/>
[在]忽视。

*相对栏*<br/>
[在]忽视。

*n相对索引*<br/>
[在]忽视。

*bouterEdge*<br/>
[在]如果 TRUE 和*dwAlignment*指定的侧有其他可停靠窗格，则窗格将停靠在其他窗格之外，靠近父框架的边缘。 如果 FALSE，则窗格停靠在工作区的中心较近。

### <a name="return-value"></a>返回值

如果无法创建窗格分隔符[（CPaneDivider 类](../../mfc/reference/cpanedivider-class.md)） 则 FALSE;否则，真实。

### <a name="remarks"></a>备注

## <a name="cpanedoesallowsiblingbars"></a><a name="doesallowsiblingbars"></a>CPane：:D允许同级条形

指示是否可以将另一个窗格停靠在当前窗格停靠的同一行上。

```
virtual BOOL DoesAllowSiblingBars() const;
```

### <a name="return-value"></a>返回值

如果此窗格可以停靠到与自身相同的行上的另一个窗格，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

您可以通过调用[CPane：：设置独占行模式](#setexclusiverowmode)来启用或禁用此行为。

默认情况下，工具栏已禁用独占行模式，并且菜单栏启用了独占行模式。

## <a name="cpanefloatpane"></a><a name="floatpane"></a>CPane：浮动窗格

浮动窗格。

```
virtual BOOL FloatPane(
    CRect rectFloat,
    AFX_DOCK_METHOD dockMethod = DM_UNKNOWN,
    bool bShow = true);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
[在]指定在屏幕坐标中的位置，以在窗格浮动时定位窗格。

*基方法*<br/>
[在]指定浮动窗格时要使用的停靠方法。 有关可能值的列表，请参阅[CPane：:DockPane](#dockpane)。

*b显示*<br/>
[在]TRUE 以在浮动时显示窗格;否则，FALSE。

### <a name="return-value"></a>返回值

如果窗格已成功浮动，或者窗格无法浮动，则为 TRUE，因为[CBasePane：：：canFloat](../../mfc/reference/cbasepane-class.md#canfloat)返回 FALSE;否则，FALSE。

### <a name="remarks"></a>备注

调用此方法以将窗格浮动到*rectFloat*参数指定的位置。 此方法会自动为窗格创建父小型框架窗口。

## <a name="cpanegetavailableexpandsize"></a><a name="getavailableexpandsize"></a>CPane：：获取可用扩展大小

返回窗格可以展开的金额（以像素为单位）。

```
virtual int GetAvailableExpandSize() const;
```

### <a name="return-value"></a>返回值

如果窗格水平停靠，则返回值为可用宽度;如果窗格水平停靠，则返回值为可用宽度。否则，返回值为可用高度。

### <a name="remarks"></a>备注

## <a name="cpanegetavailablestretchsize"></a><a name="getavailablestretchsize"></a>CPane：获取可用拉伸大小

返回窗格可以收缩的金额（以像素为单位）。

```
virtual int GetAvailableStretchSize() const;
```

### <a name="return-value"></a>返回值

窗格可以缩小的金额（以像素为单位）。 如果窗格水平停靠，则此金额为可用宽度;如果窗格水平停靠，则此金额为可用宽度。否则，它是可用的高度。

### <a name="remarks"></a>备注

通过从当前大小[（CWnd：getWindowRect）](../../mfc/reference/cwnd-class.md#getwindowrect)中减去窗格的最小允许大小[（CPane：getMinSize）](#getminsize)来计算可用的拉伸大小。

## <a name="cpanegetborders"></a><a name="getborders"></a>CPane：获取边框

返回窗格边框的宽度。

```
CRect GetBorders() const;
```

### <a name="return-value"></a>返回值

包含窗格每一侧的当前宽度（以像素为单位）的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 例如，`left``CRect`对象成员的值是左边框的宽度。

### <a name="remarks"></a>备注

要设置边框的大小，请调用[CPane：：setBorders](#setborders)。

## <a name="cpanegetclienthotspot"></a><a name="getclienthotspot"></a>CPane：获取客户热点

返回窗格*hot spot*的热点。

```
CPoint GetClientHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*热点*是用户选择并保留以移动窗格的窗格上的点。 当窗格从停靠位置移动时，热点用于平滑动画。

## <a name="cpanegetdocksiterow"></a><a name="getdocksiterow"></a>CPane：获取 DockSiteRow

返回停靠窗格的停靠行 （ [CDockingPanerow 类](../../mfc/reference/cdockingpanesrow-class.md)）。

```
CDockingPanesRow* GetDockSiteRow() const;
```

### <a name="return-value"></a>返回值

指向`CDockingPanesRow`窗格停靠的停靠行的 *;如果窗格未停靠，则为 NULL。

## <a name="cpanegetexclusiverowmode"></a><a name="getexclusiverowmode"></a>CPane：获取独占行模式

确定窗格是否处于独占行模式。

```
virtual BOOL GetExclusiveRowMode() const;
```

### <a name="return-value"></a>返回值

如果窗格处于独占行模式，则为 TRUE;如果窗格处于独占行模式。否则，FALSE。

### <a name="remarks"></a>备注

有关独占行模式的详细信息，请参阅[CPane：：设置独占行模式](#setexclusiverowmode)。

## <a name="cpanegethotspot"></a><a name="gethotspot"></a>CPane：获取热点

返回存储在基础`CMFCDragFrameImpl`对象中的热点。

```
CPoint GetHotSpot() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

类`CPane`包含一个`CMFCDragFrameImpl`对象 ，`m_dragFrameImpl`负责绘制在标准停靠模式下移动窗格时出现的矩形。 热点用于在用户移动窗格时绘制相对于当前鼠标位置的矩形。

## <a name="cpanegetminsize"></a><a name="getminsize"></a>CPane：获取最小值

检索窗格的最小允许大小。

```
virtual void GetMinSize(CSize& size) const;
```

### <a name="parameters"></a>参数

*大小*<br/>
[出]以`CSize`最小允许大小填充的对象。

### <a name="remarks"></a>备注

## <a name="cpanegetpanename"></a><a name="getpanename"></a>CPane：获取窗格名称

检索窗格的标题。

```
virtual void GetPaneName(CString& strName) const;
```

### <a name="parameters"></a>参数

*strName*<br/>
[出]使用`CString`标题名称填充的对象。

### <a name="remarks"></a>备注

当窗格停靠或浮动时，窗格标题将显示在标题区域中。 如果窗格是选项卡式组的一部分，则标题将显示在选项卡区域中。 如果窗格处于自动隐藏模式，则标题将显示在`CMFCAutoHideButton`上。

## <a name="cpanegetvirtualrect"></a><a name="getvirtualrect"></a>CPane：获取虚拟重新

检索窗格的*虚拟矩形*。

```
void GetVirtualRect(CRect& rectVirtual) const;
```

### <a name="parameters"></a>参数

*rect虚拟*<br/>
[出]填充`CRect`虚拟矩形的对象。

### <a name="remarks"></a>备注

移动窗格时，框架将窗格的原始位置存储在虚拟矩形中。 框架可以使用虚拟矩形还原窗格的原始位置。

除非以编程方式移动窗格，否则不要调用与虚拟矩形相关的方法。

## <a name="cpaneischangestate"></a><a name="ischangestate"></a>CPane：isChangeState

移动窗格时，此方法分析其相对于其他窗格、停靠行和微型框架窗口的位置，并返回相应的AFX_CS_STATUS值。

```
virtual AFX_CS_STATUS IsChangeState(
    int nOffset,
    CBasePane** ppTargetBar) const;
```

### <a name="parameters"></a>参数

*n偏移*<br/>
[在]指定停靠灵敏度。 例如，从停靠行在*nOffset*像素内移动的窗格将停靠。

*ppTargetBar*<br/>
[在]当方法返回时 *，ppTargetBar*包含指向应停靠当前窗格的对象的指针，或者包含 NULL（如果未发生停靠）。

### <a name="return-value"></a>返回值

以下AFX_CS_STATUS值之一：

|“值”|说明|
|-----------|-----------------|
|CS_NOTHING|窗格不靠近停靠站点。 框架不停靠窗格。|
|CS_DOCK_IMMEDIATELY|窗格位于停靠站点上，并启用DT_IMMEDIATE样式。 框架立即停靠窗格。|
|CS_DELAY_DOCK|窗格位于停靠站点上，该站点是另一个停靠窗格或主框架的边缘。 当用户释放移动时，框架将停靠窗格。|
|CS_DELAY_DOCK_TO_TAB|窗格位于停靠站点上，该站点会导致窗格停靠在选项卡式窗口中。 当窗格位于其他停靠窗格的标题上或选项卡式窗格的选项卡区域时，将发生这种情况。 当用户释放移动时，框架将停靠窗格。|

## <a name="cpaneisdragmode"></a><a name="isdragmode"></a>CPane：：是德拉格模式

指定是否移动窗格。

```
virtual BOOL IsDragMode() const;
```

### <a name="return-value"></a>返回值

如果正在移动窗格，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

## <a name="cpaneisinfloatingmultipaneframewnd"></a><a name="isinfloatingmultipaneframewnd"></a>CPane：：在漂浮的多窗格框架

指定窗格是否位于多窗格框架窗口中[（CMultiPaneFramewnd 类](../../mfc/reference/cmultipaneframewnd-class.md)）。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>返回值

如果窗格位于多窗格框架窗口中，则为 TRUE;如果窗格位于多窗格框架窗口中，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

只有可停靠的窗格才能浮动在多窗格框架窗口中。 因此，`CPane::IsInFloatingMultiPaneFrameWnd`始终返回 FALSE。

## <a name="cpaneisleftof"></a><a name="isleftof"></a>CPane：：是

确定窗格是否位于指定矩形的左侧（或上方）。

```
bool IsLeftOf(
    CRect rect,
    bool bWindowRect = true) const;
```

### <a name="parameters"></a>参数

*矩形*<br/>
[在]用于`CRect`比较的对象。

*b窗口雷ct*<br/>
[在]如果为 TRUE，则假定矩形包含屏幕坐标;如果为 TRUE，则假定*rect*包含屏幕坐标。如果 FALSE，则假定*rect*包含客户端坐标。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

如果窗格是水平停靠的，此方法将检查其位置是否保留为*rect*。 否则，此方法将检查位置是否高于*rect*。

## <a name="cpaneisresizable"></a><a name="isresizable"></a>CPane：可调整大小

指定窗格是否可调整大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>返回值

如果窗格可调整大小，则为 TRUE;如果窗格可调整大小，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

基`CPane`对象不可调整大小。

停靠管理器使用可调整大小的标志来确定窗格布局。 非可调整大小的窗格始终位于父框架的外边缘。

不可调整大小的窗格不能驻留在停靠容器中。

## <a name="cpaneistabbed"></a><a name="istabbed"></a>CPane：：已选项卡

确定窗格是否已插入到选项卡式窗口的选项卡控件中。

```
virtual BOOL IsTabbed() const;
```

### <a name="return-value"></a>返回值

如果窗格已选项卡，则为 TRUE;如果窗格已选项卡式使用。否则，FALSE。

### <a name="remarks"></a>备注

选项卡状态与浮动、停靠和自动隐藏状态分开处理。

## <a name="cpaneloadstate"></a><a name="loadstate"></a>CPane：加载状态

从注册表加载窗格的状态。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpsz配置文件名称*<br/>
[在]配置文件名称。

*nIndex*<br/>
[在]配置文件索引。

*uiID*<br/>
[在]窗格 ID。

### <a name="return-value"></a>返回值

如果窗格状态已成功加载，则为 TRUE;如果窗格状态已成功加载，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

框架调用此方法从注册表加载窗格状态。 在派生类中覆盖它以加载[由 CPane：：：SaveState](#savestate)保存的其他信息。

重写此方法时，也会调用基方法，如果基方法返回 FALSE，则返回 FALSE。

## <a name="cpanem_bhandleminsize"></a><a name="m_bhandleminsize"></a>CPane：：m_bHandleMinSize

支持一致处理最小窗格大小。

```
AFX_IMPORT_DATA static BOOL m_bHandleMinSize;
```

### <a name="remarks"></a>备注

如果应用程序中的一个或多个停靠窗格覆盖`GetMinSize`，或者应用程序调用`SetMinSize`，则可能需要将此静态成员设置为 TRUE，以使框架能够一致地处理窗格的大小。

如果此值设置为 TRUE，则所有大小应缩小到低于其最小大小的窗格都将剪切，而不是拉伸。 由于框架使用窗口区域进行窗格大小调整，因此，如果此值设置为 TRUE，则不要更改停靠窗格的窗口区域的大小。

## <a name="cpanem_recentdockinfo"></a><a name="m_recentdockinfo"></a>CPane：m_recentDockInfo

包含最近的停靠信息。

```
CRecentDockSiteInfo m_recentDockInfo;
```

### <a name="remarks"></a>备注

框架在此成员中存储窗格的最新停靠状态信息。

## <a name="cpanemovebyalignment"></a><a name="movebyalignment"></a>CPane：移动

按指定数量移动窗格和虚拟矩形。

```
BOOL MoveByAlignment(
    DWORD dwAlignment,
    int nOffset);
```

### <a name="parameters"></a>参数

*dwalignment*<br/>
[在]指定窗格对齐方式。

*n偏移*<br/>
[在]移动窗格和虚拟矩形的金额（以像素为单位）。

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

*dwalignment*可以是以下任一值：

|“值”|说明|
|-----------|-----------------|
|CBRS_ALIGN_TOP|使窗格能够停靠到框架窗口的工作区的顶部。|
|CBRS_ALIGN_BOTTOM|使窗格能够停靠到框架窗口的工作区的底部。|
|CBRS_ALIGN_LEFT|使窗格能够停靠到框架窗口的工作区的左侧。|
|CBRS_ALIGN_RIGHT|使窗格能够停靠到框架窗口的工作区的右侧。|
|CBRS_ALIGN_ANY|使窗格能够停靠到框架窗口的工作区的任何一侧。|

如果 dwAlignment 包含CBRS_ALIGN_LEFT或CBRS_ALIGN_RIGHT标志，则窗格和虚拟矩形将水平移动;如果*dwalignment*包含CBRS_ALIGN_LEFT或CBRS_ALIGN_RIGHT标志，则移动窗格和虚拟矩形。否则，如果*dwAlignment*包含CBRS_ALIGN_TOP或CBRS_ALIGN_BOTTOM标志，则窗格和虚拟矩形将垂直移动。

## <a name="cpanemovepane"></a><a name="movepane"></a>CPane：移动窗格

将窗格移动到指定的矩形。

```
virtual CSize MovePane(
    CRect rectNew,
    BOOL bForceMove,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*重新*<br/>
[在]指定窗格的新矩形。

*bForceMove*<br/>
[在]如果为 TRUE，则此方法将忽略允许的最小窗格大小[（CPane：getMinSize）;](#getminsize)否则，如有必要，将调整窗格，以确保它至少是允许的最小大小。

*hdwp*<br/>
[在]未使用。

### <a name="return-value"></a>返回值

包含`CSize`新旧矩形（旧矩形 - *rectNew）* 之间的宽度和高度差异的对象。

### <a name="remarks"></a>备注

此方法仅用于可停靠的窗格。

## <a name="cpaneonafterchangeparent"></a><a name="onafterchangeparent"></a>CPane：在更改后打开父级

当窗格的父级已更改时由框架调用。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>参数

*pWndOld 父级*<br/>
[进出]窗格的上一个父窗口。

### <a name="remarks"></a>备注

当窗格的父级由于停靠或浮动操作而发生更改时，框架将调用此方法。

## <a name="cpaneonafterdock"></a><a name="onafterdock"></a>CPane：在后头

当窗格已停靠时由框架调用。

```
virtual void OnAfterDock(
    CBasePane* pBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*pBar*<br/>
[在]不使用此参数。

*lpRect*<br/>
[在]不使用此参数。

*基方法*<br/>
[在]不使用此参数。

## <a name="cpaneonafterfloat"></a><a name="onafterfloat"></a>CPane：在以后浮动

在窗格浮动后由框架调用。

```
virtual void OnAfterFloat();
```

### <a name="remarks"></a>备注

如果要在窗格浮动后执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonbeforechangeparent"></a><a name="onbeforechangeparent"></a>CPane：在更改父级之前打开

当窗格的父级即将更改时，由框架调用。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*pWnd 新家长*<br/>
[进出]指定新的父窗口。

*bDelay*<br/>
[在]TRUE 延迟全局对接布局调整;否则，FALSE。

### <a name="remarks"></a>备注

当窗格的父级由于窗格停靠或浮动而即将更改时，框架将调用此方法。

默认情况下，通过调用`CDockSite::RemovePane`未注册窗格与停靠窗格。

## <a name="cpaneonbeforedock"></a><a name="onbeforedock"></a>CPane：：在Dock前

当窗格即将停靠时由框架调用。

```
virtual BOOL OnBeforeDock(
    CBasePane** ppDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*ppDockBar*<br/>
[进出]指定此窗格停靠到的窗格。

*lpRect*<br/>
[在]指定停靠矩形。

*基方法*<br/>
[在]指定停靠方法。

### <a name="return-value"></a>返回值

如果窗格可以停靠，则为 TRUE。 如果函数返回 FALSE，则停靠操作将中止。

### <a name="remarks"></a>备注

当窗格即将停靠时，框架将调用此方法。 如果要在最终停靠窗格之前执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonbeforefloat"></a><a name="onbeforefloat"></a>CPane：在漂浮前打开

当窗格即将浮动时，由框架调用。

```
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
[在]指定窗格处于浮动状态时的位置和大小。

*基方法*<br/>
[在]指定窗格的停靠方法。

### <a name="return-value"></a>返回值

如果窗格可以浮动，则为 TRUE;否则，FALSE。

### <a name="remarks"></a>备注

当窗格即将浮动时，框架将调用此方法。 如果要在窗格最终浮动之前执行任何处理，则可以在派生类中重写此方法。

## <a name="cpaneonpressclosebutton"></a><a name="onpressclosebutton"></a>CPane：打开按钮

当用户按下窗格标题上的关闭按钮时，由框架调用。

```
virtual void OnPressCloseButton();
```

### <a name="remarks"></a>备注

当用户按下窗格标题上的 **"关闭**"按钮时，框架将调用此方法。 要接收有关**Close**事件的通知，可以在派生类中重写此方法。

## <a name="cpaneonshowcontrolbarmenu"></a><a name="onshowcontrolbarmenu"></a>CPane：在显示控制栏菜单

当即将显示特殊窗格菜单时由框架调用。

```
virtual BOOL OnShowControlBarMenu(CPoint point);
```

### <a name="parameters"></a>参数

*点*<br/>
[在]指定菜单位置。

### <a name="return-value"></a>返回值

如果菜单可以显示，则为 TRUE;如果菜单可以显示，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

该菜单包含多个项，使您能够指定窗格的行为，即：**浮动**、**停靠**、**自动隐藏**和**隐藏**。 您可以通过调用[CDockingManager：：启用DockSiteMenu，](../../mfc/reference/cdockingmanager-class.md#enabledocksitemenu)为所有窗格启用此菜单。

## <a name="cpanerecalclayout"></a><a name="recalclayout"></a>CPane：Recalclayout

重新计算窗格的布局信息。

```
virtual void RecalcLayout();
```

### <a name="remarks"></a>备注

如果窗格已停靠，此方法会将其大小设置为窗格的当前大小来更新窗格的虚拟矩形。

如果窗格是浮动的，此方法会通知父迷你框架将窗格的大小调整为微型框架的大小。 框架确保迷你框架至少是窗格[（CPane：GetMinSize）](#getminsize)的最小允许大小，并在必要时调整微型框架的大小。

## <a name="cpanesavestate"></a><a name="savestate"></a>CPane：保存状态

将窗格的状态保存到注册表。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>参数

*lpsz配置文件名称*<br/>
[在]配置文件名称。

*nIndex*<br/>
[在]配置文件索引。

*uiID*<br/>
[在]窗格 ID。

### <a name="return-value"></a>返回值

如果成功保存状态，则为 TRUE;如果状态已成功保存，则为 TRUE。否则，FALSE。

### <a name="remarks"></a>备注

当框架将窗格的状态保存到注册表时，它将调用此方法。 在`SaveState`派生类中重写以存储其他信息。

重写此方法时，也会调用基方法，如果基方法返回 FALSE，则返回 FALSE。

## <a name="cpanesetactiveingroup"></a><a name="setactiveingroup"></a>CPane：设置活动组

将窗格标记为活动窗格。

```
virtual void SetActiveInGroup(BOOL bActive);
```

### <a name="parameters"></a>参数

*b 活动*<br/>
[在]指定窗格是否标记为活动状态的 BOOL。

### <a name="remarks"></a>备注

当显示可停靠窗格或选择自动隐藏按钮时，相应的自动隐藏窗格将标记为活动。

与窗格关联的自动隐藏按钮的外观基于两个因素。 如果窗格处于活动状态，并且 为`static BOOL CMFCAutoHideButton::m_bOverlappingTabs`TRUE，则框架将显示自动隐藏按钮作为图标和标签。 对于非活动窗格，框架仅显示自动隐藏图标。

如果`CMFCAutoHideButton::m_bOverlappingTabs`为 FALSE，或者窗格不在组中，则框架将显示关联的自动隐藏按钮作为图标和标签。

## <a name="cpanesetborders"></a><a name="setborders"></a>CPane：设置边框

设置窗格的边框值。

```
void SetBorders(
    int cxLeft = 0,
    int cyTop = 0,
    int cxRight = 0,
    int cyBottom = 0);

void SetBorders(LPCRECT lpRect);
```

### <a name="parameters"></a>参数

*cx 左*<br/>
[在]指定窗格左边框的宽度（以像素为单位）。

*cyTop*<br/>
[在]指定窗格顶部边框的宽度（以像素为单位）。

*cxRight*<br/>
[在]指定窗格右边框的宽度（以像素为单位）。

*cyBottom*<br/>
[在]指定窗格底部边框的宽度（以像素为单位）。

*lpRect*<br/>
[在]包含窗格每个边框的宽度（以像素为单位）的[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。

### <a name="remarks"></a>备注

调用此函数以设置窗格边框的大小。

## <a name="cpanesetclienthotspot"></a><a name="setclienthotspot"></a>CPane：设置客户端热点

*设置窗格*的热点。

```
void SetClientHotSpot(const CPoint& ptNew);
```

### <a name="parameters"></a>参数

*pt New*<br/>
[在]指定`CPoint`新热点的对象。

### <a name="remarks"></a>备注

*热点*是用户选择并保留以移动窗格的窗格上的点。 当窗格从停靠位置拖动时，热点用于平滑动画。

## <a name="cpanesetdockstate"></a><a name="setdockstate"></a>CPane：setDockState

还原窗格的停靠状态信息。

```
virtual void SetDockState(CDockingManager* pDockManager);
```

### <a name="parameters"></a>参数

*pDock管理器*<br/>
[在]指向主框架窗口的停靠管理器。

### <a name="remarks"></a>备注

框架调用此方法以还原窗格的最近停靠状态信息。 窗格在[CPane：：m_recentDockInfo](#m_recentdockinfo)中存储最近的停靠状态信息。 有关详细信息，请参阅[CRecentDockSiteInfo 类](../../mfc/reference/crecentdocksiteinfo-class.md)。

在从外部源加载窗格信息时，还可以调用此方法来设置停靠状态。

## <a name="cpanesetexclusiverowmode"></a><a name="setexclusiverowmode"></a>CPane：设置独占行模式

启用或禁用独占行模式。

```
virtual void SetExclusiveRowMode(BOOL bExclusive = TRUE);
```

### <a name="parameters"></a>参数

*b 独家*<br/>
[在]TRUE 以启用独占行模式;否则，FALSE。

### <a name="remarks"></a>备注

调用此方法以启用或禁用独占行模式。 当窗格处于独占行模式时，它不能与任何其他工具栏共享同一行。

默认情况下，所有工具栏都禁用了独占行模式，并且菜单栏启用了独占行模式。

## <a name="cpanesetminsize"></a><a name="setminsize"></a>CPane：设置最小值

设置窗格的最小允许大小。

```
void SetMinSize(const CSize& size);
```

### <a name="parameters"></a>参数

*大小*<br/>
[在]包含`CSize`窗格允许的最小大小的对象。

### <a name="remarks"></a>备注

## <a name="cpanesetvirtualrect"></a><a name="setvirtualrect"></a>CPane：设置虚拟重新

设置窗格的*虚拟矩形*。

```
void SetVirtualRect(
    const CRect& rect,
    BOOL bMapToParent = TRUE);
```

### <a name="parameters"></a>参数

*矩形*<br/>
[在]指定`CRect`要设置的虚拟矩形的对象。

*bMapto 父级*<br/>
[在]如果*矩形*包含相对于父窗口的点，则指定 TRUE。

### <a name="remarks"></a>备注

*虚拟矩形*在移动窗格时存储窗格的原始位置。 框架可以使用虚拟矩形还原原始位置。

除非以编程方式移动窗格，否则不要调用与虚拟矩形相关的方法。

## <a name="cpanesetminiframertc"></a><a name="setminiframertc"></a>CPane：设置MiniFrameRTC

设置默认小型框架窗口的运行时类信息。

```
void SetMiniFrameRTC(CRuntimeClass* pClass);
```

### <a name="parameters"></a>参数

*pClass*<br/>
[进出]指定小型帧窗口的运行时类信息。

### <a name="remarks"></a>备注

浮动窗格时，将其放在[CPaneFrameWnd（](../../mfc/reference/cpaneframewnd-class.md)微型框架）窗口中。 您可以提供自定义`CPaneFrameWnd`派生类，在调用[CPane：createDefaultMiniframe](#createdefaultminiframe)时将使用该类。

## <a name="cpanestretchpanedeferwndpos"></a><a name="stretchpanedeferwndpos"></a>CPane：：拉伸帕内德温德波斯

根据停靠样式垂直或水平拉伸窗格。

```
virtual int StretchPaneDeferWndPos(
    int nStretchSize,
    HDWP& hdwp);
```

### <a name="parameters"></a>参数

*n 拉伸尺寸*<br/>
[在]拉伸窗格的数量（以像素为单位）。 使用负值收缩窗格。

*hdwp*<br/>
[在]未使用。

### <a name="return-value"></a>返回值

窗格拉伸的实际量（以像素为单位）。

### <a name="remarks"></a>备注

如有必要，此方法将修改*n 拉伸大小*，以确保窗格不超过大小限制。 这些限制是通过调用[CPane：：获取可用拉伸大小](#getavailablestretchsize)和[CPane：获取"获取可用扩展大小](#getavailableexpandsize)"来获得的。

## <a name="cpanetoggleautohide"></a><a name="toggleautohide"></a>CPane：：切换自动隐藏

切换自动隐藏模式。

```
virtual void ToggleAutoHide();
```

### <a name="remarks"></a>备注

调用此方法以切换自动隐藏模式。 窗格必须停靠到主框架窗口才能切换到自动隐藏模式。

## <a name="cpaneundockpane"></a><a name="undockpane"></a>CPane：取消板块窗格

从当前停靠的停靠站点、默认滑块或微型框架窗口中删除窗格。

```
virtual void UndockPane(BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*bDelay*<br/>
[在]如果 FALSE，框架将调用[CBasePane：：调整停靠布局](../../mfc/reference/cbasepane-class.md#adjustdockinglayout)以调整停靠布局。

### <a name="remarks"></a>备注

使用此方法以编程方式取消窗格停靠。

## <a name="cpaneupdatevirtualrect"></a><a name="updatevirtualrect"></a>CPane：更新虚拟重新

更新虚拟矩形。

```
void UpdateVirtualRect();
void UpdateVirtualRect(CPoint ptOffset);
void UpdateVirtualRect(CSize sizeNew);
```

### <a name="parameters"></a>参数

*pt偏移*<br/>
[在]指定`CPoint`要移动窗格的偏移量的对象。

*大小新*<br/>
[在]指定`CSize`窗格的新大小的对象。

### <a name="remarks"></a>备注

第一个重载使用窗格的当前位置和大小设置虚拟矩形。

第二个重载将虚拟矩形按*ptOffset*指定的量移动。

第三个重载使用窗格的当前位置和*由 sizeNew*指定的大小设置虚拟矩形。

## <a name="see-also"></a>另请参阅

[层次结构图表](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CBasePane 类](../../mfc/reference/cbasepane-class.md)
