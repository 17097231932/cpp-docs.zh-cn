---
title: IEEE 浮点表示形式
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: 130a79ae6846df27ffabfd6cb6649e0a0de03e4b
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220622"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮点表示形式

Microsoft C++ (MSVC) 是与 IEEE 数值标准一致。 IEEE 754 标准介绍了浮点格式，表示在硬件中的实数的方式。 MSVC 编译器的目标硬件中可表示的浮点数字的至少五个内部格式，但编译器仅使用其中两个。 *单精度*（4 字节） 和*双精度*在 MSVC 中使用 （8 字节） 格式。 使用关键字声明单精度**float**。 使用关键字声明双精度**double**。 此外指定了 IEEE 标准*半精度*（2 个字节） 和*四元组精度*（16 字节） 格式，以及*双扩展精度*（10 字节）设置的格式，其某些 C 和C++编译器为实现**长双精度**数据类型。 MSVC 编译器中**长双精度**数据类型会被视为不同的类型，但存储类型映射到**double**。 不存在，但是，内部函数和程序集语言支持的计算使用其他格式，包括双扩展精度 （10 字节） 格式，在支持的硬件。

这些值存储，如下所示：

|值|作为存储|
|-----------|---------------|
|单精度|登录位、 8 位指数，23 位有效数|
|double-precision|登录位、 11 位指数、 52 位有效数|
|double-extended-precision|登录位，15 位指数，64 位有效数|

在单精度和双精度格式中，假定的前导 1 中没有小数部分，名为*有效位数*(有时称为*尾数*)，即不会存储在内存，因此有效位数是实际 24 位或 53 位，即使只有 23 或 52 位存储。 双扩展精度格式实际上将存储此位。

指数偏离其可能值的一半。 这意味着中减去此从存储的指数以获取实际的指数的偏差。 如果存储的指数小于偏置，则实际上是负指数。

指数偏离，如下所示：

|指数|影响|
|--------------|---------------|
|8 位 （单精度）|127|
|11 位 （双精度）|1023|
|15 位 （双扩展的精度）|16383|

这些指数的后面不是 10; 的幂它们是 2 的幂。 也就是说，8 位存储的指数可以介于-127 到 127，存储为 0 到 254 个。 值为 2<sup>127</sup>大致相当于 10<sup>38</sup>，即实际的限制的单精度。

有效数字存储为二进制分数的窗体 1.XXX...。 此部分的值大于或等于 1 且小于 2。 请注意实数始终存储在*规范化窗体*; 即，有效数字是向左移动以便有效数字的高顺序位始终为 1。 此位始终为 1，因为它假定 （不存储） 中的单精度和双精度格式。 二进制 （未十进制） 点被假定为前导 1 右侧。

格式，然后，各种大小的如下所示：

|格式|1 字节|2 字节|字节 3|字节 4|...|字节 n|
|------------|------------|------------|------------|------------|---------|------------|
|单精度| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|double-precision|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|double-extended-precision|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S` 表示符号位`X`的是有偏差指数位，和`M`的都是有效数字位。 请注意，最左边的位假定为单精度和双精度格式，但第 3 个字节的双扩展精度格式中显示为"1"。

若要正确变换二进制小数点，首次阶，然后向右移动二进制小数点或保持适当数量的位。

## <a name="special-values"></a>特殊值

浮点格式包括要进行专门处理某些值。

### <a name="zero"></a>零

不能规范化为零，因此生成无法表示单精度或双精度值采用规范化格式。 全部为零的特殊位模式表示 0。 此外，还可以表示的零以符号作为 0 设置位，但-0 和 0 始终比较结果相等。

### <a name="infinities"></a>无穷大

+ ∞ 和 −∞ 值由的都是一个指数和全部为零的有效数字。 可以使用符号位来表示正和负无穷大。

### <a name="subnormals"></a>Subnormals

就可以表示的较小的量值比的最小规范化数字的数字。 这些数字被称为*次正常*或*denormal*数字。 如果指数是全部为零，并且有效数字为非零，然后被视为隐式前导位的有效数字为零，而不是。 次正常数字精度出现故障，如数量的有效数字中的前导零转到上。

### <a name="nan---not-a-number"></a>NaN 的不是数字

可以表示值不是一个实数，例如 0 / 0、 IEEE 浮点格式。 这种类型的值被称为*NaN*。 通过所有的选项和非零值有效数字的指数表示的 NaN。 有两种类型的 Nan，*安静*Nan 或 QNaNs，并*信令*Nan 或 SNaNs。 Quiet Nan 具有一个前导中有效位数，并且通常会通过表达式。 它们表示不确定的值，例如除以无穷大或无穷大乘以零的结果。 信令 Nan 具有一个前导零的有效数字。 这些用于不是有效的以指示浮点硬件异常的操作。

## <a name="examples"></a>示例

以下是单精度格式的一些示例：

- 值 2，符号位为零，并存储的指数都是 128 或 1000 0000 以二进制形式，即 127 加 1。 存储二进制有效数字是 (1)。000 0000 0000 0000 0000 0000，这都有一个隐含前导 1 到二进制点，因此是实际的有效数字。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 值-2。 为 + 2 相同，只不过设置符号位。 这适用于所有 IEEE 格式浮点数的负值。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 值为 4。 同一有效位数指数加 1 （求得的值为 129 或以二进制形式的 100 0000 1。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 值为 6。 同一个指数，有效位数大于一半 — 它的 (1)。100 0000 ...0000 0000，由于这是二进制分数，为 1 1/2 因为的小数位数的值为 1/2，1/4、 1/8，依此类推。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 值 1。 作为其他 2 的幂，有偏差指数的同一个有效数字是小于 2 处 127 或 011 1111年 1 二进制文件中。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 值 0.75。 有偏差的指数是 126，011 1111年 0 中的二进制文件，并有效数字是 (1)。100 0000 ...0000 0000，即 1 1/2。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 值为 2.5。 完全相同，除非两个表示 1/4 是中设置了位有效数字。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10 是二进制文件中重复的分数。 有效数字是害怕 1.6，并有偏差的指数显示 1.6 是将除以 16 （它是以二进制表示，这是以十进制 123 011 1101年 1）。 实际的指数是 123 127 =-4，这意味着要相乘的因子为 2<sup>-4</sup> = 1/16。 请注意，存储的有效数字向上舍入中的最后一个位，尝试尽可能精确地表示无法表示的数。 (原因 1/10 到 1/100 就是不精确表示二进制文件中类似于 1/3 是以十进制表示不严格的原因。)

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 零是一种特殊情况，使用的最小可能可表示正值，即全部为零的公式。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>请参阅

[为何浮点数可能丢失精度](why-floating-point-numbers-may-lose-precision.md)