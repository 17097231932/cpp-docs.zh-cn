---
title: 编译器错误 C3400 - C3499
ms.date: 04/21/2019
f1_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
helpviewer_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
ms.assetid: a5651dfb-c402-4e01-b3ae-28f371e51d6a
ms.openlocfilehash: 587b28cedb0ab8b11c244be4278c7dc17d1f4247
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "62281382"
---
# <a name="compiler-errors-c3400-through-c3499"></a>编译器错误 C3400 - C3499

在本部分文档中的文章说明了由编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|Error|消息|
|-----------|-------------|
|[编译器错误 C3400](compiler-error-c3400.md)|涉及循环约束依赖项*constraint1*和*constraint2*|
|编译器错误 C3401|'*说明符*： 无效的程序集访问说明符的 private 只能允许类模板|
|编译器错误 C3402|'*函数*： 不能解析当前作用域中的除重载|
|编译器错误 C3403|thread_local 不能用于 /clr: pure 或 /clr: safe|
|编译器错误 C3404|'*构造*： 意外的语法错误|
|编译器错误 C3405|'*函数*： 没有完整的说明符无法解析重载|
|编译器错误 C3406|'*关键字*： 不能在详细的类型说明符中使用|
|编译器错误 C3407|'*类型*不能在此上下文中使用|
|[编译器错误 C3408](compiler-error-c3408.md)|'*特性*： 模板定义中不允许使用特性|
|[编译器错误 C3409](compiler-error-c3409.md)|不允许空特性块|
|编译器错误 C3410|'*标识符*： 显式实例化的类型*类型*类型不匹配的变量模板*类型*|
|编译器错误 C3411|'*类型*是无效的数组的大小，因为它不是整数类型|
|[编译器错误 C3412](compiler-error-c3412.md)|'*专用化*： 不能使当前作用域中的模板专用化|
|[编译器错误 C3413](compiler-error-c3413.md)|'*模板*： 显式实例化无效|
|[编译器错误 C3414](compiler-error-c3414.md)|'*函数*： 不能定义导入的成员函数|
|[编译器错误 C3415](compiler-error-c3415.md)|多个*一节*部分找到具有不同的属性 ("0 x*值*)|
|编译器错误 C3416|已过时。|
|[编译器错误 C3417](compiler-error-c3417.md)|'*声明符*： 值类型不能包含用户定义的特殊成员函数|
|[编译器错误 C3418](compiler-error-c3418.md)|访问说明符*说明符*不支持|
|编译器错误 C3419|已过时。|
|[编译器错误 C3420](compiler-error-c3420.md)|'*函数*： 终结器不能为虚|
|[编译器错误 C3421](compiler-error-c3421.md)|'*函数*： 不能为此类调用的终结器，因为它是不可访问或不存在|
|编译器错误 C3422|'*声明*： 不匹配的类型*类型*'和'*类型*|
|编译器错误 C3423|已过时。|
|编译器错误 C3424|'*类型*： 不允许函数样式强制转换为数组类型|
|编译器错误 C3425|无法引发指向不完整类型的对象*类型*|
|编译器错误 C3426|无法引发不完整类型的对象*类型*|
|编译器错误 C3427|'*上下文*':'*关键字*不能用于 layout_version (*数*)|
|编译器错误 C3428|'*上下文*':'*关键字*只能应用于类声明或定义|
|编译器错误 C3429|'*上下文*':'*关键字*不能应用于联合|
|编译器错误 C3430|区分范围的枚举必须具有的名称|
|编译器错误 C3431|'*标识符*: *type1*不能重新声明为*y p e 2*|
|编译器错误 C3432|'*标识符*： 无范围枚举的前向声明必须有基础类型|
|编译器错误 C3433|'*标识符*： 枚举的所有声明必须具有相同的基础类型，是*type1*立即*type2*|
|编译器错误 C3434|'*上下文*： 枚举器值*数*不能表示为'*类型*，值为*数*|
|编译器错误 C3435|字符集 '*名称*不支持|
|编译器错误 C3436|已指定 /source-charset、 /execution-charset 或 /utf-8 时，不支持 #pragma setlocale|
|编译器错误 C3437|已指定 /source-charset、 /execution-charset 或 /utf-8 时，不支持 #pragma execution_character_set|
|编译器错误 C3438|'*上下文*':'*值*不能应用于托管/WinRT 类|
|编译器错误 C3439|layout_version(*number*): invalid version number|
|编译器错误 C3440|'*声明*: layout_version (*数*) 与之前的声明不兼容|
|编译器错误 C3441|'*声明*':'*关键字*' 类定义后不能应用|
|编译器错误 C3442|正在初始化多个联合成员: '*member1*和*member2*|
|编译器错误 C3443|默认成员初始值设定项*类*是递归|
|编译器错误 C3444|为聚合类的空*类*必须与初始化{}|
|[编译器错误 C3445](compiler-error-c3445.md)|复制列表初始化的 '*类型*不能使用的显式构造函数|
|[编译器错误 C3446](compiler-error-c3446.md)|'*类*： 不允许的值类成员使用的默认成员初始值设定项|
|编译器错误 C3447|已过时。|
|编译器错误 C3448|已过时。|
|编译器错误 C3449|已过时。|
|[编译器错误 C3450](compiler-error-c3450.md)|'*类型*： 不是特性; 不能指定 [system:: attributeusageattribute] / [Windows::Foundation::Metadata::AttributeUsageAttribute]|
|[编译器错误 C3451](compiler-error-c3451.md)|'*特性*： 不能应用到非托管的属性*类型*|
|[编译器错误 C3452](compiler-error-c3452.md)|列出不是常量的参数成员|
|[编译器错误 C3453](compiler-error-c3453.md)|'*特性*： 因为没有应用特性限定符'*限定符*不匹配|
|[编译器错误 C3454](compiler-error-c3454.md)|类声明中不允许出现 [attribute]|
|[编译器错误 C3455](compiler-error-c3455.md)|'*特性*： 没有任何特性构造函数匹配这些参数|
|[编译器错误 C3456](compiler-error-c3456.md)|[源\_annotation_attribute] 托管/WinRT 类声明上不允许|
|[编译器错误 C3457](compiler-error-c3457.md)|'*特性*： 特性不支持未命名的参数|
|[编译器错误 C3458](compiler-error-c3458.md)|[*特性*]： 特性 [*特性*] 已为指定 '*标识符*|
|[编译器错误 C3459](compiler-error-c3459.md)|[*特性*]： 特性只能在类索引器上允许 （默认索引属性）|
|[编译器错误 C3460](compiler-error-c3460.md)|'*类型*： 只有用户定义的类型才能被转发|
|[编译器错误 C3461](compiler-error-c3461.md)|'*类型*： 仅托管/WinRT 类型才能被转发|
|[编译器错误 C3462](compiler-error-c3462.md)|'*类型*： 只有导入的类型可以转发|
|[编译器错误 C3463](compiler-error-c3463.md)|'*类型*： 特性 implements 中不允许的类型|
|[编译器错误 C3464](compiler-error-c3464.md)|'*类型*嵌套的类型不能被转发|
|[编译器错误 C3465](compiler-error-c3465.md)|若要使用类型*类型*必须引用程序集*程序集*|
|[编译器错误 C3466](compiler-error-c3466.md)|'*类型*： 不能转发泛型类的专用化|
|[编译器错误 C3467](compiler-error-c3467.md)|'*类型*： 此类型已被转发|
|[编译器错误 C3468](compiler-error-c3468.md)|'*类型*： 只能将一个类型转发到程序集:*标识符*不是程序集|
|[编译器错误 C3469](compiler-error-c3469.md)|'*类型*： 不能转发泛型类|
|[编译器错误 C3470](compiler-error-c3470.md)|'*类*： 类不能有两个索引器 （默认索引属性） 和运算符]|
|编译器错误 C3471|新的模块名称*名称*与以前的名称 （在命令行上的设置） 冲突*名称*|
|编译器错误 C3472|新的输出文件名*文件名*与以前的文件名 （在命令行上的设置） 冲突*文件名*|
|编译器错误 C3473|指定任何输出路径名称或模块名称。|
|编译器错误 C3474|无法打开输出文件*文件名*|
|编译器错误 C3475|输入文件中的语法错误*文件名*|
|编译器错误 C3476|无法打开文件*文件名*的输入|
|编译器错误 C3477|lambda 不能出现在未计算的上下文|
|编译器错误 C3478|'*标识符*： 数组不能通过复制捕获|
|编译器错误 C3479|不支持在 lambda 上的 SAL 批注|
|[编译器错误 C3480](compiler-error-c3480.md)|'*变量*: lambda 捕获变量必须来自封闭函数范围|
|[编译器错误 C3481](compiler-error-c3481.md)|'*标识符*： 未找到 lambda 捕获变量|
|[编译器错误 C3482](compiler-error-c3482.md)|“this”只能在非静态成员函数中用作 lambda 捕获|
|[编译器错误 C3483](compiler-error-c3483.md)|'*标识符*已经是 lambda 捕获列表的一部分|
|[编译器错误 C3484](compiler-error-c3484.md)|语法错误： 预期-> 之前的返回类型|
|[编译器错误 C3485](compiler-error-c3485.md)|lambda 定义不能包含任何 cv 限定符|
|编译器错误 C3486|已过时。|
|[编译器错误 C3487](compiler-error-c3487.md)|'*类型*： 所有返回表达式必须推导为相同的类型： 以前为*类型*|
|[编译器错误 C3488](compiler-error-c3488.md)|&*标识符*的默认捕获模式为按引用时，不允许|
|[编译器错误 C3489](compiler-error-c3489.md)|&*标识符*时的默认捕获模式为按复制是必需的|
|[编译器错误 C3490](compiler-error-c3490.md)|'*标识符*不能修改，因为正在通过常量对象访问|
|[编译器错误 C3491](compiler-error-c3491.md)|'*标识符*: 副本不能在非可变 lambda 中修改捕获|
|[编译器错误 C3492](compiler-error-c3492.md)|'*标识符*： 不能捕获匿名联合的成员|
|[编译器错误 C3493](compiler-error-c3493.md)|'*标识符*不能隐式捕获，因为指定默认捕获模式|
|编译器错误 C3494|this 不能显式捕获，因为封闭的捕获模式不允许|
|[编译器错误 C3495](compiler-error-c3495.md)|'*标识符*： 捕获中的标识符必须是具有自动存储持续时间在 lambda 的访问范围中声明的变量|
|[编译器错误 C3496](compiler-error-c3496.md)|“this”始终按值捕获: 已忽略“&”|
|编译器错误 C3497|无法构造 lambda 实例|
|[编译器错误 C3498](compiler-error-c3498.md)|'*标识符*： 无法捕获具有托管/WinRT 类型的变量|
|[编译器错误 C3499](compiler-error-c3499.md)|已指定返回类型为 void 的 lambda 无法返回值|

## <a name="see-also"></a>请参阅

[C /C++编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器错误 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
