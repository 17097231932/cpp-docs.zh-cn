---
title: CMDIFrameWndEx 类 |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ActiveItemRecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AddPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustClientArea
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustDockingLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AreMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ControlBarToTabbedDocument
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateDocumentWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateNewWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPaneLeftOf
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableAutoHidePanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableDocking
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMainMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableLoadDockState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabbedGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabsLastActiveActivation
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnablePaneMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetActivePopup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetDefaultResId
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMenuBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetRibbonBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetTearOffBars
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetToolbarButtonToolTipText
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::InsertPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMDITabbedGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMemberOfMDITabGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMenuBarAvailable
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPointNearDockSite
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPrintPreview
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabMoveToNextGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabNewGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::NegotiateBorderSpace
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseDockingPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnClosePopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCmdMsg
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuImage
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuLogo
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnEraseMDIClientBackground
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMenuButtonToolHitTest
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMoveMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSetPreviewMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowCustomizePane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowMDITabContextMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSizeMDIClient
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnTearOffMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnUpdateFrameMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::PaneFromPoint
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RemovePaneFromDockManager
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SaveMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetPrintPreviewFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetupToolbarMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::TabbedDocumentToControlBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateCaption
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateMDITabbedBarsIcons
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::WinHelp
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bDisableSetRedraw
dev_langs:
- C++
helpviewer_keywords:
- CMDIFrameWndEx [MFC], ActiveItemRecalcLayout
- CMDIFrameWndEx [MFC], AddPane
- CMDIFrameWndEx [MFC], AdjustClientArea
- CMDIFrameWndEx [MFC], AdjustDockingLayout
- CMDIFrameWndEx [MFC], AreMDITabs
- CMDIFrameWndEx [MFC], CanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], ControlBarToTabbedDocument
- CMDIFrameWndEx [MFC], CreateDocumentWindow
- CMDIFrameWndEx [MFC], CreateNewWindow
- CMDIFrameWndEx [MFC], DockPane
- CMDIFrameWndEx [MFC], DockPaneLeftOf
- CMDIFrameWndEx [MFC], EnableAutoHidePanes
- CMDIFrameWndEx [MFC], EnableDocking
- CMDIFrameWndEx [MFC], EnableFullScreenMainMenu
- CMDIFrameWndEx [MFC], EnableFullScreenMode
- CMDIFrameWndEx [MFC], EnableLoadDockState
- CMDIFrameWndEx [MFC], EnableMDITabbedGroups
- CMDIFrameWndEx [MFC], EnableMDITabs
- CMDIFrameWndEx [MFC], EnableMDITabsLastActiveActivation
- CMDIFrameWndEx [MFC], EnablePaneMenu
- CMDIFrameWndEx [MFC], EnableWindowsDialog
- CMDIFrameWndEx [MFC], GetActivePopup
- CMDIFrameWndEx [MFC], GetPane
- CMDIFrameWndEx [MFC], GetDefaultResId
- CMDIFrameWndEx [MFC], GetMDITabGroups
- CMDIFrameWndEx [MFC], GetMDITabs
- CMDIFrameWndEx [MFC], GetMDITabsContextMenuAllowedItems
- CMDIFrameWndEx [MFC], GetMenuBar
- CMDIFrameWndEx [MFC], GetRibbonBar
- CMDIFrameWndEx [MFC], GetTearOffBars
- CMDIFrameWndEx [MFC], GetToolbarButtonToolTipText
- CMDIFrameWndEx [MFC], InsertPane
- CMDIFrameWndEx [MFC], IsFullScreen
- CMDIFrameWndEx [MFC], IsMDITabbedGroup
- CMDIFrameWndEx [MFC], IsMemberOfMDITabGroup
- CMDIFrameWndEx [MFC], IsMenuBarAvailable
- CMDIFrameWndEx [MFC], IsPointNearDockSite
- CMDIFrameWndEx [MFC], IsPrintPreview
- CMDIFrameWndEx [MFC], LoadFrame
- CMDIFrameWndEx [MFC], LoadMDIState
- CMDIFrameWndEx [MFC], MDITabMoveToNextGroup
- CMDIFrameWndEx [MFC], MDITabNewGroup
- CMDIFrameWndEx [MFC], NegotiateBorderSpace
- CMDIFrameWndEx [MFC], OnCloseDockingPane
- CMDIFrameWndEx [MFC], OnCloseMiniFrame
- CMDIFrameWndEx [MFC], OnClosePopupMenu
- CMDIFrameWndEx [MFC], OnCmdMsg
- CMDIFrameWndEx [MFC], OnDrawMenuImage
- CMDIFrameWndEx [MFC], OnDrawMenuLogo
- CMDIFrameWndEx [MFC], OnEraseMDIClientBackground
- CMDIFrameWndEx [MFC], OnMenuButtonToolHitTest
- CMDIFrameWndEx [MFC], OnMoveMiniFrame
- CMDIFrameWndEx [MFC], OnSetPreviewMode
- CMDIFrameWndEx [MFC], OnShowCustomizePane
- CMDIFrameWndEx [MFC], OnShowMDITabContextMenu
- CMDIFrameWndEx [MFC], OnShowPanes
- CMDIFrameWndEx [MFC], OnShowPopupMenu
- CMDIFrameWndEx [MFC], OnSizeMDIClient
- CMDIFrameWndEx [MFC], OnTearOffMenu
- CMDIFrameWndEx [MFC], OnUpdateFrameMenu
- CMDIFrameWndEx [MFC], PaneFromPoint
- CMDIFrameWndEx [MFC], RecalcLayout
- CMDIFrameWndEx [MFC], RemovePaneFromDockManager
- CMDIFrameWndEx [MFC], SaveMDIState
- CMDIFrameWndEx [MFC], SetPrintPreviewFrame
- CMDIFrameWndEx [MFC], SetupToolbarMenu
- CMDIFrameWndEx [MFC], ShowFullScreen
- CMDIFrameWndEx [MFC], ShowPane
- CMDIFrameWndEx [MFC], ShowWindowsDialog
- CMDIFrameWndEx [MFC], TabbedDocumentToControlBar
- CMDIFrameWndEx [MFC], UpdateCaption
- CMDIFrameWndEx [MFC], UpdateMDITabbedBarsIcons
- CMDIFrameWndEx [MFC], WinHelp
- CMDIFrameWndEx [MFC], m_bCanCovertControlBarToMDIChild
- CMDIFrameWndEx [MFC], m_bDisableSetRedraw
ms.assetid: dbcafcb3-9a7a-4f11-9dfe-ba57565c81d0
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 1015d35bea25ceaf23a822c9edea4da121583c61
ms.sourcegitcommit: a7046aac86f1c83faba1088c80698474e25fe7c3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/04/2018
ms.locfileid: "43678809"
---
# <a name="cmdiframewndex-class"></a>CMDIFrameWndEx 类
扩展的功能[CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)，Windows 多文档界面 (MDI) 框架窗口。  
  
## <a name="syntax"></a>语法  
  
```  
class CMDIFrameWndEx : public CMDIFrameWnd  
```  
  
## <a name="members"></a>成员  
  
### <a name="public-methods"></a>公共方法  
  
|名称|描述|  
|----------|-----------------|  
|[CMDIFrameWndEx::ActiveItemRecalcLayout](#activeitemrecalclayout)|重新计算的活动项的布局。|  
|`CMDIFrameWndEx::AddDockSite`|不使用此方法。|  
|[CMDIFrameWndEx::AddPane](#addpane)|注册到停靠管理器窗格。|  
|[CMDIFrameWndEx::AdjustClientArea](#adjustclientarea)|减少了客户端区域，以允许一个边框。|  
|[CMDIFrameWndEx::AdjustDockingLayout](#adjustdockinglayout)|重新计算所有停靠的窗格的布局。|  
|[CMDIFrameWndEx::AreMDITabs](#aremditabs)|确定是否启用 MDI 选项卡功能或 MDI 选项卡式组功能。|  
|[CMDIFrameWndEx::CanCovertControlBarToMDIChild](#cancovertcontrolbartomdichild)|由框架调用以确定框架窗口是否可以转换为选项卡式文档的停靠窗格。|  
|[CMDIFrameWndEx::ControlBarToTabbedDocument](#controlbartotabbeddocument)|将指定的停靠窗格转换为选项卡式文档。|  
|[CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow)|创建子文档窗口。|  
|[CMDIFrameWndEx::CreateNewWindow](#createnewwindow)|由框架调用以创建新的窗口。|  
|`CMDIFrameWndEx::CreateObject`|由框架用于创建此类类型的动态实例。|  
|[CMDIFrameWndEx::DockPane](#dockpane)|将指定的窗格停靠到框架窗口。|  
|[CMDIFrameWndEx::DockPaneLeftOf](#dockpaneleftof)|将一个窗格停靠到另一个窗格的左侧。|  
|[CMDIFrameWndEx::EnableAutoHidePanes](#enableautohidepanes)|启用自动隐藏模式对于窗格停靠在主框架窗口的指定边时。|  
|[CMDIFrameWndEx::EnableDocking](#enabledocking)|启用属于 MDI 框架窗口的窗格的停靠。|  
|[CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu)|显示或隐藏在全屏幕模式下的主菜单。|  
|[CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode)|启用框架窗口的全屏幕模式。|  
|[CMDIFrameWndEx::EnableLoadDockState](#enableloaddockstate)|启用或禁用的插接状态的加载。|  
|[Cmdiframewndex:: Enablemditabbedgroups](#enablemditabbedgroups)|启用或禁用 MDI 选项卡式组功能。|  
|[CMDIFrameWndEx::EnableMDITabs](#enablemditabs)|启用或禁用 MDI 选项卡功能。 启用时，框架窗口将显示每个 MDI 子窗口的选项卡。|  
|[CMDIFrameWndEx::EnableMDITabsLastActiveActivation](#enablemditabslastactiveactivation)|指定当用户关闭当前选项卡是否应激活的最后一个活动选项卡。|  
|[CMDIFrameWndEx::EnablePaneMenu](#enablepanemenu)|启用或禁用自动创建和管理的弹出窗口窗格菜单中，显示的应用程序窗格的列表。  .|  
|[CMDIFrameWndEx::EnableWindowsDialog](#enablewindowsdialog)|将其命令 ID 调用的菜单项插入[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)对话框。|  
|[CMDIFrameWndEx::GetActivePopup](#getactivepopup)|返回一个指向当前显示的弹出菜单的指针。|  
|[CMDIFrameWndEx::GetPane](#getpane)|返回一个指向具有指定的控件 ID 的窗格|  
|[CMDIFrameWndEx::GetDefaultResId](#getdefaultresid)|返回 MDI 框架窗口的共享资源的 ID。|  
|[CMDIFrameWndEx::GetMDITabGroups](#getmditabgroups)|返回一系列 MDI 选项卡式窗口。|  
|[CMDIFrameWndEx::GetMDITabs](#getmditabs)|返回对带下划线的选项卡式窗口的引用。|  
|[CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems](#getmditabscontextmenualloweditems)|返回标志的组合，用于确定当启用 MDI 选项卡式组功能时，哪些上下文菜单项都有效。|  
|[CMDIFrameWndEx::GetMenuBar](#getmenubar)|返回指向附加到框架窗口的菜单栏对象的指针。|  
|[CMDIFrameWndEx::GetRibbonBar](#getribbonbar)|检索在框架的功能区栏控件。|  
|[CMDIFrameWndEx::GetTearOffBars](#gettearoffbars)|返回一系列[CPane](../../mfc/reference/cpane-class.md)-派生的对象的处于拖曳状态。|  
|`CMDIFrameWndEx::GetThisClass`|由框架调用以获取的指针[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)与此类类型相关联的对象。|  
|[CMDIFrameWndEx::GetToolbarButtonToolTipText](#gettoolbarbuttontooltiptext)|当应用程序将显示的工具栏按钮的工具提示时，由框架调用。|  
|[CMDIFrameWndEx::InsertPane](#insertpane)|注册到停靠管理器指定窗格。|  
|[CMDIFrameWndEx::IsFullScreen](#isfullscreen)|确定在全屏幕模式下是否为框架窗口。|  
|[CMDIFrameWndEx::IsMDITabbedGroup](#ismditabbedgroup)|确定是否启用 MDI 选项卡式组功能。|  
|[CMDIFrameWndEx::IsMemberOfMDITabGroup](#ismemberofmditabgroup)|确定指定的选项卡式的窗口是否在 windows 中 MDI 选项卡式组的列表中。|  
|[CMDIFrameWndEx::IsMenuBarAvailable](#ismenubaravailable)|确定框架窗口是否具有菜单栏。|  
|[CMDIFrameWndEx::IsPointNearDockSite](#ispointneardocksite)|确定指定的点是否在停靠站点附近。|  
|[CMDIFrameWndEx::IsPrintPreview](#isprintpreview)|确定框架窗口是否在打印预览模式下。|  
|[CMDIFrameWndEx::LoadFrame](#loadframe)|创建框架窗口中的资源信息。 （重写 `CMDIFrameWnd::LoadFrame`。）|  
|[Cmdiframewndex:: Loadmdistate](#loadmdistate)|加载 MDI 选项卡式组的指定的布局和以前打开的文档列表。|  
|[CMDIFrameWndEx::MDITabMoveToNextGroup](#mditabmovetonextgroup)|将从当前处于活动状态的选项卡式窗口的活动选项卡移动到下一步或上一个选项卡式组。|  
|[CMDIFrameWndEx::MDITabNewGroup](#mditabnewgroup)|创建具有单个窗口的新选项卡式的组。|  
|[CMDIFrameWndEx::NegotiateBorderSpace](#negotiateborderspace)|在 OLE 就地激活过程协商在框架窗口的边框空间。|  
|[CMDIFrameWndEx::OnCloseDockingPane](#onclosedockingpane)|由框架调用，当用户单击**关闭**可停靠窗格上的按钮。|  
|[CMDIFrameWndEx::OnCloseMiniFrame](#oncloseminiframe)|由框架调用，当用户单击**关闭**浮动微型框架窗口上的按钮。|  
|[CMDIFrameWndEx::OnClosePopupMenu](#onclosepopupmenu)|当活动的弹出菜单处理 WM_DESTROY 消息时由框架调用。|  
|[CMDIFrameWndEx::OnCmdMsg](#oncmdmsg)|由框架调用以路由和调度命令消息和更新命令用户界面对象。|  
|[CMDIFrameWndEx::OnDrawMenuImage](#ondrawmenuimage)|当绘制与菜单项关联的图像时由框架调用。|  
|[CMDIFrameWndEx::OnDrawMenuLogo](#ondrawmenulogo)|由框架调用时[CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)处理 WM_PAINT 消息。|  
|[CMDIFrameWndEx::OnEraseMDIClientBackground](#onerasemdiclientbackground)|当 MDI 框架窗口处理 WM_ERASEBKGND 消息时由框架调用。|  
|[CMDIFrameWndEx::OnMenuButtonToolHitTest](#onmenubuttontoolhittest)|由框架调用时[CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)对象处理 WM_NCHITTEST 消息。|  
|[CMDIFrameWndEx::OnMoveMiniFrame](#onmoveminiframe)|由框架调用以移动微型框架窗口。|  
|[CMDIFrameWndEx::OnSetPreviewMode](#onsetpreviewmode)|设置应用程序的主框架窗口打印预览模式。 （重写 [CFrameWnd::OnSetPreviewMode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode)。）|  
|[CMDIFrameWndEx::OnShowCustomizePane](#onshowcustomizepane)|激活快速自定义窗格时，由框架调用。|  
|[CMDIFrameWndEx::OnShowMDITabContextMenu](#onshowmditabcontextmenu)|应在其中一个选项卡上显示上下文菜单时由框架调用。 （有关 MDI 选项仅卡式组的有效）。|  
|[CMDIFrameWndEx::OnShowPanes](#onshowpanes)|由框架调用以显示或隐藏窗格。|  
|[CMDIFrameWndEx::OnShowPopupMenu](#onshowpopupmenu)|当激活弹出菜单时由框架调用。|  
|[CMDIFrameWndEx::OnSizeMDIClient](#onsizemdiclient)|客户端 MDI 窗口的大小更改时由框架调用。|  
|[CMDIFrameWndEx::OnTearOffMenu](#ontearoffmenu)|当激活带有拖曳栏的菜单时由框架调用。|  
|[CMDIFrameWndEx::OnUpdateFrameMenu](#onupdateframemenu)|由框架调用以更新框架的菜单。 （重写 `CMDIFrameWnd::OnUpdateFrameMenu`。）|  
|[CMDIFrameWndEx::PaneFromPoint](#panefrompoint)|返回包含指定的点的停靠窗格。|  
|`CMDIFrameWndEx::PreTranslateMessage`|类使用[CWinApp](../../mfc/reference/cwinapp-class.md)窗口消息调度到之前转换[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)并[DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函数。  （重写 `CMDIFrameWnd::PreTranslateMessage`。）|  
|[CMDIFrameWndEx::RecalcLayout](#recalclayout)|由框架调用以重新计算框架窗口的布局。 (重写[CFrameWnd::RecalcLayout](../../mfc/reference/cframewnd-class.md#recalclayout)。)|  
|[CMDIFrameWndEx::RemovePaneFromDockManager](#removepanefromdockmanager)|注销一个窗格，并将其从到停靠管理器中删除。|  
|[CMDIFrameWndEx::SaveMDIState](#savemdistate)|保存 MDI 选项卡式组的当前布局和以前打开的文档列表。|  
|[CMDIFrameWndEx::SetPrintPreviewFrame](#setprintpreviewframe)|设置打印预览框架窗口。|  
|[CMDIFrameWndEx::SetupToolbarMenu](#setuptoolbarmenu)|通过搜索虚拟项并将其替换为指定的用户定义项修改工具栏对象。|  
|[CMDIFrameWndEx::ShowFullScreen](#showfullscreen)|切换到全屏模式主框架从常规模式。|  
|[CMDIFrameWndEx::ShowPane](#showpane)|显示或隐藏指定的窗格。|  
|[CMDIFrameWndEx::ShowWindowsDialog](#showwindowsdialog)|创建[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)框并将其打开。|  
|[CMDIFrameWndEx::TabbedDocumentToControlBar](#tabbeddocumenttocontrolbar)|将指定的选项卡式的文档转换为停靠窗格。|  
|[CMDIFrameWndEx::UpdateCaption](#updatecaption)|由框架调用以更新窗口框架标题。|  
|[CMDIFrameWndEx::UpdateMDITabbedBarsIcons](#updatemditabbedbarsicons)|设置每个 MDI 选项卡式窗格中的图标。|  
|[CMDIFrameWndEx::WinHelp](#winhelp)|由框架调用以启动 WinHelp 应用程序或上下文帮助。 (重写[cwnd:: Winhelp](../../mfc/reference/cwnd-class.md#winhelp)。)|  
  
### <a name="data-members"></a>数据成员  
  
|name|描述|  
|----------|-----------------|  
|[CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)|确定停靠窗格是否可以转换为 MDI 子窗口。|  
|[CMDIFrameWndEx::m_bDisableSetRedraw](#m_bdisablesetredraw)|启用或禁用 MDI 子窗口的重绘优化。|  
  
## <a name="remarks"></a>备注  
 若要在 MDI 应用程序中充分利用扩展的自定义功能，派生从应用程序的 MDI 框架窗口类`CMDIFrameWndEx`而不是`CMDIFrameWnd`。  
  
## <a name="example"></a>示例  
 以下示例从一个类从`CMDIFrameWndEx`。 此代码片段来自[DrawClient 示例： MFC Ribbon-Based OLE 对象绘制应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_DrawClient#1](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_1.h)]  
  
## <a name="inheritance-hierarchy"></a>继承层次结构  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 [CCmdTarget](../../mfc/reference/ccmdtarget-class.md)  
  
 [CWnd](../../mfc/reference/cwnd-class.md)  
  
 [CFrameWnd](../../mfc/reference/cframewnd-class.md)  
  
 [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)  
  
 [CMDIFrameWndEx](../../mfc/reference/cmdiframewndex-class.md)  
  
## <a name="requirements"></a>要求  
 **标头：** afxMDIFrameWndEx.h  
  
##  <a name="activeitemrecalclayout"></a>  CMDIFrameWndEx::ActiveItemRecalcLayout  
 重新计算的活动项的布局。  
  
```  
void ActiveItemRecalcLayout();
```  
  
##  <a name="addpane"></a>  CMDIFrameWndEx::AddPane  
 注册到停靠管理器窗格。  
  
```  
BOOL AddPane(
    CBasePane* pControlBar,  
    BOOL bTail=TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*pControlBar*  
 向注册窗格的指针。  
  
 [in]*bTail*  
 指定是否将此窗格添加到列表的末尾。  
  
### <a name="return-value"></a>返回值  
 如果成功注册窗格中，将返回一个非零值。 如果已注册到停靠管理器窗格中，则返回 0。  
  
### <a name="remarks"></a>备注  
 必须已注册每个窗格[CDockingManager 类](../../mfc/reference/cdockingmanager-class.md)可以加入停靠布局中之前。 使用此方法以通知你想要将特定窗格停靠到停靠管理器。 该窗格中注册后，到停靠管理器将对齐将基于其对齐方式设置和维护的到停靠管理器窗格的列表中的位置。  
  
##  <a name="adjustclientarea"></a>  CMDIFrameWndEx::AdjustClientArea  
 减少了客户端区域，以允许一个边框。  
  
```  
virtual void AdjustClientArea();
```  
  
##  <a name="adjustdockinglayout"></a>  CMDIFrameWndEx::AdjustDockingLayout  
 重新计算所有停靠的窗格的布局。  
  
```  
virtual void AdjustDockingLayout(HDWP hdwp=NULL);
```  
  
### <a name="parameters"></a>参数  
 [in]*hdwp*  
 标识的多个窗口位置结构。 您可以通过调用来获取此值`BeginDeferWindowPos`。  
  
### <a name="remarks"></a>备注  
 调用此成员函数以重新计算所有窗格停靠在框架窗口的布局。  
  
##  <a name="aremditabs"></a>  CMDIFrameWndEx::AreMDITabs  
 确定是否启用 MDI 选项卡功能或 MDI 选项卡式的分组功能。  
  
```  
BOOL AreMDITabs(int* pnMDITabsType=NULL) const;  
```  
  
### <a name="parameters"></a>参数  
 [out]*pnMDITabsType*  
 一个指向整数变量，指示启用的功能：  
  
-   0： 禁用所有功能。  
  
-   1： 启用 MDI 选项卡。  
  
-   2： 启用 MDI 选项卡式组。  
  
### <a name="return-value"></a>返回值  
 返回 TRUE 启用 MDI 选项卡还是 MDI 选项卡式组。  
  
 返回 FALSE，如果没有上述功能，则会启用。  
  
### <a name="remarks"></a>备注  
 使用此函数可确定是否 MDI 选项卡还是 MDI 选项卡式组启用的框架窗口。 使用[CMDIFrameWndEx::EnableMDITabs](#enablemditabs)启用或禁用 MDI 选项卡功能。  
  
 使用[cmdiframewndex:: Enablemditabbedgroups](#enablemditabbedgroups)启用或禁用 MDI 选项卡式的组功能。  
  
##  <a name="cancovertcontrolbartomdichild"></a>  CMDIFrameWndEx::CanCovertControlBarToMDIChild  
 由框架调用以确定框架窗口是否可以转换为选项卡式文档的停靠窗格  
  
```  
virtual BOOL CanCovertControlBarToMDIChild();
```  
  
### <a name="return-value"></a>返回值  
 如果框架窗口可停靠窗格转换为选项卡式文档; 则返回 TRUE否则返回 FALSE。  
  
### <a name="remarks"></a>备注  
 重写此方法在派生类中的，并返回 TRUE 以启用转换到选项卡式文档停靠窗格。 或者，可以设置[CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)为 TRUE。  
  
##  <a name="controlbartotabbeddocument"></a>  CMDIFrameWndEx::ControlBarToTabbedDocument  
 将指定的停靠窗格转换为选项卡式文档。  
  
```  
virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
```  
  
### <a name="parameters"></a>参数  
 *pBar*  
 指向要转换的停靠窗格的指针。  
  
### <a name="return-value"></a>返回值  
 返回一个指向新的 MDI 子窗口，其中包含停靠窗格。  
  
### <a name="remarks"></a>备注  
 此方法转换为选项卡式文档停靠窗格。 当调用此方法时，框架将创建[CMDIChildWndEx 类](../../mfc/reference/cmdichildwndex-class.md)对象，删除停靠窗格从停靠管理器，并将停靠窗格添加到新的 MDI 子窗口。 MDI 子窗口调整大小以覆盖整个客户端区域停靠窗格  
  
##  <a name="createdocumentwindow"></a>  CMDIFrameWndEx::CreateDocumentWindow  
 创建子文档窗口。  
  
```  
virtual CMDIChildWndEx* CreateDocumentWindow(
    LPCTSTR lpcszDocName,  
    CObject* pObj);
```  
  
### <a name="parameters"></a>参数  
 [in]*lpcszDocName*  
 包含文档标识符的文本字符串。 通常情况下，它是文档文件的完整路径。  
  
 [in]*pObj*  
 指向一个用户定义的对象的指针。 例如，开发人员可以创建描述文档并告知如何在启动时初始化该文档的特定于应用程序的数据结构。  
  
### <a name="return-value"></a>返回值  
 一个指向`CMDIChildWndEx`。  
  
### <a name="remarks"></a>备注  
 加载以前保存在注册表中的文档的列表时，框架将调用此方法。  
  
 重写此方法，以创建文档时从注册表加载它们。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`CreateDocumentWindow`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 在此示例中，`g_strStartViewName`可能是文档的名称，"虚拟"（例如，"起始页"），实际上不从磁盘文件加载。 因此我们需要特殊处理，以处理这种情况。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]  
  
##  <a name="createnewwindow"></a>  CMDIFrameWndEx::CreateNewWindow  
 由框架调用以创建新的窗口。  
  
```  
virtual CMDIChildWndEx* CreateNewWindow(
    LPCTSTR lpcszDocName,  
    CObject* pObj);
```  
  
### <a name="parameters"></a>参数  
 [in]*lpcszDocName*  
 文档名称。  
  
 [in]*pObj*  
 留待将来使用。  
  
### <a name="return-value"></a>返回值  
 指向新的窗口的指针。  
  
##  <a name="dockpane"></a>  CMDIFrameWndEx::DockPane  
 将指定的窗格停靠到框架窗口。  
  
```  
void DockPane(
    CBasePane* pBar,  
    UINT nDockBarID=0,  
    LPCRECT lpRect=NULL);
```  
  
### <a name="parameters"></a>参数  
 [in]*pBar*  
 指向要停靠的窗格。  
  
 [in]*nDockBarID*  
 指定框架窗口停靠到的哪些的边。  
  
 [in]*lpRect*  
 未使用。  
  
### <a name="remarks"></a>备注  
 此方法将指定停靠的窗格为一方是框架窗口时指定[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)和[CMDIFrameWndEx::EnableDocking](#enabledocking)函数调用。  
  
### <a name="example"></a>示例  
 下面的示例演示 `DockPane` 方法的用法。 此代码片段来自[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#4](../../mfc/codesnippet/cpp/cmdiframewndex-class_3.cpp)]  
  
##  <a name="dockpaneleftof"></a>  CMDIFrameWndEx::DockPaneLeftOf  
 将一个窗格停靠到另一个窗格的左侧。  
  
```  
BOOL DockPaneLeftOf(
    CPane* pBar,  
    CPane* pLeftOf);
```  
  
### <a name="parameters"></a>参数  
 [in]*pBar*  
 一个指向停靠窗格。  
  
 [in]*pLeftOf*  
 指向用作停靠站点的窗格的指针。 .  
  
### <a name="return-value"></a>返回值  
 如果操作成功，则返回 TRUE。 否则返回 FALSE。  
  
### <a name="remarks"></a>备注  
 调用此方法以停靠在预定义顺序中的多个窗格对象。 此方法将由指定的窗格停靠*pBar*指定的窗格的左侧*pLeftOf*。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`DockPaneLeftOf`中使用方法[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#5](../../mfc/codesnippet/cpp/cmdiframewndex-class_4.cpp)]  
  
##  <a name="enableautohidepanes"></a>  CMDIFrameWndEx::EnableAutoHidePanes  
 启用自动隐藏模式对于窗格停靠在主框架窗口的指定方面时。  
  
```  
BOOL EnableAutoHidePanes(DWORD dwDockStyle);
```  
  
### <a name="parameters"></a>参数  
 [in]*dwDockStyle*  
 指定将启用主框架窗口的边。 使用一个或多个下列标志。  
  
- CBRS_ALIGN_LEFT  
  
- CBRS_ALIGN_RIGHT  
  
- CBRS_ALIGN_TOP  
  
- CBRS_ALIGN_BOTTOM  
  
### <a name="return-value"></a>返回值  
 调用此函数可停靠在主框架窗口的指定方面时启用自动隐藏模式下的窗格。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnableAutoHidePanes`中使用方法[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#6](../../mfc/codesnippet/cpp/cmdiframewndex-class_5.cpp)]  
  
### <a name="remarks"></a>备注  
  
##  <a name="enabledocking"></a>  CMDIFrameWndEx::EnableDocking  
 启用属于 MDI 框架窗口的窗格的停靠。  
  
```  
BOOL EnableDocking(DWORD dwDockStyle);
```  
  
### <a name="parameters"></a>参数  
 [in]*dwDockStyle*  
 指定你想要应用的停靠样式。  
  
### <a name="return-value"></a>返回值  
  
### <a name="remarks"></a>备注  
 调用此函数可启用属于的窗格的停靠`CMDIFrameWndEx`对象。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnableDocking`中使用方法[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#7](../../mfc/codesnippet/cpp/cmdiframewndex-class_6.cpp)]  
  
##  <a name="enablefullscreenmainmenu"></a>  CMDIFrameWndEx::EnableFullScreenMainMenu  
 显示或隐藏在全屏幕模式下的主菜单。  
  
```  
void EnableFullScreenMainMenu(BOOL bEnableMenu);
```  
  
### <a name="parameters"></a>参数  
 [in]*bEnableMenu*  
 若要在全屏幕模式下或为 FALSE，则将其隐藏显示在主菜单，则为 TRUE。  
  
### <a name="remarks"></a>备注  
  
##  <a name="enablefullscreenmode"></a>  CMDIFrameWndEx::EnableFullScreenMode  
 启用框架窗口的全屏幕模式。  
  
```  
void EnableFullScreenMode(UINT uiFullScreenCmd);
```  
  
### <a name="parameters"></a>参数  
 [in]*uiFullScreenCmd*  
 启用或禁用的全屏模式下的命令的 ID。  
  
### <a name="remarks"></a>备注  
 在全屏幕模式下，所有停靠控件条、 工具栏和菜单隐藏的调整大小活动视图以占用全屏幕。启用全屏模式时，必须指定启用或禁用它的命令的 ID。 您可以调用`EnableFullScreenMode`从主框架`OnCreate`函数。 框架窗口正在切换到全屏模式，则框架将使用一个具有指定的命令 ID 的按钮创建浮动工具栏如果您想要保留在屏幕上的主菜单中，调用[CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu)。  
  
##  <a name="enableloaddockstate"></a>  CMDIFrameWndEx::EnableLoadDockState  
 启用或禁用的插接状态的加载。  
  
```  
void EnableLoadDockState(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bEnable*  
 若要启用的插接状态的加载 FALSE 禁用的插接状态的加载，则为 TRUE。  
  
### <a name="remarks"></a>备注  
  
##  <a name="enablemditabbedgroups"></a>  Cmdiframewndex:: Enablemditabbedgroups  
 启用或禁用框架窗口的 MDI 选项卡式的分组功能。  
  
```  
void EnableMDITabbedGroups(
    BOOL bEnable,  
    const CMDITabInfo& params);
```  
  
### <a name="parameters"></a>参数  
 [in]*bEnable*  
 如果为 TRUE，启用 MDI 选项卡式的组功能;如果为 FALSE，则禁用 MDI 选项卡式的组功能。  
  
 [in]*params*  
 指定框架适用于在 MDI 工作区中创建的子窗口的参数。  
  
### <a name="remarks"></a>备注  
 此方法用于启用或禁用 MDI 选项卡式的分组功能。 此功能，以作为选项卡式窗口的垂直对齐或水平 MDI 客户端区域内显示子窗口的 MDI 应用程序。 将用拆分器分隔选项卡式窗口组。 用户可以通过使用拆分器调整大小选项卡式的组。  
  
-   用户可以：  
  
-   组之间拖动单独的选项卡。  
  
-   将单独的选项卡拖动到窗口创建新组的边缘。  
  
-   移动选项卡或使用快捷菜单中创建新的组。  
  
-   你的应用程序可以保存当前布局选项卡式窗口和当前打开的文档列表。  
  
 如果调用此方法替换*bEnable*设置为 FALSE， *params*将被忽略。  
  
 即使已启用 MDI 选项卡式组，可以调用此方法以修改子窗口的设置。 使用调用方法*bEnable*设置为 TRUE 并修改的成员`CMDITabInfo`由指定的对象*params*参数。  
  
 详细了解如何使用 MDI 选项卡式组，请参阅[MDI 选项卡式组](../../mfc/mdi-tabbed-groups.md)。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnableMDITabbedGroups`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#8](../../mfc/codesnippet/cpp/cmdiframewndex-class_7.cpp)]  
  
##  <a name="enablemditabs"></a>  CMDIFrameWndEx::EnableMDITabs  
 启用或禁用 MDI 框架窗口的 MDI 选项卡功能。 启用时，框架窗口将显示每个 MDI 子窗口的选项卡。  
  
```  
void EnableMDITabs(
    BOOL bEnable=TRUE,  
    BOOL bIcons=TRUE,  
    CMFCTabCtrl::Location tabLocation=CMFCTabCtrl::LOCATION_BOTTOM,  
    BOOL bTabCloseButton=FALSE,  
    CMFCTabCtrl::Style style=CMFCTabCtrl::STYLE_3D_SCROLLED,  
    BOOL bTabCustomTooltips=FALSE,  
    BOOL bActiveTabCloseButton=FALSE);
```  
  
### <a name="parameters"></a>参数  
 *bEnable*  
 指定是否启用选项卡。  
  
 *bIcons*  
 指定是否应在选项卡上显示图标。  
  
 *tabLocation*  
 指定的选项卡标签的位置。  
  
 *bTabCloseButton*  
 指定是否显示选项卡上的关闭按钮。  
  
 *style*  
 指定选项卡的样式。 使用 Microsoft OneNote 选项卡的常规选项卡或 STYLE_3D_ONENOTE STYLE_3D_SCROLLED。  
  
 *bTabCustomTooltips*  
 指定是否启用自定义工具提示。  
  
 *bActiveTabCloseButton*  
 如果为 TRUE，**关闭**按钮将显示在活动而不是选项卡上选项卡区域的右上角。  
  
### <a name="remarks"></a>备注  
 调用此方法来启用或禁用 MDI 框架窗口的 MDI 选项卡功能。 启用时，所有子窗口都显示为选项卡。  
  
 可以将位于顶部或底部的帧，具体取决于该参数设置选项卡标签*tabLocation*。 您可以指定`CMFCTabCtrl::LOCATION_BOTTOM`（默认设置） 或`CMFCTabCtrl::LOCATION_TOP`。  
  
 如果*bTabCustomTooltips*为 TRUE，AFX_WM_ON_GET_TAB_TOOLTIP 消息将发送到主框架窗口。 代码可以处理此消息，并提供了框架自定义工具提示使用 MDI 选项卡。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnableMDITabs`中使用[MDITabsDemo 示例： MFC 选项卡式 MDI 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_MDITabsDemo#3](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_8.cpp)]  
  
##  <a name="enablemditabslastactiveactivation"></a>  CMDIFrameWndEx::EnableMDITabsLastActiveActivation  
 指定当用户关闭当前选项卡是否应打开最后一个活动选项卡。  
  
```  
void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab=TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bLastActiveTab*  
 如果为 TRUE，则启用激活的最后一个活动选项卡。如果为 FALSE，禁用最后一个活动选项卡的激活。  
  
### <a name="remarks"></a>备注  
 有两种方法关闭活动选项卡时打开的选项卡：  
  
-   激活下一个选项卡。  
  
-   激活之前处于活动状态的选项卡。  
  
 默认实现使用第一种方法。  
  
 使用`EnableMDITabsLastActiveActivation`若要启用的选项卡激活第二种方法。 它来模拟 Windows 打开的 MDI 子窗口的方式。  
  
##  <a name="enablepanemenu"></a>  CMDIFrameWndEx::EnablePaneMenu  
 启用或禁用自动创建和管理的弹出窗口窗格菜单中，显示的应用程序窗格的列表。  
  
```  
void EnablePaneMenu(
    BOOL bEnable,  
    UINT uiCustomizeCmd,  
    const CString& strCustomizeLabel,  
    UINT uiViewToolbarsMenuEntryID,  
    BOOL bContextMenuShowsToolbarsOnly=FALSE,  
    BOOL bViewMenuShowsToolbarsOnly=FALSE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bEnable*  
 如果为 TRUE，则启用自动处理窗格菜单;如果为 FALSE，则禁用自动处理。  
  
 [in]*uiCustomizeCmd*  
 命令的 ID**自定义**菜单项。 此菜单项通常添加到窗格的列表的末尾。  
  
 [in]*strCustomizeLabel*  
 要显示的文本**自定义**菜单项 （用于本地化）。  
  
 [in]*uiViewToolbarsMenuEntryID*  
 指定用于打开窗格菜单的工具栏菜单项的 ID。 这是通常**工具栏**的子菜单**视图**菜单。  
  
 [in]*bContextMenuShowsToolbarsOnly*  
 如果为 TRUE，则窗格菜单上显示工具栏的列表。 如果为 FALSE，菜单上显示工具栏和停靠栏的列表。  
  
 [in]*bViewMenuShowsToolbarsOnly*  
 如果为 TRUE，则窗格菜单上显示工具栏的列表。 如果为 FALSE，菜单上显示工具栏和停靠栏的列表。  
  
### <a name="remarks"></a>备注  
 弹出窗口窗格菜单上显示的应用程序的窗格的列表，并使用户可以显示或隐藏各个窗格。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnablePaneMenu`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#9](../../mfc/codesnippet/cpp/cmdiframewndex-class_9.cpp)]  
  
##  <a name="enablewindowsdialog"></a>  CMDIFrameWndEx::EnableWindowsDialog  
 将其命令 ID 调用的菜单项插入[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)对话框。  
  
```  
void EnableWindowsDialog(
    UINT uiMenuId,  
    LPCTSTR lpszMenuText,  
    BOOL bShowAllways=FALSE,  
    BOOL bShowHelpButton=FALSE);

 
void EnableWindowsDialog(
    UINT uiMenuId,  
    UINT uiMenuTextResId,  
    BOOL bShowAllways=FALSE,  
    BOOL bShowHelpButton=FALSE);
```  
  
### <a name="parameters"></a>参数  
 [in]*uiMenuId*  
 指定菜单的资源 ID。  
  
 [in]*lpszMenuText*  
 指定项的文本。  
  
 [in]*bShowHelpButton*  
 指定是否显示**帮助**windows 管理对话框上的按钮。  
  
 [in]*uiMenuTextResId*  
 包含项的文本字符串的字符串资源标识符。  
  
### <a name="remarks"></a>备注  
 使用此方法将其命令调用 MDI 子窗口管理对话框中的菜单项 ( [CMFCWindowsManagerDialog 类](../../mfc/reference/cmfcwindowsmanagerdialog-class.md))。 新项插入到指定的菜单*uiMenuId*。 调用`EnableWindowsDialog`WM_CREATE 消息处理时。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`EnableWindowsDialog`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#10](../../mfc/codesnippet/cpp/cmdiframewndex-class_10.cpp)]  
  
##  <a name="getactivepopup"></a>  CMDIFrameWndEx::GetActivePopup  
 返回一个指向当前显示的弹出菜单的指针。  
  
```  
CMFCPopupMenu* GetActivePopup() const;  
```  
  
### <a name="return-value"></a>返回值  
 一个指向活动弹出菜单中;如果没有弹出菜单处于活动状态，则为 NULL。  
  
### <a name="remarks"></a>备注  
 使用此函数获取的指针[CMFCPopupMenu 类](../../mfc/reference/cmfcpopupmenu-class.md)当前显示的对象。  
  
##  <a name="getdefaultresid"></a>  CMDIFrameWndEx::GetDefaultResId  
 返回 MDI 框架窗口的共享资源的 ID。  
  
```  
UINT GetDefaultResId() const;  
```  
  
### <a name="return-value"></a>返回值  
 一个资源的 ID 值。 如果框架窗口没有菜单栏为 0。  
  
### <a name="remarks"></a>备注  
 此方法返回时加载 MDI 框架窗口指定的资源 ID [CFrameWnd::LoadFrame](../../mfc/reference/cframewnd-class.md#loadframe)。  
  
##  <a name="getmditabgroups"></a>  CMDIFrameWndEx::GetMDITabGroups  
 返回一系列 MDI 选项卡式窗口。  
  
```  
const CObList& GetMDITabGroups() const;  
```  
  
### <a name="return-value"></a>返回值  
 对引用[CObList 类](../../mfc/reference/coblist-class.md)对象，其中包含一系列选项卡式窗口。 不存储或修改的列表。  
  
### <a name="remarks"></a>备注  
 使用此方法访问的选项卡式窗口的列表。 如果你想要更改或查询的各个选项卡式窗口的某些参数，则可以非常有用。  
  
##  <a name="getmditabs"></a>  CMDIFrameWndEx::GetMDITabs  
 返回对带下划线的选项卡式窗口的引用。  
  
```  
CMFCTabCtrl& GetMDITabs();
```  
  
### <a name="return-value"></a>返回值  
 对带下划线的选项卡式窗口的引用。  
  
##  <a name="getmditabscontextmenualloweditems"></a>  CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems  
 返回标志的组合，用于确定哪些操作是有效的启用了 MDI 选项卡式组功能。  
  
```  
DWORD GetMDITabsContextMenuAllowedItems();
```  
  
### <a name="return-value"></a>返回值  
 以下标志的按位 OR 组合：  
  
- BCGP_MDI_CREATE_VERT_GROUP-可以创建一个垂直选项卡组。  
  
- BCGP_MDI_CREATE_HORZ_GROUP-可以创建水平选项卡组。  
  
- BCGP_MDI_CAN_MOVE_PREV-可以将一个选项卡移到上一个选项卡组。  
  
- BCGP_MDI_CAN_MOVE_NEXT-可以将一个选项卡移动到下一步的选项卡组。  
  
### <a name="remarks"></a>备注  
 启用 MDI 选项卡式组功能后，您必须知道特定窗口的选项卡上允许哪些操作。 此方法分析的选项卡式窗口的当前布局，并返回可以是标志的组合用于生成，例如，快捷菜单。  
  
 当所有选项卡式的窗口垂直对齐时或当只有一个选项卡式的窗口时，可以创建新的垂直选项卡组。  
  
 当所有选项卡式的窗口水平对齐，或只有一个选项卡式的窗口时，可以创建新的水平选项卡组。  
  
 仅当在选项卡式窗口中没有多个选项卡，可以转为上一组选项卡。  
  
 仅当在选项卡式窗口中没有多个选项卡，可以转为下一组选项卡。  
  
##  <a name="getmenubar"></a>  CMDIFrameWndEx::GetMenuBar  
 返回指向附加到框架窗口的菜单栏对象的指针。  
  
```  
const CMFCMenuBar* GetMenuBar() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向菜单栏对象的指针。  
  
##  <a name="getpane"></a>  CMDIFrameWndEx::GetPane  
 返回一个指向具有指定的控件 ID 的窗格  
  
```  
CBasePane* GetPane(UINT nID);
```  
  
### <a name="parameters"></a>参数  
 [in]*nID*  
 控件 id。  
  
### <a name="return-value"></a>返回值  
 指向具有指定的控件的 ID，如果它存在，则在窗格的指针。 否则，为 NULL。  
  
##  <a name="getribbonbar"></a>  CMDIFrameWndEx::GetRibbonBar  
 检索在框架的功能区栏控件。  
  
```  
CMFCRibbonBar* GetRibbonBar();
```  
  
### <a name="return-value"></a>返回值  
 指向[CMFCRibbonBar 类](../../mfc/reference/cmfcribbonbar-class.md)帧。  
  
### <a name="remarks"></a>备注  
  
##  <a name="gettearoffbars"></a>  CMDIFrameWndEx::GetTearOffBars  
 返回一系列拖曳菜单。  
  
```  
const CObList& GetTearOffBars() const;  
```  
  
### <a name="return-value"></a>返回值  
 对引用[CObList 类](../../mfc/reference/coblist-class.md)对象，其中包含指向的指针的集合`CPane`-派生的对象的处于拖曳状态。  
  
### <a name="remarks"></a>备注  
 `CMDIFrameWndEx` 维护一系列拖曳菜单。 使用此方法来检索到此列表的引用。  
  
##  <a name="gettoolbarbuttontooltiptext"></a>  CMDIFrameWndEx::GetToolbarButtonToolTipText  
 当应用程序将显示的工具栏按钮的工具提示时，由框架调用。  
  
```  
virtual BOOL GetToolbarButtonToolTipText(
    CMFCToolBarButton* pButton,  
    CString& strTTText);
```  
  
### <a name="parameters"></a>参数  
 [in]*pButton*  
 指向工具栏按钮的指针。  
  
 [in]*strTTText*  
 要为按钮显示的工具提示文本。  
  
### <a name="return-value"></a>返回值  
 如果显示工具提示，则为 TRUE。 FALSE 否则为。  
  
### <a name="remarks"></a>备注  
  
##  <a name="insertpane"></a>  CMDIFrameWndEx::InsertPane  
 注册到停靠管理器指定窗格。  
  
```  
BOOL InsertPane(
    CBasePane* pControlBar,  
    CBasePane* pTarget,  
    BOOL bAfter=TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*pControlBar*  
 指向要插入的窗格的指针。  
  
 [in]*pTarget*  
 指向之前或在其之后插入窗格的窗格的指针。  
  
 [in]*bAfter*  
 如果为 TRUE， *pControlBar*之后插入*pTarget*。 如果为 FALSE， *pControlBar*之前插入*pTarget*。  
  
### <a name="return-value"></a>返回值  
 如果该方法已成功注册窗格中，则返回 FALSE 如果窗格已注册到停靠管理器，则为 TRUE。  
  
### <a name="remarks"></a>备注  
 此方法用于告知由指定的窗格的停靠管理器*pControlBar*。 到停靠管理器将对齐窗格的对齐方式和到停靠管理器的内部列表中的位置根据此窗格。  
  
##  <a name="isfullscreen"></a>  CMDIFrameWndEx::IsFullScreen  
 确定在全屏幕模式下是否为框架窗口。  
  
```  
BOOL IsFullScreen() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果框架窗口在全屏幕模式，则为 TRUE否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 可以通过调用设置全屏幕模式下[CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode)方法。  
  
##  <a name="ismditabbedgroup"></a>  CMDIFrameWndEx::IsMDITabbedGroup  
 指定是否启用 MDI 选项卡式组功能。  
  
```  
BOOL IsMDITabbedGroup() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果启用 MDI 选项卡式组功能，则为 TRUE否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 若要确定是否启用正则 MDI 选项卡还是 MDI 选项卡式组功能，请使用[CMDIFrameWndEx::AreMDITabs](#aremditabs)。  
  
##  <a name="ismemberofmditabgroup"></a>  CMDIFrameWndEx::IsMemberOfMDITabGroup  
 确定指定的选项卡式的窗口是否在 windows 中 MDI 选项卡式组的列表中。  
  
```  
BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
```  
  
### <a name="parameters"></a>参数  
 [in]*pWnd*  
 指向选项卡式窗口的指针。  
  
### <a name="return-value"></a>返回值  
 如果指定的选项卡式的窗口在窗体 MDI 选项卡式组的选项卡式窗口的列表，则为 TRUE。 否则为 FALSE。  
  
##  <a name="ismenubaravailable"></a>  CMDIFrameWndEx::IsMenuBarAvailable  
 确定框架窗口是否具有菜单栏。  
  
```  
BOOL IsMenuBarAvailable() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果菜单栏对象的指针不为 NULL; 则为 TRUE否则为 FALSE。  
  
##  <a name="ispointneardocksite"></a>  CMDIFrameWndEx::IsPointNearDockSite  
 确定指定的点是否在停靠站点附近。  
  
```  
BOOL IsPointNearDockSite(
    CPoint point,  
    DWORD& dwBarAlignment,  
    BOOL& bOuterEdge) const;  
```  
  
### <a name="parameters"></a>参数  
 [in]*点*  
 屏幕坐标中指定的点。  
  
 [in]*dwBarAlignment*  
 指定的点是附近的边缘。 可能的值为 CBRS_ALIGN_LEFT、 CBRS_ALIGN_RIGHT、 CBRS_ALIGN_TOP 和 CBRS_ALIGN_BOTTOM  
  
 [in]*bOuterEdge*  
 在点附近的外边框的停靠站点中; 如果为 TRUEFALSE 否则为。  
  
### <a name="return-value"></a>返回值  
 在点附近停靠站点中; 如果为 TRUE否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 在到停靠管理器中设置的敏感度内时，关键是附近停靠站点。 默认敏感度为 15 像素。  
  
##  <a name="isprintpreview"></a>  CMDIFrameWndEx::IsPrintPreview  
 确定框架窗口是否在打印预览模式下。  
  
```  
BOOL IsPrintPreview();
```  
  
### <a name="return-value"></a>返回值  
 如果框架窗口在打印预览模式，则为 TRUE否则为 FALSE。  
  
### <a name="remarks"></a>备注  
  
##  <a name="loadframe"></a>  CMDIFrameWndEx::LoadFrame  
 创建框架窗口中的资源信息。  
  
```  
virtual BOOL LoadFrame(
    UINT nIDResource,  
    DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,  
    CWnd* pParentWnd = NULL,  
    CCreateContext* pContext = NULL);
```  
  
### <a name="parameters"></a>参数  
 [in]*nIDResource*  
 与框架窗口关联的共享资源 ID。  
  
 [in]*dwDefaultStyle*  
 框架窗口的样式。  
  
 [in]*pParentWnd*  
 指向帧的父级的指针。  
  
 [in]*pContext*  
 一个指向[CCreateContext 结构](../../mfc/reference/ccreatecontext-structure.md)。 此参数可以为 NULL。  
  
### <a name="return-value"></a>返回值  
 如果该方法成功，否则为 FALSE，则为 TRUE。  
  
##  <a name="loadmdistate"></a>  Cmdiframewndex:: Loadmdistate  
 加载 MDI 选项卡式组的指定的布局和以前打开的文档列表。  
  
```  
virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
```  
  
### <a name="parameters"></a>参数  
 [in]*lpszProfileName*  
 指定的配置文件名称。  
  
### <a name="return-value"></a>返回值  
 如果加载成功，则为 TRUE如果加载失败或没有要加载的数据，则为 FALSE。  
  
### <a name="remarks"></a>备注  
 若要加载或保存 MDI 选项卡和组的状态和打开的文档列表，请执行以下操作：  
  
-   调用[CMDIFrameWndEx::SaveMDIState](#savemdistate)主框架关闭时  
  
-   调用[cmdiframewndex:: Loadmdistate](#loadmdistate)主框架创建时。 第一次显示主框架之前，此调用的建议的位置。 添加`CWinAppEx::EnableLoadWindowPlacement``(FALSE);`之前`pMainFrame->LoadFrame (IDR_MAINFRAME);.`添加`CBCGPWorkspace::ReloadWindowPlacement``(pMainFrame);`调用的后面`LoadMDIState`在注册表中存储的位置显示主框架。  
  
-   重写`GetDocumentName`在`CMDIChildWndEx`的派生类，如果你的应用程序将显示不作为文件存储的文档。 返回的字符串将保存在注册表中，为文档标识符。 基实现[CMDIChildWndEx::GetDocumentName](../../mfc/reference/cmdichildwndex-class.md#getdocumentname)返回一个值，该值来自[CDocument::GetPathName](../../mfc/reference/cdocument-class.md#getpathname)。  
  
-   重写[CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow)正确创建文档时从注册表加载它们。 第一个参数是字符串的`GetDocumentName`返回。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`LoadMDIState`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#11](../../mfc/codesnippet/cpp/cmdiframewndex-class_11.cpp)]  
  
##  <a name="mditabmovetonextgroup"></a>  CMDIFrameWndEx::MDITabMoveToNextGroup  
 将从当前处于活动状态的选项卡式窗口的活动选项卡移动到下一步或上一个选项卡式组。  
  
```  
void MDITabMoveToNextGroup(BOOL bNext=TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bNext*  
 如果为 TRUE，将选项卡移动到下一个选项卡式组。 如果为 FALSE，则将其移到上一个选项卡式组。  
  
##  <a name="mditabnewgroup"></a>  CMDIFrameWndEx::MDITabNewGroup  
 创建具有单个窗口的新选项卡式的组。  
  
```  
void MDITabNewGroup(BOOL bVert=TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bVert*  
 指定新组对齐方式。 如果为 TRUE，则新组与垂直对齐。 如果为 FALSE，则新的组是水平对齐。  
  
### <a name="remarks"></a>备注  
 使用此函数创建一个新选项卡式窗口 （新选项卡式组） 并向其添加第一个选项卡。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`MDITabNewGroup`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#12](../../mfc/codesnippet/cpp/cmdiframewndex-class_12.cpp)]  
  
##  <a name="m_bcancovertcontrolbartomdichild"></a>  CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild  
 指定停靠窗格是否可以转换为 MDI 子窗口。  
  
```  
BOOL m_bCanCovertControlBarToMDIChild;  
```  
  
### <a name="remarks"></a>备注  
 指示是否可以将停靠控件条转换到 MDI 子窗口。 如果此标志为 TRUE，该框架将处理转换会自动在用户选择时**选项卡式文档**命令。 保护标志，则必须显式启用此选项设置`m_bCanCovertControlBarToMDIChild`的构造函数中`CMDIFrameWndEx`-派生的类，或通过重写`CanConvertControlBarToMDIChild`。  
  
 默认值为 `FALSE`。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`m_bCanCovertControlBarToMDIChild`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#13](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]  
  
##  <a name="m_bdisablesetredraw"></a>  CMDIFrameWndEx::m_bDisableSetRedraw  
 启用或禁用 MDI 子窗口的重绘优化。  
  
```  
AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;  
```  
  
### <a name="remarks"></a>备注  
 默认值为 TRUE。  
  
 如果你想要优化重绘功能的 MDI 子窗体，请将此标志设置为 FALSE。 在这种情况下，框架将调用`SetRedraw (FALSE)`的主框架应用程序更改活动选项卡时。  
  
 此标志可能会导致不需要的副作用 （例如背景的应用程序变得可见）。 因此我们建议仅当您遇到明显闪烁在 MDI 选项卡激活过程中更改默认值。  
  
##  <a name="negotiateborderspace"></a>  CMDIFrameWndEx::NegotiateBorderSpace  
 在 OLE 就地激活过程协商在框架窗口的边框空间。  
  
```  
virtual BOOL NegotiateBorderSpace(
    UINT nBorderCmd,  
    LPRECT lpRectBorder);
```  
  
### <a name="parameters"></a>参数  
 [in]*nBorderCmd*  
 包含枚举中的以下值之一`CFrameWnd::BorderCmd`:  
  
- `borderGet` = 1  
  
- `borderRequest` = 2  
  
- `borderSet` = 3  
  
 [in、 out]*lpRectBorder*  
 指向[RECT 结构](../../mfc/reference/rect-structure1.md)或[CRect 类](../../atl-mfc-shared/reference/crect-class.md)对象，它指定边框的坐标。  
  
### <a name="return-value"></a>返回值  
 如果此方法已成功，则非零值否则为 0。  
  
### <a name="remarks"></a>备注  
 此方法是实现 OLE 边框空间协商。  
  
##  <a name="onclosedockingpane"></a>  CMDIFrameWndEx::OnCloseDockingPane  
 由框架调用，当用户单击**关闭**可停靠窗格上的按钮。  
  
```  
virtual BOOL OnCloseDockingPane(CDockablePane* pWnd);
```  
  
### <a name="parameters"></a>参数  
 [in]*pWnd*  
 指向正在关闭了窗格的指针。  
  
### <a name="return-value"></a>返回值  
 如果可以关闭停靠的窗格，则为 TRUE。 否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 重写此方法以处理的停靠窗格隐藏。 如果你想要防止停靠窗格被隐藏，则返回 FALSE。  
  
 默认实现不执行任何操作，则返回 TRUE。  
  
##  <a name="oncloseminiframe"></a>  CMDIFrameWndEx::OnCloseMiniFrame  
 由框架调用，当用户单击**关闭**浮动微型框架窗口上的按钮。  
  
```  
virtual BOOL OnCloseMiniFrame(CPaneFrameWnd*);
```  
  
### <a name="parameters"></a>参数  
 [in]*pWnd*  
 指向微型框架窗口正在关闭。  
  
### <a name="return-value"></a>返回值  
 如果可以关闭浮动微型框架窗口，则为 TRUE。 否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 重写此方法以处理的浮动微型框架窗口隐藏。 如果你想要防止浮动微型框架窗口被隐藏，则返回 FALSE。  
  
 默认实现不执行任何操作，则返回 TRUE。  
  
##  <a name="onclosepopupmenu"></a>  CMDIFrameWndEx::OnClosePopupMenu  
 当活动的弹出菜单处理 WM_DESTROY 消息时由框架调用。  
  
```  
virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
```  
  
### <a name="parameters"></a>参数  
 [in]*pMenuPopup*  
 指向一个弹出菜单。  
  
### <a name="remarks"></a>备注  
 重写此方法，如果你想要处理来自通知[CMFCPopupMenu 类](../../mfc/reference/cmfcpopupmenu-class.md)属于 MDI 框架窗口，这些对象处理 WM_DESTROY 消息时的对象。  
  
##  <a name="oncmdmsg"></a>  CMDIFrameWndEx::OnCmdMsg  
 由框架调用以路由和调度命令消息和更新命令用户界面对象。  
  
```  
virtual BOOL OnCmdMsg(
    UINT nID,  
    int nCode,  
    void* pExtra,  
    AFX_CMDHANDLERINFO* pHandlerInfo);
```  
  
### <a name="parameters"></a>参数  
 [in]*nID*  
 命令 ID。  
  
 [in]*nCode*  
 标识命令通知代码。 请参阅[CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)的值有关的详细信息*nCode*。  
  
 [in]*pExtra*  
 使用的值根据*nCode*。 请参阅[CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)有关详细信息*pExtra*。  
  
 [in、 out]*pHandlerInfo*  
 通常情况下，此参数应为 NULL。如果不为 NULL，`OnCmdMsg`填入`pTarget`并`pmf`的成员*pHandlerInfo*而不是调度该命令的结构。  
  
### <a name="return-value"></a>返回值  
 处理此消息; 如果非零值否则为 0。  
  
##  <a name="ondrawmenuimage"></a>  CMDIFrameWndEx::OnDrawMenuImage  
 当绘制与菜单项关联的图像时由框架调用。  
  
```  
virtual BOOL OnDrawMenuImage(
    CDC* pDC,  
    const CMFCToolBarMenuButton* pMenuButton,  
    const CRect& rectImage);
```  
  
### <a name="parameters"></a>参数  
 [in]*pDC*  
 指向设备上下文的指针。  
  
 [in]*pMenuButton*  
 指针，指向菜单按钮。  
  
 [in]*rectImage*  
 图像边框。  
  
### <a name="return-value"></a>返回值  
 如果该方法绘制的图像，则为 TRUE。 默认实现将返回 FALSE。  
  
### <a name="remarks"></a>备注  
 重写此方法，如果你想要自定义属于拥有的菜单栏的菜单项的图像呈现`CMDIFrameWndEx`-派生的对象。 默认实现不执行任何操作。  
  
##  <a name="ondrawmenulogo"></a>  CMDIFrameWndEx::OnDrawMenuLogo  
 由框架调用时[CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)处理 WM_PAINT 消息。  
  
```  
virtual void OnDrawMenuLogo(
    CDC*, 
    CMFCPopupMenu*, 
    const CRect&);
```  
  
### <a name="remarks"></a>备注  
 重写此函数可在弹出菜单属于拥有的菜单栏上显示徽标`CMDIFrameWndEx`-派生的对象。 默认实现不执行任何操作。  
  
##  <a name="onerasemdiclientbackground"></a>  CMDIFrameWndEx::OnEraseMDIClientBackground  
 当 MDI 框架窗口处理 WM_ERASEBKGND 消息时由框架调用。  
  
```  
virtual BOOL OnEraseMDIClientBackground(CDC*);
```  
  
### <a name="return-value"></a>返回值  
 如果应用程序处理消息并清除背景，则为 TRUE。  
  
### <a name="remarks"></a>备注  
 如果你想要处理 WM_ERASEBKGND 消息中的重写此成员函数`CMDIFrameWndEx`-派生的类。  
  
##  <a name="onmenubuttontoolhittest"></a>  CMDIFrameWndEx::OnMenuButtonToolHitTest  
 由框架调用时[CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)对象处理 WM_NCHITTEST 消息。  
  
```  
virtual BOOL OnMenuButtonToolHitTest(
    CMFCToolBarButton* pButton,  
    TOOLINFO* pTI);
```  
  
### <a name="parameters"></a>参数  
 [in]*pButton*  
 工具栏按钮。  
  
 [out]*pTI*  
 指向[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)结构。  
  
### <a name="return-value"></a>返回值  
 如果应用程序已满，则返回 TRUE *pTI*参数。 默认实现将返回 FALSE。  
  
### <a name="remarks"></a>备注  
 如果你想要提供有关特定菜单项为工具提示的信息，请重写此方法。 默认实现不执行任何操作。  
  
##  <a name="onmoveminiframe"></a>  CMDIFrameWndEx::OnMoveMiniFrame  
 由框架调用以移动微型框架窗口。  
  
```  
virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
```  
  
### <a name="parameters"></a>参数  
 [in]*pFrame*  
 指向微型框架窗口的指针。  
  
### <a name="return-value"></a>返回值  
 如果该方法成功，否则为 FALSE，则为 TRUE。  
  
##  <a name="onsetpreviewmode"></a>  CMDIFrameWndEx::OnSetPreviewMode  
 设置应用程序的主框架窗口打印预览模式。  
  
```  
virtual void OnSetPreviewMode(
    BOOL bPreview,  
    CPrintPreviewState* pState);
```  
  
### <a name="parameters"></a>参数  
 [in]*bPreview*  
 如果为 TRUE，设置打印预览模式。 如果为 FALSE，则取消预览模式。  
  
 [in]*pState*  
 一个指向`CPrintPreviewState`结构。  
  
### <a name="remarks"></a>备注  
 此方法重写[cframewnd:: Onsetpreviewmode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode)。  
  
##  <a name="onshowcustomizepane"></a>  CMDIFrameWndEx::OnShowCustomizePane  
 激活快速自定义窗格时，由框架调用。  
  
```  
virtual BOOL OnShowCustomizePane(
    CMFCPopupMenu* pMenuPane,  
    UINT uiToolbarID);
```  
  
### <a name="parameters"></a>参数  
 [in]*pMenuPane*  
 快速自定义窗格指向的指针。  
  
 [in]*uiToolbarID*  
 控件 ID 的工具栏自定义。  
  
### <a name="return-value"></a>返回值  
 此方法始终返回 TRUE。  
  
### <a name="remarks"></a>备注  
 快速自定义窗格是用户单击时，将打开一个菜单**自定义**工具栏上。  
  
 重写此方法在派生类中的快速自定义窗格进行更改。  
  
##  <a name="onshowmditabcontextmenu"></a>  CMDIFrameWndEx::OnShowMDITabContextMenu  
 其中一个选项卡上显示快捷菜单之前由框架调用。 有效的 MDI 选项卡式组仅。  
  
```  
virtual BOOL OnShowMDITabContextMenu(
    CPoint point,  
    DWORD dwAllowedItems,  
    BOOL bTabDrop);
```  
  
### <a name="parameters"></a>参数  
 [in]*点*  
 以屏幕坐标表示菜单的位置。  
  
 [in]*dwAllowedItems*  
 按位 OR 组合的标志，指示当前选项卡允许的操作：  
  
- BCGP_MDI_CREATE_VERT_GROUP-可以创建一个垂直选项卡组。  
  
- BCGP_MDI_CREATE_HORZ_GROUP-可以创建水平选项卡组。  
  
- BCGP_MDI_CAN_MOVE_PREV-可以将一个选项卡移到上一个选项卡组。  
  
- BCGP_MDI_CAN_MOVE_NEXT-可以将一个选项卡移动到下一步的选项卡组。  
  
- BCGP_MDI_CAN_BE_DOCKED-切换到停靠状态 （适用于仅选项卡式文档） 的选项卡式的文档。  
  
 [in]*bTabDrop*  
 由于拖动到另一个选项卡式组的选项卡菜单显示为 TRUE。 为 FALSE，则为当前处于活动状态的选项卡上的快捷方式菜单显示菜单。  
  
### <a name="return-value"></a>返回值  
 重写此方法中的[CBCGPMDIFrameWnd](../../mfc/reference/cmdiframewndex-class.md)-派生的类。  
  
### <a name="remarks"></a>备注  
 如果不处理`OnShowMDITabContextMenu`，将不会显示快捷菜单。 此函数生成的**MFC 应用程序向导**时启用 MDI 选项卡式组功能。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`OnShowMDITabContextMenu`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#14](../../mfc/codesnippet/cpp/cmdiframewndex-class_13.cpp)]  
  
##  <a name="onshowpanes"></a>  CMDIFrameWndEx::OnShowPanes  
 由框架调用以显示或隐藏窗格。  
  
```  
virtual BOOL OnShowPanes(BOOL bShow);
```  
  
### <a name="parameters"></a>参数  
 [in]*bShow*  
 若要显示窗格中，为 FALSE，则隐藏窗格，则为 TRUE。  
  
### <a name="return-value"></a>返回值  
 如果由于调用此方法，FALSE，如果窗格在已指定的状态窗格的状态更改为 TRUE *bShow*。 例如，如果隐藏窗格并*bShow*为 FALSE 时，返回值为 FALSE。  
  
### <a name="remarks"></a>备注  
 从顶级框架窗口中的默认实现删除工具栏。  
  
 如果[CDockingManager::m_bHideDockingBarsInContainerMode](../../mfc/reference/cdockingmanager-class.md#m_bhidedockingbarsincontainermode)是 TRUE （默认值），则将隐藏所有停靠窗格。  
  
##  <a name="onshowpopupmenu"></a>  CMDIFrameWndEx::OnShowPopupMenu  
 在打开的弹出菜单时由框架调用。  
  
```  
virtual BOOL OnShowPopupMenu(CMFCPopupMenu*);
```  
  
### <a name="return-value"></a>返回值  
 如果弹出菜单的显示，则为 TRUE。 否则为 FALSE。 默认实现，则返回 TRUE。  
  
### <a name="remarks"></a>备注  
 如果你想要实现特殊处理，在弹出菜单激活后的，重写此方法。 例如，如果你想要将常规菜单项更改为颜色菜单按钮，设置拖曳栏，依次类推。  
  
 默认实现不执行任何操作。  
  
##  <a name="onsizemdiclient"></a>  CMDIFrameWndEx::OnSizeMDIClient  
 客户端 MDI 窗口的大小更改时由框架调用。  
  
```  
virtual void OnSizeMDIClient(
    const CRect& rectOld,  
    const CRect& rectNew);
```  
  
### <a name="parameters"></a>参数  
 [in]*rectOld*  
 MDI 客户端窗口的当前大小。  
  
 [in]*rectNew*  
 MDI 客户端窗口的新大小。  
  
### <a name="remarks"></a>备注  
  
##  <a name="ontearoffmenu"></a>  CMDIFrameWndEx::OnTearOffMenu  
 当激活带有拖曳栏的菜单时由框架调用。  
  
```  
virtual BOOL OnTearOffMenu(
    CMFCPopupMenu* pMenuPopup,  
    CPane* pBar);
```  
  
### <a name="parameters"></a>参数  
 [in]*pMenuPopup*  
 指向弹出菜单的指针。  
  
 [in]*pBar*  
 指向拖曳栏的指针。  
  
### <a name="return-value"></a>返回值  
 为 TRUE，则允许带有拖曳栏进行激活; 的弹出菜单否则为 FALSE。 默认值为 TRUE。  
  
### <a name="remarks"></a>备注  
 当你想要实现用于拖曳栏的特殊安装程序时，重写此函数。 默认实现不执行任何操作。  
  
##  <a name="onupdateframemenu"></a>  CMDIFrameWndEx::OnUpdateFrameMenu  
 由框架调用以更新框架的菜单。  
  
```  
virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
```  
  
### <a name="parameters"></a>参数  
 [in]*hMenuAlt*  
 菜单句柄。  
  
##  <a name="panefrompoint"></a>  CMDIFrameWndEx::PaneFromPoint  
 返回包含指定的点的停靠窗格。  
  
```  
CBasePane* PaneFromPoint(
    CPoint point,  
    int nSensitivity,  
    bool bExactBar,  
    CRuntimeClass* pRTCBarType) const;  
  
CBasePane* PaneFromPoint(
    CPoint point,  
    int nSensitivity,  
    DWORD& dwAlignment,  
    CRuntimeClass* pRTCBarType) const;  
```  
  
### <a name="parameters"></a>参数  
 [in]*点*  
 在点 （用屏幕坐标表示）。  
  
 [in]*nSensitivity*  
 此值被放大了在所有方向上的每个已检查窗格窗口矩形。  
  
 [in]*bExactBar*  
 如果为 TRUE， *nSensitivity*参数将被忽略。  
  
 [in]*pRTCBarType*  
 如果非 NULL，该方法循环访问仅指定类型的窗格。  
  
 [out]*dwAlignment*  
 如果找到一个窗格，则此参数将指定哪一侧窗格的是最接近指定点。  
  
### <a name="return-value"></a>返回值  
 停靠的窗格中或如果没有控件包含由指定的点，则为 NULL 的指针*点*。  
  
### <a name="remarks"></a>备注  
 在调用重定向到[CDockingManager 类](../../mfc/reference/cdockingmanager-class.md)。 请参阅[CDockingManager::ControlBarFromPoint](../../mfc/reference/cdockingmanager-class.md#panefrompoint)有关详细信息。  
  
##  <a name="recalclayout"></a>  CMDIFrameWndEx::RecalcLayout  
 由框架调用以重新计算框架窗口的布局。  
  
```  
virtual void RecalcLayout(BOOL bNotify = TRUE);
```  
  
### <a name="parameters"></a>参数  
 [in]*bNotify*  
 确定框架窗口的活动的就地项是否接收通知的布局更改。 如果为 TRUE，项是收到通知;否则为 FALSE。  
  
### <a name="remarks"></a>备注  
 此方法重写[CFrameWnd::RecalcLayout](../../mfc/reference/cframewnd-class.md#recalclayout)。  
  
##  <a name="removepanefromdockmanager"></a>  CMDIFrameWndEx::RemovePaneFromDockManager  
 注销一个窗格，并将其从到停靠管理器中删除。  
  
```  
void RemovePaneFromDockManager(
    CBasePane* pControlBar,  
    BOOL bDestroy,  
    BOOL bAdjustLayout,  
    BOOL bAutoHide,  
    CBasePane* pBarReplacement);
```  
  
### <a name="parameters"></a>参数  
 [in]*pControlBar*  
 指向要删除一个窗格的指针。  
  
 [in]*bDestroy*  
 若要销毁已删除的窗格中，则为 TRUE。 为 FALSE，则不将其销毁。  
  
 [in]*bAdjustLayout*  
 若要立即调整停靠布局，则为 TRUE。 如果为 FALSE，调整将发生仅当重绘事件发生时出于其他原因 （用户调整窗口大小时，将拖动的主框架，等等）。  
  
 [in]*bAutoHide*  
 若要从自动隐藏窗格的列表中删除窗格中，则为 TRUE。 如果为 FALSE，以从列表中的正则窗格删除窗格。  
  
 [in]*pBarReplacement*  
 指向一个窗格，它将替换已删除的窗格的指针。  
  
### <a name="remarks"></a>备注  
 每个窗格必须注册到停靠管理器中停靠布局。 使用[CMDIFrameWndEx::AddPane](#addpane)或[CMDIFrameWndEx::InsertPane](#insertpane)注册窗格。  
  
 当一个窗格不再框架窗口的停靠布局的一部分时，请使用此方法。  
  
##  <a name="savemdistate"></a>  CMDIFrameWndEx::SaveMDIState  
 保存 MDI 选项卡式组的当前布局和以前打开的文档列表。  
  
```  
virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);
```  
  
### <a name="parameters"></a>参数  
 [in]*lpszProfileName*  
 指定的配置文件名称。  
  
### <a name="return-value"></a>返回值  
 如果保存成功，则为 TRUE如果保存失败，则为 FALSE。  
  
### <a name="remarks"></a>备注  
 若要加载或保存 MDI 选项卡和组的状态和打开的文档列表，请执行以下操作：  
  
-   调用`SaveMDIState`主框架关闭时  
  
-   调用[cmdiframewndex:: Loadmdistate](#loadmdistate)主框架创建时。 建议在此调用的此位置是第一次显示主框架之前。  
  
-   调用`CWinAppEx::EnableLoadWindowPlacement(FALSE);`之前 `pMainFrame->LoadFrame (IDR_MAINFRAME);`  
  
-   调用`CWinAppEx::ReloadWindowPlacement(pMainFrame)`后`LoadMDIState`在注册表中存储的位置显示主框架。  
  
-   重写`GetDocumentName`在`CMDIChildWndEx`的派生类，如果你的应用程序将显示不作为文件存储的文档。 返回的字符串将保存在注册表中，为文档标识符。 有关详细信息，请参阅[CMDIChildWndEx::GetDocumentName](../../mfc/reference/cmdichildwndex-class.md#getdocumentname)。  
  
-   重写[CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow)加载时从注册表正确创建文档。 参数`CreateDocumentWindow`的字符串的`GetDocumentName`前面返回。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`SaveMDIState`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#15](../../mfc/codesnippet/cpp/cmdiframewndex-class_14.cpp)]  
  
##  <a name="setprintpreviewframe"></a>  CMDIFrameWndEx::SetPrintPreviewFrame  
 设置打印预览框架窗口。  
  
```  
void SetPrintPreviewFrame(CFrameWnd* pWnd);
```  
  
### <a name="parameters"></a>参数  
 [in]*pWnd*  
 到打印预览框架窗口的指针。  
  
### <a name="remarks"></a>备注  
  
##  <a name="setuptoolbarmenu"></a>  CMDIFrameWndEx::SetupToolbarMenu  
 通过虚拟项替换为用户定义的项修改工具栏对象。  
  
```  
void SetupToolbarMenu(
    CMenu& menu,  
    const UINT uiViewUserToolbarCmdFirst,  
    const UINT uiViewUserToolbarCmdLast);
```  
  
### <a name="parameters"></a>参数  
 [in]*菜单*  
 对引用[CMenu 类](../../mfc/reference/cmenu-class.md)要修改对象。  
  
 [in]*uiViewUserToolbarCmdFirst*  
 指定用户定义的第一个命令。  
  
 [in]*uiViewUserToolbarCmdLast*  
 指定用户定义的最后一个命令。  
  
##  <a name="showfullscreen"></a>  CMDIFrameWndEx::ShowFullScreen  
 切换到全屏模式主框架从常规模式。  
  
```  
void ShowFullScreen();
```  
  
### <a name="remarks"></a>备注  
  
##  <a name="showpane"></a>  CMDIFrameWndEx::ShowPane  
 显示或隐藏指定的窗格。  
  
```  
void ShowPane(
    CBasePane* pBar,  
    BOOL bShow,  
    BOOL bDelay,  
    BOOL bActivate);
```  
  
### <a name="parameters"></a>参数  
 [in]*pBar*  
 指向要显示或隐藏的窗格。  
  
 [in]*bShow*  
 若要显示的窗格，则为 TRUE。 如果为 FALSE，则若要隐藏窗格。  
  
 [in]*bDelay*  
 若要延迟的停靠布局的重新计算，则为 TRUE。 如果为 FALSE，则立即重新计算停靠布局。  
  
 [in]*bActivate*  
 为 true，则显示在窗格应为活动状态。 为 FALSE，则显示为非活动状态的窗格。  
  
### <a name="remarks"></a>备注  
 调用此方法以显示或隐藏窗格。 不要使用`ShowWindow`的停靠窗格。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`ShowPane`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#16](../../mfc/codesnippet/cpp/cmdiframewndex-class_15.cpp)]  
  
##  <a name="showwindowsdialog"></a>  CMDIFrameWndEx::ShowWindowsDialog  
 创建[CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)框并将其打开。  
  
```  
void ShowWindowsDialog();
```  
  
### <a name="example"></a>示例  
 下面的示例演示如何`ShowWindowsDialog`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#18](../../mfc/codesnippet/cpp/cmdiframewndex-class_16.cpp)]  
  
##  <a name="tabbeddocumenttocontrolbar"></a>  CMDIFrameWndEx::TabbedDocumentToControlBar  
 将指定的选项卡式的文档转换为停靠窗格。  
  
```  
virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);
```  
  
### <a name="parameters"></a>参数  
 *pMDIChildWnd*  
 指向包含停靠窗格的 MDI 子窗口的指针。  
  
### <a name="return-value"></a>返回值  
 如果此方法已成功，则在失败时为 FALSE，则为 TRUE。  
  
### <a name="remarks"></a>备注  
 使用此方法将选项卡式的文档转换为停靠窗格。 选项卡式的文档必须通过创建[CMDIFrameWndEx::ControlBarToTabbedDocument](#controlbartotabbeddocument)。  
  
### <a name="example"></a>示例  
 下面的示例演示如何`TabbedDocumentToControlBar`中使用[VisualStudioDemo 示例： MFC Visual Studio 应用程序](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#19](../../mfc/codesnippet/cpp/cmdiframewndex-class_17.cpp)]  
  
##  <a name="updatecaption"></a>  CMDIFrameWndEx::UpdateCaption  
 由框架调用以更新窗口框架标题。  
  
```  
void UpdateCaption();
```  
  
### <a name="remarks"></a>备注  
  
##  <a name="updatemditabbedbarsicons"></a>  CMDIFrameWndEx::UpdateMDITabbedBarsIcons  
 设置每个 MDI 选项卡式窗格中的图标。  
  
```  
void UpdateMDITabbedBarsIcons();
```  
  
##  <a name="winhelp"></a>  CMDIFrameWndEx::WinHelp  
 由框架调用以启动 WinHelp 应用程序或上下文帮助。  
  
```  
virtual void WinHelp(
    DWORD dwData,  
    UINT nCmd = HELP_CONTEXT);
```  
  
### <a name="parameters"></a>参数  
 [in]*dwData*  
 指定所需的帮助由指定类型的数据*nCmd*。  
  
 [in]*nCmd*  
 指定请求的帮助的类型。 有关一系列可能的值以及它们如何影响*dwData*参数，请参阅[WinHelp 函数](/windows/desktop/api/winuser/nf-winuser-winhelpa)Windows SDK 中。  
  
### <a name="remarks"></a>备注  
 此方法重写[cwnd:: Winhelp](../../mfc/reference/cwnd-class.md#winhelp)。  
  
## <a name="see-also"></a>请参阅  
 [层次结构图表](../../mfc/hierarchy-chart.md)   
 [类](../../mfc/reference/mfc-classes.md)   
 [CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)   
 [CMDIChildWndEx 类](../../mfc/reference/cmdichildwndex-class.md)
