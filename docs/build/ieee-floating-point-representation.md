---
title: IEEE 浮点表示形式
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: bb8523256c05479b303dec66ca79caa28e7cda03
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/24/2020
ms.locfileid: "80169807"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮点表示形式

Microsoft C++ （MSVC）与 IEEE 数字标准一致。 IEEE-754 标准介绍了浮点格式，这是一种在硬件中表示真实数字的方式。 对于浮点数，可在 MSVC 编译器面向的硬件中提供至少五种内部格式，但编译器仅使用其中的两种格式。 *单精度*（4字节）和*双精度*（8字节）格式用于 MSVC。 使用关键字**float**声明单精度。 双精度使用关键字**double**进行声明。 IEEE 标准还指定了*半精度*（2字节）和*四精度*（16字节）格式，以及*双*精度（10字节）格式，其中某些 C 和C++编译器将实现为**long double**数据类型。 在 MSVC 编译器中，**长双精度**数据类型被视为不同的类型，但存储类型映射为**double**。 但对于使用其他格式（包括双精度扩展（10字节）格式，其中硬件支持）的计算，存在内部和汇编语言支持。

值按如下方式存储：

|值|存储为|
|-----------|---------------|
|单精度 (single-precision)|符号位，8位指数，23位有效位数|
|双精度|符号位，11位指数，52位有效位数|
|double-extended-precision|符号位，15位指数，64位有效位数|

在单精度和双精度格式中，在小数部分（称为*有效位数*（有时称为*尾数*））中假设有一个前导1，它不存储在内存中，因此有效位数实际上为24或53位，即使只存储23或52位。 双精度扩展格式实际存储此位。

指数的偏差为其可能值的一半。 这意味着，可以从存储的指数减去此偏差以获取实际的指数。 如果存储的指数小于偏差，则实际上为负指数。

指数的偏差如下：

|Exponent|偏向|
|--------------|---------------|
|8位（单精度）|127|
|11位（双精度）|1023|
|15位（双精度扩展）|16383|

这些指数不是10的幂;它们是2的幂。 也就是说，8位存储指数的范围为-127 到127，存储为0到254。 值 2<sup>127</sup>大致等效于 10<sup>38</sup>，这是单精度的实际限制。

有效位数存储为1.XXX 形式的二进制小数。 此分数的值大于或等于1且小于2。 请注意，实数始终以*标准化形式*存储;也就是说，有效位数是左移动的，因此有效位数的高序位始终为1。 因为此位始终为1，所以它采用单精度和双精度格式（不存储）。 二进制（不是小数）点被假定为紧靠前导1的右侧。

不同大小的格式如下所示：

|格式|字节1|字节2|字节3|字节4|...|字节 n|
|------------|------------|------------|------------|------------|---------|------------|
|单精度 (single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|双精度|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|double-extended-precision|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S` 表示符号位，则 `X`是偏差指数位，`M`是有效位数位。 请注意，在单精度和双精度格式中采用最左侧的位，但在双精度格式的字节3中以 "1" 的形式出现。

若要正确地移动二进制点，请首先 unbias 指数，然后将二进制点向右或向左移动适当的位数。

## <a name="special-values"></a>特殊值

浮点格式包括一些专门处理的值。

### <a name="zero"></a>零

不能对零进行正常化，这使得它 unrepresentable 为单精度值或双精度值的规范化形式。 所有零的特殊位模式都表示0。 还可以将-0 表示为带有符号位集的零，但是-0 和0始终比较为相等。

### <a name="infinities"></a>无穷大

\+ ∞和−∞值由所有值的一个指数和所有零的有效位数表示。 正无穷大和负无穷大均可使用符号位表示。

### <a name="subnormals"></a>Subnormals

可以表示比最小标准化数字更小的数值。 这些数字称为*次正常*或*denormal*号。 如果指数全为零并且有效位数为非零，则将有效位数的隐式前导位视为零，而不是一个。 次正常数的精度会下降，因为有效位数中的前导零的数目就会下降。

### <a name="nan---not-a-number"></a>NaN-非数字

可以表示非实数的值（例如 0/0），采用 IEEE 浮点格式。 此类型的值称为*NaN*。 NaN 由所有值和非零有效位数的指数表示。 有两种类型的 Nan、 *quiet* Nan 或 QNaNs，以及发出 Nan 或 SNaNs 的*信号*。 Quiet Nan 在有效位数中有前导一，通常通过表达式传播。 它们表示一个不确定的值，例如除以无穷所得的结果，或将无穷乘以零。 发出的信号表明有效位数中有一个前导零。 它们用于无效的操作，以发出浮点硬件异常信号。

## <a name="examples"></a>示例

下面是单精度格式的一些示例：

- 对于值2，符号位为零，存储的指数为128，或二进制中的 1000 0000 （即 127 + 1）。 存储的二进制有效位数是（1.） 000 0000 0000 0000 0000 0000，它具有一个隐含的前导1和二进制点，因此实际有效位数为1。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 值-2。 除了设置了符号位外，与 + 2 相同。 对于所有 IEEE 格式浮点数，均为 true。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 值4。 相同的有效位数，指数增加1（偏差值为129，或二进制形式为 100 0000 1）。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 值6。 指数相同，有效位数更大，即（1.） 100 0000 .。。0000 0000，因为这是一个二进制小数，所以是 1 1/2，因为小数位的值是1/2、1/4、1/8 等。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 值1。 与第二个有效位数的其他幂相同，有偏差指数为127，即二进制形式的 011 1111 1。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 值0.75。 偏差指数为126，二进制形式为 011 1111 0，有效位数为（1，） 100 0000 .。。0000 0000，即 1 1/2。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 值2.5。 与2完全相同，只是在有效位数中设置表示1/4 的位。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10 是二进制中的重复分数。 有效位数仅 shy 为1.6，而有偏差指数指示1.6 将除以16（二进制形式为 011 1101 1，即十进制的123）。 True 指数为 123-127 =-4，这意味着乘运算系数为 2<sup>-4</sup> = 1/16。 请注意，存储的有效位数将在上一位向上舍入，这表示尝试尽可能准确地表示 unrepresentable 数。 （1/10 和1/100 在二进制中的表示形式不能完全表示，这类似于1/3 无法以十进制表示的原因。）

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 零是一种特殊情况，它使用公式来实现最小可能的可表示正值，该值全为零。

   |值|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>另请参阅

[为何浮点数可能丢失精度](why-floating-point-numbers-may-lose-precision.md)
