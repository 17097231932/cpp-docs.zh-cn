---
title: 1. 介绍
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 99020e9cf8c38bcfaeefdf5c31663b3e66352556
ms.sourcegitcommit: 2ebbf8093fadb9a1b78a4381439bcd5c01a89267
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/18/2019
ms.locfileid: "54397298"
---
# <a name="1-introduction"></a>1.介绍

本文档指定编译器指令，库函数，以及可用于 C 和 c + + 程序中指定共享内存的并行度的环境变量的集合。 本文档中所述的功能统称为*OpenMP C/c + + 应用程序接口 (API)*。 此规范的目的是提供的并行编程模型允许跨不同供应商的共享内存体系结构为可移植程序。 许多供应商提供的编译器支持 OpenMP C/c + + API。 OpenMP，有关详细信息包括*OpenMP Fortran 应用程序编程接口*，可以在以下网站上找到：

[https://www.openmp.org](https://www.openmp.org)

指令中，库函数和本文档中定义的环境变量，可创建和管理并行程序，同时允许可移植性。 指令扩展 C 和 c + + 顺序编程模型的多个数据 (SPMD) 构造的单个程序、 工作共享构造和同步构造。 它们还支持共享和私有化的数据。 OpenMP C 和 c + + API 支持的编译器包括命令行选项对编译器进行激活，并允许所有 OpenMP 编译器指令的解释。

## <a name="11-scope"></a>1.1 范围

此规范介绍仅用户指定的并行，显式定义的操作，其中编译器和运行时系统需要并行执行程序。 OpenMP C 和 c + + 实现无需检查依赖项、 冲突、 死锁、 争用条件或不正确的程序执行会导致其他问题。 您有责任确保应用程序使用 OpenMP C 和 c + + API 构造正确执行。 编译器生成自动并行化和编译器的指令，以帮助此类并行化不涉及本文档中的内容。

## <a name="12-definition-of-terms"></a>1.2 术语的定义

本文档中使用以下术语：

- barrier

  在团队中的所有线程必须都达到同步点。  每个线程等待，直到团队中的所有线程都到达该点。 有显式标识的指令和由实现创建的隐式屏障的障碍。

- 构造

  一种构造是一个语句。 它包含的指令，然后是结构化块。 一些指令不是一种构造的一部分。 (请参阅*openmp 指令*中[附录 C](c-openmp-c-and-cpp-grammar.md))。

- 指令

  C 或 c + +`#pragma`跟`omp`标识符、 其他文本和新行。 指令指定的程序行为。

- 动态范围

  中的所有语句*词法范围*，加上在函数中的词法范围内的语句执行结果执行任何语句。 动态范围也称为*区域*。

- 词法范围

  语句在词法上持有*结构化的块*。

- 主线程

  创建了团队的线程时*并行区域*输入。

- 并行区域

  将绑定到 OpenMP 并行构造，并可能由多个线程执行的语句。

- private

  私有变量的名称是唯一的线程，从而将该引用的存储块。 有几种方法来指定一个变量是私有： 并行区域内的定义`threadprivate`指令， `private`， `firstprivate`， `lastprivate`，或`reduction`子句或使用作为变量`for`循环中的控制变量`for`循环紧跟`for`或`parallel for`指令。

- 区域

  在动态范围。

- 串行区域

  仅可由执行的语句*主线程*之外的任何动态程度*并行区域*。

- 序列化

  若要执行的并行构造：

  - 线程包含只有一个线程 （即该并行构造的主线程），团队

  - 串行 （相同订购像块不是并行构造的一部分） 的结构化块中的语句的执行顺序和

  - 返回的值不会影响`omp_in_parallel()`（除了效果的任何嵌套并行构造）。

- 共享

  共享的变量命名一个独立的存储块。 在团队中访问此变量的所有线程都访问存储此单个块。

- 结构化的块

  结构化的块是具有单个条目和单个出口的语句 （单个或复合）。 如果跳转入或移出一条语句，该语句是结构化的块。 (此规则包括调用`longjmp`(3 C) 或使用`throw`，尽管调用`exit`允许。)如果始终执行开始左括号`{`，始终结尾处结束`}`，复合语句是结构化的块。 表达式语句、 选择语句、 迭代语句或`try`块是结构化的块，如果通过将其封闭在获得相应的复合语句`{`和`}`是结构化的块。 跳转语句、 标记的语句或声明语句不是结构化的块。

- 团队

  执行过程中的一种构造都联合的一个或多个线程。

- thread

  执行实体具有一串行的控制流、 一组专用变量和对共享变量的访问。

- 变量

  根据需要由命名空间名称限定的标识符的命名对象。

## <a name="13-execution-model"></a>1.3 执行模型

OpenMP 利用并行执行的派生-联结模式。 尽管此 fork-join 模型可用于解决各种问题，但它为基于数组的大型应用程序量身定制。 OpenMP 旨在支持正确执行二者均为并行程序 （多个线程的执行和完整 OpenMP 支持库） 的程序。 它也是程序的执行 （忽略指令和简单的 OpenMP 存根库） 的正确顺序程序。 但是，它可能并允许开发的行为与不正确时按顺序执行的程序。 此外，不同程度的并行度可能会导致不同的数值结果由于中的数值操作关联的更改。 例如，串行添加减少可能有不同的模式的并行缩减比添加关联。 这些不同的关联可能会更改浮点加法的结果。

使用 OpenMP C/c + + API 编写的程序开始执行名为作为单个线程执行*主线程*。 在遇到第一个并行构造之前，主线程执行串行区域中。 在 OpenMP C/c + + API 中，`parallel`指令构成并行构造。 当遇到并行构造时，主线程创建的线程，团队和主机成为主团队。 团队中的每个线程并行区域，除了工作共享构造的动态范围中执行的语句。 团队中的所有线程必须都遇到的相同顺序的工作共享构造和一个或多个线程执行的语句相关联的结构化块中。 关卡末尾而无需的工作共享构造的隐式`nowait`子句执行由团队中的所有线程。

如果一个线程修改共享的对象，它会在其自己的执行环境，不仅在程序中的其他线程的影响。 修改保证可完成，另一个线程，在下一步的序列点的角度 （如定义的基本语言），仅当对象被声明为易失性。 否则，要完成后第一次修改线程，保证进行修改。 请参阅其他线程然后 （或并发） `flush` （隐式或显式） 指定的对象的指令。 当`flush`隐含其他 OpenMP 指令的指令不能保证正确顺序的负面影响，它是程序员的责任，以提供附加的显式`flush`指令。

完成后的并行构造，团队中的线程同步在隐式的障碍，并仅在主线程继续执行。 可以在单一程序指定任意数量的并行构造。 因此，程序可能会创建分支并加入期间执行的很多时间。

OpenMP C/c + + API 使程序员可以使用并行构造中从调用的函数中的指令。 指令不会显示在并行构造的词法范围，但可能处于的动态范围内被称为*孤立*指令。 与孤立指令，程序员可以根据程序的主要部分并行执行，进行到顺序的程序只有少量的更改。 使用此功能，可以在程序调用关系树的顶部级别的并行构造的代码并使用指令来控制在任何调用的函数中执行。

未同步的调用 C 和 c + + 输出写入到同一文件的函数可能会导致的输出在其中写入由不同的线程的数据显示在具有不确定性的顺序。 同样，输入从同一个文件中读取的函数的未同步的调用可能会读取具有不确定性的顺序中的数据。 未同步的使用的 I/O，以便每个线程访问不同的文件，将生成与 I/O 函数的串行执行相同的结果。

## <a name="14-compliance"></a>1.4 遵从性

OpenMP C/c + + API 的实现*OpenMP 符合*如果它可以识别并为分布在各章 1，2，3，4，保留此规范的所有元素的语义和附录 C.附录 A、 B、 D、 E 和 F 适用于信息仅目的并不规范的一部分。 包含 API 的一个子集的实现并不符合 OpenMP。

OpenMP C 和 c + + API 是支持的实现的基本语言的扩展。 如果基础语言不支持的语言构造或显示的扩展，本文档中，OpenMP 实现不需要支持它。

所有标准的 C 和 c + + 库函数和内置函数 （即，编译器具有特定的知识的函数） 必须是线程安全的。 未同步的使用并行区域内的不同线程的线程安全函数不会产生未定义的行为。 但是，行为可能不是与串行区域中的相同。 （随机数字生成函数是一个示例。）

OpenMP C/c + + API 指定特定的行为是*实现定义。* 需要定义并记录在这些情况下其行为符合标准的 OpenMP 实现。 实现定义的行为的列表，请参阅[附录 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)。

## <a name="15-normative-references"></a>1.5 规范引用

- ISO/IEC 9899:1999*信息技术-编程语言-C*。此 OpenMP API 规范将 ISO/IEC 9899:1999 称为 C99。

- ISO/IEC 9899:1990*信息技术-编程语言-C*。此 OpenMP API 规范将 ISO/IEC 9899:1990 称为 C90。

- ISO/IEC 14882:1998*信息技术-编程语言-c + +*。 ISO/IEC 14882:1998 作为 c + + 引用此 OpenMP API 规范。

在此 OpenMP API 规范是指 C，引用是对实现支持的基本语言。

## <a name="16-organization"></a>1.6 组织

- [运行时库函数](3-run-time-library-functions.md)
- [环境变量](4-environment-variables.md)
- [实现定义的行为在 OpenMP C/c + +](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C/c + + 2.0 版中的新增功能](f-new-features-and-clarifications-in-version-2-0.md)
