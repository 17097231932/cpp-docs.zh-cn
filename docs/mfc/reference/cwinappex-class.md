---
title: CWinAppEx 类
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: c222567703d0e57480c00f6f2bf9e78f16979150
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/04/2019
ms.locfileid: "57288826"
---
# <a name="cwinappex-class"></a>CWinAppEx 类

`CWinAppEx` 处理应用程序状态、 将状态保存到注册表、 从注册表加载状态，初始化应用程序管理器和提供那些相同的应用程序管理器的链接。

   有关更多详细信息，请参阅中的源代码**VC\\atlmfc\\src\\mfc**的 Visual Studio 安装文件夹。
## <a name="syntax"></a>语法

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|[CWinAppEx::CWinAppEx](#cwinappex)|构造 `CWinAppEx` 对象。|

### <a name="public-methods"></a>公共方法

|名称|描述|
|----------|-----------------|
|[CWinAppEx::CleanState](#cleanstate)|从 Windows 注册表中删除应用程序的信息。|
|[CWinAppEx::EnableLoadWindowPlacement](#enableloadwindowplacement)|指定是否在应用程序将加载的初始大小和位置的主框架窗口从注册表。|
|[CWinAppEx::EnableTearOffMenus](#enabletearoffmenus)|启用拖曳菜单应用程序。|
|[CWinAppEx::EnableUserTools](#enableusertools)|使用户能够在应用程序中创建自定义菜单命令。|
|[CWinAppEx::ExitInstance](#exitinstance)|由框架调用内`Run`成员函数以退出应用程序的此实例。 (重写[CWinApp::ExitInstance](../../mfc/reference/cwinapp-class.md#exitinstance)。)|
|[CWinAppEx::GetBinary](#getbinary)|读取与指定的注册表值相关联的二进制数据。|
|[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)|返回一个指向全局[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)对象。|
|[CWinAppEx::GetDataVersion](#getdataversion)||
|[CWinAppEx::GetDataVersionMajor](#getdataversionmajor)|返回保存在 Windows 注册表中的应用程序的主版本。|
|[CWinAppEx::GetDataVersionMinor](#getdataversionminor)|返回保存在 Windows 注册表中的应用程序的次版本。|
|[CWinAppEx::GetInt](#getint)|读取注册表中指定的值与关联的数值数据。|
|[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)|返回一个指向全局[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)对象。|
|[CWinAppEx::GetMouseManager](#getmousemanager)|返回一个指向全局[CMouseManager](../../mfc/reference/cmousemanager-class.md)对象。|
|[CWinAppEx::GetObject](#getobject)|读取`CObject`-派生与注册表中的指定值相关联的数据。|
|[CWinAppEx::GetRegSectionPath](#getregsectionpath)|返回一个字符串，它的注册表项的路径。 此路径将连接的应用程序路径提供的相对路径。|
|[CWinAppEx::GetRegistryBase](#getregistrybase)|返回应用程序的注册表路径。|
|[CWinAppEx::GetSectionBinary](#getsectionbinary)|读取与指定的键和注册表中的值相关联的二进制数据。|
|[CWinAppEx::GetSectionInt](#getsectionint)|从与指定的键和值关联的注册表中读取的数值数据。|
|[CWinAppEx::GetSectionObject](#getsectionobject)|读取`CObject`与指定的键和注册表中的值相关联的数据。|
|[CWinAppEx::GetSectionString](#getsectionstring)|读取与指定的键和注册表中的值相关联的字符串数据。|
|[CWinAppEx::GetShellManager](#getshellmanager)|返回一个指向全局[CShellManager](../../mfc/reference/cshellmanager-class.md)对象。|
|[CWinAppEx::GetString](#getstring)|读取注册表中指定的值与相关联的字符串数据。|
|[CWinAppEx::GetTooltipManager](#gettooltipmanager)|返回一个指向全局[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)对象。|
|[CWinAppEx::GetUserToolsManager](#getusertoolsmanager)|返回一个指向全局[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)对象。|
|[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)|初始化 `CContextMenuManager` 对象。|
|[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)|初始化 `CKeyboardManager` 对象。|
|[CWinAppEx::InitMouseManager](#initmousemanager)|初始化 `CMouseManager` 对象。|
|[CWinAppEx::InitShellManager](#initshellmanager)|初始化`CShellManager`类|
|[CWinAppEx::InitTooltipManager](#inittooltipmanager)|初始化`CTooltipManager`类。|
|[CWinAppEx::IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx::IsStateExists](#isstateexists)|指示指定的键是否是在注册表中。|
|[CWinAppEx::LoadState](#loadstate)|从注册表加载应用程序状态。|
|[CWinAppEx::OnAppContextHelp](#onappcontexthelp)|由框架调用，当用户请求的上下文帮助**自定义**对话框。|
|[CWinAppEx::OnViewDoubleClick](#onviewdoubleclick)|当用户双击应用程序中的任意位置时，请调用用户定义的命令。|
|[CWinAppEx::OnWorkspaceIdle](#onworkspaceidle)||
|[CWinAppEx::SaveState](#savestate)|应用程序框架的状态写入 Windows 注册表。|
|[CWinAppEx::SetRegistryBase](#setregistrybase)|设置默认注册表项的路径。 此密钥将充当所有后续注册表调用的根。|
|[CWinAppEx::ShowPopupMenu](#showpopupmenu)|显示弹出菜单。|
|[CWinAppEx::WriteBinary](#writebinary)|将二进制数据写入到指定的注册表值。|
|[CWinAppEx::WriteInt](#writeint)|将数字数据写入到指定的注册表值。|
|[CWinAppEx::WriteObject](#writeobject)|写入数据派生自[CObject 类](../../mfc/reference/cobject-class.md)为指定的注册表值。|
|[CWinAppEx::WriteSectionBinary](#writesectionbinary)|将二进制数据写入到指定的注册表项的值。|
|[CWinAppEx::WriteSectionInt](#writesectionint)|将数字数据写入到指定的注册表项的值。|
|[CWinAppEx::WriteSectionObject](#writesectionobject)|写入数据派生自`CObject`类传递给一个值，指定的注册表项。|
|[CWinAppEx::WriteSectionString](#writesectionstring)|将字符串数据写入到指定的注册表项的值。|
|[CWinAppEx::WriteString](#writestring)|将字符串数据写入到指定的注册表值。|

### <a name="protected-methods"></a>受保护的方法

|名称|描述|
|----------|-----------------|
|[CWinAppEx::LoadCustomState](#loadcustomstate)|当加载应用程序状态，由框架调用。|
|[CWinAppEx::LoadWindowPlacement](#loadwindowplacement)|从注册表加载的大小和位置的应用程序时由框架调用。 加载的数据包含你的应用程序在上次关闭的时的大小和位置的主框架。|
|[CWinAppEx::OnClosingMainFrame](#onclosingmainframe)|当主框架窗口正在处理 WM_CLOSE 时由框架调用。|
|[CWinAppEx::PreLoadState](#preloadstate)|之前由框架调用加载应用程序状态。|
|[CWinAppEx::PreSaveState](#presavestate)|之前由框架调用保存应用程序状态。|
|[CWinAppEx::ReloadWindowPlacement](#reloadwindowplacement)|重新加载的大小和位置的注册表中提供的窗口|
|[CWinAppEx::SaveCustomState](#savecustomstate)|它将应用程序状态写入到注册表后，由框架调用。|
|[CWinAppEx::StoreWindowPlacement](#storewindowplacement)|由框架调用以写入注册表的大小和位置的主框架。|

### <a name="data-members"></a>数据成员

|name|描述|
|----------|-----------------|
|[CWinAppEx::m_bForceImageReset](#m_bforceimagereset)|指定是否在 framework 将重置所有工具栏图像加载包含工具栏的框架窗口时。|

## <a name="remarks"></a>备注

很多 MFC 框架提供的功能依赖于`CWinAppEx`类。 您可以将合并`CWinAppEx`类到你的应用程序中通过两种方式之一：

- 构造`CWinAppEx`主线程中的类。

- 派生从主应用程序类`CWinAppEx`。

您将合并后`CWinAppEx`到应用程序，您可以初始化应用程序管理器的任何一个。 在使用应用程序管理器之前，必须通过调用适当的 initialize 方法对其进行初始化。 若要获取特定的管理器的指针，调用相关联的 get 方法。 `CWinAppEx`类管理以下应用程序管理器：[CMouseManager 类](../../mfc/reference/cmousemanager-class.md)， [CContextMenuManager 类](../../mfc/reference/ccontextmenumanager-class.md)， [CKeyboardManager 类](../../mfc/reference/ckeyboardmanager-class.md)， [CUserToolsManager 类](../../mfc/reference/cusertoolsmanager-class.md)，和[CMenuTearOffManager 类](../../mfc/reference/cmenutearoffmanager-class.md)。

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[CWinApp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>要求

**标头：** afxwinappex.h

##  <a name="cleanstate"></a>  CWinAppEx::CleanState

从 Windows 注册表中删除有关应用程序的所有信息。

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>参数

*lpszSectionName*<br/>
[in]一个字符串，包含注册表项的路径。

### <a name="return-value"></a>返回值

如果此方法已成功，则非零值否则为 0。

### <a name="remarks"></a>备注

此方法会清除注册表的特定节中的应用程序数据。 可以指定要使用参数来清除的部分*lpszSectionName*。 如果*lpszSectionName*为 NULL，此方法将使用默认注册表路径存储在`CWinAppEx`对象。 若要获取默认注册表路径，请使用[CWinAppEx::GetRegistryBase](#getregistrybase)。

##  <a name="cwinappex"></a>  CWinAppEx::CWinAppEx

构造 `CWinAppEx` 对象。

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>参数

*bResourceSmartUpdate*<br/>
[in]一个布尔参数，指定工作区对象是否应检测和处理资源更新。

### <a name="remarks"></a>备注

`CWinAppEx`类具有初始化的方法，提供的保存和加载到注册表中，应用程序信息的功能并控制全局应用程序设置。 它还可以使用如下所示全局管理员[CKeyboardManager 类](../../mfc/reference/ckeyboardmanager-class.md)并[CUserToolsManager 类](../../mfc/reference/cusertoolsmanager-class.md)。 每个应用程序可以只有一个实例`CWinAppEx`类。

##  <a name="enableloadwindowplacement"></a>  CWinAppEx::EnableLoadWindowPlacement

指定是否在应用程序将加载的初始大小和位置的主框架窗口从注册表。

```
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*bEnable*<br/>
[in]指定应用程序从注册表中是否加载的初始大小和位置的主框架窗口。

### <a name="remarks"></a>备注

默认情况下的大小和位置的主框架是从注册表中加载以及其他应用程序设置。 期间将发生这种情况[CWinAppEx::LoadState](#loadstate)。 如果您不想要从注册表加载初始窗口位置，调用此方法替换*bEnable*设置为 FALSE。

##  <a name="enabletearoffmenus"></a>  CWinAppEx::EnableTearOffMenus

创建并初始化[CMenuTearOffManager](../../mfc/reference/cmenutearoffmanager-class.md)对象。

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>参数

*lpszRegEntry*<br/>
[in]一个字符串，包含注册表项的路径。 应用程序使用此注册表项来存储拖曳菜单的信息。

*uiCmdFirst*<br/>
[in]第一个菜单拆解 id。

*uiCmdLast*<br/>
[in]最后一个菜单拆解 id。

### <a name="return-value"></a>返回值

如果`CMenuTearOffManager`进行创建和初始化成功，则FALSE 如果发生错误或如果`CMenuTearOffManager`已存在。

### <a name="remarks"></a>备注

使用此函数以启用应用程序中的分离式菜单。 应调用该函数从`InitInstance`。

##  <a name="enableusertools"></a>  CWinAppEx::EnableUserTools

使用户能够创建自定义菜单命令，从而减少应用程序中的击键。 此方法创建[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)对象。

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>参数

*uiCmdToolsDummy*<br/>
[in]无符号的整数，该框架作为占位符用于用户工具菜单的命令 ID。

*uiCmdFirst*<br/>
[in]第一个用户工具命令的命令 ID。

*uiCmdLast*<br/>
[in]最后一个用户工具命令的命令 ID。

*pToolRTC*<br/>
[in]一个类，该类`CUserToolsManager`对象用于创建新的用户工具。

*uArgMenuID*<br/>
[in]参数菜单 id。

*uInitDirMenuID*<br/>
[in]初始工具目录菜单 ID。

### <a name="return-value"></a>返回值

如果此方法创建并初始化为`CUserToolsManager`对象;FALSE 如果方法失败或如果`CUserToolsManager`对象已存在。

### <a name="remarks"></a>备注

启用用户定义的工具时，框架自动支持动态菜单，可以自定义期间进行扩展。 该框架将每个新项与外部命令相关联。 当用户选择从合适的项目时，框架将调用这些命令**工具**菜单。

每次用户添加新项时，框架将创建一个新的对象。 通过定义新对象的类类型*pToolRTC*。 *PToolRTC*类类型必须派生自[CUserTool 类](../../mfc/reference/cusertool-class.md)。

有关用户工具以及如何将其合并到你的应用程序的详细信息，请参阅[用户定义的工具](../../mfc/user-defined-tools.md)。

##  <a name="exitinstance"></a>  CWinAppEx::ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

##  <a name="getbinary"></a>  CWinAppEx::GetBinary

从指定的注册表项读取二进制数据。

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含的注册表项名称的字符串。

*ppData*<br/>
[out]指向该方法填充的二进制数据的缓冲区的指针。

*pBytes*<br/>
[out]指向一个无符号整数，该方法用来编写读取的字节数的指针。

### <a name="return-value"></a>返回值

如果成功，则为 TRUEFALSE 否则为。

### <a name="remarks"></a>备注

此方法读取二进制数据写到注册表。 将数据写入到注册表，使用方法[CWinAppEx::WriteBinary](#writebinary)并[CWinAppEx::WriteSectionBinary](#writesectionbinary)。

*LpszEntry*参数是位于你的应用程序默认注册表项下的注册表项的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getcontextmenumanager"></a>  CWinAppEx::GetContextMenuManager

返回一个指向全局[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)对象。

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>返回值

指向全局`CContextMenuManager`对象。

### <a name="remarks"></a>备注

如果未初始化 CContextMenuManager 对象，此函数将调用[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)之前它将返回一个指针。

##  <a name="getdataversion"></a>  CWinAppEx::GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

##  <a name="getdataversionmajor"></a>  CWinAppEx::GetDataVersionMajor

返回在调用时在 Windows 注册表中保存的应用程序的主版本[CWinAppEx::SaveState](#savestate)。

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>返回值

一个包含主版本号的整数值。

##  <a name="getdataversionminor"></a>  CWinAppEx::GetDataVersionMinor

返回在调用时在 Windows 注册表中保存的应用程序的次版本[CWinAppEx::SaveState](#savestate)。

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>返回值

一个包含的次版本号的整数值。

##  <a name="getint"></a>  CWinAppEx::GetInt

从指定的注册表项读取整数数据。

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]一个字符串，包含注册表项的名称。

*nDefault*<br/>
[in]该方法将返回指定的注册表条目不存在默认值。

### <a name="return-value"></a>返回值

如果此方法已成功，则注册表数据否则为*n 默认*。

### <a name="remarks"></a>备注

此方法从注册表中读取的整数数据。 如果没有整数数据与所指示的注册表项相关联*lpszEntry*，此方法返回*n 默认*。 将数据写入到注册表，使用方法[CWinAppEx::WriteSectionInt](#writesectionint)并[CWinAppEx::WriteInt](#writeint)。

*LpszEntry*参数是位于你的应用程序默认注册表项下的注册表项的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getkeyboardmanager"></a>  CWinAppEx::GetKeyboardManager

返回一个指向全局[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)对象。

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>返回值

指向全局`CKeyboardManager`对象。

### <a name="remarks"></a>备注

如果未初始化键盘管理器，此函数将调用[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)之前它将返回一个指针。

##  <a name="getmousemanager"></a>  CWinAppEx::GetMouseManager

返回一个指向全局[CMouseManager](../../mfc/reference/cmousemanager-class.md)对象。

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>返回值

指向全局`CMouseManager`对象。

### <a name="remarks"></a>备注

如果未初始化鼠标管理器、 此函数将调用[CWinAppEx::InitMouseManager](#initmousemanager)之前它将返回一个指针。

##  <a name="getobject"></a>  CWinAppEx::GetObject

读取[CObject](../../mfc/reference/cobject-class.md)注册表中的派生数据。

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]一个字符串，包含注册表项的相对路径。

*obj*<br/>
[out]对引用`CObject`。 该方法使用此引用来存储的注册表数据。

### <a name="return-value"></a>返回值

如果此方法已成功，则非零值否则为 0。

### <a name="remarks"></a>备注

此方法从派生自的注册表中读取数据`CObject`。 若要编写`CObject`数据到注册表中，使用两种[CWinAppEx::WriteObject](#writeobject)或[CWinAppEx::WriteSectionObject](#writesectionobject)。

*LpszEntry*参数是您的应用程序的默认注册表项下的注册表条目的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getregistrybase"></a>  CWinAppEx::GetRegistryBase

检索应用程序的默认注册表路径。

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>返回值

一个字符串，包含默认注册表位置的路径。

### <a name="remarks"></a>备注

所有方法[CWinAppEx 类](../../mfc/reference/cwinappex-class.md)访问注册表启动在默认位置。 使用此方法来检索默认注册表位置的路径。 使用[CWinAppEx::SetRegistryBase](#setregistrybase)若要更改默认注册表位置。

##  <a name="getregsectionpath"></a>  CWinAppEx::GetRegSectionPath

创建并返回注册表项的绝对路径。

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>参数

*szSectionAdd*<br/>
[in]一个字符串，包含注册表项的相对路径。

### <a name="return-value"></a>返回值

一个`CString`，其中包含的注册表项的绝对路径。

### <a name="remarks"></a>备注

此方法通过追加的相对路径中定义的注册表项的绝对路径*szSectionAdd*到你的应用程序的默认注册表位置。 若要获取默认注册表项，请使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)。

##  <a name="getsectionbinary"></a>  CWinAppEx::GetSectionBinary

从注册表中读取二进制数据。

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]一个字符串，包含注册表项的相对路径。

*lpszEntry*<br/>
[in]包含要读取的值的字符串。

*ppData*<br/>
[out]指向该方法在其中存储数据的缓冲区的指针。

*pBytes*<br/>
[out]指向一个无符号整数的指针。 该方法将写入的大小*ppData*给此参数。

### <a name="return-value"></a>返回值

若成功，则为 TRUE；否则为 FALSE。

### <a name="remarks"></a>备注

此方法将写到注册表使用方法的二进制数据读入[CWinAppEx::WriteBinary](#writebinary)并[CWinAppEx::WriteSectionBinary](#writesectionbinary)。

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getsectionint"></a>  CWinAppEx::GetSectionInt

从注册表中读取的整数数据。

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]一个字符串，包含注册表项的相对路径。

*lpszEntry*<br/>
[in]包含要读取的值的字符串。

*nDefault*<br/>
[in]要返回指定的值不存在的默认值。

### <a name="return-value"></a>返回值

存储在指定的注册表值中; 整数数据*n 默认*如果数据不存在。

### <a name="remarks"></a>备注

使用的方法[CWinAppEx::WriteInt](#writeint)并[CWinAppEx::WriteSectionInt](#writesectionint)将整数数据写入到注册表。

*LpszSubSection*参数不是注册表项的绝对路径。 它是被添加到你的应用程序的默认注册表项的结尾相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getsectionobject"></a>  CWinAppEx::GetSectionObject

读取[CObject](../../mfc/reference/cobject-class.md)从注册表的注册表数据。

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]一个字符串，包含注册表项的相对路径。

*lpszEntry*<br/>
[in]包含要读取的值的字符串。

*obj*<br/>
[out]对引用`CObject`。 方法使用此`CObject`存储注册表数据。

### <a name="return-value"></a>返回值

如果成功，则不为 0；否则为 0。

### <a name="remarks"></a>备注

此方法从注册表中读取数据。 数据读取`CObject`数据或从派生的类的数据`CObject`。 若要编写`CObject`数据到注册表中，使用两种[CWinAppEx::WriteObject](#writeobject)或[CWinAppEx::WriteSectionObject](#writesectionobject)。

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getsectionstring"></a>  CWinAppEx::GetSectionString

读取字符串注册表中的数据。

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]一个字符串，包含注册表项的相对路径。

*lpszEntry*<br/>
[in]包含要读取的值的字符串。

*lpszDefault*<br/>
[in]要返回指定的值不存在的默认值。

### <a name="return-value"></a>返回值

如果数据存在，则存储在指定的注册表值中的字符串数据否则为*lpszDefault*。

### <a name="remarks"></a>备注

该方法将字符串数据写到注册表。 使用[CWinAppEx::WriteString](#writestring)并[CWinAppEx::WriteSectionString](#writesectionstring)将字符串数据写入到注册表。

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="getshellmanager"></a>  CWinAppEx::GetShellManager

返回一个指向全局[CShellManager](../../mfc/reference/cshellmanager-class.md)对象。

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>返回值

指向全局`CShellManager`对象。

### <a name="remarks"></a>备注

如果`CShellManager`对象未初始化，此函数将调用[CWinAppEx::InitShellManager](#initshellmanager)之前它将返回一个指针。

##  <a name="getstring"></a>  CWinAppEx::GetString

读取的字符串中指定的注册表项的数据。

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含的注册表项名称的字符串

*lpzDefault*<br/>
[in]该方法将返回指定的注册表条目不存在默认值。

### <a name="return-value"></a>返回值

如果成功，则在注册表中存储的字符串数据*lpszDefault*否则为。

### <a name="remarks"></a>备注

该方法将字符串数据写到注册表。 将数据写入到注册表，使用方法[CWinAppEx::WriteString](#writestring)或[CWinAppEx::WriteSectionString](#writesectionstring)。

*LpszEntry*参数是位于你的应用程序默认注册表项下的注册表项的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="gettooltipmanager"></a>  CWinAppEx::GetTooltipManager

返回一个指向全局[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)对象。

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>返回值

指向全局`CTooltipManager`对象。

### <a name="remarks"></a>备注

如果`CTooltipManager`对象未初始化，此函数将调用[cwinappex:: Inittooltipmanager](#inittooltipmanager)之前它将返回一个指针。

##  <a name="getusertoolsmanager"></a>  CWinAppEx::GetUserToolsManager

返回一个指向全局[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)对象。

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>返回值

指向全局`CUserToolsManager`对象;如果用户工具管理，则为 NULL 的应用程序未启用。

### <a name="remarks"></a>备注

检索指向的指针之前`CUserToolsManager`对象，必须通过调用初始化管理器[CWinAppEx::EnableUserTools](#enableusertools)。

##  <a name="initcontextmenumanager"></a>  CWinAppEx::InitContextMenuManager

初始化[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)对象。

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>返回值

该方法将创建 CContextMenuManager 对象; 如果非零值0`CContextMenuManager`对象已存在。

### <a name="remarks"></a>备注

如果您调用[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)，该方法的默认实现调用`InitContextMenuManager`。

如果应用程序已具有上下文菜单管理器，并且您调用`InitContextMenuManager`，你的应用程序将具有[ASSERT](diagnostic-services.md#assert)失败。 因此，不应调用`InitContextMenuManager`如果您创建`CContextMenuManager`直接对象。 如果不使用自定义`CContextMenuManager`，则应使用`GetContextMenuManager`若要创建`CContextMenuManager`对象。

##  <a name="initkeyboardmanager"></a>  CWinAppEx::InitKeyboardManager

初始化[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)对象。

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>返回值

如果该方法将创建非零`CKeyboardManager`对象; 0`CKeyboardManager`对象已存在。

### <a name="remarks"></a>备注

如果您调用[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)，该方法的默认实现调用`InitKeyboardManager`。

如果应用程序已具有一个键盘管理器，并且您调用`InitKeyboardManager`，你的应用程序将具有[ASSERT](diagnostic-services.md#assert)失败。 因此，不应调用`InitKeyboardManager`如果您创建`CKeyboardManager`直接对象。 如果不使用自定义`CKeyboardManager`，则应使用`GetKeyboardManager`若要创建`CKeyboardManager`对象。

##  <a name="initmousemanager"></a>  CWinAppEx::InitMouseManager

初始化[CMouseManager](../../mfc/reference/cmousemanager-class.md)对象。

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>返回值

如果该方法将创建非零`CMouseManager`对象; 0`CMouseManager`对象已存在。

### <a name="remarks"></a>备注

如果您调用[CWinAppEx::GetMouseManager](#getmousemanager)，该方法的默认实现调用`InitMouseManager`。

如果应用程序已具有鼠标管理器，并且您调用`InitMouseManager`，你的应用程序将具有[ASSERT](diagnostic-services.md#assert)失败。 因此不应调用`InitMouseManager`如果您创建`CMouseManager`直接对象。 如果不使用自定义`CMouseManager`，则应使用`GetMouseManager`若要创建`CMouseManager`对象。

##  <a name="initshellmanager"></a>  CWinAppEx::InitShellManager

初始化[CShellManager](../../mfc/reference/cshellmanager-class.md)对象。

```
BOOL InitShellManager();
```

### <a name="return-value"></a>返回值

如果该方法将创建非零`CShellManager`对象; 0`CShellManager`对象已存在。

### <a name="remarks"></a>备注

如果您调用[CWinAppEx::GetShellManager](#getshellmanager)，该方法的默认实现调用`InitShellManager`。

如果应用程序已具有 shell 管理器，并且您调用`InitShellManager`，在应用程序将引发[ASSERT](diagnostic-services.md#assert)失败。 因此，不要调用`InitShellManager`如果您创建`CShellManager`直接对象。 如果不使用自定义`CShellManager`，使用`GetShellManager`若要创建`CShellManager`对象。

##  <a name="inittooltipmanager"></a>  CWinAppEx::InitTooltipManager

初始化[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)对象。

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>返回值

如果该方法将创建非零`CTooltipManager`对象; 0`CTooltipManager`对象已存在。

### <a name="remarks"></a>备注

如果您调用[CWinAppEx::GetTooltipManager](#gettooltipmanager)，该方法的默认实现调用`InitTooltipManager`。

如果应用程序已具有工具提示管理器并调用`InitTooltipManager`，你的应用程序将具有[ASSERT](diagnostic-services.md#assert)失败。 因此，不应调用`InitTooltipManager`如果您创建`CTooltipManager`直接对象。 如果不使用自定义`CTooltipManager`，则应使用`GetTooltipManager`若要创建`CTooltipManager`对象。

##  <a name="isresourcesmartupdate"></a>  CWinAppEx::IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

##  <a name="isstateexists"></a>  CWinAppEx::IsStateExists

指示指定的键是否是在注册表中。

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>参数

*lpszSectionName*<br/>
[in]一个字符串，包含注册表项的路径。

### <a name="return-value"></a>返回值

如果密钥是在注册表中; 非零值否则为 0。

##  <a name="loadcustomstate"></a>  CWinAppEx::LoadCustomState

它从注册表加载应用程序的状态后，框架将调用此方法。

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>备注

如果你想要执行的任何处理，应用程序从注册表加载的状态后，重写此方法。 默认情况下，此方法没有任何影响。

若要从注册表加载自定义状态信息，必须首先保存信息通过使用[CWinAppEx::SaveCustomState](#savecustomstate)。

##  <a name="loadstate"></a>  CWinAppEx::LoadState

从 Windows 注册表中读取应用程序状态。

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>参数

*pFrame*<br/>
[in]指向框架窗口对象的指针。 该方法适用于此框架窗口在注册表中的状态信息。

*lpszSectionName*<br/>
[in]一个字符串，包含注册表项的相对路径。

*pFrameImpl*<br/>
[in]一个指向`CFrameImpl`对象。 该方法适用于此框架窗口在注册表中的状态信息。

### <a name="return-value"></a>返回值

如果成功，则非零值否则为 0。

### <a name="remarks"></a>备注

此方法加载应用程序和框架窗口的任何状态信息的状态。 框架窗口的加载的信息应用于提供的框架窗口。 如果未提供框架窗口，将加载应用程序状态信息。 应用程序信息包括的状态[CMouseManager 类](../../mfc/reference/cmousemanager-class.md)， [CContextMenuManager 类](../../mfc/reference/ccontextmenumanager-class.md)， [CKeyboardManager 类](../../mfc/reference/ckeyboardmanager-class.md)，和[CUserToolsManager 类](../../mfc/reference/cusertoolsmanager-class.md)。

默认实现`CFrameImpl::OnLoadFrame`调用`LoadState`。

*LpszSectionName*参数不是注册表项的绝对路径。 它是被添加到你的应用程序的默认注册表项的结尾相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="loadwindowplacement"></a>  CWinAppEx::LoadWindowPlacement

从注册表加载的大小和位置的主框架窗口时由框架调用。

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>参数

*rectNormalPosition*<br/>
[out]在还原位置中时包含的坐标的主框架窗口的矩形。

*nFlags*<br/>
[out]控制最小化的窗口和操作系统切换最小化的窗口和还原的窗口的位置的标志。

*nShowCmd*<br/>
[out]一个整数，指定窗口的显示状态。 有关可能的值的详细信息，请参阅[CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)。

### <a name="return-value"></a>返回值

如果成功，则非零值否则为 0。

### <a name="remarks"></a>备注

默认情况下，MFC 会自动加载以前的位置和主框架窗口的状态时在应用程序启动。 有关如何将此信息存储在注册表中的详细信息，请参阅[CWinAppEx::StoreWindowPlacement](#storewindowplacement)。

如果你想要加载有关主框架窗口的其他信息，请重写此方法。

##  <a name="m_bforceimagereset"></a>  CWinAppEx::m_bForceImageReset

指定是否在 framework 重置所有工具栏图像时重新加载包含工具栏的框架窗口。

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>备注

`m_bForceImageReset`数据成员是受保护的变量。

##  <a name="onappcontexthelp"></a>  CWinAppEx::OnAppContextHelp

框架调用此方法，当用户请求的上下文帮助**自定义**对话框。

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>参数

*pWndControl*<br/>
[in]指向用户对其调用上下文的帮助窗口对象的指针。

*dwHelpIDArray[]*<br/>
[in]保留的值。

### <a name="remarks"></a>备注

此方法当前保留供将来使用。 默认实现不执行任何操作，它当前不由框架调用。

##  <a name="onclosingmainframe"></a>  CWinAppEx::OnClosingMainFrame

框架窗口正在处理 WM_CLOSE 时，框架将调用此方法。

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>参数

*pFrameImpl*<br/>
[in]一个指向`CFrameImpl`对象。

### <a name="remarks"></a>备注

此方法的默认实现将保存的状态*pFrameImpl*。

##  <a name="onviewdoubleclick"></a>  CWinAppEx::OnViewDoubleClick

调用是与视图相关联，当用户双击该视图中的任意位置的用户定义的命令。

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>参数

*pWnd*<br/>
[in]指向对象派生自[CView 类](../../mfc/reference/cview-class.md)。

*iViewId*<br/>
[in]视图 id。

### <a name="return-value"></a>返回值

如果框架将查找命令; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

为了支持自定义鼠标行为，您必须处理需知道 WM_LBUTTONDBLCLK 消息时调用此函数。 此方法将执行与由提供的视图 ID 关联的命令*iViewId*。 有关自定义鼠标行为的详细信息，请参阅[键盘和鼠标自定义](../../mfc/keyboard-and-mouse-customization.md)。

##  <a name="onworkspaceidle"></a>  CWinAppEx::OnWorkspaceIdle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>参数

[in] *CWnd&#38;*<br/>

### <a name="return-value"></a>返回值

### <a name="remarks"></a>备注

##  <a name="preloadstate"></a>  CWinAppEx::PreLoadState

它从注册表加载应用程序状态之前，框架将调用此方法。

```
virtual void PreLoadState();
```

### <a name="remarks"></a>备注

如果你想要执行的任何处理，框架将加载应用程序状态之前，重写此方法。

##  <a name="presavestate"></a>  CWinAppEx::PreSaveState

它将保存应用程序状态之前，框架将调用此方法。

```
virtual void PreSaveState();
```

### <a name="remarks"></a>备注

如果你想要执行的任何处理，框架将保存应用程序状态之前，重写此方法。

##  <a name="reloadwindowplacement"></a>  CWinAppEx::ReloadWindowPlacement

重新加载的大小和位置的注册表中的窗口。

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>参数

*pFrame*<br/>
[in]指向框架窗口的指针。

### <a name="return-value"></a>返回值

如果此方法已成功，则非零值如果负载失败，或者没有要加载的数据为 0。

### <a name="remarks"></a>备注

使用函数[CWinAppEx::StoreWindowPlacement](#storewindowplacement)写入注册表的大小和窗口的位置。

##  <a name="savecustomstate"></a>  CWinAppEx::SaveCustomState

它将保存到注册表的应用程序的状态后，框架将调用此方法。

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>备注

如果你想要执行的任何处理，应用程序将状态保存到注册表后，重写此方法。 默认情况下，此方法没有任何影响。

##  <a name="savestate"></a>  CWinAppEx::SaveState

应用程序状态写入 Windows 注册表。

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>参数

*lpszSectionName*<br/>
[in]一个字符串，包含注册表项的相对路径。

*pFrameImpl*<br/>
[in]一个指向`CFrameImpl`对象。 此帧保存到 Windows 注册表。

*pFrame*<br/>
[in]指向框架窗口对象的指针。 此帧保存到 Windows 注册表。

### <a name="return-value"></a>返回值

如果成功，则为 TRUEFALSE 否则为。

### <a name="remarks"></a>备注

此方法将保存应用程序和提供的框架窗口的任何状态信息的状态。 如果未提供框架窗口，该方法将仅保存应用程序状态。 应用程序信息包括的状态[CMouseManager 类](../../mfc/reference/cmousemanager-class.md)， [CContextMenuManager 类](../../mfc/reference/ccontextmenumanager-class.md)， [CKeyboardManager 类](../../mfc/reference/ckeyboardmanager-class.md)，和[CUserToolsManager 类](../../mfc/reference/cusertoolsmanager-class.md)。

*LpszSectionName*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

##  <a name="setregistrybase"></a>  CWinAppEx::SetRegistryBase

设置应用程序的默认注册表路径。

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>参数

*lpszSectionName*<br/>
[in]一个字符串，包含注册表项的路径。

### <a name="return-value"></a>返回值

一个字符串，包含默认注册表位置的路径。

### <a name="remarks"></a>备注

所有方法[CWinAppEx 类](../../mfc/reference/cwinappex-class.md)访问注册表启动在默认位置。 使用此方法来更改该默认注册表位置。 使用[CWinAppEx::GetRegistryBase](#getregistrybase)来检索默认注册表位置。

##  <a name="showpopupmenu"></a>  CWinAppEx::ShowPopupMenu

显示弹出菜单。

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>参数

*uiMenuResId*<br/>
[in]一个菜单资源 id。

*point*<br/>
[in]一个[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)屏幕坐标中指定菜单的位置。

*pWnd*<br/>
[in]指向拥有的弹出菜单的窗口的指针。

### <a name="return-value"></a>返回值

如果成功，则显示弹出菜单中，非零值否则为 0。

### <a name="remarks"></a>备注

此方法会显示与关联的菜单*uiMenuResId*。

若要支持弹出菜单，您必须具有[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)对象。 如果您未初始化`CContextMenuManager`对象，`ShowPopupMenu`将失败。

##  <a name="storewindowplacement"></a>  CWinAppEx::StoreWindowPlacement

由框架调用以写入注册表的大小和位置的主框架窗口。

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>参数

*nFlags*<br/>
[in]控制最小化的窗口和操作系统切换最小化的窗口和还原的窗口的位置的标志。

*nShowCmd*<br/>
[in]一个整数，指定窗口的显示状态。 有关可能的值的详细信息，请参阅[CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)。

*rectNormalPosition*<br/>
[in]一个包含主框架窗口的坐标时它处于正在还原状态的矩形。

### <a name="return-value"></a>返回值

如果成功，则非零值否则为 0。

### <a name="remarks"></a>备注

默认情况下，MFC 会自动保存的位置和应用程序退出之前的主框架窗口状态。 此信息存储在你的应用程序中默认注册表位置的 WindowPlacement 密钥下的 Windows 注册表中。 有关你的应用程序的默认注册表位置的详细信息，请参阅[CWinAppEx::GetRegistryBase](#getregistrybase)。

如果你想要存储有关主框架窗口的其他信息，请重写此方法。

##  <a name="writebinary"></a>  CWinAppEx::WriteBinary

将二进制数据写入到注册表。

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含的注册表项名称的字符串。

*pData*<br/>
[in]要存储的数据。

*nBytes*<br/>
[in]大小*pData*以字节为单位。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszEntry*参数是您的应用程序的默认注册表项下的注册表条目的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果通过指定的键*lpszEntry*不存在，此方法将创建它。

##  <a name="writeint"></a>  CWinAppEx::WriteInt

将数字数据写入到注册表。

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含的注册表项名称的字符串。

*nValue*<br/>
[in]要存储的数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszEntry*参数是位于你的应用程序默认注册表项下的注册表项的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果通过指定的键*lpszEntry*不存在，此方法将创建它。

##  <a name="writeobject"></a>  CWinAppEx::WriteObject

写入数据派生自[CObject 类](../../mfc/reference/cobject-class.md)到注册表。

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含要设置的值的字符串。

*obj*<br/>
[in]对引用`CObject`方法将存储的数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

此方法写入*obj*默认注册表项下的指定值的数据。 使用[CWinAppEx::GetRegistryBase](#getregistrybase)来确定当前的注册表项。

##  <a name="writesectionbinary"></a>  CWinAppEx::WriteSectionBinary

将二进制数据写入到注册表中的值。

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]包含的注册表项名称的字符串

*lpszEntry*<br/>
[in]包含要设置的值的字符串。

*pData*<br/>
[in]要向注册表写入的数据。

*nBytes*<br/>
[in]大小*pData*以字节为单位。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果通过指定的键*lpszEntry*不存在，此方法将创建它。

##  <a name="writesectionint"></a>  CWinAppEx::WriteSectionInt

将数字数据写入到注册表。

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]一个字符串，包含注册表项的相对路径。

*lpszEntry*<br/>
[in]包含要设置的值的字符串。

*nValue*<br/>
[in]要向注册表写入的数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果通过指定的键*lpszEntry*不存在，此方法将创建它。

##  <a name="writesectionobject"></a>  CWinAppEx::WriteSectionObject

写入数据派生自[CObject 类](../../mfc/reference/cobject-class.md)为特定的注册表值。

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]包含的注册表项名称的字符串。

*lpszEntry*<br/>
[in]一个字符串，包含要设置的值的名称。

*obj*<br/>
[in]要存储的数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果指定的值*lpszEntry*下指定的注册表项不存在*lpszSubSection*，此方法将创建该值。

##  <a name="writesectionstring"></a>  CWinAppEx::WriteSectionString

将字符串数据写入到注册表中的值。

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>参数

*lpszSubSection*<br/>
[in]包含的注册表项名称的字符串。

*lpszEntry*<br/>
[in]包含要设置的值的字符串。

*lpszValue*<br/>
[in]要写入注册表的字符串数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszSubSection*参数不是注册表项的绝对路径。 它是追加到你的应用程序的默认注册表项的末尾的相对路径。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果指定的值*lpszEntry*下不存在*lpszSubSection*，此方法将创建它。

##  <a name="writestring"></a>  CWinAppEx::WriteString

将字符串数据写入到注册表。

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>参数

*lpszEntry*<br/>
[in]包含的注册表项名称的字符串。

*lpszValue*<br/>
[in]要存储的数据。

### <a name="return-value"></a>返回值

如果此方法成功，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*LpszEntry*参数是位于你的应用程序默认注册表项下的注册表项的名称。 若要获取或设置默认注册表项，使用方法[CWinAppEx::GetRegistryBase](#getregistrybase)并[CWinAppEx::SetRegistryBase](#setregistrybase)分别。

如果通过指定的键*lspzEntry*不存在，此方法将创建它。

## <a name="see-also"></a>请参阅

[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp 类](../../mfc/reference/cwinapp-class.md)<br/>
[CMouseManager 类](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager 类](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[CKeyboardManager 类](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[CUserToolsManager 类](../../mfc/reference/cusertoolsmanager-class.md)
