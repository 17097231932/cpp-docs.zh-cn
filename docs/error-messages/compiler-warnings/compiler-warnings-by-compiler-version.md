---
title: "由编译器版本的编译器警告 |Microsoft 文档"
ms.custom: 
ms.date: 05/16/2017
ms.reviewer: 
ms.suite: 
ms.technology: devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- warnings, by compiler version
- cl.exe compiler, setting warning options
ms.assetid: 886c5a66-088c-4a4b-908b-aa3ec189e595
caps.latest.revision: "0"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 52513b156ee8c86d8358be84a27c28d15eb86641
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/21/2017
---
# <a name="compiler-warnings-by-compiler-version"></a>由编译器版本的编译器警告  
  
编译器可禁止显示后，你可以通过使用指定的版本推出的警告[/Wv](../../build/reference/compiler-option-warning-level.md)编译器选项。 这可用于管理你的生成过程时引入新的工具集版本，并且想要暂时禁止显示新的警告。 此选项不会取消新的错误消息。 我们建议不要禁止显示所有新的警告永久 ！ 我们建议你始终在最高的正则警告等级，编译__/W4__，并删除__/Wv__越早越好在你的生成选项。  
  
这些版本的编译器引入新的警告：

| 产品 | 编译器的版本号 |  
|-|-|  
| Visual c + + 2002 | 13.00.9466 |  
| Visual c + + 2003 | 13.10.3077 |  
| Visual C++ 2005 | 14.00.50727.762 |  
| Visual C++ 2008 | 15.00.21022.08 |  
| Visual C++ 2010 | 16.00.40219.01 |  
| Visual c + + 2012 | 17.00.51106.1 |  
| Visual c + + 2013 | 18.00.21005.1 |  
| Visual c + + 2015 RTM | 19.00.23026.0 |  
| Visual c + + 2015 Update 1 | 19.00.23506.0 |  
| Visual c + + 2015 Update 2 | 19.00.23918.0 |  
| Visual c + + 2015 Update 3 | 19.00.24215.1 |  
| Visual c + + 2017 RTM | 19.10.24903.0 |  
| Visual c + + 2017 Update 1 | 19.10.25017.0 |  
  
你可以指定仅主版本号、 主版本号和次数字或主要，并生成数字与__/Wv__选项，这样会禁止显示所有警告版本大于指定的数。 例如，若要禁止显示警告引入 Visual c + + 2015 Update 2 及更高版本，可以使用__/Wv:19.00.23900__。 若要禁止显示所有警告在 Visual c + + 2013年及更高版本，可以使用__/Wv:18__。  
  
以下各节列出引入的每个版本的 Visual c + +，则可以通过使用禁止显示警告__/Wv__编译器选项。 __/Wv__选项不能禁止显示未列出，其早指定的版本的编译器的警告。
  
## <a name="warnings-introduced-in-visual-c-2017-update-1"></a>在 Visual c + + 2017 Update 1 中引入的警告
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19.10.25000__。  
  
|||  
|-|-|  
C4597|未定义的行为：*说明*  
C4604|*类型*： 在本机和托管的边界之间按值传递自变量需要有效的复制构造函数。 否则，运行时行为是不确定  
C4749|有条件地支持：*说明*  
C4768|则将忽略链接规范的前面的 __declspec 属性  
C4834|放弃具有 nodiscard 属性的函数的返回的值  
C4841|使用的非标准扩展：*扩展*
C4842|offsetof 应用于使用多重继承的类型的结果不是保证是编译器版本之间一致  
C4869|nodiscard 只能应用到类、 枚举和非 void 返回类型的函数  
C5033|*存储类*不再受支持的存储类  
C5034|使用内部函数的*内部*将导致函数*函数*编译为访客代码  
C5035|使用的功能*功能*将导致函数*函数*编译为访客代码  
C5036|varargs 函数指针转换使用 /hybrid:x86arm64 编译时*type1*到*type2*  
C5037|*成员函数*： 类模板的成员的超行定义不能具有默认自变量  
  
## <a name="warnings-introduced-in-visual-c-2017-rtm"></a>在 Visual c + + 2017 RTM 中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19.10__。  
  
|||  
|-|-|  
C4468|fallthrough： 特性必须跟 case 标签或默认的标签
C4698|*功能*是用于评估目的仅并且随时可能更改或删除在将来更新。
C4839|类的非标准使用*类*作为可变参数函数的自变量
C4840|类的非可移植使用*类*作为可变参数函数的自变量
  
## <a name="warnings-introduced-in-visual-c-2015-update-3"></a>在 Visual c + + 2015 Update 3 中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19.00.24000__。  
  
|||  
|-|-|  
C4467|已弃用 ATL 属性用法
C4596|*名称*： 非法的限定的名称，在成员声明
C4598|#include \<*标头*\>： 标头编号*数*中*源*不符*源*该位置
C4599|*参数*:*源*参数号*数*不符*源*
  
## <a name="warnings-introduced-in-visual-c-2015-update-2"></a>Visual c + + 2015 Update 2 中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19.00.23900__。  
  
|||  
|-|-|  
C4466|无法执行协同程序堆省略
C4595|*类*： 非成员运算符 new 或 delete 函数不能声明内联
C4828|该文件包含从偏移量为 0 处开始的字符 x*值*这是在当前的源字符集中非法 (代码页*数*)。
C4868|编译器可能会不强制实施大括号内的初始值设定项列表中从左到右计算顺序
  
## <a name="warnings-introduced-in-visual-c-2015-update-1"></a>Visual c + + 2015 Update 1 中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19.00.23500__。  
  
|||  
|-|-|  
C4426|优化标志发生更改后包括标头，可能是由于 #pragma optimize （） 超出
C4654|前后放置的代码包含预编译标头的行将被忽略。 将代码添加到预编译标头。
C5031|#pragma warning （pop): 可能不匹配，弹出推入不同的文件的警告状态
C5032|检测到与测试 warning （没有相应 #pragma pop） #pragma warning （push）
  
## <a name="warnings-introduced-in-visual-c-2015-rtm"></a>在 Visual c + + 2015 RTM 中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:19__。  
  
|||  
|-|-|  
C4427|*错误*： 在常量除法中，未定义的行为的溢出
C4438|*类型*： 不在中安全地调用 / await: clrcompat 模式。 如果*类型*调用 CLR 到它可能会导致 CLR 头损坏
C4455|运算符*名称*： 保留文本的后缀不是以下划线开头的标识符
C4456|声明*名称*隐藏了以前本地声明
C4457|声明*名称*隐藏函数参数
C4458|声明*名称*隐藏类成员
C4459|声明*名称*隐藏了全局声明
C4462|*类型*： 无法确定类型的 GUID。 程序可能在运行时失败。
C4463|溢出;分配*值*到只包含中的值的位域*值*到*值*
C4473|*说明*： 没有足够自变量传递为格式字符串
C4474|*说明*： 为格式字符串中传递的参数太多
C4475|*说明*： 长度修饰符*修饰符*不能用于类型字段字符*字符*格式说明符中
C4476|*说明*': 未知的类型字段字符*字符*格式说明符中
C4477|*说明*： 格式字符串*字符串*要求类型自变量*类型*，但可变参数自变量*数*具有类型*类型*
C4478|*说明*： 位置和非位置占位符不能混合在同一格式字符串
C4494|*类型*： 忽略 __declspec(allocator)，因为该函数返回类型不是指针或引用
C4495|__super 使用的非标准扩展： 将替换为显式基类名称
C4496|使用 for each 的非标准扩展： 替换范围 for 语句
C4497|sealed 使用的非标准扩展： 将替换为最终
C4498|使用的非标准扩展:*扩展*
C4499|*专用化*： 显式专用化不能具有存储类 （忽略）
C4576|初始值设定项列表后跟一个用圆括号括起来类型是一种非标准的显式类型转换语法
C4577|noexcept 用于没有异常处理模式，以指定;不保证异常终止。 指定 /EHsc
C4578|abs： 从转换*类型*到*类型*，可能丢失数据 (您的意思调用*名称*或 #include <cmath>？)
C4582|*类型*： 不隐式调用构造函数
C4583|*类型*： 不隐式调用析构函数
C4587|*类型*： 行为更改： 不再隐式调用构造函数
C4588|*类型*： 行为更改： 不再隐式调用析构函数
C4589|抽象类的构造函数*类型*忽略虚拟基类的初始值设定项*类型*
C4591|constexpr 调用深度限制*数*超出 (/ constexpr:depth<NUMBER>)
C4592|*类型*： 符号将动态初始化 （实现限制）
C4593|*类型*: constexpr 调用评估步骤限制的*值*超出; 使用 /constexpr:steps<NUMBER>以提高限制
C4647|行为更改： __is_pod (*类型*) 在以前版本中具有不同的值
C4648|忽略标准属性 carries_dependency
C4649|在此上下文中，则忽略属性
C4753|找不到为指针; 的边界忽略 MPX 内部函数
C4771|必须使用简单的指针; 创建边界忽略 MPX 内部函数
C4774|*说明*： 格式字符串中自变量应*数*不是字符串文本
C4775|在格式字符串中使用的非标准扩展*字符串*of function*函数*
C4776|%*字符*'函数的格式字符串中不允许*函数*
C4777|*说明*： 格式字符串*字符串*要求类型自变量*类型*，但可变参数自变量*数*具有类型*类型*
C4778|*说明*： 格式字符串未终止*字符串*
C4838|从*类型*到*类型*需要收缩转换
C5022|*类型*： 指定了多个移动构造函数
C5023|*类型*： 指定的多个移动赋值运算符
C5024|*声明*： 移动构造函数隐式定义，为已删除
C5025|*声明*： 移动赋值运算符已隐式定义为已删除
C5026|*类型*： 移动构造函数隐式定义，为已删除
C5027|*类型*： 移动赋值运算符已隐式定义为已删除
C5028|*名称*： 先前声明中指定的对齐方式 (*数*) 定义中未指定
C5029|使用的非标准扩展： c + + 中的对齐方式属性应用于变量、 数据成员和仅适用于标记类型
C5030|属性*属性*无法识别
  
## <a name="warnings-introduced-in-visual-c-2013"></a>在 Visual c + + 2013年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:18__。  
  
|||  
|-|-|  
C4301|*类型*： 仅重写虚函数不同于*声明*const/volatile 限定符
C4316|*类型*： 在堆上分配的对象可能未对齐*数*
C4380|*类型*： 不能弃用默认构造函数
C4388|*令牌*： 有符号/无符号不匹配
C4423|std:: bad_alloc： 类将捕获 (*类型*) 在行上*数*
C4424|有关捕获*类型*前面通过*类型*行上*数*; 不可预测可能会导致行为，如果引发 std:: bad_alloc
C4425|SAL 批注不能应用于...
C4464|相对包含路径包含..
C4575|__vectorcall 与不兼容 / clr 选项： 将转换为 __stdcall
C4609|*类型*派生自默认接口*类型*类型上*类型*。 使用适用于不同的默认界面*类型*，或中断的基/派生关系。
C4754|在比较中的算术运算的转换规则*说明*(*数*) 意味着无法执行一个分支。 强制转换*类型*到*类型*(或类似类型的*数*字节)。
C4755|在比较中的算术运算的转换规则*说明*(*数*) 意味着不能在一个内联函数执行一个分支。 强制转换*类型*到*类型*(或类似类型的*数*字节)。
C4767|节名称*名称*的长度超过 8 个字符，将链接器截断
C4770|部分验证枚举*名称*用作索引
C4827|具有 0 参数的公共 ToString 方法应标记为虚拟和重写
C4882|将使用非 const 调用运算符函子传递给 concurrency:: parallel_for_each 已弃用
C4973|*类型*： 标记为已弃用
C4974|*类型*： 标记为已弃用
C4981|Warbird： 函数*声明*标记为 __forceinline 不内联因为它包含异常语义
C4990|Warbird:*消息*
C4991|Warbird： 函数*声明*标记为 __forceinline 不内联因为被内联方的保护级别大于父级
C4992|Warbird： 函数*声明*标记为 __forceinline 不内联因为它包含内联程序集不能受保护的
  
## <a name="warnings-introduced-in-visual-c-2012"></a>Visual c + + 2012年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:17__。  
  
|||  
|-|-|  
C4330|属性*属性*for 一节*部分*忽略
C4415|重复 __declspec (code_seg (*名称*'))
C4416|__declspec(code_seg(...)) 包含空字符串： 忽略
C4417|显式模板实例化不能具有 __declspec(code_seg(...))： 忽略
C4418|__declspec(code_seg(...)) 忽略上枚举
C4419|*名称*时起任何作用于在私有 ref 类*类型*。
C4435|*类型*: /vd2 下的对象布局将因虚拟基而更改*类型*
C4436|从虚拟基的 dynamic_cast*类型*到*类型*构造函数或析构函数可能会失败与部分构造对象
C4437|从虚拟基的 dynamic_cast*类型*到*类型*可能会在某些上下文中失败
C4443|杂注参数应为 '0'、 '1' 或 '2'
C4446|*类型*： 无法映射成员*名称*为此类型，因为与类型名称冲突。 该方法已重命名为*名称*
C4447|如果线程处理模型未找到 main 的签名。 请考虑使用 int main (platform:: array\<platform:: string ^ > ^ 参数)。
C4448|*类型*没有元数据中指定的默认接口。 选择:*类型*，这可能会在运行时失败。
C4449|*类型*未密封的类型应标记为 [WebHostHidden]
C4450|*类型*应将标记为 [WebHostHidden] 由于它派生自*类型*
C4451|*类型*: ref 类的用法*类型*内部此上下文可能会导致无效的封送处理对象跨上下文
C4452|*类型*： 在全局范围内不能为公共类型。 它必须是输出.winmd 文件的名称的子节点的命名空间中。
C4453|*类型*: [WebHostHidden] 类型不应使用不是公共类型的发布接口上 [WebHostHidden]
C4454|*类型*而无 [DefaultOverload] 指定重载的多个输入参数的数目。 选取*声明*为默认重载
C4471|*名称*： 未区分范围的枚举的前向声明必须具有基础类型 (假定为 int)
C4472|*名称*是本机枚举： 添加访问说明符 (private/public) 来声明托管/WinRT 枚举
C4492|*类型*： 匹配基 ref 类方法*类型*，但未标记为重写
C4493|删除表达式不起作用的析构函数作为*类型*没有 'public' 可访问性
C4585|*类型*: WinRT 公共 ref class 必须要么都密封或派生自的现有未密封的类
C4586|*类型*： 无法在名为 Windows 顶级命名空间声明为公共类型
C4695|#pragma execution_character_set:*参数*不是受支持的参数： 支持当前仅 utf-8
C4703|可能未初始化的局部指针变量*名称*使用
C4728|/ Yl 选项被忽略，因为所需 PCH 引用
C4745|可变访问*名称*不能为承兑由于其大小
C4746|可变访问*名称*受到 /volatile:\<iso\|ms > 设置;请考虑使用 __iso_volatile_load/store 内部函数
C4872|浮点编译在 concurrency:: parallel_for_each 的调用关系图时检测到的零除以:*说明*
C4880|从强制转换*类型*到*类型*： 转换掉 constness 从指针或引用可能会导致未定义的行为，在 amp 限制函数
C4881|构造函数和/或析构函数将不会调用 tile_static 变量*类型*
C4966|*说明*具有不受支持的段名称，忽略的批注与 __code_seg 批注
C4988|*类型*： 声明外部类/函数范围变量
C4989|*说明*： 类型具有冲突定义。
  
## <a name="warnings-introduced-in-visual-c-2010"></a>在 Visual c + + 2010年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:16__。  
  
|||  
|-|-|  
C4352|*名称*： 已定义的内部函数
C4573|使用情况*类型*要求编译器捕获 this，但当前的默认捕获模式不允许
C4574|*名称*定义为"0： 你是否希望使用 #if*名称*？
C4689|*字符*： 不支持的字符中 #pragma detect_mismatch; #pragma 忽略
C4751|/arch AVX 标志不适用于 intel （） 流式处理 SIMD 扩展中内联 ASM
C4752|找到 intel （） 高级矢量扩展;请考虑使用相应的 /arch AVX 标志
C4837|检测到的三元组:??*字符*替换为*字符*
C4986|*声明*： 异常规范与前面的声明不匹配
C4987|使用了非标准扩展：“throw (...)”
  
## <a name="warnings-introduced-in-visual-c-2008"></a>在 Visual c + + 2008年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:15__。  
  
|||  
|-|-|  
C4396|*类型*： 友元声明引用函数模板的专用化时，不能使用内联说明符
C4413|*声明*： 引用成员初始化为构造函数退出后不会保留一个临时
C4491|*说明*： 非法 IDL 版本格式
C4603|*名称*： 未定义宏或在预编译标头使用后定义发生改变
C4627|*说明*： 在查找预编译标头使用时跳过
C4750|*说明*： 函数 with _alloca （) 内嵌到循环
C4910|*类型*: __declspec （dllexport） 和 extern 不兼容的显式实例化上
C4985|*声明*： 先前声明中不存在特性。
  
## <a name="warnings-introduced-in-visual-c-2005"></a>在 Visual c + + 2005年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:14__。  
  
|||  
|-|-|  
C4000|请未知警告选择技术支持命令的 Visual c + + 帮助菜单上，或打开技术支持帮助文件了解详细信息
C4272|*类型*： 标记 __declspec （dllimport）; 导入函数时，必须指定本地调用约定。
C4333|*表达式*： 右移位运算过大数据丢失
C4334|*表达式*： 结果的 32 位 shift 隐式转换为 64 位 （是否 64 位位移？）
C4335|检测到的 Mac 文件格式： 请将源文件转换为 DOS 或 UNIX 格式
C4342|行为更改:*类型*调用，但在早期版本中调用时是成员运算符
C4350|行为更改:*声明*而不是调用*声明*
C4357|在委托的形式自变量列表中找到 param 数组自变量*声明*忽略生成时*类型*
C4358|*表达式*： 的组合的委托的返回类型不是 void; 返回的值是不确定
C4359|*类型*： 对齐说明符小于实际的对齐方式 (*数*)，并且将被忽略。
C4362|*类型*: CLR 不支持大于 8 个字节的对齐方式
C4364|#using 为程序集*名称*以前看到在*说明*(*数*) 而无需 as_friend 属性; as_friend 不应用
C4365|*表达式*： 从转换*类型*到*类型*，有符号/无符号不匹配
C4366|一元的结果*运算符*运算符可能未对齐
C4367|从*类型*到*类型*可能会导致数据类型不一致问题异常
C4368|不能定义*名称*为托管的成员*类型*： 不支持混合的类型
C4369|*类型*： 枚举器值*数*不能表示为*类型*，值是*数*
C4374|*声明*： 非虚拟方法将不实现接口方法*声明*
C4375|非公共方法*声明*不重写*声明*
C4376|访问说明符*说明符*: 不再受支持： 请使用*说明符*: 改为
C4377|本机类型是私有的默认设置;-d1PrivateNativeTypes 已弃用
C4378|必须获取函数指针，以便运行初始值设定项;请考虑 System::ModuleHandle::ResolveMethodHandle
C4379|版本*版本*的公共语言运行时不支持此编译器。 使用此版本可能会导致意外的结果
C4381|*声明*： 非公共方法将不实现接口方法*声明*
C4382|引发*类型*： 具有 __clrcall 析构函数或复制构造函数的类型仅可捕获在 /clr: pure 模块
C4383|*类型*： 取消句柄引用的含义可以更改，用户定义*运算符*运算符存在; 编写作为静态函数可以明确地操作数的运算符
C4384|#pragma*指令*仅应在全局范围内使用
C4393|*类型*: const 不起任何作用*说明*数据成员; 忽略
C4394|*类型*： 不应将每个 appdomain 符号标记与 __declspec (*值*)
C4395|*类型*： 成员函数将调用上一份 initonly 数据成员*类型*
C4397|忽略 DefaultCharSetAttribute
C4398|*类型*： 每个进程的全局对象可能无法与多个 appdomain 进行正常工作; 请考虑使用 __declspec(appdomain)
C4399|*类型*： 不应将每个进程符号标记与 __declspec (*值*) 时使用 /clr 进行编译： 纯
C4400|*类型*： 不支持在此类型上的 const/volatile 限定符
C4412|*声明*： 函数签名包含类型*类型*';C + + 对象是不安全的时间间隔纯代码和混合或本机。
C4429|可能不完整或格式不正确通用字符名称
C4430|缺少类型说明符 - 假定为 int。 注意： c + + 不支持默认的 int
C4431|缺少类型说明符 - 假定为 int。 注意: C 不再支持默认的 int
C4434|静态构造函数必须具有私有可访问性;将更改为私有访问
C4439|*类型*： 与托管签名中类型的函数定义必须具有调用约定 __clrcall
C4441|调用约定的*约定*忽略;*约定*改用
C4445|*声明*： 托管/WinRT 类型中虚方法不能为私有
C4460|CLR/WinRT 运算符*类型*，通过引用传递参数。 CLR/WinRT 运算符*运算符*具有不同的语义与 c + + 运算符*运算符*，是否希望按值传递？
C4461|*类型*： 此类有终结器 ！*类型*但没有析构函数 ~*类型*
C4470|忽略在 /clr 下的浮点控制杂注
C4480|使用的非标准扩展： 指定枚举的基础类型*类型*
C4481|使用的非标准扩展： 重写说明符*说明符*
C4482|使用的非标准扩展： 枚举*类型*限定名称中使用
C4483|语法错误： 应为 c + + 关键字
C4484|*类型*： 匹配基 ref 类方法*类型*，但未标记为虚拟一步、 上一 new 或 '重写';假定 new （和不是虚拟）
C4485|*类型*： 匹配基 ref 类方法*类型*，但不是标记 new 或重写';假定 new （和虚拟）
C4486|*类型*: ref 类或值类的私有虚拟方法应标记为 sealed
C4487|*类型*： 匹配项继承非虚拟方法*类型*但不是显式标记为 new
C4488|*类型*： 需要*关键字*关键字实现接口方法*类型*
C4489|*关键字*： 接口方法上不允许*名称*; 重写说明符仅可以在 ref 类和值类方法
C4490|*关键字*： 重写说明符; 的不正确使用*类型*不匹配的 ref 基类类方法
C4538|*类型*： 不支持在此类型上的 const/volatile 限定符
C4559|*类型*： 重定义; 函数提升 __declspec (*值*)
C4565|*类型*： 重定义; 符号之前声明与 __declspec (*值*)
C4566|通用字符名称由表示的字符*字符*不能表示在当前代码页 (*数*)
C4568|*类型*： 显式重写的签名匹配的任何成员
C4569|*类型*： 显式重写的签名匹配的任何成员
C4570|*类型*： 没有显式声明为抽象的但具有抽象函数
C4571|自 Visual c + + 7.1; 以来更改的信息： 之后语义不再捕获结构化的异常 (SEH)
C4572|[ParamArray] 特性弃用在 /clr 下，请使用...改为
C4580|[attribute] 已弃用;改为指定*指定*用作基类的属性
C4581|已否决的行为:"*名称*"替换为*名称*进程属性
C4606|#pragma 警告:*数*忽略;代码分析警告不与警告级别相关联
C4631|MSXML 或 XPath 不可用，将不会处理 XML 文档注释。 description
C4632|XML 文档注释：*说明*-访问被拒绝：*说明*
C4633|XML 文档注释*说明*： 错误：*说明*
C4634|XML 文档注释*说明*： 不能应用：*说明*
C4635|XML 文档注释*说明*： 格式错误的 XML:*说明*
C4636|XML 文档注释*说明*： 标记需要非空 '*说明*属性。
C4637|XML 文档注释*说明*:<include>丢弃的标记。 description
C4638|XML 文档注释*说明*： 引用未知符号*说明*。
C4639|MSXML 错误，将不会处理注释的 XML 文档。 description
C4641|XML 文档注释中有明确的交叉引用： 
C4678|基本类的*声明*is 可访问性低于*名称*
C4679|*说明*： 无法导入成员
C4687|*类型*： 密封的抽象类不能实现接口*类型*
C4688|*名称*： 约束列表包含程序集私有类型*声明*
C4690|[ emitidl( pop ) ]: 详细栈比入
C4691|*类型*： 引用的类型应在以上不访问*模块**说明*，而是使用了当前翻译单元中定义的类型
C4692|*名称*： 非私有成员的签名包含程序集私有本机类型*声明*
C4693|*类型*： 密封的抽象类不能具有任何实例成员*名称*
C4694|*类型*： 密封的抽象类不能有基类的*类型*
C4720|内联汇编程序报告:*说明*
C4721|*说明*： 不可用作内部函数
C4722|*说明*： 析构函数永远不会返回时，可能存在内存泄漏
C4726|ARM arch4/4T 仅支持 ' < cpsr_f > 或 < spsr_f > 与即时值
C4727|名为的 PCH*名称*中找到的相同时间戳*名称*和*名称*。  使用第一个 PCH。
C4729|根据警告，函数对于流图形太大
C4730|*说明*： 混合 _m64 和浮点表达式可能会导致代码不正确
C4731|*说明*： 帧指针寄存器*注册*修改内联程序集代码
C4732|内部函数*内部*不支持在此体系结构
C4733|内联 asm 将分配给"fs: 0": 未注册为安全的处理程序的处理程序
C4734|多个 64k COFF 中的行号调试信息部分;停止发出的模块的 COFF 调试行号*模块*
C4738|将 32 位浮点型结果存储在内存中，可能会降低性能
C4739|对变量引用*变量*超过了其存储空间
C4740|流在代码或跳出内联 asm 代码会取消全局优化
C4742|*变量*中具有不同的对齐*位置*和*位置*:*数*和*数*
C4743|*名称*中具有不同的大小*位置*和*位置*:*数*和*数*字节
C4744|*名称*具有不同的类型*位置*和*位置*:*类型*和*类型*
C4747|调用托管*类型*： 不会在有加载程序锁，包括 DLL 入口点和调用从 DLL 入口点达到运行托管的代码
C4761|自变量; 中的整型的大小不匹配提供的转换
C4764|无法对齐大于 16 个字节的捕获对象
C4788|*标识符*： 标识符被截断为*数*' 字符
C4789|缓冲区*名称*的大小*数*字节将溢出;*数*将从偏移量开始写入字节*数*
C4801|通过引用返回是不可验证：*说明*
C4819|该文件包含不能在当前代码页中表示的字符 (*数*)。 保存该文件以 Unicode 格式，以防止数据丢失
C4826|从*类型*到*类型*进行符号扩展。 这可能导致意外的运行时行为。
C4829|函数 main 的参数可能不正确。 请考虑 int main (platform:: array\<platform:: string ^ > ^ argv)
C4835|*类型*： 在宿主程序集首次执行托管的代码之前，不会运行导出的数据的初始值设定项
C4867|*类型*： 非标准的语法; 请改用 & 以创建指向成员的指针
C4936|只有使用 /clr 或 /clr:pure 编译时，才支持此 __declspec
C4937|*名称*和*名称*'是否作为自变量时不可区分*选项*
C4938|*类型*： 浮点型 reduction 变量可能会导致不一致的结果在 /fp: strict 或 #pragma fenv_access
C4939|#pragma vtordisp 已被否决，并将在 Visual C++ 将来的版本移除
C4947|*类型*： 标记为过时
C4949|托管和非托管杂注为仅在使用编译时，才有意义 / clr [: 选项]
C4950|*类型*： 标记为过时
C4955|*说明*： 忽略导入; 已从导入*源*
C4956|*类型*： 此类型不是可验证
C4957|*表达式*： 显式强制转换，从*类型*到*类型*是不可验证
C4958|*表达式*： 指针算法是不可验证
C4959|不能定义非托管*类**类型*在 /clr: safe 因为访问其成员会产生不可验证的代码
C4960|*说明*太大，要进行事件探查
C4961|没有配置文件数据合并到*位置*，已禁用按配置文件优化
C4962|*说明*： 已禁用在于优化导致了配置文件数据变得不一致的按配置文件优化
C4963|*说明*： 找到任何配置文件数据; 检测的生成中使用不同的编译器选项
C4964|未不指定任何优化选项;将不会收集配置文件信息
C4965|隐式框中的整数 0;使用 nullptr 或显式强制转换
C4970|委托构造函数： 目标对象忽略自*声明*是静态的
C4971|参数顺序：\<目标对象 >，\<目标函数 > 委托构造函数已弃用，对于使用\<目标函数 >，\<目标对象 >
C4972|直接修改取消装箱操作的结果或将其视为左值是不可验证的
  
## <a name="warnings-introduced-in-visual-c-2003"></a>在 Visual c + + 2003年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:13.10__。  
  
|||  
|-|-|  
C4343|#pragma 优化 (*说明*、 off) 重写 /Og 选项
C4344|行为更改： 使用显式模板自变量中的结果调用*声明*
C4346|*类型*： 依赖名称不是类型
C4348|*声明*： 重定义的默认参数： 参数*数*
C4356|*类型*： 不能通过派生类中初始化静态数据成员
C4408|匿名*结构*不声明任何数据成员
C4544|*声明*： 默认模板自变量已忽略此模板声明
C4545|逗号前的表达式计算为缺少自变量列表的函数
C4546|逗号前的函数调用缺少自变量列表
C4547|*表达式*： 逗号不起任何作用; 前的运算符预期带副作用的运算符
C4548|逗号前的表达式不起任何作用；应输入带副作用的表达式
C4549|*表达式*： 逗号前的运算符起任何作用; 是否要使用*表达式*？
C4628|-Ze 不支持二合字母。 字符序列*序列*未解释为用于替换标记*令牌*
C4629|二合字母使用，字符序列*序列*解释为标记*令牌*（如果这是不是你所期望的内容，则插入的两个字符之间留一个空格）
C4671|*说明*： 复制构造函数不可访问
C4676|*说明*: 析构函数不可访问
C4677|*名称*： 非私有成员的签名包含程序集私有类型*声明*
C4686|*类型*： 行为可能有更改，UDT 中的更改返回调用约定
C4812|过时的声明样式： 请使用*类型*::*名称*改为
C4813|*类型*： 局部类的友元函数必须之前被声称
C4821|无法确定 Unicode 编码类型，请保存签名 (清单 BOM) 文件
C4822|*类型*： 局部类成员函数没有正文
C4823|*类型*： 使用钉住指针但展开语义不会启用。 请考虑使用 /EHa
C4913|存在用户定义的二进制运算符“,”，但没有重载可以转换所有操作数，使用了默认的内置二进制运算符“,”
C4948|返回类型*声明*与相应的 setter 的最后一个参数类型不匹配
C4951|*说明*已编辑过收集配置文件数据后，不使用函数配置文件数据
C4952|*说明*： 在程序数据库中找到的任何其他配置文件数据*说明*
C4953|被内联方*说明*已编辑过收集配置文件数据后，不使用配置文件数据
C4954|*说明*： 不会分析 （包含 __int64 switch 表达式）
  
## <a name="warnings-introduced-in-visual-c-2002"></a>在 Visual c + + 2002年中引入的警告  
  
通过使用编译器选项禁止显示这些警告和更高版本中的所有警告__/Wv:13__。  
  
|||  
|-|-|  
C4096|*类型*： 接口不是一个 COM 接口; 不会发出到 IDL
C4097|杂注参数应是“restore”或者“off”
C4165|要转换为 bool; HRESULT是否确定这是你想得到？
C4183|*名称*： 缺少返回的类型; 假定为成员函数返回 'int'
C4199|description
C4255|*名称*： 函数原型给定： 转换到 (void) 的 ' （）'
C4256|*声明*： 具有虚拟基的类的构造函数具有...; 调用可能不兼容与旧版本的 Visual c + +
C4258|*名称*： 从定义忽略 for 循环; 使用封闭范围中的定义
C4263|*声明*： 成员函数不重写任何基类虚拟成员函数
C4264|*声明*： 不重写基的虚拟成员函数的*类*; 函数被隐藏
C4265|*类型*： 类具有虚函数，但析构函数不是虚拟此类的实例可能不能正确析构
C4266|*声明*： 不重写基的虚拟成员函数的*类*; 函数被隐藏
C4267|*表达式*： 从 size_t 到*类型*，可能丢失数据
C4274|#ident 忽略;请参阅文档 #pragma 注释 （exestr，'string'）
C4277|导入的项*类型*::*名称*作为数据成员和函数成员; 存在忽略的数据成员
C4278|*名称*： 类型库中的标识符*说明*已经宏; 使用重命名限定符
C4279|*名称*： 类型库中的标识符*说明*是一个关键字; 使用重命名限定符
C4287|*表达式*： 无符号/负常量不匹配
C4288|使用的非标准扩展:*名称*： 在 for 循环中声明的循环控制变量用在了 for 循环范围外; 它与外层作用域中的声明冲突
C4289|使用的非标准扩展:*名称*： 在 for 循环中声明的循环控制变量用在了 for 循环范围外
C4293|*表达式*： 移动计数负或太大、 未定义的行为
C4295|*类型*： 数组是太小，无法包括终止 null 字符
C4296|*表达式*： 表达式始终是*值*
C4297|*类型*： 假定函数不引发异常，但不会
C4298|*名称*： 类型库中的标识符*说明*已经宏; 重命名为 __*名称*
C4299|*名称*： 类型库中的标识符*说明*是一个关键字; 重命名为 __*名称*
C4302|*表达式*： 从截断*类型*到*类型*
C4303|*转换*从*类型*到*类型*是已弃用，使用 static_cast、 __try_cast 或 dynamic_cast
C4314|杂注参数应为"32"或"64"
C4315|*类型*： 成员 this 指针*类型*可能未对齐*数*按预期构造函数
C4318|将常量零长度作为传递给 memset
C4319|*表达式*： 零扩展*类型*到*类型*更大的
C4321|自动生成接口 IID*类型*
C4322|自动生成的类的 CLSID*类型*
C4323|重新使用注册类的 CLSID*类型*
C4324|*类型*： 结构已填充由于对齐说明符
C4325|忽略标准节*说明*忽略
C4326|返回类型*名称*'应是'*类型*而不是 of*类型*
C4327|*表达式*: LHS 间接寻址对齐方式 (*数*) 大于 RHS (*数*)
C4328|*说明*： 形参的间接寻址对齐*数*(*数*) 大于实际自变量的对齐方式 (*数*)
C4329|对齐说明符忽略上枚举
C4336|导入交叉引用的类型库*库*再导入*说明*
C4337|交叉引用的类型库*库*in*说明*正在自动导入
C4338|#pragma*说明*： 标准部分*部分*使用
C4339|*类型*： 未定义的类型检测到使用在 CLR/WinRT 的元数据-使用此类型可能导致运行时异常
C4353|使用的非标准扩展： 常数 0 作为函数表达式。  请改用 __noop 函数内部函数
C4370|*声明*： 类的布局已从早期版本更好地封装由于编译器
C4371|*声明*： 类的布局可能已更改从早期版本的编译器由于更好地封装成员*类型*
C4373|*类型*： 虚函数重写*声明*，以前版本的编译器未进行重写时只上有 const/volatile 限定符差异的参数
C4387|*说明*： 被认为是
C4389|*表达式*： 有符号/无符号不匹配
C4391|*声明*： 内部函数，预期的返回类型不正确*类型*
C4392|*声明*： 缺少内部函数的参数数目不正确*数*自变量
C4407|指向成员表示形式不同的指针之间强制转换，编译器也会生成不正确的代码
C4420|*名称*： 操作员不可用，请使用*名称*替换; 运行时检查可能已泄露
C4440|调用约定重定义从*说明*到*说明*忽略
C4442|嵌入的 null 终止符，__annotation 自变量中。  值将被截断。
C4444|*名称*： 在此上下文中未实现顶级 __unaligned
C4526|*类型*： 静态成员函数不能重写虚函数*声明*被忽略，重写虚函数将被隐藏
C4531|C + + 异常处理在 Windows CE 上不可用。 使用结构化的异常处理
C4532|*说明*： 跳出*最后*块具有未定义的行为在终止处理过程
C4533|初始化*声明*通过跳过 goto*声明*
C4534|*声明*将不会默认构造函数*类**类型*由于默认自变量
C4535|调用 _set_se_translator() 需要 /EHa
C4536|*说明*： 类型名超出了元数据限制为*数*' 字符
C4537|*声明*:。 应用于非 UDT 类型
C4542|正在跳过生成合并插入的文本文件，无法写入*类型*文件:*filename*:*错误*
C4543|将插入的文本抑制属性的没有\_injected_text
C4555|表达式无效；应输入带副作用的表达式
C4557|__assume 包含效果*效果*
C4558|操作数的值*数*is 超出范围*数* - *数*
C4561|__fastcall 与不兼容 / clr 选项： 将转换为 __stdcall
C4562|完全原型函数所需使用 / clr 选项： 转换到 (void) 的 ' （）'
C4564|方法*名称*的*类**类型*定义不支持的默认参数*参数*
C4584|*类型*： 基类的*声明*is 已基类的*声明*
C4608|初始化联合的多个成员:*类型*和*类型*
C4619|#pragma 警告： 没有警告编号*数*
C4623|*类型*： 默认构造函数隐式定义，为已删除
C4624|*类型*： 析构函数隐式定义，为已删除
C4625|*类型*： 复制构造函数隐式定义，为已删除
C4626|*类型*： 赋值运算符已隐式定义为已删除
C4645|使用 noreturn 声明的函数具有的 return 语句
C4646|使用 noreturn 声明的函数有非 void 返回类型
C4659|#pragma*说明*： 使用保留的段的*名称*具有未定义的行为，使用 #pragma 注释 （链接器，...）
C4667|*声明*： 没有匹配的函数模板定义强制实例化
C4668|*名称*未定义为预处理器宏，用"0"替换为中*值*
C4669|*表达式*： 不安全的转换:*类型*是一个托管/WinRT 类型对象
C4674|*名称*应声明为 'static' 并正好有一个参数
C4680|*类型*： 组件类不指定的默认接口。
C4681|*类型*： 组件类不指定是事件源的默认接口
C4682|*类型*： 指定，默认为 [in] 未方向参数特性
C4683|*声明*： 事件源具有输出的参数; 慎重操作时将多个事件处理程序挂钩
C4684|*说明*： 警告!! 属性可能会导致无效的代码生成： 谨慎使用
C4685|分析模板参数时需要“> >”，却找到了“>>”
C4700|未初始化的局部变量*名称*使用
C4701|可能未初始化的局部变量*名称*使用
C4702|无法访问的代码
C4711|函数*名称*为自动内联展开选定
C4714|函数*声明*标记为 __forceinline 不内联
C4715|*函数*： 并非所有控制路径都返回值
C4716|*函数*： 必须返回值
C4717|*函数*： 所有控制路径的递归，函数将导致运行时堆栈溢出
C4718|*函数*： 递归调用没有任何副作用，删除
C4719|指定 Qfast 时发现-使用 f 作为后缀，以指示单精度的双精度常量
C4723|潜在的被 0 除
C4724|潜在的以 0 求模
C4725|在一些 Pentium 中，指令可能不准确
C4757|下标是较大的无符号的值，是否有意用负常量的？
C4772|#import 从缺少的类型库; 引用了类型*说明*用作占位符
C4792|函数*函数*声明使用 sysimport 声明和引用从本机代码; 需要导入库链接
C4794|线程本地存储区变量的段*名称*更改，不再是*段*到*段*
C4798|为 p 代码函数生成的本机代码*名称*与异常处理程序或展开语义
C4799|函数*名称*具有不 EMMS 指令
C4803|*声明*： 引发方法具有不同的存储类，该事件，从*声明*
C4810|杂注 pack （show） 的值 = =*数*
C4811|杂注的值符合 (forScope，show) = =*值*
C4820|*类型*:*数*字节填充添加后*类型**类型*
C4905|强制转换为宽字符串*类型*
C4906|字符串强制转换为*类型*
C4912|*属性*： 特性有未定义在嵌套 UDT 上的行为
C4916|为了具有 dispid*类型*： 必须引入由接口
C4917|*类型*: GUID 只能与类、 接口或命名空间关联
C4918|*字符*： 杂注优化列表中的无效字符
C4920|枚举*名称*成员*名称*=*数*已在枚举中看到*名称*作为*名称*=*数*
C4921|*名称*： 属性值*值*不应累积指定
C4925|*声明*： 无法从脚本调用调度接口方法
C4926|*声明*： 已定义符号： 忽略特性
C4927|非法转换则隐式应用了多个用户定义的转换
C4928|副本初始化非法；隐式应用了多个用户定义的转换
C4929|*说明*： 类型库包含联合; 忽略 embedded_idl 限定符
C4930|*声明*： 未调用原型函数 （是有意用变量定义？）
C4931|我们假定类型库为生成*数*-位指针
C4932|__identifier (*说明*) 和 __identifier (*说明*) 时不可区分
C4934|__delegate(multicast) 已弃用，请使用 __delegate，而是
C4935|从修改的程序集访问说明符*说明*
C4944|*名称*： 无法导入来自符号*源*： 为*声明*当前范围内已存在
C4945|*名称*： 无法导入来自符号*源*： 为*声明*具有已导入从另一个程序集*源*
C4946|reinterpret_cast 在相关类之间使用:*声明*和*声明*
C4995|*名称*： 名称被标记为弃用 #pragma
C4996|*问题*:*说明*
C4997|*类型*： 组件类不实现 COM 接口或伪接口
C4998|预期失败：*说明*(*数*)
  
## <a name="see-also"></a>请参阅  
[/Wv 编译器选项](../../build/reference/compiler-option-warning-level.md)  
[默认情况下处于关闭状态的编译器警告](../../preprocessor/compiler-warnings-that-are-off-by-default.md)  
[warning](../../preprocessor/warning.md)  
