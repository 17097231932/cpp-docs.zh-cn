---
title: 编译器错误 C2600 - C2699
ms.date: 04/21/2019
f1_keywords:
- C2604
- C2606
- C2607
- C2608
- C2609
- C2610
- C2615
- C2618
- C2620
- C2621
- C2622
- C2623
- C2625
- C2629
- C2631
- C2639
- C2641
- C2642
- C2643
- C2644
- C2684
- C2685
- C2686
- C2697
helpviewer_keywords:
- C2604
- C2606
- C2607
- C2608
- C2609
- C2610
- C2615
- C2618
- C2620
- C2621
- C2622
- C2623
- C2625
- C2629
- C2631
- C2639
- C2641
- C2642
- C2643
- C2644
- C2684
- C2685
- C2686
- C2697
ms.assetid: 73c6319f-cbea-4a2f-913b-90dc1af61f64
ms.openlocfilehash: 9ac5f5724490574aecf0e5b542f6fdd42b0ae5bb
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "62406504"
---
# <a name="compiler-errors-c2600-through-c2699"></a>编译器错误 C2600 - C2699

在本部分文档中的文章说明了由编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|Error|消息|
|-----------|-------------|
|[编译器错误 C2600](compiler-error-c2600.md)|'*函数*： 不能定义编译器生成的特殊成员函数 （必须在类中首先声明）|
|[编译器错误 C2601](compiler-error-c2601.md)|'*函数*： 本地函数定义是非法的|
|[编译器错误 C2602](compiler-error-c2602.md)|'*类*::*标识符*'不是基类的成员'*类*|
|[编译器错误 C2603](compiler-error-c2603.md)|'*函数*:太多块范围静态对象构造函数/析构函数在函数中使用|
|编译器错误 C2604|'*标识符*:不能实现多个接口方法|
|[编译器错误 C2605](compiler-error-c2605.md)|'*标识符*： 托管/WinRT 类中的此方法保留字|
|编译器错误 C2606|'*class1*： 无法重新实现*成员*'，因为它从运行时基本继承'*class2*|
|编译器错误 C2607|静态断言失败|
|编译器错误 C2608|已过时。|
|编译器错误 C2609|已过时。|
|编译器错误 C2610|'*类*::*成员*： 不是默认值的特殊成员函数|
|[编译器错误 C2611](compiler-error-c2611.md)|'*令牌*： 非法的后缀 ~ （应为标识符）|
|[编译器错误 C2612](compiler-error-c2612.md)|尾随的 '*字符*基/成员初始值设定项列表中非法|
|[编译器错误 C2613](compiler-error-c2613.md)|尾随的 '*字符*在基类列表中非法|
|[编译器错误 C2614](compiler-error-c2614.md)|'*类*： 成员初始化非法:*标识符*不是基或成员|
|编译器错误 C2615|已过时。|
|[编译器错误 C2616](compiler-error-c2616.md)|*转换*： 不能隐式转换不是 lvalue*type1*'到'*y p e 2*不是常量|
|[编译器错误 C2617](compiler-error-c2617.md)|'*函数*： 返回语句不一致|
|编译器错误 C2618|已过时。|
|[编译器错误 C2619](compiler-error-c2619.md)|'*标识符*： 匿名结构/联合中不允许使用静态数据成员|
|编译器错误 C2620|已过时。|
|编译器错误 C2621|已过时。|
|编译器错误 C2622|已过时。|
|编译器错误 C2623|已过时。|
|[编译器错误 C2624](compiler-error-c2624.md)|'*作用域*::*类型*： 局部类不能用于声明 extern 变量|
|编译器错误 C2625|'*标识符*： 非法的联合成员; 类型*类型*是引用类型|
|[编译器错误 C2626](compiler-error-c2626.md)|'*标识符*： 匿名结构/联合中不允许私有/受保护的数据成员|
|[编译器错误 C2627](compiler-error-c2627.md)|'*函数*： 不允许匿名联合中的成员函数|
|[编译器错误 C2628](compiler-error-c2628.md)|'*type1*跟*type2*是非法的 (是否忘记了;？)|
|编译器错误 C2629|'*标识符*： 匿名结构/联合不能声明嵌套的类型|
|[编译器错误 C2630](compiler-error-c2630.md)|'*符号*应该是什么的以逗号分隔列表中找到|
|编译器错误 C2631|'*标识符*： 不能在别名模板中定义的类或枚举|
|[编译器错误 C2632](compiler-error-c2632.md)|'*type1*跟有'*type2*是非法的|
|[编译器错误 C2633](compiler-error-c2633.md)|'*标识符*: inline 是构造函数的唯一合法存储类|
|[编译器错误 C2634](compiler-error-c2634.md)|'*类*::*成员*： 指向引用成员的指针是非法的|
|[编译器错误 C2635](compiler-error-c2635.md)|不能转换*type1*\*'到'*type2*\*; 从虚拟基类的转换隐式|
|[编译器错误 C2636](compiler-error-c2636.md)|'*标识符*： 指向引用成员的指针是非法的|
|[编译器错误 C2637](compiler-error-c2637.md)|'*标识符*： 不能修改指向数据成员的指针|
|[编译器错误 C2638](compiler-error-c2638.md)|'*标识符*: __based 修饰符在指向成员的指针上非法|
|编译器错误 C2639|已过时。|
|[编译器错误 C2640](compiler-error-c2640.md)|'*标识符*: __based 修饰符在引用上的非法|
|编译器错误 C2641|已过时。|
|编译器错误 C2642|已过时。|
|编译器错误 C2643|已过时。|
|编译器错误 C2644|已过时。|
|[编译器错误 C2645](compiler-error-c2645.md)|指向成员的指针没有限定的名 (找到:: *)|
|[编译器错误 C2646](compiler-error-c2646.md)|匿名结构/联合在全局或命名空间范围必须声明为静态|
|[编译器错误 C2647](compiler-error-c2647.md)|*运算符*： 不能取消引用*type1*'上'*type2*|
|[编译器错误 C2648](compiler-error-c2648.md)|'*标识符*： 将成员作为默认参数使用要求静态成员|
|[编译器错误 C2649](compiler-error-c2649.md)|'*标识符*： 不是类/结构/联合|
|[编译器错误 C2650](compiler-error-c2650.md)|'*运算符*： 不能为虚函数|
|[编译器错误 C2651](compiler-error-c2651.md)|'*类型*： 左侧的:: 必须是类、 结构或联合|
|[编译器错误 C2652](compiler-error-c2652.md)|'*标识符*： 非法的复制构造函数： 第一个参数不能'*类型*|
|[编译器错误 C2653](compiler-error-c2653.md)|'*标识符*： 不是类或命名空间名称|
|[编译器错误 C2654](compiler-error-c2654.md)|'*标识符*： 成员函数的外部访问成员的尝试|
|[编译器错误 C2655](compiler-error-c2655.md)|'*标识符*： 定义或在当前作用域中的非法重新声明|
|[编译器错误 C2656](compiler-error-c2656.md)|'*函数*： 函数不能作为位域|
|[编译器错误 C2657](compiler-error-c2657.md)|'*类*:: * 语句的开始找到 （是否忘记指定类型？）|
|[编译器错误 C2658](compiler-error-c2658.md)|'*标识符*： 匿名结构/联合中的重定义|
|[编译器错误 C2659](compiler-error-c2659.md)|'*运算符*： 作为左操作数|
|[编译器错误 C2660](compiler-error-c2660.md)|'*函数*： 函数不采用*数*参数|
|[编译器错误 C2661](compiler-error-c2661.md)|'*函数*： 没有重载的函数接受*数*参数|
|[编译器错误 C2662](compiler-error-c2662.md)|'*函数*： 不能将从 this 指针转换*type1*to*type2*|
|[编译器错误 C2663](compiler-error-c2663.md)|'*函数*:*数*重载具有 this 指针没有合法转换|
|[编译器错误 C2664](compiler-error-c2664.md)|'*函数*： 不能将自变量转换*数*从*type1*to*type2*|
|[编译器错误 C2665](compiler-error-c2665.md)|'*函数*： 没有任何*数*重载可以转换所有参数类型|
|[编译器错误 C2666](compiler-error-c2666.md)|'*函数*:*数*重载有相似的转换|
|[编译器错误 C2667](compiler-error-c2667.md)|'*函数*： 没有任何*数*重载具有最佳转化|
|[编译器错误 C2668](compiler-error-c2668.md)|'*函数*： 对重载函数的调用不明确|
|[编译器错误 C2669](compiler-error-c2669.md)|不允许匿名联合中的成员函数|
|[编译器错误 C2670](compiler-error-c2670.md)|'*函数*： 函数模板不能将参数转换*数量*从类型*类型*|
|[编译器错误 C2671](compiler-error-c2671.md)|'*函数*： 静态成员函数没有 this 指针|
|[编译器错误 C2672](compiler-error-c2672.md)|'*函数*： 没有匹配的重载函数找到|
|[编译器错误 C2673](compiler-error-c2673.md)|'*函数*： 全局函数没有 this 指针|
|[编译器错误 C2674](compiler-error-c2674.md)|在此上下文中不允许出现泛型声明|
|[编译器错误 C2675](compiler-error-c2675.md)|一元 '*运算符*':'*类型*不定义该运算符或到可接受类型转换到预定义的运算符|
|[编译器错误 C2676](compiler-error-c2676.md)|二进制*运算符*': '*类型*不定义该运算符或到可接受类型转换到预定义的运算符|
|[编译器错误 C2677](compiler-error-c2677.md)|二进制*运算符*： 没有全局运算符找到接受类型*类型*（或没有可接受的转换）|
|[编译器错误 C2678](compiler-error-c2678.md)|二进制*运算符*： 没有找到运算符接受类型的左操作数 '*类型*（或没有可接受的转换）|
|[编译器错误 C2679](compiler-error-c2679.md)|二进制*运算符*： 没有找到运算符接受的右侧操作数的类型*类型*（或没有可接受的转换）|
|[编译器错误 C2680](compiler-error-c2680.md)|'*类型*： 无效的目标类型*强制转换*|
|[编译器错误 C2681](compiler-error-c2681.md)|'*类型*： 无效的表达式类型*强制转换*|
|[编译器错误 C2682](compiler-error-c2682.md)|不能使用*强制转换*以从转换*type1*to*type2*|
|[编译器错误 C2683](compiler-error-c2683.md)|'*cast*':'*类型*不是多态类型|
|编译器错误 C2684|'*声明符*： 托管/WinRT 类中不支持已删除和默认的函数|
|编译器错误 C2685|'*声明符*： 显式限制说明符不支持删除的和默认函数|
|编译器错误 C2686|不能重载具有相同的参数类型的静态和非静态成员函数|
|[编译器错误 C2687](compiler-error-c2687.md)|'*类型*： 异常声明不能为 void 或表示不完整类型或指针或对不完整类型引用|
|[编译器错误 C2688](compiler-error-c2688.md)|'*类型*::*成员*： 具有多个协变返回或 varargs 函数不支持虚拟继承|
|[编译器错误 C2689](compiler-error-c2689.md)|'*函数*： 不能局部类中定义友元函数|
|[编译器错误 C2690](compiler-error-c2690.md)|'*运算符*： 不能对托管/WinRT 数组执行指针算术|
|[编译器错误 C2691](compiler-error-c2691.md)|'*类型*： 托管/WinRT 数组不能具有此元素类型|
|[编译器错误 C2692](compiler-error-c2692.md)|'*函数*： 完全原型的函数中使用的 C 编译器需要 / clr 选项|
|[编译器错误 C2693](compiler-error-c2693.md)|'*运算符*： 对托管/WinRT 数组的引用比较非法|
|[编译器错误 C2694](compiler-error-c2694.md)|'*override_function*： 重写虚函数具有限制性异常规范比基类虚拟成员函数*base_function*|
|[编译器错误 C2695](compiler-error-c2695.md)|'*override_function*： 重写虚函数不同于*base_function*只是在调用约定|
|[编译器错误 C2696](compiler-error-c2696.md)|无法创建临时对象的托管 WinRT 类型*类型*|
|编译器错误 C2697|已过时。|
|[编译器错误 C2698](compiler-error-c2698.md)|using 声明为*declaration1*不能同时存在与现有 using 声明为*declaration2*|

## <a name="see-also"></a>请参阅

[C /C++编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器错误 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
