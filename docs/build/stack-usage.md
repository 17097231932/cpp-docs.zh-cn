---
title: x64 堆栈使用
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: 902e4304ac124be46c6edf0860118dc522b34890
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78856958"
---
# <a name="x64-stack-usage"></a>x64 堆栈使用

所有超出 RSP 当前地址的内存都被视为易失性：操作系统或调试器可能会在用户调试会话期间或中断处理程序中覆盖此内存。 因此，在尝试读取或写入堆栈帧之前，必须始终设置 RSP。

本部分讨论本地变量和**alloca**内部函数的堆栈空间分配。

## <a name="stack-allocation"></a>堆栈分配

函数的 prolog 负责为本地变量、保存的寄存器、堆栈参数和寄存器参数分配堆栈空间。

参数区域始终位于堆栈的底部（即使使用 `alloca`），以便在任何函数调用期间它将始终与返回地址相邻。 它至少包含四个项，但始终包含足够的空间来保存任何可能被调用的函数所需的所有参数。 请注意，始终为寄存器参数分配空间，即使这些参数本身从不驻留在堆栈中也是如此。被调用方保证已为其所有参数分配了空间。 家乡地址是寄存器参数所必需的，因此，如果所调用的函数需要获取参数列表（va_list）或单独参数的地址，则可以使用连续区域。 此区域还提供了一个方便的位置，用于在 thunk 执行期间保存寄存器参数，并作为调试选项（例如，如果它们存储在 prolog 代码中的主地址，则它可以在调试期间轻松查找参数）。 即使被调用的函数包含的参数少于4个，这四个堆栈位置实际上是被调用的函数所拥有的，并且被调用的函数可能会出于其他目的使用该函数，除了保存参数寄存器值之外。  因此，调用方可能不会在函数调用中保存此堆栈区域中的信息。

如果在函数中动态分配空间（`alloca`），则必须使用非易失性寄存器作为帧指针来标记堆栈的固定部分的基础，并且必须在序言中保存和初始化该注册。 请注意，在使用 `alloca` 时，对同一调用方的相同调用方的调用对于其寄存器参数可能具有不同的 home 地址。

堆栈将始终保持16字节对齐，但在 prolog 中除外（例如，推送返回地址后），除了在函数类型中指示的某个帧函数的[函数类型](#function-types)之外。

下面是堆栈布局的一个示例，其中函数 A 调用非叶函数 b.。函数 A 的 prolog 已经为堆栈底部的 B 所需的所有 register 和 stack 参数分配了空间。 此调用推送返回地址，而 B 的序言为其局部变量、非易失性寄存器和调用函数所需的空间分配空间。 如果 B 使用 `alloca`，则在本地变量/非易失性寄存器保存区域和参数堆栈区域之间分配空间。

![AMD 转换示例](../build/media/vcamd_conv_ex_5.png "AMD 转换示例")

当函数 B 调用另一个函数时，返回地址被推送到 RCX 的 home 地址下面。

## <a name="dynamic-parameter-stack-area-construction"></a>动态参数堆栈区构造

如果使用帧指针，则该选项可用于动态创建参数堆栈区域。 此操作当前不是在 x64 编译器中完成的。

## <a name="function-types"></a>函数类型

主要有两种类型的函数。 需要堆栈帧的函数称为 "*帧函数*"。 不需要堆栈帧的函数称为*叶函数*。

Frame 函数是一个函数，该函数分配堆栈空间、调用其他函数、保存非易失寄存器或使用异常处理。 它还需要函数表项。 Frame 函数需要序言和 epilog。 Frame 函数可以动态分配堆栈空间，并可以使用帧指针。 Frame 函数在其处置时具有此调用标准的全部功能。

如果 frame 函数不调用其他函数，则不需要将堆栈对齐（在部分[堆栈分配](#stack-allocation)中引用）。

叶函数是不需要函数表项的函数。 它无法更改任何非易失性寄存器（包括 RSP），这意味着它不能调用任何函数或分配堆栈空间。 它在执行时允许保留堆栈未对齐。

## <a name="malloc-alignment"></a>malloc 对齐

[malloc](../c-runtime-library/reference/malloc.md)保证返回的内存已进行了适当调整，以便存储具有基本对齐方式的任何对象，并且这些对象可以适合所分配的内存量。 *基本对齐*方式是小于或等于实现所支持的最大对齐方式的对齐方式，无需对齐规范。 （在视觉C++对象中，这是 `double`或8字节所需的对齐方式。 在面向64位平台的代码中，它是16个字节。）例如，四字节分配将在支持任何四字节或更小对象的边界上对齐。

视觉C++对象允许具有*扩展对齐方式*的类型，这些类型也称为 "*对齐*类型"。 例如，SSE 类型[__m128](../cpp/m128.md)和 `__m256`，并且通过使用 `n` 大于8的 `__declspec(align( n ))` 声明的类型进行了扩展对齐。 `malloc`不保证适合于需要扩展对齐的对象的边界上的内存对齐。 若要为超对齐类型分配内存，请使用[_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)和相关函数。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)要求必须是16字节的对齐，并且还需要使用帧指针。

已分配的堆栈需要在其后面包含空格作为后续调用函数的参数，如[堆栈分配](#stack-allocation)中所述。

## <a name="see-also"></a>另请参阅

[x64 软件约定](../build/x64-software-conventions.md)<br/>
[align](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
