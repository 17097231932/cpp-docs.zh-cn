---
title: Iterators
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: 3b6713a80244d7063baac2c75ffead76fe93facc
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "62396132"
---
# <a name="iterators"></a>Iterators

迭代器是一个对象，可以循环访问 C++ 标准库容器中的元素，并提供对各个元素的访问。 C++ 标准库容器全都提供迭代器，以便算法可以采用标准方式访问其元素，而不必考虑用于存储元素的容器类型。

可以使用显式如使用成员函数和全局函数的迭代器`begin()`和`end()`和如运算符 **++** 并 **--** 继续推进工作或向后。 您还可以使用迭代器隐式具有范围的 for 循环或 （对于某些迭代器类型） 下标运算符 **\[]**。

在 C++ 标准库中，序列或范围的开头是第一个元素。 序列或范围的末尾始终定义为最后一个元素的下一个位置。 全局函数`begin`和`end`返回到指定容器的迭代器。 典型显式迭代器循环访问容器中的所有元素，如下所示：

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

可以使用范围 for 循环更加简单地完成相同操作：

```cpp
for (auto num : vec)
{
    // no deference operator
    cout << num << " ";
}
```

有五种类别的迭代器。 这些类别如下所示（按功能逐渐增强的顺序）：

- **输出**。 *输出迭代器* `X`可以向前循环访问序列使用 **++** 运算符，并可以通过使用一次，编写一个元素 __\*__ 运算符。

- **输入**。 *输入迭代器* `X`可以向前循环访问序列通过使用 + + 运算符，并通过使用可以读取元素任意次数 **&ast;** 运算符。 可以通过使用比较输入迭代器 **++** 并 **！ =** 运算符。 递增输入迭代器的任何副本之后，没有其他任何副本可以安全地进行比较、取消引用或递增。

- **向前**。 一个*前向迭代器* `X`可以向前循环访问序列使用 + + 运算符和可以读取的任何元素或通过使用写入非常量元素任意次数 **&ast;** 运算符。 可以使用访问元素成员 **->** 运算符和比较向前迭代器通过使用 **==** 并  **！ =** 运算符。 可以创建向前迭代器的多个副本，其中每个副本都可以独立地取消引用和递增。 没有对任何容器的引用名为初始化的向前迭代器*null 向前迭代器*。 Null 向前迭代器的比较结果始终是相等的。

- **双向**。 一个*双向迭代器*`X`可以发生的前向迭代器。 您可以但是，还递减双向迭代器，如`--X`， `X--`，或`(V = *X--)`。 可以采用与向前迭代器相同的方式访问元素成员和比较双向迭代器。

- **随机访问**。 一个*随机访问迭代器*`X`可以发生的双向迭代器。 与随机访问迭代器可以使用下标运算符 **\[]** 访问元素。 可以使用 **+**， **-**， **+=** 和 **-=** 运算符移动向前或向后指定的数目的元素以及计算迭代器之间的距离。 可以通过使用比较双向迭代器 **==**， **！ =**， **\<**， **>**， **\<=**，和 **>=**。

可以分配或复制所有迭代器。 它们被假定为轻量对象，通常按值（而不是按引用）进行传递和返回。 另请注意，前面所述的操作都无法在对有效迭代器执行时引发异常。

可以通过显示三个序列来汇总迭代器类别的层次结构。 若要对序列进行只写访问，可以使用以下任何项：

> 输出迭代器<br/>
> -> 前向迭代器<br/>
> -> 双向迭代器<br/>
> -> 随机访问迭代器<br/>

向右箭头标识“可以替代”。 例如，为输出迭代器调用的任何算法都应十分适用于向前迭代器，而不是相反。

若要对序列进行只读访问，可以使用以下任何项：

> 输入迭代器<br/>
> -> 前向迭代器<br/>
> -> 双向迭代器<br/>
> -> 随机访问迭代器<br/>

输入迭代器在这种情况下是所有类别中最弱的。

最后，若要对序列进行读/写访问，可以使用以下任何项：

> 前向迭代器<br/>
> -> 双向迭代器<br/>
> -> 随机访问迭代器<br/>

对象指针可以始终充当随机访问迭代器，因此如果它支持对它指定的序列进行正确的读/写访问，则它可以充当任何类别的迭代器。

对象指针以外的迭代器 `Iterator` 还必须定义专用化 `iterator_traits<Iterator>` 所需的成员类型。 请注意，可以通过从公共基类 [iterator](../standard-library/iterator-struct.md) 派生 `Iterator` 来满足这些需求。

请务必了解每个迭代器类别的承诺和限制，以便了解 C++ 标准库中的容器和算法如何使用迭代器。

> [!NOTE]
> 可以使用范围 for 循环来避免显式使用迭代器。 有关详细信息，请参阅[基于范围的 for 语句](../cpp/range-based-for-statement-cpp.md)。

VisualC++现在提供经过检查的迭代器和调试迭代器，以确保不会覆盖容器的边界。 有关详细信息，请参阅[经过检查的迭代器](../standard-library/checked-iterators.md)和[调试迭代器支持](../standard-library/debug-iterator-support.md)。

## <a name="see-also"></a>请参阅

[C++ 标准库参考](../standard-library/cpp-standard-library-reference.md)<br/>
[C++ 标准库中的线程安全](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
