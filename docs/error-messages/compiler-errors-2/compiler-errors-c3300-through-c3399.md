---
title: 编译器错误 C3300 通过 C3399 |Microsoft 文档
ms.custom: ''
ms.date: 11/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
helpviewer_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
dev_langs:
- C++
ms.assetid: 190b7d29-ffe6-4261-921d-140da1935d00
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 4c5976e57e0a3b7f51c9df3fbdf3ebebb08dd1b4
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
---
# <a name="compiler-errors-c3300-through-c3399"></a>编译器错误 C3300 通过 C3399

本部分中的文档的文章说明由编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|Error|消息|
|-----------|-------------|
|编译器错误 C3300|*符号*: idl 的格式不正确*值*|
|编译器错误 C3301|*组件类*： 组件类不能为*符号*接口|
|编译器错误 C3302|*标识符*： 标识符具有多个*数*字符|
|[编译器错误 C3303](compiler-error-c3303.md)|*属性*： 属性仅对使用*类型*|
|编译器错误 C3304|已过时。|
|编译器错误 C3305|已过时。|
|编译器错误 C3306|*模板*： 不允许未命名的类模板/泛型|
|编译器错误 C3307|*模块*： 无法创建 IDL 模块|
|编译器错误 C3308|*函数*： 直接导入的类通过调用不支持|
|[编译器错误 C3309](compiler-error-c3309.md)|*宏*/*关键字*： 模块名称不能是宏或关键字|
|编译器错误 C3310|*标识符*： 模块名称冲突|
|编译器错误 C3311|模块特性必须在全局范围内定义|
|编译器错误 C3312|没有可调用*标识符*找到类型的函数*类型*|
|编译器错误 C3313|*标识符*： 变量不能是类型*类型*|
|编译器错误 C3314|*符号*： 不是受支持的 IDL 模块类型|
|编译器错误 C3315|*函数*： 必须是成员函数|
|编译器错误 C3316|*类型*': 未知的大小的数组不能用于在基于范围的语句|
|编译器错误 C3317|*标识符*： 重载函数不能用作对于语句中基于范围的表达式|
|编译器错误 C3318|*类型*： 数组不能具有包含 auto 的元素类型|
|编译器错误 C3319|已过时。|
|[编译器错误 C3320](compiler-error-c3320.md)|*类型*： 类型不能有与模块 'name' 属性相同的名称|
|编译器错误 C3321|初始值设定项列表并非在此上下文中|
|[编译器错误 C3322](compiler-error-c3322.md)|*属性*： 不是属性的有效属性*属性*|
|编译器错误 C3323|在函数声明上不允许 alignas 和 __declspec(align)|
|编译器错误 C3324|*属性*： 属性多次出现在属性*属性*|
|编译器错误 C3325|*属性*： 属性具有的参数太多|
|编译器错误 C3326|*值*： 不是属性的有效值*属性*of attribute*属性*|
|编译器错误 C3327|*属性*： 必须指定属性的属性的值*属性*|
|编译器错误 C3328|*属性*： 没有足够的参数属性。|
|编译器错误 C3329|语法错误： 预期*token1*not*token2*|
|编译器错误 C3330|*函数*: 函数不能返回数组*类型*|
|编译器错误 C3331|*标识符*： 参数上的属性只能在 COM 接口和组件类|
|编译器错误 C3332|*属性*： 语法不一致，属性*属性*是两个所需并具有一个默认|
|[编译器错误 C3333](compiler-error-c3333.md)|*库*： 无法 #import 损坏的类型库|
|[编译器错误 C3334](compiler-error-c3334.md)|无法 #import 损坏的类型库|
|编译器错误 C3335|*标识符*： 有最多只能包含一个默认接口的组件类的*类*|
|编译器错误 C3336|必须在类范围内执行此操作|
|编译器错误 C3337|*标识符*: defaultvtable 必须是事件源为组件类的*类*|
|编译器错误 C3338|*标识符*： 有最多只能包含一个默认接口，也是事件源为组件类的*类*|
|编译器错误 C3339|模板 template 参数在参数列表之后需要 class 或 typename|
|[编译器错误 C3340](compiler-error-c3340.md)|*标识符*： 接口不能为 restricted 和 default 在组件类的*类*|
|编译器错误 C3341|*接口*: defaultvtable 接口必须为双向或自定义|
|[编译器错误 C3342](compiler-error-c3342.md)|*标识符*： 不明确的特性|
|编译器错误 C3343|*类*::*名称*： 属性标识符包含字符过多|
|编译器错误 C3344|不能定义的显式专用化或部分专用化*符号*|
|[编译器错误 C3345](compiler-error-c3345.md)|*名称*： 模块名称的标识符无效|
|编译器错误 C3346|导出的声明中的非命名空间范围处|
|[编译器错误 C3347](compiler-error-c3347.md)|*参数*： 所需参数未指定属性中*asttribute*|
|编译器错误 C3348|导出的模板不是当前的 c + + 标准的一部分|
|编译器错误 C3349|*类*::*成员*： 已由提供程序实现多路广播的特性*提供程序*|
|[编译器错误 C3350](compiler-error-c3350.md)|*函数*： 委托构造函数需要*数*参数|
|[编译器错误 C3351](compiler-error-c3351.md)|*函数*： 如果将 NULL 对象实例传递给委托构造函数还必须传递静态成员函数的地址|
|[编译器错误 C3352](compiler-error-c3352.md)|*函数*： 指定的函数委托类型不匹配*类型*|
|[编译器错误 C3353](compiler-error-c3353.md)|*标识符*： 委托只能创建从全局函数或托管/WinRT 类型的成员函数|
|[编译器错误 C3354](compiler-error-c3354.md)|*标识符*： 用来创建委托的函数不能有返回类型*类型*|
|编译器错误 C3355|*类*::*成员*： 提供程序到侦听多路广播的特性*provider1*，但提供程序实现*provider2*|
|[编译器错误 C3356](compiler-error-c3356.md)|*标识符*： 不能调用具有完全限定名称的多路广播的特性|
|编译器错误 C3357|*属性*： 特性不明确，必须使用完全限定的名称|
|[编译器错误 C3358](compiler-error-c3358.md)|*符号*： 未找到符号|
|编译器错误 C3359|*专用化*： 无法专用化模板|
|[编译器错误 C3360](compiler-error-c3360.md)|*字符串*： 无法创建*名称*|
|编译器错误 C3361|没有在其中到上下文*操作*|
|编译器错误 C3362|*类*::*成员*： 未实现多路广播的特性|
|[编译器错误 C3363](compiler-error-c3363.md)|*标识符*: typeid 只能应用于类型|
|[编译器错误 C3364](compiler-error-c3364.md)|*函数*： 委托构造函数的参数无效; 目标必须是指向成员函数的指针的委托|
|[编译器错误 C3365](compiler-error-c3365.md)|运算符*运算符*： 区分类型的操作数*类型*和*类型*|
|[编译器错误 C3366](compiler-error-c3366.md)|*成员*： 必须在类定义中定义的管理/WinRT 类型的静态数据成员|
|[编译器错误 C3367](compiler-error-c3367.md)|*函数*： 不能使用静态函数创建未绑定的委托|
|[编译器错误 C3368](compiler-error-c3368.md)|*声明符*: idl 的调用约定无效|
|[编译器错误 C3369](compiler-error-c3369.md)|*模块*: idl_module 已经定义|
|[编译器错误 C3370](compiler-error-c3370.md)|*模块*: idl_module 尚未定义|
|[编译器错误 C3371](compiler-error-c3371.md)|“idl_module”: 此处只允许“name”属性|
|[编译器错误 C3372](compiler-error-c3372.md)|必须指定至少 1 个接口属性*属性*针对组件类|
|[编译器错误 C3373](compiler-error-c3373.md)|属性*属性*不带自变量除了针对组件类|
|[编译器错误 C3374](compiler-error-c3374.md)|不能采用的地址*函数*除非创建委托实例|
|[编译器错误 C3375](compiler-error-c3375.md)|*函数*： 不明确的委托函数|
|编译器错误 C3376|*模板*： 允许仅静态数据成员模板|
|编译器错误 C3377|在新表达式中不允许 decltype （auto）|
|编译器错误 C3378|可以仅从模块界面单元导出的声明|
|[编译器错误 C3379](compiler-error-c3379.md)|*类*： 嵌套的类不能将作为其声明的一部分的程序集访问说明符|
|[编译器错误 C3380](compiler-error-c3380.md)|*说明符*': 无效的程序集访问说明符-只允许 public 或 private|
|[编译器错误 C3381](compiler-error-c3381.md)|*说明符*： 程序集访问说明符才与 /clr 选项编译的代码中可用|
|[编译器错误 C3382](compiler-error-c3382.md)|不支持将“sizeof”与 /clr:safe 一同使用|
|[编译器错误 C3383](compiler-error-c3383.md)|不支持将“operator new”与 /clr:safe 一起使用|
|[编译器错误 C3384](compiler-error-c3384.md)|*类型*： 值约束与 ref 约束是互相排斥|
|[编译器错误 C3385](compiler-error-c3385.md)|*函数*： 具有 DllImport 自定义特性的函数不能返回类的实例|
|[编译器错误 C3386](compiler-error-c3386.md)|*类型*: /__declspec 到托管/WinRT 类型|
|[编译器错误 C3387](compiler-error-c3387.md)|*成员*: /__declspec 到托管/WinRT 类型的成员|
|[编译器错误 C3388](compiler-error-c3388.md)|*令牌*： 不允许作为约束，假定*值*以继续进行分析|
|[编译器错误 C3389](compiler-error-c3389.md)|__declspec (*说明符*) 不能与 /clr: pure 或 /clr: safe|
|[编译器错误 C3390](compiler-error-c3390.md)|*类型*： 泛型参数的类型参数无效*参数*of 泛型*generic_type*，必须是引用类型|
|[编译器错误 C3391](compiler-error-c3391.md)|*类型*： 泛型参数的类型参数无效*参数*of 泛型*generic_type*，必须是不可为 null 的值类型|
|[编译器错误 C3392](compiler-error-c3392.md)|*类型*： 泛型参数的类型参数无效*参数*of 泛型*generic_type*，必须具有公共无参数构造函数|
|[编译器错误 C3393](compiler-error-c3393.md)|constraint 子句的语法错误:*标识符*不是类型|
|[编译器错误 C3394](compiler-error-c3394.md)|constraint 子句的语法错误： 找到*符号*应为类型|
|[编译器错误 C3395](compiler-error-c3395.md)|*函数*: __declspec （dllexport） 不能与调用约定 __clrcall 应用于函数|
|[编译器错误 C3396](compiler-error-c3396.md)|*类*。*成员*： 中找不到自定义特性*命名空间*|
|[编译器错误 C3397](compiler-error-c3397.md)|默认参数中不允许进行聚合初始化|
|[编译器错误 C3398](compiler-error-c3398.md)|*运算符*： 不能从转换*类型*到*类型*。 源表达式必须是函数符号|
|[编译器错误 C3399](compiler-error-c3399.md)|*类型*： 创建泛型参数的实例时，无法提供变量|
