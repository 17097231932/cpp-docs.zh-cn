---
title: 翻译单位和联系（C++）
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 791ec53d4df863b218db463f2b9b9401bf6f466d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374315"
---
# <a name="translation-units-and-linkage"></a>翻译单元和链接

在C++程序中，*符号*（例如变量或函数名称）可以在其范围内声明任意次数，但只能定义一次。 此规则是"一个定义规则"（ODR）。 *声明*将名称引入（或重新引入）到程序中。 *定义*引入了名称。 如果名称表示变量，则定义显式初始化它。 *函数定义*由签名和函数体组成。 类定义由类名称后跟列出所有类成员块组成。 （成员函数的主体可以选择在另一个文件中单独定义。

下面的示例显示了一些声明：

```cpp
int i;
int f(int x);
class C;
```

下面的示例显示了一些定义：

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

程序由一个或多个*翻译单元*组成。 翻译单元由实现文件及其直接或间接包含的所有标头组成。 实现文件通常具有*cpp*或*cxx*的文件扩展名。 标题文件通常具有*h*或*hpp*的扩展名。 每个翻译单元由编译器独立编译。 编译完成后，链接器将编译的翻译单元合并到单个*程序中*。 违反 ODR 规则的行为通常将显示为链接器错误。 当同一名称在不同的翻译单元中有两个不同的定义时，将发生链接器错误。

通常，使变量跨多个文件可见的最佳方式是将其放入头文件中。 然后在每个需要声明的*cpp*文件中添加#include指令。 通过在标头内容周围添加*包含保护，* 可确保声明的名称仅定义一次。

在 C++20 中，[模块](modules-cpp.md)被引入作为标头文件的改进替代方法。

在某些情况下，可能需要在*cpp*文件中声明全局变量或类。 在这些情况下，您需要一种方法来告诉编译器和链接器名称具有什么样的*链接*。 链接类型指定对象的名称是只应用于一个文件还是适用于所有文件。 链接的概念仅适用于全球名称。 链接的概念不适用于在作用域内声明的名称。 作用域由一组封闭大括号（如函数或类定义）指定。

## <a name="external-vs-internal-linkage"></a>外部与内部联动

*自由函数*是在全局或命名空间作用域中定义的函数。 默认情况下，非全局变量和自由函数具有*外部链接*;它们从程序中的任何翻译单元可见。 因此，没有其他全局对象可以具有该名称。 具有*内部链接*或*无链接*的符号仅在声明它的翻译单元中可见。 当名称具有内部链接时，其他翻译单元中可能存在相同的名称。 使用类定义或函数体声明的变量没有链接。

可以通过显式声明全局名称为**静态**来强制全局名称具有内部链接。 这将将其可见性限制为声明它的同一翻译单元。 在此上下文中，**静态**表示与应用于局部变量时不同的东西。

默认情况下，以下对象具有内部链接：

- const 对象
- 缺点体物体
- typedefs
- 命名空间范围内的静态对象

要为 const 对象外部链接，请将其声明为**外部链接**并为其分配一个值：

```cpp
extern const int value = 42;
```

有关详细信息[，请参阅外部。](extern-cpp.md)

## <a name="see-also"></a>另请参阅

[基本概念](../cpp/basic-concepts-cpp.md)
