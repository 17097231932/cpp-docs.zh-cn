---
title: CDockablePane Class
ms.date: 10/18/2018
f1_keywords:
- CDockablePane
- AFXDOCKABLEPANE/CDockablePane
- AFXDOCKABLEPANE/CDockablePane::CDockablePane
- AFXDOCKABLEPANE/CDockablePane::AttachToTabWnd
- AFXDOCKABLEPANE/CDockablePane::CalcFixedLayout
- AFXDOCKABLEPANE/CDockablePane::CanAcceptMiniFrame
- AFXDOCKABLEPANE/CDockablePane::CanAcceptPane
- AFXDOCKABLEPANE/CDockablePane::CanAutoHide
- AFXDOCKABLEPANE/CDockablePane::CanBeAttached
- AFXDOCKABLEPANE/CDockablePane::ConvertToTabbedDocument
- AFXDOCKABLEPANE/CDockablePane::CopyState
- AFXDOCKABLEPANE/CDockablePane::Create
- AFXDOCKABLEPANE/CDockablePane::CreateDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::CreateEx
- AFXDOCKABLEPANE/CDockablePane::CreateTabbedPane
- AFXDOCKABLEPANE/CDockablePane::DockPaneContainer
- AFXDOCKABLEPANE/CDockablePane::DockPaneStandard
- AFXDOCKABLEPANE/CDockablePane::DockToRecentPos
- AFXDOCKABLEPANE/CDockablePane::DockToWindow
- AFXDOCKABLEPANE/CDockablePane::EnableAutohideAll
- AFXDOCKABLEPANE/CDockablePane::EnableGripper
- AFXDOCKABLEPANE/CDockablePane::GetAHRestoredRect
- AFXDOCKABLEPANE/CDockablePane::GetAHSlideMode
- AFXDOCKABLEPANE/CDockablePane::GetCaptionHeight
- AFXDOCKABLEPANE/CDockablePane::GetDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::GetDockingStatus
- AFXDOCKABLEPANE/CDockablePane::GetDragSensitivity
- AFXDOCKABLEPANE/CDockablePane::GetLastPercentInPaneContainer
- AFXDOCKABLEPANE/CDockablePane::GetTabArea
- AFXDOCKABLEPANE/CDockablePane::GetTabbedPaneRTC
- AFXDOCKABLEPANE/CDockablePane::HasAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::HitTest
- AFXDOCKABLEPANE/CDockablePane::IsAutohideAllEnabled
- AFXDOCKABLEPANE/CDockablePane::IsAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::IsDocked
- AFXDOCKABLEPANE/CDockablePane::IsHideInAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::IsInFloatingMultiPaneFrameWnd
- AFXDOCKABLEPANE/CDockablePane::IsResizable
- AFXDOCKABLEPANE/CDockablePane::IsTabLocationBottom
- AFXDOCKABLEPANE/CDockablePane::IsTracked
- AFXDOCKABLEPANE/CDockablePane::IsVisible
- AFXDOCKABLEPANE/CDockablePane::OnAfterChangeParent
- AFXDOCKABLEPANE/CDockablePane::OnAfterDockFromMiniFrame
- AFXDOCKABLEPANE/CDockablePane::OnBeforeChangeParent
- AFXDOCKABLEPANE/CDockablePane::OnBeforeFloat
- AFXDOCKABLEPANE/CDockablePane::RemoveFromDefaultPaneDividier
- AFXDOCKABLEPANE/CDockablePane::ReplacePane
- AFXDOCKABLEPANE/CDockablePane::RestoreDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::SetAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::SetAutoHideParents
- AFXDOCKABLEPANE/CDockablePane::SetLastPercentInPaneContainer
- AFXDOCKABLEPANE/CDockablePane::SetRestoredDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::SetTabbedPaneRTC
- AFXDOCKABLEPANE/CDockablePane::ShowPane
- AFXDOCKABLEPANE/CDockablePane::Slide
- AFXDOCKABLEPANE/CDockablePane::ToggleAutoHide
- AFXDOCKABLEPANE/CDockablePane::UndockPane
- AFXDOCKABLEPANE/CDockablePane::CheckAutoHideCondition
- AFXDOCKABLEPANE/CDockablePane::CheckStopSlideCondition
- AFXDOCKABLEPANE/CDockablePane::DrawCaption
- AFXDOCKABLEPANE/CDockablePane::OnPressButtons
- AFXDOCKABLEPANE/CDockablePane::OnSlide
- AFXDOCKABLEPANE/CDockablePane::m_bDisableAnimation
- AFXDOCKABLEPANE/CDockablePane::m_bHideInAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::m_nSlideSteps
helpviewer_keywords:
- CDockablePane [MFC], CDockablePane
- CDockablePane [MFC], AttachToTabWnd
- CDockablePane [MFC], CalcFixedLayout
- CDockablePane [MFC], CanAcceptMiniFrame
- CDockablePane [MFC], CanAcceptPane
- CDockablePane [MFC], CanAutoHide
- CDockablePane [MFC], CanBeAttached
- CDockablePane [MFC], ConvertToTabbedDocument
- CDockablePane [MFC], CopyState
- CDockablePane [MFC], Create
- CDockablePane [MFC], CreateDefaultPaneDivider
- CDockablePane [MFC], CreateEx
- CDockablePane [MFC], CreateTabbedPane
- CDockablePane [MFC], DockPaneContainer
- CDockablePane [MFC], DockPaneStandard
- CDockablePane [MFC], DockToRecentPos
- CDockablePane [MFC], DockToWindow
- CDockablePane [MFC], EnableAutohideAll
- CDockablePane [MFC], EnableGripper
- CDockablePane [MFC], GetAHRestoredRect
- CDockablePane [MFC], GetAHSlideMode
- CDockablePane [MFC], GetCaptionHeight
- CDockablePane [MFC], GetDefaultPaneDivider
- CDockablePane [MFC], GetDockingStatus
- CDockablePane [MFC], GetDragSensitivity
- CDockablePane [MFC], GetLastPercentInPaneContainer
- CDockablePane [MFC], GetTabArea
- CDockablePane [MFC], GetTabbedPaneRTC
- CDockablePane [MFC], HasAutoHideMode
- CDockablePane [MFC], HitTest
- CDockablePane [MFC], IsAutohideAllEnabled
- CDockablePane [MFC], IsAutoHideMode
- CDockablePane [MFC], IsDocked
- CDockablePane [MFC], IsHideInAutoHideMode
- CDockablePane [MFC], IsInFloatingMultiPaneFrameWnd
- CDockablePane [MFC], IsResizable
- CDockablePane [MFC], IsTabLocationBottom
- CDockablePane [MFC], IsTracked
- CDockablePane [MFC], IsVisible
- CDockablePane [MFC], OnAfterChangeParent
- CDockablePane [MFC], OnAfterDockFromMiniFrame
- CDockablePane [MFC], OnBeforeChangeParent
- CDockablePane [MFC], OnBeforeFloat
- CDockablePane [MFC], RemoveFromDefaultPaneDividier
- CDockablePane [MFC], ReplacePane
- CDockablePane [MFC], RestoreDefaultPaneDivider
- CDockablePane [MFC], SetAutoHideMode
- CDockablePane [MFC], SetAutoHideParents
- CDockablePane [MFC], SetLastPercentInPaneContainer
- CDockablePane [MFC], SetRestoredDefaultPaneDivider
- CDockablePane [MFC], SetTabbedPaneRTC
- CDockablePane [MFC], ShowPane
- CDockablePane [MFC], Slide
- CDockablePane [MFC], ToggleAutoHide
- CDockablePane [MFC], UndockPane
- CDockablePane [MFC], CheckAutoHideCondition
- CDockablePane [MFC], CheckStopSlideCondition
- CDockablePane [MFC], DrawCaption
- CDockablePane [MFC], OnPressButtons
- CDockablePane [MFC], OnSlide
- CDockablePane [MFC], m_bDisableAnimation
- CDockablePane [MFC], m_bHideInAutoHideMode
- CDockablePane [MFC], m_nSlideSteps
ms.assetid: e2495f4c-765f-48f9-a2e2-e45e47608d91
ms.openlocfilehash: 657f71e5d89f7d91d8b44836b4d478b41d041f88
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/31/2018
ms.locfileid: "50623010"
---
# <a name="cdockablepane-class"></a>CDockablePane Class

实现可在停靠站点停靠或包含在选项卡式窗格中的窗格。

## <a name="syntax"></a>语法

```
class CDockablePane : public CPane
```

## <a name="members"></a>成员

### <a name="public-constructors"></a>公共构造函数

|名称|描述|
|----------|-----------------|
|[CDockablePane::CDockablePane](#cdockablepane)|构造并初始化一个 `CDockablePane` 对象。|

### <a name="public-methods"></a>公共方法

|名称|描述|
|----------|-----------------|
|[Cdockablepane:: Attachtotabwnd](#attachtotabwnd)|将一个窗格，附加到另一个窗格。 这将创建选项卡式的窗格。|
|[CDockablePane::CalcFixedLayout](#calcfixedlayout)|返回窗格矩形的大小。|
|[CDockablePane::CanAcceptMiniFrame](#canacceptminiframe)|确定指定的最小范围是否可停靠到窗格。|
|[CDockablePane::CanAcceptPane](#canacceptpane)|确定是否可以将另一个窗格停靠到当前的窗格。|
|[CDockablePane::CanAutoHide](#canautohide)|确定在窗格是否支持自动隐藏模式。 (重写[CBasePane::CanAutoHide](../../mfc/reference/cbasepane-class.md#canautohide)。)|
|[CDockablePane::CanBeAttached](#canbeattached)|确定是否可以将当前窗格停靠到另一个窗格。|
|[CDockablePane::ConvertToTabbedDocument](#converttotabbeddocument)|将一个或多个可停靠窗格转换为 MDI 选项卡式文档。|
|[CDockablePane::CopyState](#copystate)|将复制的可停靠窗格的状态。|
|[CDockablePane::Create](#create)|创建 Windows 控件，并将其附加到`CDockablePane`对象。|
|[CDockablePane::CreateDefaultPaneDivider](#createdefaultpanedivider)|创建到框架窗口停靠的窗格中的默认分隔符。|
|[Cdockablepane:: Createex](#createex)|创建 Windows 控件，并将其附加到`CDockablePane`对象。|
|[CDockablePane::CreateTabbedPane](#createtabbedpane)|从当前窗格创建选项卡式的窗格。|
|[CDockablePane::DockPaneContainer](#dockpanecontainer)|将容器停靠到窗格。|
|[CDockablePane::DockPaneStandard](#dockpanestandard)|将窗格停靠使用大纲 （标准） 停靠。|
|`CDockablePane::DockToFrameWindow`|内部使用。 若要将停靠窗格，请使用[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)或[CDockablePane::DockToWindow](#docktowindow)。|
|[CDockablePane::DockToRecentPos](#docktorecentpos)|将一个窗格停靠到其存储最近的停靠位置。|
|[CDockablePane::DockToWindow](#docktowindow)|将一个停靠窗格停靠到另一个停靠窗格。|
|[CDockablePane::EnableAutohideAll](#enableautohideall)|启用或禁用此窗格以及在容器中的其他窗格的自动隐藏模式。|
|[CDockablePane::EnableGripper](#enablegripper)|显示或隐藏的标题 （手柄）。|
|[CDockablePane::GetAHRestoredRect](#getahrestoredrect)|指定窗格可见自动隐藏模式下时的位置。|
|[CDockablePane::GetAHSlideMode](#getahslidemode)|检索在窗格的自动隐藏幻灯片模式。|
|`CDockablePane::GetAutoHideButton`|内部使用。|
|`CDockablePane::GetAutoHideToolBar`|内部使用。|
|[CDockablePane::GetCaptionHeight](#getcaptionheight)|返回当前标题的高度。|
|[CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)|返回窗格的容器的默认窗格分隔符。|
|[CDockablePane::GetDockingStatus](#getdockingstatus)|确定一个窗格的停靠的功能根据提供的指针位置。|
|[CDockablePane::GetDragSensitivity](#getdragsensitivity)|返回停靠窗格拖动的敏感性。|
|[CDockablePane::GetLastPercentInPaneContainer](#getlastpercentinpanecontainer)|检索一个窗格，其容器中所占据的空间的百分比。|
|[CDockablePane::GetTabArea](#gettabarea)|检索在窗格的选项卡区域。|
|[CDockablePane::GetTabbedPaneRTC](#gettabbedpanertc)|返回有关另一个窗格将停靠到当前窗格时，会创建一个选项卡式窗口的运行时类信息。|
|[CDockablePane::HasAutoHideMode](#hasautohidemode)|指定是否可停靠窗格切换为自动隐藏模式。|
|[CDockablePane::HitTest](#hittest)|当用户单击鼠标的窗格中指定的特定位置。|
|`CDockablePane::IsAccessibilityCompatible`|内部使用。|
|[CDockablePane::IsAutohideAllEnabled](#isautohideallenabled)|指示是否可以在自动隐藏模式下放置停靠窗格和在容器中的所有其他窗格。|
|[CDockablePane::IsAutoHideMode](#isautohidemode)|确定一个窗格是否处于自动隐藏模式。|
|`CDockablePane::IsChangeState`|内部使用。|
|[CDockablePane::IsDocked](#isdocked)|确定是否当前窗格停靠。|
|[CDockablePane::IsHideInAutoHideMode](#ishideinautohidemode)|确定的行为的窗格，只是在自动隐藏模式下，如果它是显示 （或隐藏） 通过调用`ShowPane`。|
|[CDockablePane::IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定窗格是否在多窗格框架窗口中。|
|[CDockablePane::IsResizable](#isresizable)|指定是否可以在窗格的大小。|
|[CDockablePane::IsTabLocationBottom](#istablocationbottom)|指定是否将选项卡位于顶部或底部窗格中。|
|[CDockablePane::IsTracked](#istracked)|指定是否正在由用户拖动一个窗格。|
|[CDockablePane::IsVisible](#isvisible)|确定当前窗格是否可见。|
|[Cdockablepane:: Loadstate](#loadstate)|内部使用。|
|[CDockablePane::OnAfterChangeParent](#onafterchangeparent)|一个窗格的父级发生更改时由框架调用。 (重写[CPane::OnAfterChangeParent](../../mfc/reference/cpane-class.md#onafterchangeparent)。)|
|[CDockablePane::OnAfterDockFromMiniFrame](#onafterdockfromminiframe)|浮动的停靠栏将停靠在框架窗口时由框架调用。|
|[CDockablePane::OnBeforeChangeParent](#onbeforechangeparent)|在窗格的父即将更改时由框架调用。 (重写[CPane::OnBeforeChangeParent](../../mfc/reference/cpane-class.md#onbeforechangeparent)。)|
|[CDockablePane::OnBeforeFloat](#onbeforefloat)|当窗格时有关为浮点数，由框架调用。 (重写[CPane::OnBeforeFloat](../../mfc/reference/cpane-class.md#onbeforefloat)。)|
|[CDockablePane::RemoveFromDefaultPaneDividier](#removefromdefaultpanedividier)|移除一个窗格时，框架将调用此方法。|
|[CDockablePane::ReplacePane](#replacepane)|替换指定的窗格中的窗格。|
|[CDockablePane::RestoreDefaultPaneDivider](#restoredefaultpanedivider)|框架调用此方法窗格是反序列化以还原默认窗格分隔符。|
|`CDockablePane::SaveState`|内部使用。|
|`CDockablePane::Serialize`|序列化窗格。 （重写 `CBasePane::Serialize`。）|
|[CDockablePane::SetAutoHideMode](#setautohidemode)|切换可见停靠窗格和自动隐藏模式。|
|[CDockablePane::SetAutoHideParents](#setautohideparents)|设置自动隐藏按钮和窗格中的自动隐藏工具栏。|
|`CDockablePane::SetDefaultPaneDivider`|内部使用。|
|[CDockablePane::SetLastPercentInPaneContainer](#setlastpercentinpanecontainer)|设置一个窗格，其容器中所占据的空间的百分比。|
|`CDockablePane::SetResizeMode`|内部使用。|
|[CDockablePane::SetRestoredDefaultPaneDivider](#setrestoreddefaultpanedivider)|还原的默认窗格分隔符设置。|
|[Cdockablepane:: Settabbedpanertc](#settabbedpanertc)|设置两个窗格停靠在一起时，会创建一个选项卡式窗口的运行时类信息。|
|[CDockablePane::ShowPane](#showpane)|显示或隐藏窗格。|
|[CDockablePane::Slide](#slide)|显示或隐藏具有一个滑动动画，其中显示了仅当窗格处于自动隐藏模式时的窗格。|
|[CDockablePane::ToggleAutoHide](#toggleautohide)|切换自动隐藏模式。 (重写[CPane::ToggleAutoHide](../../mfc/reference/cpane-class.md#toggleautohide) 。)|
|[CDockablePane::UndockPane](#undockpane)|从主框架窗口或袖珍框架窗口容器窗格中取消停靠。|
|`CDockablePane::UnSetAutoHideMode`|内部使用。 若要设置自动隐藏模式，请使用[CDockablePane::SetAutoHideMode](#setautohidemode)|

### <a name="protected-methods"></a>受保护的方法

|名称|描述|
|----------|-----------------|
|[CDockablePane::CheckAutoHideCondition](#checkautohidecondition)|确定是否 （在自动隐藏模式下） 隐藏停靠窗格。|
|[CDockablePane::CheckStopSlideCondition](#checkstopslidecondition)|确定何时自动隐藏停靠窗格应停止滑动。|
|[CDockablePane::DrawCaption](#drawcaption)|绘制的停靠窗格标题 （手柄）。|
|[CDockablePane::OnPressButtons](#onpressbuttons)|当用户按下的 AFX_HTCLOSE 和 AFX_HTMAXBUTTON 按钮之外的一个标题按钮时调用。|
|[CDockablePane::OnSlide](#onslide)|由框架调用以呈现自动隐藏滑动效果时显示或隐藏窗格。|

### <a name="data-members"></a>数据成员

|name|描述|
|----------|-----------------|
|[CDockablePane::m_bDisableAnimation](#m_bdisableanimation)|指定是否禁用自动隐藏可停靠窗格的动画。|
|[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)|当窗格处于自动隐藏模式时，请确定窗格的行为。|
|[CDockablePane::m_nSlideSteps](#m_nslidesteps)|指定动画速度的窗格时进行显示或隐藏在自动隐藏模式下。|

## <a name="remarks"></a>备注

`CDockablePane` 实现以下功能：

- 到主框架窗口停靠窗格。

- 切换到自动隐藏模式下一个窗格。

- 将一个窗格，附加到选项卡式窗口。

- 浮动微型框窗口中的窗格。

- 到浮动微型框窗口中的另一个窗格的停靠窗格。

- 调整窗格的大小。

- 加载和保存状态的停靠窗格。

    > [!NOTE]
    >  状态信息保存到 Windows 注册表。

- 使用或不带标题，请创建一个窗格。 标题可以包含文本标签，并且它可以为填充渐变颜色。

- 在显示窗格的内容的同时拖动一个窗格

- 将一个窗格拖动时显示的拖动矩形。

若要在应用程序中使用停靠的窗格中，派生从窗格类`CDockablePane`类。 到主框架窗口对象或窗口对象，用于控制您的窗格的实例，或者嵌入派生的对象。 然后调用[CDockablePane::Create](#create)方法或[cdockablepane:: Createex](#createex)方法处理主框架窗口中的 WM_CREATE 消息时。 最后，设置窗格对象通过调用[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)， [cbasepane:: Dockpane](../../mfc/reference/cbasepane-class.md#dockpane)，或[cdockablepane:: Attachtotabwnd](#attachtotabwnd)。

## <a name="customization-tips"></a>自定义提示

以下提示适用于`CDockablePane`对象：

- 如果您调用[cdockablepane:: Attachtotabwnd](#attachtotabwnd)对于两个非选项卡式、 可停靠窗格，指向选项卡式窗口的指针将返回在*ppTabbedControlBar*参数。 您可以继续使用此参数将选项卡添加到选项卡式窗口。

- 这个选项卡式窗格中创建的[cdockablepane:: Attachtotabwnd](#attachtotabwnd)由`CDockablePane`对象中*pTabControlBarAttachTo*参数。 您可以调用[cdockablepane:: Settabbedpanertc](#settabbedpanertc)到设置类型的选项卡式窗格`CDockablePane`将创建。 默认类型由`dwTabbedStyle`的[CDockablePane::Create](#create)当你首次创建`CDockablePane`。 如果*dwTabbedStyle*是默认类型是的 AFX_CBRS_OUTLOOK_TABS [CMFCOutlookBar 类](../../mfc/reference/cmfcoutlookbar-class.md); 如果*dwTabbedStyle* AFX_CBRS_REGULAR_TABS 默认类型是[CTabbedPane 类](../../mfc/reference/ctabbedpane-class.md)。

- 如果你想要将一个可停靠窗格停靠到另一台，则调用[CDockablePane::DockToWindow](#docktowindow)方法。 原始窗格必须停靠位置然后再调用此方法。

- 成员变量[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)控件如何可停靠窗格的行为方式在自动隐藏模式下调用时[CDockablePane::ShowPane](#showpane)。 如果此成员变量设置为 TRUE，将隐藏可停靠窗格和其自动隐藏按钮。 否则，它们将滑入和签出。

- 可以通过设置禁用自动隐藏动画[CDockablePane::m_bDisableAnimation](#m_bdisableanimation)成员变量为 TRUE。

## <a name="example"></a>示例

下面的示例演示如何配置`CDockablePane`通过使用中的各种方法的对象`CDockablePane`类。 该示例演示了如何以启用自动隐藏可停靠的窗格中的所有功能、 标题或控制手柄，都启用自动隐藏模式，显示窗格中，和窗格，只是在自动隐藏模式下进行动画处理。 此代码片段属于[Visual Studio 演示示例](../../visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#27](../../mfc/codesnippet/cpp/cdockablepane-class_1.cpp)]
[!code-cpp[NVC_MFC_VisualStudioDemo#28](../../mfc/codesnippet/cpp/cdockablepane-class_2.cpp)]

## <a name="inheritance-hierarchy"></a>继承层次结构

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

[CPane](../../mfc/reference/cpane-class.md)

[CDockablePane](../../mfc/reference/cdockablepane-class.md)

## <a name="requirements"></a>要求

**标头：** afxDockablePane.h

##  <a name="attachtotabwnd"></a>  Cdockablepane:: Attachtotabwnd

将当前窗格附加到目标窗格中，创建选项卡式的窗格。

```
virtual CDockablePane* AttachToTabWnd(
    CDockablePane* pTabControlBarAttachTo,
    AFX_DOCK_METHOD dockMethod,
    BOOL bSetActive= TRUE,
    CDockablePane** ppTabbedControlBar = NULL);
```

### <a name="parameters"></a>参数

*pTabControlBarAttachTo*<br/>
[in、 out]指定当前窗格将附加到的目标窗格。 目标窗格中必须是可停靠窗格。

*dockMethod*<br/>
[in]指定的扩展方法。

*bSetActive*<br/>
[in]为 TRUE，则在附加操作; 后激活的选项卡式的窗格否则为 FALSE。

*ppTabbedControlBar*<br/>
[out]包含附加操作生成的选项卡式的窗格。

### <a name="return-value"></a>返回值

指向当前窗格中，如果它不是选项卡式的窗格中;否则为指向附加操作生成的选项卡式窗格的指针。 如果不能附加当前窗格中，或如果出错，则返回值为 NULL。

### <a name="remarks"></a>备注

当一个可停靠窗格附加到另一个窗格，使用此方法时，将发生以下情况：

1. Framework 检查是否在目标窗格*pTabControlBarAttachTo*一个常规停靠窗格或如果它派生自[CBaseTabbedPane](../../mfc/reference/cbasetabbedpane-class.md)。

1. 如果目标窗格中，选项卡式的窗格框架当前窗格向其添加为一个选项卡。

1. 如果目标窗格中是一个常规的停靠窗格，框架将创建选项卡式的窗格。

   - 框架将调用`pTabControlBarAttachTo->CreateTabbedPane`。 新选项卡式窗格样式取决于`m_pTabbedControlBarRTC`成员。 默认情况下，此成员设置为运行时类的[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。 如果通过 AFX_CBRS_OUTLOOK_TABS 样式作为*dwTabbedStyle*参数[CDockablePane::Create](#create)方法中，运行时类对象设置为运行时类的[CMFCOutlookBar](../../mfc/reference/cmfcoutlookbar-class.md)。 您可以在任何时候若要更改的新窗格样式更改此成员。

   - 当此方法创建选项卡式的窗格时，框架将替换指向的指针*pTabControlBarAttachTo* （如果窗格处于停靠状态还是浮动多微型框窗口） 用一个指针指向新的选项卡式窗格。

   - 该框架将添加*pTabControlBarAttachTo*到选项卡式窗格中，作为第一个选项卡的窗格。然后，框架将当前窗格添加作为第二个选项卡。

1. 如果当前窗格派生自`CBaseTabbedPane`，所有其选项卡移动到*pTabControlBarAttachTo*和销毁当前窗格。 因此，要小心时调用此方法，因为该方法将返回指向当前窗格的指针可能无效。

如果生成停靠布局时，可附加到另一个窗格，设置`dockMethod`DM_SHOW 到。

然后将另一个窗格附加到该控件应该停靠的第一个窗格。

##  <a name="calcfixedlayout"></a>  CDockablePane::CalcFixedLayout

返回窗格矩形的大小。

```
virtual CSize CalcFixedLayout(
    BOOL bStretch,
    BOOL bHorz);
```

### <a name="parameters"></a>参数

*bStretch*<br/>
[in]不使用。

*bHorz*<br/>
[in]不使用。

### <a name="return-value"></a>返回值

一个`CSize`对象，其中包含的窗格中矩形的大小。

##  <a name="canacceptminiframe"></a>  CDockablePane::CanAcceptMiniFrame

确定是否为指定的最小化框架可停靠到窗格。

```
virtual BOOL CanAcceptMiniFrame(CPaneFrameWnd* pMiniFrame) const;
```

### <a name="parameters"></a>参数

*pMiniFrame*<br/>
[in]指向`CPaneFrameWnd`对象。

### <a name="return-value"></a>返回值

则为 TRUE *pMiniFrame*可停靠到窗格中; 否则为 FALSE。

##  <a name="canacceptpane"></a>  CDockablePane::CanAcceptPane

确定是否可以将另一个窗格停靠到当前的窗格。

```
virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
```

### <a name="parameters"></a>参数

*pBar*<br/>
[in]指定当前窗格停靠的窗格。

### <a name="return-value"></a>返回值

如果指定的窗格可停靠此窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

前一个窗格停靠到当前窗格中，框架将调用此方法。

重写此函数在派生类来启用或禁用停靠到特定窗格中。

默认情况下，此方法返回 TRUE，如果任一*pBar*或其父类型`CDockablePane`。

##  <a name="canautohide"></a>  CDockablePane::CanAutoHide

确定是否在窗格可以自动隐藏。

```
virtual BOOL CanAutoHide() const;
```

### <a name="return-value"></a>返回值

如果窗格可以自动隐藏，则返回 TRUE;否则为 FALSE。

### <a name="remarks"></a>备注

`CDockablePane::CanAutoHide` 在任何以下情况下，返回 FALSE:

- 则窗格会显示没有父级。

- 到停靠管理器不允许要自动隐藏的窗格。

- 未停靠窗格。

##  <a name="canbeattached"></a>  CDockablePane::CanBeAttached

确定是否可以将当前窗格停靠到另一个窗格。

```
virtual BOOL CanBeAttached() const;
```

### <a name="return-value"></a>返回值

可停靠窗格可停靠到另一个窗格或主框架窗口中; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

默认情况下，此方法始终返回 TRUE。 重写此方法在派生类来启用或禁用而无需调用停靠[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)。

##  <a name="cdockablepane"></a>  CDockablePane::CDockablePane

构造并初始化[CDockablePane](../../mfc/reference/cdockablepane-class.md)对象。

```
CDockablePane();
```

### <a name="remarks"></a>备注

构造一个可停靠窗格对象后，调用[CDockablePane::Create](#create)或[cdockablepane:: Createex](#createex)来创建它。

##  <a name="converttotabbeddocument"></a>  CDockablePane::ConvertToTabbedDocument

将一个或多个可停靠窗格转换为 MDI 选项卡式文档。

```
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```

### <a name="parameters"></a>参数

*bActiveTabOnly*<br/>
[in]转换时`CTabbedPane`，指定为 TRUE，则转换仅活动选项卡。指定为 FALSE，则将在窗格中的所有制表符都转换。

##  <a name="checkautohidecondition"></a>  CDockablePane::CheckAutoHideCondition

确定是否 （也称为自动隐藏模式下） 隐藏停靠窗格。

```
virtual BOOL CheckAutoHideCondition();
```

### <a name="return-value"></a>返回值

如果满足隐藏条件; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

框架将使用一个计时器以定期检查是否隐藏自动隐藏可停靠窗格。 当窗格未处于活动状态时，窗格未正在调整大小，鼠标指针不是窗格上方，则该方法返回 TRUE。

如果满足所有以前的条件，框架将调用[CDockablePane::Slide](#slide)要隐藏窗格。

##  <a name="checkstopslidecondition"></a>  CDockablePane::CheckStopSlideCondition

确定何时自动隐藏停靠窗格应停止滑动。

```
virtual BOOL CheckStopSlideCondition(BOOL bDirection);
```

### <a name="parameters"></a>参数

*bDirection*<br/>
[in]如果窗格可见，则为 TRUE如果窗格将隐藏，则为 FALSE。

### <a name="return-value"></a>返回值

如果满足的停止条件; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

当可停靠窗格设置为自动隐藏模式下时，框架将使用滑动效果来显示或隐藏窗格。 滑动窗格时，框架将调用此函数。 `CheckStopSlideCondition` 当窗格时完全可见或完全隐藏时，则返回 TRUE。

重写此方法在派生类来实现自定义自动隐藏效果。

##  <a name="copystate"></a>  CDockablePane::CopyState

将复制的可停靠窗格的状态。

```
virtual void CopyState(CDockablePane* pOrgBar);
```

### <a name="parameters"></a>参数

*pOrgBar*<br/>
[in]指向可停靠窗格的指针。

### <a name="remarks"></a>备注

`CDockablePane::CopyState` 将复制的状态*pOrgBar*到当前窗格通过调用以下方法：

- [CPane::CopyState](../../mfc/reference/cpane-class.md#copystate)

- [CDockablePane::GetAHRestoredRect](#getahrestoredrect)

- [CDockablePane::GetAHSlideMode](#getahslidemode)

- [CDockablePane::GetLastPercentInPaneContainer](#getlastpercentinpanecontainer)

- [CDockablePane::IsAutohideAllEnabled](#isautohideallenabled)

##  <a name="create"></a>  CDockablePane::Create

创建 Windows 控件，并将其附加到[CDockablePane](../../mfc/reference/cdockablepane-class.md)对象。

```
virtual BOOL Create(
    LPCTSTR lpszCaption,
    CWnd* pParentWnd,
    const RECT& rect,
    BOOL bHasGripper,
    UINT nID,
    DWORD dwStyle,
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE,
    CCreateContext* pContext = NULL);

virtual BOOL Create(
    LPCTSTR lpszWindowName,
    CWnd* pParentWnd,
    CSize sizeDefault,
    BOOL bHasGripper,
    UINT nID,
    DWORD dwStyle = WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE,
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE);
```

### <a name="parameters"></a>参数

*lpszCaption*<br/>
[in]指定窗口名称。

*pParentWnd*<br/>
[in、 out]指定的父窗口。

*rect*<br/>
[in]指定的大小和窗口的位置中的客户端坐标*pParentWnd*。

*bHasGripper*<br/>
[in]为 TRUE，则用标题; 创建窗格否则为 FALSE。

*nID*<br/>
[in]指定的子窗口的 ID。 此值必须是唯一的如果你想要保存此停靠窗格的停靠状态。

*dwStyle*<br/>
[in]指定的窗口样式特性。

*dwTabbedStyle*<br/>
[in]指定在用户拖动一个窗格，在此窗格的标题上时创建的选项卡式窗口的选项卡式的样式。

*dwControlBarStyle*<br/>
[in]指定其他样式特性。

*pContext*<br/>
[in、 out]指定窗口的创建上下文。

*lpszWindowName*<br/>
[in]指定窗口名称。

*大小*<br/>
[in]指定窗口的大小。

### <a name="return-value"></a>返回值

如果已成功创建可停靠窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

创建 Windows 窗格，并将其附加到`CDockablePane`对象。

如果*dwStyle*窗口样式有 CBRS_FLOAT_MULTI 标志，都可以与袖珍框架窗口中的其他窗格是浮动微型框窗口。 默认情况下，停靠窗格可以只浮动单独。

如果*dwTabbedStyle*参数指定了 AFX_CBRS_OUTLOOK_TABS 标志，窗格创建 Outlook 样式的选项卡式窗格时另一个窗格附加到此窗格使用[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法。 默认情况下可停靠窗格创建类型的常规选项卡式的窗格[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。

##  <a name="createdefaultpanedivider"></a>  CDockablePane::CreateDefaultPaneDivider

创建到框架窗口停靠的窗格中的默认分隔符。

```
static CPaneDivider* __stdcall CreateDefaultPaneDivider(
    DWORD dwAlignment,
    CWnd* pParent,
    CRuntimeClass* pSliderRTC = NULL);
```

### <a name="parameters"></a>参数

*dwAlignment*<br/>
[in]指定的端到停靠窗格主框架。 如果*dwAlignment*包含 CBRS_ALIGN_LEFT 或 CBRS_ALIGN_RIGHT 标志，此方法创建垂直 (`CPaneDivider::SS_VERT`) 分隔线; 否则，此方法创建水平 (`CPaneDivider::SS_HORZ`) 分隔符。

*pParent*<br/>
[in]指向父帧指针。

*pSliderRTC*<br/>
[in]不使用。

### <a name="return-value"></a>返回值

如果分隔符创建失败，此方法返回新创建的分隔线，或者为 NULL 指针。

### <a name="remarks"></a>备注

*dwAlignment*可以是任何以下值：

|“值”|描述|
|-----------|-----------------|
|CBRS_ALIGN_TOP|框架窗口的工作区的顶部停靠窗格。|
|CBRS_ALIGN_BOTTOM|框架窗口的工作区的底部停靠窗格。|
|CBRS_ALIGN_LEFT|左侧和右侧的框架窗口的客户端区域停靠窗格。|
|CBRS_ALIGN_RIGHT|框架窗口的客户端区域的右侧被停靠窗格。|

##  <a name="createex"></a>  Cdockablepane:: Createex

创建 Windows 控件，并将其附加到[CDockablePane](../../mfc/reference/cdockablepane-class.md)对象。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszCaption,
    CWnd* pParentWnd,
    const RECT& rect,
    BOOL bHasGripper,
    UINT nID,
    DWORD dwStyle,
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>参数

*dwStyleEx*<br/>
[in]指定新的窗口的扩展的样式属性。

*lpszCaption*<br/>
[in]指定窗口名称。

*pParentWnd*<br/>
[in、 out]指定的父窗口。

*rect*<br/>
[in]指定的大小和窗口的位置中的客户端坐标*pParentWnd*。

*bHasGripper*<br/>
[in]为 TRUE，则用标题; 创建窗格否则为 FALSE。

*nID*<br/>
[in]指定的子窗口的 ID。 此值必须是唯一的如果你想要保存此停靠窗格的停靠状态。

*dwStyle*<br/>
[in]指定的窗口样式特性。

*dwTabbedStyle*<br/>
[in]指定在用户拖动一个窗格，在此窗格的标题上时创建的选项卡式窗口的选项卡式的样式。

*dwControlBarStyle*<br/>
[in]指定其他样式特性。

*pContext*<br/>
[in、 out]指定窗口的创建上下文。

### <a name="return-value"></a>返回值

如果已成功创建可停靠窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

创建 Windows 窗格，并将其附加到`CDockablePane`对象。

如果*dwStyle*窗口样式有 CBRS_FLOAT_MULTI 标志，都可以与袖珍框架窗口中的其他窗格是浮动微型框窗口。 默认情况下，停靠窗格可以只浮动单独。

如果*dwTabbedStyle*参数指定了 AFX_CBRS_OUTLOOK_TABS 标志，窗格创建 Outlook 样式的选项卡式窗格时另一个窗格附加到此窗格使用[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法。 默认情况下可停靠窗格创建类型的常规选项卡式的窗格[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。

##  <a name="createtabbedpane"></a>  CDockablePane::CreateTabbedPane

从当前窗格创建选项卡式的窗格。

```
virtual CTabbedPane* CreateTabbedPane();
```

### <a name="return-value"></a>返回值

新选项卡式的窗格中或如果创建操作失败，则为 NULL。

### <a name="remarks"></a>备注

创建可替换此窗格的选项卡式的窗格时，框架将调用此方法。 有关详细信息，请参阅[cdockablepane:: Attachtotabwnd](#attachtotabwnd)。

重写此方法在派生类自定义如何选项卡式的窗格中创建和初始化。

根据存储在运行时类信息创建选项卡式的窗格`m_pTabbedControlBarRTC`成员，初始化[cdockablepane:: Createex](#createex)方法。

##  <a name="dockpanecontainer"></a>  CDockablePane::DockPaneContainer

将容器停靠到窗格。

```
virtual BOOL DockPaneContainer(
    CPaneContainerManager& barContainerManager,
    DWORD dwAlignment,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*barContainerManager*<br/>
[in]对要停靠的容器的容器管理器的引用。

*dwAlignment*<br/>
[in]指定向其停靠容器窗格一侧的 DWORD。

*dockMethod*<br/>
[in]不使用。

### <a name="return-value"></a>返回值

如果容器已成功停靠到窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

*dwAlignment*可以是任何以下值：

|“值”|描述|
|-----------|-----------------|
|CBRS_ALIGN_TOP|顶部窗格的停靠容器。|
|CBRS_ALIGN_BOTTOM|底部窗格的停靠容器。|
|CBRS_ALIGN_LEFT|容器被停靠窗格的左侧。|
|CBRS_ALIGN_RIGHT|容器被停靠到窗格的右侧。|

##  <a name="dockpanestandard"></a>  CDockablePane::DockPaneStandard

将窗格停靠使用大纲 （标准） 停靠。

```
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```

### <a name="parameters"></a>参数

*bWasDocked*<br/>
[in]方法返回时，此值包含 TRUE 如果成功停靠窗格;否则，它将包含 FALSE。

### <a name="return-value"></a>返回值

如果窗格已停靠到选项卡式窗口中，或者如果已创建选项卡式的窗口停靠，此方法返回指向选项卡式窗口。 如果窗格是否则成功停靠，则此方法返回**这**指针。 如果停靠失败，则此方法将返回 NULL。

##  <a name="docktorecentpos"></a>  CDockablePane::DockToRecentPos

将一个窗格停靠到其存储的停靠位置。

```
BOOL CDockablePane::DockToRecentPos();
```

### <a name="return-value"></a>返回值

如果成功停靠窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

可停靠窗格最近停靠将信息存储在[CRecentDockSiteInfo](../../mfc/reference/crecentdocksiteinfo-class.md)对象。

##  <a name="docktowindow"></a>  CDockablePane::DockToWindow

将一个停靠窗格停靠到另一个停靠窗格。

```
virtual BOOL DockToWindow(
    CDockablePane* pTargetWindow,
    DWORD dwAlignment,
    LPCRECT lpRect = NULL);
```

### <a name="parameters"></a>参数

*pTargetWindow*<br/>
[in、 out]指定的可停靠窗格停靠到此窗格。

*dwAlignment*<br/>
[in]指定在窗格的停靠对齐方式。 可能 CBRS_ALIGN_LEFT、 CBRS_ALIGN_TOP、 CBRS_ALIGN_RIGHT、 CBRS_ALIGN_BOTTOM 或 CBRS_ALIGN_ANY 之一。 （在 afxres.h 中定义）。

*lpRect*<br/>
[in]指定在窗格的停靠矩形。

### <a name="return-value"></a>返回值

如果已成功，则停靠窗格，则返回 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法可将一个窗格停靠到另一个窗格与由指定的对齐方式*dwAlignment*。

##  <a name="drawcaption"></a>  CDockablePane::DrawCaption

绘制标题的停靠窗格 （也称为控制手柄）。

```
virtual void DrawCaption(
    CDC* pDC,
    CRect rectCaption);
```

### <a name="parameters"></a>参数

*pDC*<br/>
[in]表示用于绘图的设备上下文。

*rectCaption*<br/>
[in]指定该窗格的标题的边框。

### <a name="remarks"></a>备注

框架调用此方法以绘制可停靠窗格的标题。

重写此方法在派生类的标题的外观进行自定义中。

##  <a name="enableautohideall"></a>  CDockablePane::EnableAutohideAll

启用或禁用自动隐藏模式下，此窗格和在容器中的其他窗格。

```
void EnableAutohideAll(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>参数

*bEnable*<br/>
[in]为 TRUE，则启用自动隐藏可停靠的窗格中; 所有功能否则为 FALSE。

### <a name="remarks"></a>备注

当用户按住**Ctrl**键并单击固定按钮以切换到自动隐藏模式，在同一个容器中的所有其他窗格的窗格还会切换到自动隐藏模式。

调用此方法替换*bEnable*设置为 FALSE 可为特定的窗格中禁用此功能。

##  <a name="enablegripper"></a>  CDockablePane::EnableGripper

显示或隐藏 （也称为控制手柄） 的标题。

```
virtual void EnableGripper(BOOL bEnable);
```

### <a name="parameters"></a>参数

*bEnable*<br/>
[in]为 true 以启用标题;否则为 FALSE。

### <a name="remarks"></a>备注

当框架创建可停靠窗格时，它们没有 WS_STYLE 窗口样式，即使指定。 这意味着该窗格的标题是由框架，控制的非工作区，但与标准的窗口标题不同，此区域。

可以显示或隐藏标题在任何时间。 到选项卡式窗口或窗格浮动微型框窗口中，添加一个窗格，为选项卡时，框架将隐藏标题。

##  <a name="getahrestoredrect"></a>  CDockablePane::GetAHRestoredRect

指定在自动隐藏模式下的窗格的位置。

```
CRect GetAHRestoredRect() const;
```

### <a name="return-value"></a>返回值

一个`CRect`对象，其中包含窗格的位置时自动隐藏模式。

### <a name="remarks"></a>备注

##  <a name="getahslidemode"></a>  CDockablePane::GetAHSlideMode

检索在窗格的自动隐藏幻灯片模式。

```
virtual UINT GetAHSlideMode() const;
```

### <a name="return-value"></a>返回值

指定在窗格的自动隐藏幻灯片模式 UINT。 返回值可以是 AFX_AHSM_MOVE 或 AFX_AHSM_STRETCH，但该实现仅使用 AFX_AHSM_MOVE。

### <a name="remarks"></a>备注

##  <a name="getcaptionheight"></a>  CDockablePane::GetCaptionHeight

返回的高度，以像素为单位的当前标题。

```
virtual int GetCaptionHeight() const;
```

### <a name="return-value"></a>返回值

标题，以像素为单位的高度。

### <a name="remarks"></a>备注

标题高度为 0，如果通过隐藏的标题[CDockablePane::EnableGripper](#enablegripper)方法，或如果窗格没有标题。

##  <a name="getdefaultpanedivider"></a>  CDockablePane::GetDefaultPaneDivider

返回窗格的容器的默认窗格分隔符。

```
CPaneDivider* GetDefaultPaneDivider() const;
```

### <a name="return-value"></a>返回值

一个有效[CPaneDivider](../../mfc/reference/cpanedivider-class.md)对象的可停靠窗格停靠到主框架窗口中，如果或`NULL`如果可停靠窗格未停靠或起来具有浮动。

### <a name="remarks"></a>备注

有关详细信息窗格中分隔线，请参阅[CPaneDivider 类](../../mfc/reference/cpanedivider-class.md)。

##  <a name="getdockingstatus"></a>  CDockablePane::GetDockingStatus

确定一个窗格的停靠的功能根据提供的指针位置。

```
virtual AFX_CS_STATUS GetDockingStatus(
    CPoint pt,
    int nSensitivity);
```

### <a name="parameters"></a>参数

*pt*<br/>
[in]以屏幕坐标表示的指针的位置。

*nSensitivity*<br/>
[in]距离，以像素为单位，从矩形的边缘指针必须是启用停靠。

### <a name="return-value"></a>返回值

以下状态的值之一：

|AFX_CS_STATUS 值|含义|
|---------------------------|-------------|
|CS_NOTHING|指针不是停靠站点段。 该框架将窗格未停靠。|
|CS_DOCK_IMMEDIATELY|指针位于停靠站点通过在直接模式下 （窗格中使用 DT_IMMEDIATE 停靠模式）。 该框架将立即停靠窗格。|
|CS_DELAY_DOCK|在指针位于停靠站点是另一个停靠窗格或主框架的一个边缘上。 在延迟后，该框架停靠窗格。 请参阅有关此延迟的详细信息备注部分。|
|CS_DELAY_DOCK_TO_TAB|通过使窗格停靠在选项卡式窗口停靠站点指针位于。 当指针位于通过另一个停靠窗格的标题或选项卡式窗格的选项卡区域时，将发生这种情况。|

### <a name="remarks"></a>备注

框架调用此方法以处理浮动窗格的停靠。

对于浮动工具栏或停靠窗格，使用 DT_IMMEDIATE 停靠模式，该框架会延迟停靠命令，以使用户能够脱离父框架的客户端区域窗口停靠发生之前。 以毫秒为单位的延迟的长度，且受[CDockingManager::m_nTimeOutBeforeToolBarDock](../../mfc/reference/cdockingmanager-class.md#m_ntimeoutbeforetoolbardock)数据成员... 默认值[CDockingManager::m_nTimeOutBeforeToolBarDock](../../mfc/reference/cdockingmanager-class.md#m_ntimeoutbeforetoolbardock)为 200。 此行为来模拟 Microsoft Word 2007 的停靠行为。

对于延迟停靠状态 （CS_DELAY_DOCK 和 CS_DELAY_DOCK_TO_TAB），该框架不会执行停靠直到用户释放鼠标按钮。 如果窗格使用 DT_STANDARD 停靠模式下，框架将显示在预计的停靠位置的矩形。 如果一个窗格使用 DT_SMART 停靠模式下，框架将在预计的停靠位置显示智能停靠标记和半透明矩形。 若要指定您的窗格的停靠模式，请调用[CBasePane::SetDockingMode](../../mfc/reference/cbasepane-class.md#setdockingmode)方法。 有关智能停靠的详细信息，请参阅[CDockingManager::GetSmartDockingParams](../../mfc/reference/cdockingmanager-class.md#getsmartdockingparams)。

##  <a name="getdragsensitivity"></a>  CDockablePane::GetDragSensitivity

返回停靠窗格拖动的敏感性。

```
static const CSize& GetDragSensitivity();
```

### <a name="return-value"></a>返回值

一个[CSize](../../atl-mfc-shared/reference/csize-class.md)对象，其中包含的宽度和高度，以像素为单位以拖动点为中心的矩形。 直到鼠标指针移动此矩形外，才会开始拖动操作。

##  <a name="getlastpercentinpanecontainer"></a>  CDockablePane::GetLastPercentInPaneContainer

检索一个窗格，在其容器中占用的空间百分比 ( [CPaneContainer 类](../../mfc/reference/cpanecontainer-class.md))。

```
int GetLastPercentInPaneContainer() const;
```

### <a name="return-value"></a>返回值

*Int* ，指定空间窗格在其容器中所占的百分比。

### <a name="remarks"></a>备注

当容器调整其布局时使用此方法。

##  <a name="gettabarea"></a>  CDockablePane::GetTabArea

检索在窗格的选项卡区域。

```
virtual void GetTabArea(
    CRect& rectTabAreaTop,
    CRect& rectTabAreaBottom) const;
```

### <a name="parameters"></a>参数

*rectTabAreaTop*<br/>
[in]`GetTabArea`如果选项卡位于窗格的顶部与选项卡区域填充此变量。 如果选项卡位于窗格的底部，一个空矩形填充此变量。

*rectTabAreaBottom*<br/>
[in]`GetTabArea`如果选项卡位于窗格的底部使用选项卡区域填充此变量。 如果选项卡位于顶部的窗格中，此变量被填充空矩形。

### <a name="remarks"></a>备注

仅在从派生类中使用此方法`CDockablePane`和具有选项卡。 有关详细信息，请参阅[CTabbedPane::GetTabArea](../../mfc/reference/ctabbedpane-class.md#gettabarea)并[CMFCOutlookBar::GetTabArea](../../mfc/reference/cmfcoutlookbar-class.md#gettabarea)。

##  <a name="gettabbedpanertc"></a>  CDockablePane::GetTabbedPaneRTC

返回有关另一个窗格将停靠到当前窗格时，会创建一个选项卡式窗口的运行时类信息。

```
CRuntimeClass* GetTabbedPaneRTC() const;
```

### <a name="return-value"></a>返回值

可停靠的窗格中运行时类信息。

### <a name="remarks"></a>备注

调用此方法以检索动态创建的选项卡式窗格的运行时类信息。 当用户将一个窗格拖动到另一个窗格的标题，或如果调用可以发生这种情况[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法以编程方式从两个可停靠窗格创建选项卡式的窗格。

可以通过调用设置运行时类信息[cdockablepane:: Settabbedpanertc](#settabbedpanertc)方法。

##  <a name="hasautohidemode"></a>  CDockablePane::HasAutoHideMode

指定是否可以为自动隐藏模式切换停靠窗格。

```
virtual BOOL HasAutoHideMode() const;
```

### <a name="return-value"></a>返回值

如果可停靠窗格可以切换到自动隐藏模式，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

重写此方法在派生类中，若要禁用自动隐藏模式为特定的可停靠窗格中。

##  <a name="hittest"></a>  CDockablePane::HitTest

当用户单击鼠标的窗格中指定的位置。

```
virtual int HitTest(
    CPoint point,
    BOOL bDetectCaption = FALSE);
```

### <a name="parameters"></a>参数

*点*<br/>
[in]指定要测试的点。

*bDetectCaption*<br/>
[in]如果应返回 HTCAPTION，如果该点上窗格的标题，则为 TRUE否则为 FALSE。

### <a name="return-value"></a>返回值

以下值之一：

- HTNOWHERE 如果*点*不在可停靠窗格。

- HTCLIENT 如果*点*是可停靠窗格的工作区中。

- HTCAPTION 如果*点*是可停靠窗格的标题区域中。

- AFX_HTCLOSE 如果*点*是关闭按钮。

- HTMAXBUTTON 如果*点*固定按钮上。

##  <a name="isautohideallenabled"></a>  CDockablePane::IsAutohideAllEnabled

指示是否可以为自动隐藏模式切换停靠窗格和在容器中的所有其他窗格。

```
virtual BOOL IsAutohideAllEnabled() const;
```

### <a name="return-value"></a>返回值

如果可停靠的窗格中，并在容器中，所有其他窗格可以切换到自动隐藏模式，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

用户通过单击按住停靠固定按钮启用自动隐藏模式**Ctrl**密钥

若要启用或禁用此行为，请调用[CDockablePane::EnableAutohideAll](#enableautohideall)方法。

##  <a name="isautohidemode"></a>  CDockablePane::IsAutoHideMode

确定一个窗格是否处于自动隐藏模式。

```
virtual BOOL IsAutoHideMode() const;
```

### <a name="return-value"></a>返回值

如果可停靠的窗格中自动隐藏模式，则为 TRUE否则为 FALSE。

##  <a name="isdocked"></a>  CDockablePane::IsDocked

确定是否当前窗格停靠。

```
virtual BOOL IsDocked() const;
```

### <a name="return-value"></a>返回值

可停靠窗格不属于微型框窗口是否浮动在另一个窗格的微型框窗口中，则为 TRUE。 如果窗格是一个微型框窗口的子级，并且存在属于袖珍框架窗口的任何其他窗格，则为 FALSE。

### <a name="remarks"></a>备注

若要确定是否将窗格停靠到主框架窗口，请调用[CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)。 如果该方法返回一个非 NULL 指针，在主框架窗口停靠窗格。

##  <a name="ishideinautohidemode"></a>  CDockablePane::IsHideInAutoHideMode

确定的行为的窗格，只是在自动隐藏模式下，如果它是显示 （或隐藏） 通过调用[CDockablePane::ShowPane](#showpane)。

```
virtual BOOL IsHideInAutoHideMode() const;
```

### <a name="return-value"></a>返回值

如果应在自动隐藏模式下; 隐藏可停靠的窗格中，则返回 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

在自动隐藏模式下可停靠窗格时，它的行为以不同的方式在调用`ShowPane`隐藏或显示窗格。 此行为由静态成员控制[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)。 如果此成员为 TRUE，可停靠窗格中，且其相关的自动隐藏工具栏或自动隐藏按钮隐藏或显示当您调用`ShowPane`。 否则为可停靠的窗格中激活或停用，并且其相关的自动隐藏工具栏或自动隐藏按钮始终是可见。

重写此方法在派生类来更改各个窗格的默认行为。

默认值为`m_bHideInAutoHideMode`为 FALSE。

##  <a name="isinfloatingmultipaneframewnd"></a>  CDockablePane::IsInFloatingMultiPaneFrameWnd

指定窗格是否在多窗格框架窗口中 ( [CMultiPaneFrameWnd 类](../../mfc/reference/cmultipaneframewnd-class.md))。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>返回值

在窗格的多窗格框架窗口; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

##  <a name="isresizable"></a>  CDockablePane::IsResizable

指定是否可以在窗格的大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>返回值

在窗格中，可调整大小; 如果为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

默认情况下可停靠窗格是可调整大小。 若要防止重设大小，请重写此方法在派生类中的，并返回 FALSE。 请注意，值为 FALSE 会导致故障**ASSERT**中[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)。 使用[CDockingManager::AddPane](../../mfc/reference/cdockingmanager-class.md#addpane)改为停靠在父范围内的窗格。

无法调整大小的窗格可以既不浮动，也不进入自动隐藏模式并将始终位于父框架的外边缘。

##  <a name="istablocationbottom"></a>  CDockablePane::IsTabLocationBottom

指定是否将选项卡位于顶部或底部窗格中。

```
virtual BOOL IsTabLocationBottom() const;
```

### <a name="return-value"></a>返回值

选项卡在底部窗格中; 如果为 TRUE如果选项卡位于顶部的窗格中，则为 FALSE。

### <a name="remarks"></a>备注

有关详细信息，请参阅[CTabbedPane::IsTabLocationBottom](../../mfc/reference/ctabbedpane-class.md#istablocationbottom)。

##  <a name="istracked"></a>  CDockablePane::IsTracked

指定用户是否移动一个窗格。

```
BOOL IsTracked() const;
```

### <a name="return-value"></a>返回值

如果要移动窗格; 则为 TRUE否则为 FALSE。

##  <a name="isvisible"></a>  CDockablePane::IsVisible

确定当前窗格是否可见。

```
virtual BOOL IsVisible() const;
```

### <a name="return-value"></a>返回值

如果可停靠窗格可见，则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法来确定可停靠窗格是否可见。 您可以使用此方法，而不是调用[CWnd::IsWindowVisible](../../mfc/reference/cwnd-class.md#iswindowvisible)或测试 WS_VISIBLE 样式。 返回的可见性状态取决于是否启用或禁用自动隐藏模式和的值[CDockablePane::IsHideInAutoHideMode](#ishideinautohidemode)属性。

如果可停靠窗格处于自动隐藏模式和`IsHideInAutoHideMode`返回 FALSE 的可见性状态始终为 FALSE。

如果可停靠窗格处于自动隐藏模式和`IsHideInAutoHideMode`返回 TRUE 的可见性状态取决于相关的自动隐藏工具栏的可见性状态。

如果在自动隐藏模式下不是可停靠窗格中，来确定的可见性状态[CBasePane::IsVisible](../../mfc/reference/cbasepane-class.md#isvisible)方法。

## ##  <a name="loadstate"></a>  Cdockablepane:: Loadstate

仅限内部使用。 有关详细信息，请参阅所安装的 Visual Studio 的 VC\atlmfc\src\mfc 文件夹中的源代码。

```
virtual BOOL LoadState(
   LPCTSTR lpszProfileName = NULL,
   int nIndex = -1,
   UINT uiID = (UINT) -1
);
```

##  <a name="m_bdisableanimation"></a>  CDockablePane::m_bDisableAnimation

指定是否禁用自动隐藏可停靠窗格的动画。

```
AFX_IMPORT_DATA static BOOL m_bDisableAnimation;
```

##  <a name="m_bhideinautohidemode"></a>  CDockablePane::m_bHideInAutoHideMode

当窗格处于自动隐藏模式时，请确定窗格的行为。

```
AFX_IMPORT_DATA static BOOL m_bHideInAutoHideMode;
```

### <a name="remarks"></a>备注

此值会影响应用程序中的所有停靠窗格。

如果将此成员设置为 TRUE，那么可停靠窗格会显示或隐藏与他们相关的自动隐藏工具栏和按钮时调用[CDockablePane::ShowPane](#showpane)。

如果将此成员设置为 FALSE，可停靠窗格是激活或停用时，调用[CDockablePane::ShowPane](#showpane)。

##  <a name="m_nslidesteps"></a>  CDockablePane::m_nSlideSteps

在自动隐藏模式下时，请指定动画速度的窗格。

```
AFX_IMPORT_DATA static int m_nSlideSteps;
```

### <a name="remarks"></a>备注

要更快的动画效果，请减小此值。 要速度较慢的动画效果，请增大此值。

##  <a name="onafterchangeparent"></a>  CDockablePane::OnAfterChangeParent

有关更多详细信息，请参阅中的源代码**VC\\atlmfc\\src\\mfc**的 Visual Studio 安装文件夹。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>参数

[in]*pWndOldParent*<br/>

### <a name="remarks"></a>备注

##  <a name="onafterdockfromminiframe"></a>  CDockablePane::OnAfterDockFromMiniFrame

浮动的停靠栏将停靠在框架窗口时由框架调用。

```
virtual void OnAfterDockFromMiniFrame();
```

### <a name="remarks"></a>备注

默认情况下，此方法没有任何影响。

##  <a name="onbeforechangeparent"></a>  CDockablePane::OnBeforeChangeParent

更改窗格的父之前，框架将调用此方法。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*pWndNewParent*<br/>
[in]指向新的父窗口的指针。

*bDelay*<br/>
[in]布尔值，指定是否要延迟重新计算停靠布局的如果未停靠窗格。 有关详细信息，请参阅[CDockablePane::UndockPane](#undockpane)。

### <a name="remarks"></a>备注

如果新的父级不允许的停靠窗格停靠，则此方法中取消停靠窗格。

如果要转换为选项卡式文档窗格中，此方法将存储其最近的停靠位置。 该框架使用最近的停靠位置转换回停靠状态时还原窗格的位置。

##  <a name="onbeforefloat"></a>  CDockablePane::OnBeforeFloat

框架调用此方法，然后一个窗格，再转换到浮动状态。

```
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>参数

*rectFloat*<br/>
[in]当处于浮动状态时指定的位置和窗格的大小。

*dockMethod*<br/>
[in]指定的扩展方法。 请参阅[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)有关可能的值的列表。

### <a name="return-value"></a>返回值

如果可以浮动窗格; 则为 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

当窗格时有关为浮点数，由框架调用此方法。 如果你想要执行任何处理之前浮动窗格，可以重写此方法在派生类中。

##  <a name="onpressbuttons"></a>  CDockablePane::OnPressButtons

当用户按下的 AFX_HTCLOSE 和 AFX_HTMAXBUTTON 按钮之外的一个标题按钮时调用。

```
virtual void OnPressButtons(UINT nHit);
```

### <a name="parameters"></a>参数

*nHit*<br/>
[in]未使用此参数。

### <a name="remarks"></a>备注

如果为标题的可停靠窗格添加自定义按钮，重写此方法以接收通知，当用户按下按钮。

##  <a name="onslide"></a>  CDockablePane::OnSlide

由框架调用以在自动隐藏模式下时，窗格中进行动画处理。

```
virtual void OnSlide(BOOL bSlideOut);
```

### <a name="parameters"></a>参数

*bSlideOut*<br/>
[in]为 TRUE，则显示窗格;如果为 FALSE，则若要隐藏窗格。

### <a name="remarks"></a>备注

重写此方法在派生类来实现自定义自动隐藏效果。

##  <a name="removefromdefaultpanedividier"></a>  CDockablePane::RemoveFromDefaultPaneDividier

移除一个窗格时，框架将调用此方法。

```
void RemoveFromDefaultPaneDividier();
```

### <a name="remarks"></a>备注

此方法的默认窗格分隔符设置为 NULL，并从其容器中删除窗格。

##  <a name="replacepane"></a>  CDockablePane::ReplacePane

替换指定的窗格中的窗格。

```
BOOL ReplacePane(
    CDockablePane* pBarToReplaceWith,
    AFX_DOCK_METHOD dockMethod,
    BOOL bRegisterWithFrame = FALSE);
```

### <a name="parameters"></a>参数

*pBarToReplaceWith*<br/>
[in]指向可停靠窗格的指针。

*dockMethod*<br/>
[in]不使用。

*bRegisterWithFrame*<br/>
[in]如果为 TRUE，旧窗格中的父到停靠管理器注册新窗格。 旧窗格停靠管理器维护的窗格的列表中的索引处插入新窗格。

### <a name="return-value"></a>返回值

如果更换过程已成功，则为 TRUE否则为 FALSE。

##  <a name="restoredefaultpanedivider"></a>  CDockablePane::RestoreDefaultPaneDivider

当窗格进行反序列化时，框架将调用此方法，以还原默认窗格分隔符。

```
void RestoreDefaultPaneDivider();
```

### <a name="remarks"></a>备注

还原的默认窗格分隔符替换当前的默认窗格分隔符，如果它存在。

##  <a name="setautohidemode"></a>  CDockablePane::SetAutoHideMode

切换可见停靠窗格和自动隐藏模式。

```
virtual CMFCAutoHideBar* SetAutoHideMode(
    BOOL bMode,
    DWORD dwAlignment,
    CMFCAutoHideBar* pCurrAutoHideBar = NULL,
    BOOL bUseTimer = TRUE);
```

### <a name="parameters"></a>参数

*bMode*<br/>
[in]如果启用了自动隐藏模式，则为如果为 FALSE，则若要启用正则停靠模式。

*dwAlignment*<br/>
[in]指定自动隐藏窗格中创建的对齐方式。

*pCurrAutoHideBar*<br/>
[in、 out]指向当前的自动隐藏工具栏的指针。 可以为 NULL。

*bUseTimer*<br/>
[in]指定是否要使用自动隐藏效果，当用户将窗格切换为自动隐藏模式，或若要立即隐藏窗格。

### <a name="return-value"></a>返回值

自动隐藏工具栏中的第切换到自动隐藏模式，则为 NULL。

### <a name="remarks"></a>备注

当用户单击固定按钮以切换到自动隐藏模式或正则停靠模式的可停靠窗格时，框架将调用此方法。

调用此方法以编程方式切换到自动隐藏模式可停靠窗格。 必须将窗格停靠到主框架窗口 ( [CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)必须返回到的有效指针[CPaneDivider](../../mfc/reference/cpanedivider-class.md))。

##  <a name="setautohideparents"></a>  CDockablePane::SetAutoHideParents

设置自动隐藏按钮和窗格中的自动隐藏工具栏。

```
void SetAutoHideParents(
    CMFCAutoHideBar* pToolBar,
    CMFCAutoHideButton* pBtn);
```

### <a name="parameters"></a>参数

*pToolBar*<br/>
[in]为自动隐藏工具栏的指针。

*pBtn*<br/>
[in]指向一个自动隐藏按钮。

##  <a name="setlastpercentinpanecontainer"></a>  CDockablePane::SetLastPercentInPaneContainer

设置窗格在其容器中所占的空间的百分比。

```
void SetLastPercentInPaneContainer(int n);
```

### <a name="parameters"></a>参数

*n*<br/>
[in]**Int** ，指定空间窗格在其容器中所占的百分比。

### <a name="remarks"></a>备注

Framework 调整窗格时要使用的新值重新计算布局。

##  <a name="setrestoreddefaultpanedivider"></a>  CDockablePane::SetRestoredDefaultPaneDivider

还原的默认窗格分隔符设置。

```
void SetRestoredDefaultPaneDivider(HWND hRestoredSlider);
```

### <a name="parameters"></a>参数

*hRestoredSlider*<br/>
[in]句柄的窗格分隔符 （滑块）。

### <a name="remarks"></a>备注

还原的默认窗格分隔符是一个窗格，反序列化时获取的。 有关详细信息，请参阅[CDockablePane::RestoreDefaultPaneDivider](#restoredefaultpanedivider)。

##  <a name="settabbedpanertc"></a>  Cdockablepane:: Settabbedpanertc

设置两个窗格停靠在一起时，会创建一个选项卡式窗口的运行时类信息。

```
void SetTabbedPaneRTC(CRuntimeClass* pRTC);
```

### <a name="parameters"></a>参数

*pRTC*<br/>
[in]选项卡式窗格中运行时类信息。

### <a name="remarks"></a>备注

调用此方法以设置动态创建的选项卡式窗格的运行时类信息。 当用户将一个窗格拖动到另一个窗格的标题，或如果调用可以发生这种情况[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法以编程方式从两个可停靠窗格创建选项卡式的窗格。

根据设置的默认运行时类*dwTabbedStyle*的参数[CDockablePane::Create](#create)并[cdockablepane:: Createex](#createex)。 若要自定义新的选项卡式的窗格，请从以下类之一派生您的类：

- [CBaseTabbedPane 类](../../mfc/reference/cbasetabbedpane-class.md)

- [CTabbedPane 类](../../mfc/reference/ctabbedpane-class.md)

- [CMFCOutlookBar 类](../../mfc/reference/cmfcoutlookbar-class.md)。

然后，调用此方法用指针指向其运行时类信息。

##  <a name="showpane"></a>  CDockablePane::ShowPane

显示或隐藏窗格。

```
virtual void ShowPane(
    BOOL bShow,
    BOOL bDelay,
    BOOL bActivate);
```

### <a name="parameters"></a>参数

*bShow*<br/>
[in]为 TRUE，则显示窗格;如果为 FALSE，则若要隐藏窗格。

*bDelay*<br/>
[in]为 true，则延迟调整停靠布局;为 FALSE，则立即调整停靠布局。

*bActivate*<br/>
[in]若要激活窗格显示; 时，则返回 TRUE否则为 FALSE。

### <a name="remarks"></a>备注

调用此方法，而不是[CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)时显示或隐藏可停靠窗格。

##  <a name="slide"></a>  CDockablePane::Slide

在自动隐藏模式下的窗格之间进行动画处理。

```
virtual void Slide(
    BOOL bSlideOut,
    BOOL bUseTimer = TRUE);
```

### <a name="parameters"></a>参数

*bSlideOut*<br/>
[in]为 TRUE，则显示窗格;如果为 FALSE，则若要隐藏窗格。

*bUseTimer*<br/>
[in]若要显示或隐藏自动隐藏效果; 窗格，则返回 TRUE显示或隐藏窗格立即为 FALSE。

### <a name="remarks"></a>备注

框架调用此方法进行动画处理是在自动隐藏模式下的窗格。

此方法使用`CDockablePane::m_nSlideDefaultTimeOut`值以确定的滑动效果的超时时间。 超时时间的默认值为 1。 如果自定义自动隐藏算法，请修改此成员，才能更改超时时间。

##  <a name="toggleautohide"></a>  CDockablePane::ToggleAutoHide

切换窗格之间始终可见和自动隐藏模式。

```
virtual void ToggleAutoHide();
```

### <a name="remarks"></a>备注

此方法通过调用切换为窗格的自动隐藏模式[CDockablePane::SetAutoHideMode](#setautohidemode)。

##  <a name="undockpane"></a>  CDockablePane::UndockPane

从主框架窗口或袖珍框架窗口容器窗格中取消停靠。

```
virtual void UndockPane(BOOL bDelay = FALSE);
```

### <a name="parameters"></a>参数

*bDelay*<br/>
[in]为 true，则延迟计算停靠布局;如果为 FALSE，则立即重新计算停靠布局。

### <a name="remarks"></a>备注

调用此方法来取消停靠窗格从主框架窗口或从多微型框窗口容器 （在其他窗格与单个微型框窗口中浮动窗格）。

执行不由任何外部操作之前，必须取消停靠窗格[CDockingManager](../../mfc/reference/cdockingmanager-class.md)。 例如，你必须取消停靠窗格以它以编程方式从一个位置移动到另一个。

销毁它们之前，框架自动中窗格取消停靠。

## <a name="see-also"></a>请参阅

[层次结构图](../../mfc/hierarchy-chart.md)<br/>
[类](../../mfc/reference/mfc-classes.md)<br/>
[CPane 类](../../mfc/reference/cpane-class.md)
