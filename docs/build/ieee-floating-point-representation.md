---
title: IEEE 浮点表示形式
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: bb8523256c05479b303dec66ca79caa28e7cda03
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/24/2020
ms.locfileid: "80169807"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮点表示形式

Microsoft C++ (MSVC) 与 IEEE 数值标准保持一致。 IEEE-754 标准描述浮点格式，这是一种在硬件中表示实数的方法。 浮点数至少有五种可在 MSVC 编译器针对的硬件中表示出来的内部格式，但编译器仅使用其中两种格式。 MSVC 中使用单精度（4 字节）和双精度（8 字节）格式   。 单精度使用关键字 float 声明  。 双精度使用关键字 double 声明  。 IEEE 标准还规定了半精度（2 字节）和四倍精度（16 字节）格式，以及扩展双精度（10 字节）格式（某些 C 和 C++ 编译器将其作为 long double 数据类型实现）     。 在 MSVC 编译器中，long double 数据类型被视为不同的类型，但存储类型映射到 double   。 然而，内部和汇编语言支持使用其他格式的计算，其中包括硬件支持的扩展双精度（10 字节）格式。

这些值按如下格式存储：

|“值”|存储格式|
|-----------|---------------|
|单精度 (single-precision)|符号位，8 位指数，23 位有效数|
|双精度|符号位，11 位指数，52 位有效数|
|扩展双精度|符号位，15 位指数，64 位有效数|

在单精度和双精度格式中，小数部分有一个假设的前导 1，称为“有效数”（有时称为“尾数”），它不存储在内存中，因此，即使仅存储 23 或 52 位，但有效数实际为 24 或 53 位   。 扩展双精度格式实际存储此位。

指数的偏差是其可能值的一半。 这意味着可以从存储的指数中减去此偏差以获得实际指数。 如果存储的指数小于偏差，则实际为负指数。

指数偏差如下所示：

|指数|偏差|
|--------------|---------------|
|8 位（单精度）|127|
|11 位（双精度）|1023|
|15 位（扩展双精度）|16383|

这些指数不是 10 的幂；它们是 2 的幂。 也就是说，存储的 8 位指数的范围为 -127 到 127，并存储为 0 到 254。 值 2<sup>127</sup> 大约等于 10<sup>38</sup>，这是单精度的实际极限。

有效数以 1.XXX... 的形式存储为二进制分数。 此分数的值大于或等于 1 且小于 2。 请注意，实数始终以规范化形式存储；也就是说，有效数左移，以使有效数的高位始终为 1  。 由于此位始终为 1，其在单精度和双精度格式中为假设（不存储）。 假设二进制（而不是十进制）小数点刚好位于前导 1 的右侧，

则不同大小的格式如下所示：

|格式|字节 1|字节 2|字节 3|字节 4|...|字节 n|
|------------|------------|------------|------------|------------|---------|------------|
|单精度 (single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|双精度|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|扩展双精度|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S` 表示符号位，`X` 是偏差的指数位，`M` 是有效数位。 请注意，最左边的位在单精度和双精度格式中为假设，但在扩展双精度格式的字节 3 中表示为“1”。

若要正确移动二进制小数点，首先要取消指数偏差，然后将二进制小数点向右或向左移动适当的位数。

## <a name="special-values"></a>特殊值

浮点格式包括一些被特殊对待的值。

### <a name="zero"></a>零

零无法规范化，这使其无法以单精度或双精度值的规范化形式表示。 全零的特殊位模式表示 0。 也可以通过设置符号位将 -0 表示为零，但 -0 和 0 的比较结果始终为相等。

### <a name="infinities"></a>无穷大

+∞ 和 −∞ 值由一个全 1 的指数和一个全 0 的有效数表示。 正负无穷大都可以使用符号位表示。

### <a name="subnormals"></a>次正规数

可以表示小于最小规范化数的数字。 这些数字称为次正规  或非正规  数。 如果指数为全零且有效数不为零，则有效数的隐式前导位被视为 0，而不是 1。 次正规数的精度随有效数中前导零数量的增加而下降。

### <a name="nan---not-a-number"></a>NaN - 非数

可以使用 IEEE 浮点格式表示不是实数的值，例如 0/0。 这种值称为 NaN  。 NaN 由一个全 1 的指数和一个非 0 的有效数表示。 NaN 有两种：quiet NaN  (QNaN) 和 signaling  NaN (SNaN)。 Quiet NaN 的有效数有一个前导 1，并且通常通过表达式传播。 它们表示不定值，例如除以无穷大或将无穷大乘以零的结果。 Signaling NaN 的有效数有一个前导 0。 它们用于无效的操作，表示浮点硬件异常。

## <a name="examples"></a>示例

以下是单精度格式的一些示例：

- 对于值 2，符号位为 0，存储的指数为 128（在二进制中为 1000 0000，即 127 加 1）。 存储的二进制有效数为 (1.)000 0000 0000 0000 0000 0000，它具有隐含的前导 1 和二进制小数点，因此实际有效数为 1。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 值 -2。 除已设置符号位外，与 +2 相同。 对于所有 IEEE 格式浮点数的负数而言都是如此。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 值 4。 有效数相同，指数加 1（偏差值为 129，在二进制中为 100 0000 1）。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 值 6。 指数相同，有效数大一半，为 (1.)100 0000 ...0000 0000，因为这是二进制分数，所以是1 1/2，因此，小数位的值为 1/2、1/4、1/8，依此类推。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 值 1。 与 2 的其他幂的有效数相同，偏差指数为 2 的指数减 1，即 127（在二进制中为 011 1111 1）。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 值 0.75。 偏差指数为 126（在二进制中为 011 1111 0），有效数是 (1.)100 0000 ...0000 0000，即 1 1/2。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 值 2.5。 与 2 完全相同，但表示 1/4 的位在有效数中已设置。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10 是二进制中的循环小数。 有效数仅略小于 1.6，且偏差指数指示 1.6 将除以 16（在二进制中为 011 1101 1，即十进制中的 123）。 真实指数为 123 - 127 = -4，这意味着乘数因子为 2<sup>-4</sup> = 1/16。 请注意，存储的有效数在最后一位进行四舍五入，这是在尝试尽可能准确地表示无法表示的数字。 （1/10 和 1/100 不能用二进制准确表示的原因类似于 1/3 不能用十进制准确表示的原因。）

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 零是一种特殊情况，它对可以表示的最小正值使用公式，即全零。

   |“值”|公式|二进制表示形式|十六进制|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>请参阅

[为何浮点数可能丢失精度](why-floating-point-numbers-may-lose-precision.md)
