---
title: 由编译器版本的编译器警告 |Microsoft Docs
ms.custom: ''
ms.date: 07/03/2018
ms.technology:
- devlang-cpp
ms.topic: error-reference
dev_langs:
- C++
helpviewer_keywords:
- warnings, by compiler version
- cl.exe compiler, setting warning options
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 6645bb81a1fd4a2b42eb7419a0d008b9ac7692ad
ms.sourcegitcommit: f0c90000125a9497bf61e41624de189a043703c0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/10/2018
ms.locfileid: "44319079"
---
# <a name="compiler-warnings-by-compiler-version"></a>由编译器版本的编译器警告

编译器可禁止显示你通过使用指定的版本后引入的警告[/Wv](../../build/reference/compiler-option-warning-level.md)编译器选项。 这可用于管理你的生成过程时想要引入新的工具集版本，并想要暂时禁止显示新的警告。 此选项不会取消新建错误消息。 建议不要禁止显示所有新警告永久 ！ 我们建议始终在最高的正则警告级别编译 __/w4__，并删除 __/Wv__尽可能快地在你的生成选项。

这些版本的编译器引入了新的警告：

| 产品 | 编译器的版本号 |
|-|-|
| Visual c + + 2002 | 13.00.9466 |
| Visual c + + 2003 | 13.10.3077 |
| Visual C++ 2005 | 14.00.50727.762 |
| Visual C++ 2008 | 15.00.21022.08 |
| Visual C++ 2010 | 16.00.40219.01 |
| Visual c + + 2012 | 17.00.51106.1 |
| Visual c + + 2013 | 18.00.21005.1 |
| Visual c + + 2015 RTM | 19.00.23026.0 |
| Visual c + + 2015 Update 1 | 19.00.23506.0 |
| Visual c + + 2015年更新 2 | 19.00.23918.0 |
| Visual c + + 2015年更新 3 | 19.00.24215.1 |
| Visual c + + 2017 RTM | 19.10.25017.0 |
| Visual c + + 2017 版本 15.3 | 19.11.25506.0 |
| Visual c + + 2017 版本 15.5 | 19.12.25830.0 |
| Visual c + + 2017 版本 15.6 | 19.13.26128.0 |
| Visual c + + 2017 版本 15.7 | 19.14.26428.0 |

可以指定仅主版本号、 主要和次要数字或主要、 次要和生成到的数字 __/Wv__选项。 编译器会报告与开头，该指定数字的版本相匹配的所有警告并禁止显示的版本大于指定数目的所有警告。 例如， __/Wv:17__报告引入中或之前的 Visual Studio 2012 中，任何版本的所有警告并禁止显示由任何编译器从 Visual Studio 2013 （版本 18） 或更高版本引入的所有警告。 若要取消显示 Visual Studio 2015 中引入的警告更新 2 和更高版本，可以使用 __/Wv:19.00.23506__。 使用 __/Wv:19.11__来报告所有警告在 Visual Studio，Visual Studio 2017 版本 15.5 中，任何版本中引入的但取消显示 Visual Studio 2017 版本 15.5 和更高版本中引入的警告。

以下部分列出了可通过使用取消的 Visual c + + 每个版本引入的警告 __/Wv__编译器选项。 __/Wv__选项不能禁止显示未列出，其中可以指定的版本的编译器的警告。

## <a name="warnings-introduced-in-visual-c-2017-version-157-compiler-version-1914264280"></a>Visual c + + 2017 版本 15.7 （编译器版本 19.14.26428.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.13__。

|||
|-|-|
C4642|'*问题*： 无法导入的泛型参数约束*参数*
C5045|为内存负载如果 /Qspectre 开关指定，编译器将插入 Spectre 缓解措施

## <a name="warnings-introduced-in-visual-c-2017-version-156-compiler-version-1913261280"></a>在 Visual c + + 2017 版本 15.6 （编译器版本 19.13.26128.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.12__。

|||
|-|-|
C5044|命令行选项的参数*选项*指向的路径*路径*不存在

## <a name="warnings-introduced-in-visual-c-2017-version-155-compiler-version-1912258300"></a>在 Visual c + + 2017 版本 15.5 （编译器版本 19.12.25830.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.11__。

|||
|-|-|
C4843|'*type1*： 对数组或函数类型的引用是异常处理程序无法访问，请使用'*type2*改为
C4844|导出模块*module_name*; 现在是声明模块接口的首选的语法
C5039|'*函数*： 指针或引用可能引发函数传递到-EHc 下 extern C 函数。 如果此函数将引发异常，则可能会出现未定义的行为。
C5040|动态异常规范是有效的仅在 C + + 14 和更早版本;将视为 noexcept （false）
C5041|'*定义*： 对 constexpr 静态数据成员的外部定义，则不需要和在 C + + 17 中弃用
C5042|'*声明*： 在块范围内的函数声明不能在标准 c + + 中为指定的内联; 删除内联说明符
C5043|'*规范*： 异常规范与前面的声明不匹配

## <a name="warnings-introduced-in-visual-c-2017-version-153-compiler-version-1911255060"></a>在 Visual c + + 2017 版本 15.3 （编译器版本 19.11.25506.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.10__。

|||
|-|-|
C4597|未定义的行为：*说明*
C4604|'*类型*： 跨本机和托管边界按值传递参数要求有效的复制构造函数。 否则是不确定的运行时行为
C4749|有条件地支持：*说明*
C4768|已忽略链接规范前的 __declspec 特性
C4834|放弃具有 'nodiscard' 属性的函数的返回值
C4841|使用非标准扩展：*扩展*
C4842|offsetof 应用于使用多重继承的类型的结果不能保证编译器版本之间保持一致
C4869|nodiscard 可能仅应用于类、 枚举和具有非 void 返回类型的函数
C5033|'*存储类*不再受支持的存储类
C5034|使用的内部函数*内部函数*将导致函数*函数*编译为来宾代码
C5035|使用功能*功能*将导致函数*函数*编译为来宾代码
C5036|将/hybrid:x86arm64 编译时的 varargs 函数指针转换*type1*到*type2*
C5037|'*成员函数*： 类模板的成员的外部定义不能包含默认自变量
C5038|数据成员*member1*将之后被初始化数据成员*member2*

## <a name="warnings-introduced-in-visual-c-2017-rtm-compiler-version-1910250170"></a>在 Visual c + + 2017 RTM （编译器版本 19.10.25017.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.00__。

|||
|-|-|
C4468|fallthrough： 属性后面必须跟一个 case 标签或默认标签
C4698|'*功能*是用于评估目的，并且可能会更改在将来的更新或删除。
C4839|类的非标准用法*类*作为可变参数函数的参数
C4840|类的不可移植用法*类*作为可变参数函数的参数

## <a name="warnings-introduced-in-visual-c-2015-update-3-compiler-version-1900242151"></a>在 Visual c + + 2015 Update 3 （编译器版本 19.00.24215.1） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.00.23918__。

|||
|-|-|
C4467|已弃用 ATL 属性的使用情况
C4596|'*名称*： 成员声明中的非法限定的名
C4598|#include \<*标头*\>： 标头数*数*中*源*不符*源*看这个位置
C4599|'*自变量*:*源*参数号*数*不符*源*

## <a name="warnings-introduced-in-visual-c-2015-update-2-compiler-version-1900239180"></a>Visual c + + 2015 Update 2 （编译器版本 19.00.23918.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.00.23506__。

|||
|-|-|
C4466|无法执行系统程序堆删除
C4595|'*类*： 非成员运算符 new 或 delete 函数不能声明内联
C4828|该文件包含的字符偏移量 0 开始 x*值*这是当前源字符集中非法 (代码页*数*)。
C4868|编译器不会强制在大括号内的初始值设定项列表中的从左到右计算顺序

## <a name="warnings-introduced-in-visual-c-2015-update-1-compiler-version-1900235060"></a>Visual c + + 2015 Update 1 （编译器版本 19.00.23506.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:19.00.23026__。

|||
|-|-|
C4426|优化标志发生更改后包括标头，可能是由于 #pragma optimize （） 超出
C4654|代码放在包含的预编译标头行中将被忽略。 将代码添加到预编译标头。
C5031|#pragma warning （pop): 可能不匹配，弹出推入不同文件的警告状态
C5032|检测到 #pragma warning (push) 测试 warning （没有相应 #pragma pop)

## <a name="warnings-introduced-in-visual-c-2015-rtm-compiler-version-1900230260"></a>在 Visual c + + 2015 RTM （编译器版本 19.00.23026.0） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/wv:18__。

|||
|-|-|
C4427|'*错误*： 除数，未定义的行为发生溢出
C4438|'*类型*： 不能安全地调用 /await: clrcompat 模式。 如果 '*类型*调入 CLR 则可能会导致 CLR 头损坏
C4455|运算符*名称*： 保留不以下划线开头的文本后缀标识符
C4456|声明*名称*隐藏上一个本地声明
C4457|声明*名称*隐藏了函数参数
C4458|声明*名称*隐藏了类成员
C4459|声明*名称*隐藏了全局声明
C4462|'*类型*： 无法确定的类型的 GUID。 程序可能在运行时失败。
C4463|地址信息溢出;将分配*值*到只包含中的值的位域*值*到*值*
C4473|'*函数*： 没有足够自变量传递为格式字符串
C4474|'*函数*： 格式字符串中传递的参数太多
C4475|'*函数*： 长度修饰符*修饰符*不能与类型字段字符一起使用'*字符*格式说明符中
C4476|'*函数*： 未知的类型字段字符*字符*格式说明符中
C4477|'*函数*： 格式字符串*字符串*要求类型的自变量*类型*，但可变参数参数*数*具有类型*类型*
C4478|'*函数*： 不能在相同的格式字符串中混合位置和非位置占位符
C4494|'*类型*： 忽略 __declspec （allocator），因为该函数返回类型不是指针或引用
C4495|使用了非标准扩展 __super： 替换为显示基类名
C4496|使用非标准扩展 for each： 替换为 ranged-for 语句
C4497|sealed 使用了非标准扩展： 替换为最终
C4498|使用了非标准扩展:*扩展*
C4499|'*专用化*： 显式专用化不能具有存储类 （忽略）
C4576|后跟初始值设定项列表的带圆括号类型是一种非标准的显式类型转换语法
C4577|noexcept 与任何异常处理模式，以指定; 一起使用不能保证在异常终止。 指定 /EHsc
C4578|abs： 从转换*类型*到*类型*，可能丢失数据 (您是否希望调用*名称*或 #include \<cmath >？)
C4582|'*类型*： 构造函数未隐式调用
C4583|'*类型*： 析构函数未隐式调用
C4587|'*类型*： 行为更改： 不再隐式调用构造函数
C4588|'*类型*： 行为更改： 不再隐式调用析构函数
C4589|抽象类的构造函数*类型*将忽略虚拟基类的初始值设定项*类型*
C4591|constexpr 调用深度限制*数量*超出 (/ constexpr:depth\<数 >)
C4592|'*类型*： 符号将自动初始化 （实现限制）
C4593|'*类型*: constexpr 调用评估步骤限制*值*超出; 请使用 /constexpr:\<数 > 以提高限制
C4647|行为更改： __is_pod (*类型*) 在早期版本中具有不同的值
C4648|忽略标准属性 carries_dependency
C4649|此上下文中忽略了属性
C4753|找不到指针的界限;忽略了 MPX 内部函数
C4771|必须使用简单的指针; 创建边界忽略了 MPX 内部函数
C4774|'*描述*： 格式字符串参数中的预期*数*不是字符串文字
C4775|格式字符串中使用了非标准扩展*字符串*的函数*函数*
C4776|%*字符*'函数的格式字符串中不允许 '*函数*
C4777|'*描述*： 格式字符串*字符串*要求类型的自变量*类型*，但可变参数参数*数*具有类型*类型*
C4778|'*描述*： 未终止的格式字符串*字符串*
C4838|从转换*类型*到*类型*需要收缩转换
C5022|'*类型*： 指定了多个移动构造函数
C5023|'*类型*： 指定的多个移动赋值运算符
C5024|'*声明*： 移动构造函数被隐式定义为已删除
C5025|'*声明*： 移动赋值运算符已隐式定义为已删除
C5026|'*类型*： 移动构造函数被隐式定义为已删除
C5027|'*类型*： 移动赋值运算符已隐式定义为已删除
C5028|'*名称*： 在之前的声明中指定的对齐方式 (*数*) 定义中未指定
C5029|使用了非标准扩展： c + + 中的对齐属性适用于变量、 数据成员和仅标记类型
C5030|属性*特性*无法识别

## <a name="warnings-introduced-in-visual-c-2013-compiler-version-1800210051"></a>在 Visual c + + 2013 （编译器版本 18.00.21005.1） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:17__。

|||
|-|-|
C4301|'*类型*： 仅重写虚函数不同于*声明*由 const/volatile 限定符
C4316|'*类型*： 在堆上分配的对象可能未对齐*数*
C4380|'*类型*： 无法弃用默认构造函数
C4388|'*令牌*： 有符号/无符号不匹配
C4423|std:: bad_alloc： 类将捕获 ('*类型*) 行上*数*
C4424|捕获为*类型*前面有*类型*行上*数*; 不可预知行为可能会导致如果引发 std:: bad_alloc
C4425|SAL 批注不能应用于...
C4464|相对包含路径包含..
C4575|__vectorcall 与不兼容 / clr 选项： 将转换为 __stdcall
C4609|'*类型*派生默认接口*类型*类型上*类型*。 使用适用于不同的默认界面 '*类型*，或中断基/派生关系。
C4754|在比较中的算术运算的转换规则*描述*(*数*) 意味着不能执行一个分支。 强制转换*类型*到*类型*(或类似类型的*数*字节)。
C4755|在比较中的算术运算的转换规则*描述*(*数*) 意味着不能内联函数中执行一个分支。 强制转换*类型*到*类型*(或类似类型的*数*字节)。
C4767|节名称*名称*的长度超过 8 个字符并将由链接器截断
C4770|部分验证的枚举*名称*用作索引
C4827|不带参数的公共 ToString 方法应标记为虚拟和重写
C4882|将带非常量调用运算符函子传递给 concurrency:: parallel_for_each 已弃用
C4973|'*类型*： 标记为已弃用
C4974|'*类型*： 标记为已弃用
C4981|Warbird： 函数*声明*标记为 __forceinline 未内联，因为它包含异常语义
C4990|Warbird:*消息*
C4991|Warbird： 函数*声明*标记为 __forceinline 未内联，因为已被内联方的保护级别高于父级
C4992|Warbird： 函数*声明*标记为 __forceinline 未内联，因为它包含无法保护的内联程序集

## <a name="warnings-introduced-in-visual-c-2012-compiler-version-1700511061"></a>在 Visual c + + 2012 （编译器版本 17.00.51106.1） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:16__。

|||
|-|-|
C4330|属性*特性*for 部分*部分*被忽略
C4415|重复 __declspec (code_seg ('*名称*'))
C4416|__declspec(code_seg(...)) 包含空字符串： 忽略
C4417|显式模板实例化不能具有 __declspec(code_seg(...))： 忽略
C4418|在枚举上忽略 __declspec(code_seg(...))
C4419|'*名称*不起作用时应用于私有 ref 类*类型*。
C4435|'*类型*': / vd2 下的对象布局将因虚拟基而更改*类型*
C4436|从虚拟基的 dynamic_cast '*类型*到*类型*构造函数或析构函数可能会失败的部分构造的对象
C4437|从虚拟基的 dynamic_cast '*类型*到*类型*在某些上下文中可能会失败
C4443|杂的注参数应为"0"、"1"或"2"
C4446|'*类型*： 不能将映射成员*名称*到这种类型，由于与类型名称冲突。 该方法已重命名为*名称*
C4447|main 签名找到不带线程模型。 请考虑使用 int main (platform:: array\<platform:: string ^ > ^ args)。
C4448|'*类型*没有元数据中指定的默认接口。 选择:*类型*，这可能会在运行时失败。
C4449|'*类型*非密封的类型应标记为 [WebHostHidden]
C4450|'*类型*应将标记为 [WebHostHidden] 因为它派生'*类型*
C4451|'*类型*: ref 类的用法*类型*在此上下文可能会导致无效的封送处理对象跨上下文
C4452|'*类型*： 公共类型不能在全局范围内。 它必须是输出.winmd 文件的名称的子级的命名空间中。
C4453|'*类型*： 不应使用不是公共类型的发布接口上的 [WebHostHidden] 类型 [WebHostHidden]
C4454|'*类型*[defaultoverload] 指定重载的多个输入参数的数目。 选取*声明*为默认重载
C4471|'*名称*： 无范围枚举的前向声明必须有基础类型 (假定为 int)
C4472|'*名称*是本机枚举： 添加访问说明符 (private/public) 以声明托管/WinRT 枚举
C4492|'*类型*： 匹配 ref 基类方法*类型*，但未标记为 override
C4493|删除表达式不起作用的析构函数作为 '*类型*没有 'public' 可访问性
C4585|'*类型*: WinRT public ref class 必须密封的或派生自的现有未密封的类
C4586|'*类型*： 不能在名为 Windows 的顶级命名空间中声明为公共类型
C4695|#pragma execution_character_set: '*自变量*不是受支持的参数： 支持当前仅 utf-8
C4703|可能未初始化的局部指针变量*名称*使用
C4728|/Yl-选项被忽略，因为需要 PCH 引用
C4745|可变访问*名称*能遵守由于其大小
C4746|可变访问*名称*' 受 /volatile:\<iso\|ms > 设置; 请考虑使用 __iso_volatile_load/store 内部函数
C4872|浮点编译在 concurrency:: parallel_for_each 的调用关系图时检测到的零除以: '*说明*
C4880|从执行强制转换*类型*到*类型*： 转换 constness 从指针或引用可能会导致在 amp 限制函数中未定义的行为
C4881|构造函数和/或析构函数将不会调用为 tile_static 变量*类型*
C4966|'*说明*具有 __code_seg 批注具有不受支持的段名称，忽略批注
C4988|'*类型*： 类/函数范围外声明了变量
C4989|'*说明*： 类型包含冲突的定义。

## <a name="warnings-introduced-in-visual-c-2010-compiler-version-16004021901"></a>在 Visual c + + 2010 （编译器版本 16.00.40219.01） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:15__。

|||
|-|-|
C4352|'*名称*： 已定义的内部函数
C4573|使用情况*类型*要求编译器捕获 this，但当前默认捕获模式不允许
C4574|'*名称*定义为"0： 您是否希望使用 #if*名称*？
C4689|'*字符*: #pragma 的 detect_mismatch 中不支持的字符; 忽略 #pragma
C4751|/arch AVX 标志不适用于 intel （） 流式处理 SIMD 扩展的内联 ASM 内
C4752|发现 intel （） 高级矢量扩展;请考虑使用相应的 /arch AVX 标志
C4837|检测到三元祖:??*字符*替换为*字符*
C4986|'*声明*： 异常规范与前面的声明不匹配
C4987|使用了非标准扩展：“throw (...)”

## <a name="warnings-introduced-in-visual-c-2008-compiler-version-15002102208"></a>在 Visual c + + 2008 （编译器版本 15.00.21022.08） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:14__。

|||
|-|-|
C4396|'*类型*： 友元声明引用函数模板的专用化时，不能使用内联说明符
C4413|'*声明*： 引用成员被初始化为构造函数退出后不会持久保存临时
C4491|'*说明*： 具有非法的 IDL 版本格式
C4603|'*名称*： 未定义宏或在预编译的头使用后定义发生改变
C4627|'*说明*： 在查找预编译标头使用时跳过
C4750|'*说明*： 函数 with _alloca （) 内嵌到循环
C4910|'*类型*: __declspec （dllexport） 和 extern 在显式实例化上不兼容
C4985|'*声明*： 以前的声明上不存在特性。

## <a name="warnings-introduced-in-visual-c-2005-compiler-version-140050727762"></a>在 Visual c + + 2005 （编译器版本 14.00.50727.762） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:13__。

|||
|-|-|
C4000|请未知警告选择技术支持命令的 Visual c + + 帮助菜单上，或打开技术支持帮助文件了解详细信息
C4272|'*类型*： 被标记为 __declspec （dllimport）; 导入函数时必须指定本机调用约定。
C4333|'*表达式*： 右移位数过大数据丢失
C4334|'*表达式*: 32 位移位的结果隐式转换为 64 位 （是否 64 位移？）
C4335|检测到 Mac 文件格式： 请将源文件转换为 DOS 或 UNIX 格式
C4342|行为更改: '*类型*调用，但在以前的版本中，称为成员运算符
C4350|行为更改: '*声明*而不是名为*声明*
C4357|委托的形式自变量列表中找到 param 数组参数*声明*生成时，忽略'*类型*
C4358|'*表达式*： 组合委托的返回类型不是 void; 返回的值是不确定
C4359|'*类型*： 对齐说明符小于实际对齐方式 (*数*)，并且将被忽略。
C4362|'*类型*: CLR 不支持大于 8 个字节的对齐方式
C4364|#using 适用于程序集 '*名称*在以前看到*说明*(*数*) 没有 as_friend 特性; 未应用 as_friend
C4365|'*表达式*： 从转换*类型*to*类型*，有符号/无符号不匹配
C4366|一元的结果*运算符*运算符可能是未对齐
C4367|从转换*类型*到*类型*可能会导致数据类型不对齐异常
C4368|不能定义*名称*为托管的成员*类型*： 不支持混合的类型
C4369|'*类型*： 枚举器值*数*不能表示为'*类型*，值为*数*
C4374|'*声明*： 不能由非虚方法实现接口方法*声明*
C4375|非公共方法*声明*不重写*声明*
C4376|访问说明符*说明符*: 不再受支持： 请使用 '*说明符*: 改为
C4377|本机类型是私有默认设置。-d1PrivateNativeTypes 已被否决
C4378|必须获得函数指针才能运行初始值设定项;请考虑 System::ModuleHandle::ResolveMethodHandle
C4379|版本*版本*的公共语言运行时不支持此编译器。 使用此版本可能会导致意外的结果
C4381|'*声明*： 不能由非公共方法实现接口方法*声明*
C4382|引发 '*类型*： 带有 __clrcall 析构函数或复制构造函数的类型仅可捕获在 /clr: pure 模块
C4383|'*类型*： 取消引用句柄的意义可以更改，用户定义*运算符*运算符存在; 将该运算符编写为有关操作数的显式静态函数
C4384|#pragma '*指令*仅应在全局范围内使用
C4393|'*类型*： 常量不起任何作用*说明*数据成员; 被忽略
C4394|'*类型*: per-appdomain 符号不应该标记与 __declspec (*值*)
C4395|'*类型*: initonly 数据成员的副本将调用成员函数*类型*
C4397|已忽略 DefaultCharSetAttribute
C4398|'*类型*： 每个进程的全局对象可能无法使用多个 appdomain 正常工作; 请考虑使用 __declspec
C4399|'*类型*: per-process 符号不应该标记与 __declspec (*值*) 时使用 /clr 编译： pure
C4400|'*类型*： 不支持此类型上的 const/volatile 限定符
C4412|'*声明*： 函数签名包含类型*类型*';C + + 对象是不安全纯代码之间传递与混合或本机。
C4429|可能不完整或格式不正确通用字符名称
C4430|缺少类型说明符 - 假定为 int。 注意： c + + 不支持默认 int
C4431|缺少类型说明符 - 假定为 int。 注意: C 不再支持默认的 int
C4434|静态构造函数必须具有私有可访问性;更改为专用访问
C4439|'*类型*： 函数签名中的托管类型的定义必须具有 __clrcall 调用约定
C4441|调用约定的 '*约定*被忽略;'*约定*改为使用
C4445|'*声明*： 托管/WinRT 类型中的虚方法不能是私有
C4460|CLR/WinRT 运算符 '*类型*，通过引用传递参数。 CLR/WinRT 运算符 '*运算符*具有不同的语义与 c + + 运算符*运算符*，是否原本希望通过值传递？
C4461|'*类型*： 此类有一个终结器 ！*类型*，但没有析构函数 ~*类型*
C4470|在 /clr 下忽略了浮点控制 pragma
C4480|使用了非标准扩展： 指定枚举的基础类型*类型*
C4481|使用了非标准扩展： 重写说明符*说明符*
C4482|使用了非标准扩展： 枚举 '*类型*限定名称中使用
C4483|语法错误： 应为 c + + 关键字
C4484|'*类型*： 匹配 ref 基类方法*类型*，但未标记为 virtual 一步、 上一 new 或 override;假定 new （而不是 virtual）
C4485|'*类型*： 匹配 ref 基类方法*类型*，但未标记为 new 或 override;假定 new （和 virtual）
C4486|'*类型*: ref 类或值类的私有虚方法应标记为 sealed
C4487|'*类型*： 匹配继承非虚方法*类型*，但不是显式标记为 new
C4488|'*类型*： 需要*关键字*关键字才能实现的接口方法*类型*
C4489|'*关键字*： 接口方法上不允许'*名称*; 重写说明符只允许在 ref 类和值类方法
C4490|'*关键字*： 重写说明符; 的使用不正确'*类型*不匹配 ref 基类方法
C4538|'*类型*： 不支持此类型上的 const/volatile 限定符
C4559|'*类型*： 重定义; 函数提升 __declspec (*值*)
C4565|'*类型*： 重定义; 符号之前声明的使用 __declspec (*值*)
C4566|通用字符名称表示字符*字符*不能出现在当前代码页 (*数*)
C4568|'*类型*： 没有成员的显式重写签名匹配
C4569|'*类型*： 没有成员的显式重写签名匹配
C4570|'*类型*： 没有显式声明为抽象的但具有抽象函数
C4571|Visual c + + 7.1; 之后更改的信息： 自语义不再捕获结构化的异常 (SEH)
C4572|在 /clr 下的 [ParamArray] 特性不推荐使用，请使用...改为
C4580|[attribute] 已弃用;改为指定*指定*作为基类的属性
C4581|已否决的行为:"*名称*"替换*名称*进程属性
C4606|#pragma 警告: '*数*被忽略;代码分析警告与警告等级无关
C4631|MSXML 或 XPath 不可用，将不会处理 XML 文档注释。 description
C4632|XML 文档注释：*描述*-访问被拒绝：*说明*
C4633|XML 文档注释*描述*： 错误：*说明*
C4634|XML 文档注释*描述*： 不能应用：*说明*
C4635|XML 文档注释*描述*： 格式错误的 XML:*说明*
C4636|XML 文档注释*描述*： 标记需要非空 '*说明*属性。
C4637|XML 文档注释*描述*:\<包括 > 标记被丢弃。 description
C4638|XML 文档注释*描述*： 引用未知符号*说明*。
C4639|MSXML 错误，不会处理注释的 XML 文档。 description
C4641|XML 文档注释含有不明确的交叉引用：
C4678|基本类的*声明*是可访问性低于*名称*
C4679|'*说明*： 无法导入成员
C4687|'*类型*： 密封的抽象类不能实现接口*类型*
C4688|'*名称*： 约束列表包含程序集私有类型*声明*
C4690|\[ emitidl (pop)]: 比入栈的多个
C4691|'*类型*： 引用的类型应在未引用*模块*'*说明*，而是使用了当前翻译单元中定义的类型
C4692|'*名称*： 非私有成员的签名包含程序集私有本机类型*声明*
C4693|'*类型*： 密封的抽象类不能具有任何实例成员*名称*
C4694|'*类型*： 密封的抽象类不能有基类'*类型*
C4720|内联汇编程序报告:*说明*
C4721|'*说明*： 不可用作内部函数
C4722|'*说明*： 析构函数永远不会返回，可能会发生内存泄漏
C4726|ARM arch4/4T 仅支持\<cpsr_f > 或\<spsr_f > 与即时值
C4727|名为的 PCH*名称*具有相同时间戳中找到*名称*并*名称*。  使用第一个 PCH。
C4729|根据警告，函数对于流图形太大
C4730|'*说明*： 混合 _m64 和浮点表达式可能会导致不正确的代码
C4731|'*描述*： 框架指针寄存器'*注册*被内联程序集代码修改
C4732|内部函数*内部函数*不支持在此体系结构
C4733|内联 asm 分配到"fs: 0": 未注册为安全处理程序的处理程序
C4734|超过 64k 中行号 COFF 调试信息节，则停止发出 COFF 调试行号为模块*模块*
C4738|将 32 位浮点型结果存储在内存中，可能会降低性能
C4739|对变量的引用*变量*超过了其存储空间
C4740|工作流中或出内联 asm 代码会取消全局优化
C4742|'*变量*具有不同的对齐*位置*'和'*位置*:*数*和*数*
C4743|'*名称*具有不同的大小*位置*和*位置*:*数*并*数量*字节
C4744|'*名称*具有不同的类型*位置*和*位置*':'*类型*'和'*类型*
C4747|调用托管*类型*： 托管的代码可能无法运行在有加载程序锁，包括 DLL 入口点和调用从 DLL 入口点访问
C4761|参数; 中的整型大小不匹配提供了转换
C4764|无法对齐大于 16 个字节的捕获对象
C4788|'*标识符*： 标识符被截断为*数*字符
C4789|缓冲区 '*名称*的大小*数*字节将溢出;*数量*将偏移量开始写入字节*数*
C4801|按引用返回是不可验证：*说明*
C4819|该文件包含无法出现在当前代码页的字符 (*数*)。 将文件保存以 Unicode 格式，以防止数据丢失
C4826|从转换*类型*到*类型*将进行符号扩展。 这可能会导致意外的运行时行为。
C4829|函数 main 的参数可能不正确。 请考虑 int main (platform:: array\<platform:: string ^ > ^ argv)
C4835|'*类型*： 在主机程序集中首次执行托管的代码之后，将不会运行导出的数据的初始值设定项
C4867|'*类型*： 非标准语法; 请使用 & 来创建指向成员的指针
C4936|只有使用 /clr 或 /clr:pure 编译时，才支持此 __declspec
C4937|'*名称*和*名称*'是无法区分作为参数'*选项*
C4938|'*类型*： 浮点 reduction 变量可能会导致不一致的结果在 /fp: strict 或 #pragma fenv_access
C4939|#pragma vtordisp 已被否决，并将在 Visual C++ 将来的版本移除
C4947|'*类型*： 标记为已过时
C4949|杂注 managed 和 unmanaged 是仅当使用编译时，才有意义 / clr [: 选项]
C4950|'*类型*： 标记为已过时
C4955|'*描述*： 忽略导入; 已经从导入*源*
C4956|'*类型*： 此类型是不可验证
C4957|'*表达式*： 从显式强制转换*类型*to*类型*是不可验证
C4958|'*表达式*： 指针算法是不可验证
C4959|不能定义非托管*类*'*类型*/clr: safe 中因为访问其成员会产生不可验证代码
C4960|'*说明*太大而无法进行事件探查
C4961|没有配置文件数据合并到*位置*，已禁用按配置文件优化
C4962|'*说明*： 已禁用在于优化导致了配置文件数据变得不一致的按配置优化
C4963|'*说明*： 没有配置文件数据找到; 检测的生成中使用不同的编译器选项
C4964|未不指定任何优化选项;将不会收集个人资料信息
C4965|整数 0; 的隐式装箱请使用 nullptr 或显式强制转换
C4970|委托构造函数： 因为忽略目标对象*声明*' 是静态的
C4971|参数顺序：\<目标对象 >，\<目标函数 > 委托构造函数已被弃用，请使用\<目标函数 >，\<目标对象 >
C4972|直接修改取消装箱操作的结果或将其视为左值是不可验证的

## <a name="warnings-introduced-in-visual-c-2003-compiler-version-13103077"></a>在 Visual c + + 2003 （编译器版本 13.10.3077） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:13.00.9466__。

|||
|-|-|
C4343|#pragma 优化 (*说明*，off) 重写 /Og 选项
C4344|行为更改： 使用显式模板参数导致调用 '*声明*
C4346|'*类型*： 依赖名称不是类型
C4348|'*声明*： 重定义默认参数： 参数*数*
C4356|'*类型*： 不能通过派生类中初始化静态数据成员
C4408|匿名*结构*没有声明任何数据成员
C4544|'*声明*： 默认模板自变量将忽略此模板声明
C4545|逗号前的表达式计算为缺少自变量列表的函数
C4546|逗号前的函数调用缺少自变量列表
C4547|'*表达式*： 运算符之前逗号不起任何作用; 应输入带副作用的运算符
C4548|逗号前的表达式不起任何作用；应输入带副作用的表达式
C4549|'*表达式*： 逗号前的运算符不起作用; 是否打算'*表达式*？
C4628|-Ze 不支持二合字母。 字符序列*序列*未解释的替换标记为*令牌*
C4629|有向图时会使用，字符序列*序列*解释为标记*令牌*（如果这是不是您想在此处插入的两个字符之间有空格）
C4671|'*说明*： 复制构造函数不可访问
C4676|'*说明*: 析构函数不可访问
C4677|'*名称*： 非私有成员的签名包含程序集私有类型*声明*
C4686|'*类型*： 行为可能有更改，UDT 中的更改返回调用约定
C4812|过时的声明样式： 请使用 '*类型*::*名称*改为
C4813|'*类型*： 局部类的友元函数必须具有已以前声明
C4821|无法确定 Unicode 编码类型，请用签名 (BOM) 保存文件
C4822|'*类型*： 局部类成员函数没有正文
C4823|'*类型*： 使用钉住指针但展开语义不会启用。 请考虑使用 /EHa
C4913|存在用户定义的二进制运算符“,”，但没有重载可以转换所有操作数，使用了默认的内置二进制运算符“,”
C4948|返回类型*声明*与相应的 setter 的最后一个参数类型不匹配
C4951|'*说明*已编辑过收集配置文件数据后，没有使用函数配置文件数据
C4952|'*描述*： 在程序数据库中找到的任何配置文件数据'*说明*
C4953|被内联方*说明*已编辑过收集配置文件数据后，不使用配置文件数据
C4954|'*说明*： 不会分析 （包含 __int64 switch 表达式）

## <a name="warnings-introduced-in-visual-c-2002-compiler-version-13009466"></a>在 Visual c + + 2002 （编译器版本 13.00.9466） 中引入的警告

通过使用编译器选项禁止显示这些警告和更高版本中的所有警告 __/Wv:12__。

|||
|-|-|
C4096|'*类型*： 接口不是 COM 接口; 不会发送到 IDL
C4097|杂注参数应是“restore”或者“off”
C4165|HRESULT 正在转换为 bool;是否确定这是你想？
C4183|'*名称*： 缺少返回类型; 假定为返回 int 的成员函数
C4199|description
C4255|'*名称*： 未给出函数原型： 将转换为 (void)
C4256|'*声明*： 带虚拟基的类构造函数有...; 调用可能不会与较旧版本的 Visual c + + 兼容
C4258|'*名称*： 从定义忽略 for 循环; 使用封闭范围中的定义
C4263|'*声明*： 成员函数不重写任何基类虚拟成员函数
C4264|'*声明*： 不重写虚拟成员函数从基本的'*类*; 函数被隐藏
C4265|'*类型*： 类有虚函数，但析构函数不是虚拟的此类实例可能不能正确析构
C4266|'*声明*： 不重写虚拟成员函数从基本的'*类*; 函数被隐藏
C4267|'*表达式*： 从 size_t 为转换*类型*，可能丢失数据
C4274|#ident 忽略;请参阅 #pragma comment （exestr，'string'） 的文档
C4277|导入的项*类型*::*名称*作为数据成员和函数成员; 存在忽略数据成员
C4278|'*名称*： 类型库中的标识符*说明*已经是宏; 使用 rename 限定符
C4279|'*名称*： 类型库中的标识符*说明*是关键字; 使用 rename 限定符
C4287|'*表达式*： 无符号/负常量不匹配
C4288|使用了非标准扩展:*名称*： 在 for 循环中声明的循环控制变量用在 for 循环范围外; 它与外部作用域中的声明冲突
C4289|使用了非标准扩展:*名称*： 在 for 循环中声明的循环控制变量用在 for 循环范围外
C4293|'*表达式*: shift 计数为负或过大、 未定义的行为
C4295|'*类型*： 数组是太小，无法包括终止 null 字符
C4296|'*表达式*： 表达式始终是*值*
C4297|'*类型*： 假定函数不引发异常，但确实
C4298|'*名称*： 类型库中的标识符*说明*已经是宏; 重命名为 __*名称*
C4299|'*名称*： 类型库中的标识符*说明*是关键字; 重命名为 __*名称*
C4302|'*表达式*： 从截断*类型*to*类型*
C4303|*转换*从*类型*到*类型*是不推荐使用，使用 static_cast、 __try_cast 或 dynamic_cast
C4314|杂的注参数应为"32"或"64"
C4315|'*类型*： 成员 this 指针*类型*可能未对齐*数*按预期方式由构造函数
C4318|将常量零作为长度传递给 memset
C4319|'*表达式*： 零扩展*类型*to*类型*更大的
C4321|自动生成接口的 IID '*类型*
C4322|自动生成的类的 CLSID*类型*
C4323|重新使用的类的已注册 CLSID*类型*
C4324|'*类型*： 由于对齐说明符，结构被填充
C4325|忽略标准节*说明*被忽略
C4326|返回类型*名称*'应是'*类型*而不是 of*类型*
C4327|'*表达式*: LHS 的间接对齐 (*数量*) 大于 RHS (*数*)
C4328|*描述*： 形参的间接对齐*数*(*数*) 大于实参对齐 (*数*)
C4329|枚举上忽略对齐说明符
C4336|导入交叉引用的类型库*库*之前导入*说明*
C4337|交叉引用的类型库*库*in*说明*自动导入
C4338|#pragma*描述*： 标准节*部分*使用
C4339|'*类型*： 未定义的类型检测到使用了在 CLR/WinRT 元数据-使用此类型可能导致运行时异常
C4353|使用了非标准扩展： 常量 0 作为了函数表达式。  请改用 __noop 函数内部函数
C4370|'*声明*： 类的布局已从以前版本更好地封装的编译器的更改
C4371|'*声明*： 类的布局可能已更改从以前版本的编译器更好地封装成员*成员*
C4373|'*类型*： 虚函数重写*声明*上, 一版本的编译器未进行重写时参数只上有差异 const/volatile 限定符
C4387|'*说明*： 被视为
C4389|'*表达式*： 有符号/无符号不匹配
C4391|'*声明*： 内部函数，预期的返回类型不正确*类型*
C4392|'*声明*： 缺少内部函数的参数数目不正确*数*参数
C4407|指向成员表示形式的不同指针之间强制转换，编译器可能生成不正确的代码
C4420|'*名称*： 操作员不可用，请使用'*名称*改为; 运行时检查可能会危及
C4440|调用约定重定义从*描述*到*说明*被忽略
C4442|__annotation 参数中嵌入了 null 结束符。  该值将被截断。
C4444|'*名称*： 顶层 __unaligned 未在此上下文中实现
C4526|'*类型*： 静态成员函数不能重写虚函数*声明*重写将被忽略，将隐藏虚函数
C4531|C + + 异常处理在 Windows CE 上不可用。 使用结构化的异常处理
C4532|'*描述*： 跳出*最后*块已在终止处理期间未定义行为
C4533|初始化*声明*通过跳过 goto*声明*
C4534|'*声明*不会默认构造函数*类*'*类型*由于默认自变量
C4535|调用 _set_se_translator （） 需要 /EHa
C4536|'*说明*： 类型名超出了元数据限制，'*数*字符
C4537|'*声明*': '。 应用于非 UDT 类型
C4542|跳过生成合并的注入的文本文件，无法写入*类型*文件: '*filename*:*错误*
C4543|插入文本特性禁止显示没有\_injected_text
C4555|表达式无效；应输入带副作用的表达式
C4557|__assume 包含效果*效果*
C4558|操作数的值*数量*不在范围内'*数* - *数*
C4561|__fastcall 与不兼容 / clr 选项： 将转换为 __stdcall
C4562|完全保持原型的函数所需使用 / clr 选项： 将转换为 (void)
C4564|方法*名称*的*类*'*类型*定义了不受支持的默认参数'*参数*
C4584|'*类型*： 基类'*声明*'已是基类的*声明*
C4608|正在初始化多个联合成员: '*类型*和*类型*
C4619|#pragma 警告： 无警告编号*数*
C4623|'*类型*： 默认构造函数隐式定义为已删除
C4624|'*类型*： 析构函数隐式定义为已删除
C4625|'*类型*： 复制构造函数隐式定义为已删除
C4626|'*类型*： 赋值运算符已隐式定义为已删除
C4645|用 noreturn 声明的函数具有 return 语句
C4646|用 noreturn 声明的函数具有非 void 返回类型
C4659|#pragma '*描述*： 使用的保留段*名称*具有未定义行为，使用 #pragma comment (linker，...)
C4667|'*声明*： 没有匹配的函数模板定义与强制实例化
C4668|'*名称*未定义为预处理器宏，用"0"替换为中'*值*
C4669|'*表达式*： 不安全的转换:*类型*是托管/WinRT 类型对象
C4674|'*名称*应声明为 static 和正好有一个参数
C4680|'*类型*： 组件类不指定默认接口
C4681|'*类型*： 组件类不指定是事件源的默认接口
C4682|'*类型*： 指定，默认为 [in] 未方向参数特性
C4683|'*声明*： 事件源有输出的参数; 遇到警告时挂接多个事件处理程序
C4684|'*说明*： 警告!! 属性可能会导致生成无效代码： 小心使用
C4685|分析模板参数时需要“> >”，却找到了“>>”
C4700|未初始化的局部变量*名称*使用
C4701|可能未初始化的局部变量*名称*使用
C4702|无法访问的代码
C4711|函数*名称*为自动内联扩展选择
C4714|函数*声明*标记为 __forceinline 未内联
C4715|'*函数*： 并非所有控件路径都返回值
C4716|'*函数*： 必须返回值
C4717|'*函数*： 递归的所有控件路径，函数将导致运行时堆栈溢出
C4718|'*函数*： 递归调用没有任何副作用，删除
C4719|指定 Qfast 时发现的使用 f 作为后缀以指示单精度的双精度常量
C4723|潜在的被 0 除
C4724|潜在的以 0 求模
C4725|在一些 Pentium 中，指令可能不准确
C4757|下标是大无符号的值，是否负常量？
C4772|#import 从缺少的类型库; 引用了类型'*说明*用作占位符
C4792|函数*函数*声明使用 sysimport 声明并引用从本机代码; 需要导入库链接
C4794|线程本地存储区变量的段*名称*更改*段*to*段*
C4798|为 p 代码函数生成的本机代码*名称*与异常处理程序或展开语义
C4799|函数*名称*没有 EMMS 指令
C4803|'*声明*： 引发方法具有不同的存储类从与事件*声明*
C4810|杂注 pack （show） 的值 = =*数*
C4811|conform (forScope，show) 的杂注的值 = =*值*
C4820|'*类型*:*数量*字节填充添加后*类型*'*类型*
C4905|宽字符串文本转换为*类型*
C4906|字符串强制转换为*类型*
C4912|'*特性*： 特性有未定义在嵌套 UDT 上的行为
C4916|为具有 dispid，'*类型*： 必须通过接口引入
C4917|'*类型*: GUID 只能与类、 接口或命名空间相关联
C4918|'*字符*： 杂注优化列表中的字符无效
C4920|枚举*名称*成员*名称*=*数*已经看到在枚举*名称*作为*名称*=*数*
C4921|'*名称*： 属性值*值*不应累积指定
C4925|'*声明*： 不能从脚本调用调度接口方法
C4926|'*声明*： 已定义符号： 忽略特性
C4927|转换非法;隐式应用了多个用户定义的转换
C4928|副本初始化非法；隐式应用了多个用户定义的转换
C4929|'*说明*： 类型库包含联合; 忽略 embedded_idl 限定符
C4930|'*声明*： 未调用原型函数 （是否有意用变量定义？）
C4931|我们假定类型库为生成*数*-位指针
C4932|__identifier (*描述*) 和 __identifier (*说明*) 无法区分
C4934|__delegate （multicast） 已弃用，请使用改用 __delegate
C4935|程序集访问说明符修改从*说明*
C4944|*名称*： 不能从导入符号*源*： 作为*声明*已存在于当前作用域
C4945|*名称*： 不能从导入符号*源*： 作为*声明*具有已导入从另一个程序集'*源*
C4946|reinterpret_cast 在相关类之间使用:*声明*和*声明*
C4995|'*名称*： 名称被标记为不推荐使用的 #pragma
C4996|'*问题*:*说明*
C4997|'*类型*： 组件类不实现 COM 接口或伪接口
C4998|预期失败：*描述*(*数*)

## <a name="see-also"></a>请参阅

- [/Wv 编译器选项](../../build/reference/compiler-option-warning-level.md)
- [默认情况下处于关闭状态的编译器警告](../../preprocessor/compiler-warnings-that-are-off-by-default.md)
- [warning](../../preprocessor/warning.md)
