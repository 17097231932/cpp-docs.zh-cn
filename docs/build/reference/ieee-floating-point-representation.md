---
title: IEEE 浮点表示形式 |Microsoft 文档
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: d209d1c2a7429515383f8ebe80c621d6f2b15890
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/03/2018
ms.locfileid: "32379427"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮点表示形式
Microsoft Visual c + + 是与 IEEE 数值标准保持一致。 有三个内部类型的实际数量。 实际\*4 和 real\*在 Visual c + + 中使用 8。 实际\*使用 word 声明 4 **float**。 实际\*使用 word 声明 8 **double**。 在 32 位 Windows 编程中，`long double`数据类型映射到**double**。 没有，但是，程序集语言支持用于计算使用 real * 10 个数据类型。  
  
 这些值存储，如下所示：  
  
|值|存储为|  
|-----------|---------------|  
|real * 4|登录位，8 位指数，23 位尾数|  
|real * 8|登录位、 11 位指数、 52 位尾数|  
|real * 10|登录位、 15 位指数、 64 位尾数|  
  
 在 real * 4 和 real\*8 格式，而它并不存储在内存中，因此尾数实际上是 24 或 53 位位，即使存储仅 23 或 52 位尾数中没有假定的前导 1。 真实\*10 格式实际上将存储此位。  
  
 指数偏离其可能的值的一半。 这意味着减去此从存储的指数以获取实际的指数的偏差。 如果存储的指数小于偏差，则实际上是负指数。  
  
 指数偏离，如下所示：  
  
|指数|通过偏向|  
|--------------|---------------|  
|8 位 (real * 4)|127|  
|11 位 (real * 8)|1023|  
|15 位 (real * 10)|16383|  
  
 这些指数不是 2 的 10 个; 幂它们是 2 的幂。 也就是说，8 位存储的指数可以最多为 127。 值为 2 * * 127 是大致相当于 10\*\*38，这是真实的实际上限\*4。  
  
 尾数存储为二进制分数的窗体 1.XXX...。 此部分具有大于或等于 1 且小于 2 的值。 请注意，实数始终存储在标准化形式;也就是说，尾数是向左移动以便尾数的高顺序位始终为 1。 此位始终为 1，因为它假定 （不存储） 在 real * 4 和 real\*8 格式。 二进制 （未小数） 点假定可前导 1 右侧。  
  
 格式，然后，针对各种大小为，如下所示：  
  
|格式|字节 1|字节 2|字节 3|字节 4|...|字节 n|  
|------------|------------|------------|------------|------------|---------|------------|  
|real * 4|`SXXX XXXX`|`XMMM MMMM`|`MMMM MMMM`|`MMMM MMMM`|||  
|real * 8|`SXXX XXXX`|`XXXX MMMM`|`MMMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
|real * 10|`SXXX XXXX`|`XXXX XXXX`|`1MMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
  
 `S` 表示符号位`X`的是指数的位，与`M`的是尾数位。 请注意，将最左边的位假定在 real * 4 和 real\*8 格式，但显示为"1"的实际字节 3 中\*10 格式。  
  
 若要正确地变换二进制点，您首先阶，然后向右移动一些二进制点或剩余的适当数量的位。  
  
## <a name="examples"></a>示例  
 以下是一些示例在 real * 4 格式：  
  
-   在下面的示例中，符号位为零，且存储的指数是 128 或 100 0000 0 二进制文件中，即 127 加 1。 存储的尾数是 (1)。000 0000 ...0000 0000，其中有一个隐含前导 1 和二进制点，因此实际的尾数是 1。  
  
    ```  
                        SXXX XXXX XMMM MMMM ... MMMM MMMM  
    2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000  
    ```  
  
-   与 + 2 相同，只不过设置符号位。 这适用于所有 IEEE 格式浮点数。  
  
    ```  
    -2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000  
    ```  
  
-   尾数相同，指数加一 （有偏差的值为 129 或以二进制形式的 100 0000 1。  
  
    ```  
    4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000  
    ```  
  
-   指数相同，尾数大于一半 — 它的 (1)。100 0000...0000 0000，由于这是一个二进制分数，为 1 1/2 （的小数位数的值是 1/2、 1/4、 1/8 和等）。  
  
    ```  
    6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000  
    ```  
  
-   与其他 2 的两个，尾数幂的指数相同是小于 2 处 127 或以二进制形式 011 1111年 1。  
  
    ```  
    1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000  
    ```  
  
-   有偏差的指数是 126 011 1111年 0 在二进制和尾数为 (1)。100 0000 ...0000 0000，即 1 1/2。  
  
    ```  
    .75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000  
    ```  
  
-   完全设置与相同，除非两个表示 1/4 位尾数中。  
  
    ```  
    2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000  
    ```  
  
-   1/10 是重复的分数以二进制形式。 尾数是害怕 1.6，并有偏差的指数显示 1.6 旨在除以 16 （它是二进制文件中，这是采用十进制 123 011 1101年 1）。 实际的指数是 123-127 =-4，这意味着要相乘的因子为 2 * *-4 = 1/16。 请注意，存储的尾数向上舍入中的最后一位-尝试尽可能精确地表示无法表示的数。 (原因 1/10 和 1/100 是以二进制形式不完全可表示类似于 1/3 不完全在十进制中表示的原因。)  
  
    ```  
    0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD  
    ```  
  
-   `0  = 1.0 * 2**-128 = all zeros--a special case.`  
  
## <a name="see-also"></a>请参阅  
 [为何浮点数可能丢失精度](../../build/reference/why-floating-point-numbers-may-lose-precision.md)