---
title: "1.3 执行模型 |Microsoft 文档"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
caps.latest.revision: "5"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: ce9c2398b38effebbca428c811d86481ca94e7cd
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/21/2017
---
# <a name="13-execution-model"></a>1.3 执行模型
OpenMP 使用并行执行 fork-join 模型。 虽然此 fork-join 模型可用于解决各种问题，但它是某种程度上针对大型数组基于应用程序。 OpenMP 旨在到将立即执行正确同时并行程序 （多个执行线程和完整的 OpenMP 支持库） 的支持计划并为顺序程序 （忽略的指令和简单的 OpenMP 存根 （stub） 库）。 但是，它有可能，并且允许开发不无法正确工作时按顺序执行的程序。 此外，不同的并行度可能会导致不同的数值结果由于数值运算的关联中的变化。 例如，串行添加减少可能具有比并行缩减添加关联的不同模式。 这些不同的关联可能会更改浮点加法的结果。  
  
 使用 OpenMP C/c + + API 编写的程序开始执行调用作为单个线程执行*主线程*。 直到遇到的第一个并行构造，主线程执行串行区域中。 在 OpenMP C/c + + API 中，**并行**指令构成并行构造。 当遇到并行构造时，主线程创建一个团队的线程，而主变成 master 的团队。 团队在每个线程并行区域，但工作共享构造除外的动态范围中执行的语句。 必须由相同的顺序，团队中的所有线程遇到工作共享构造和关联的结构化块内的语句执行一个或多个线程。 缺少工作共享构造末尾默示屏障`nowait`通过团队中的所有线程执行子句。  
  
 如果一个线程将修改共享的对象，则会影响其自己的执行环境、 不仅那些在程序中的其他线程。 修改保证仅当对象被声明为易失性时，才会完成后，从角度来看的其他线程，在下一个序列点之一 （如在基的语言中定义）。 否则，修改可以保证完成后第一次修改线程，然后 （或同时） 其他线程遇到**刷新**（隐式或显式） 指定的对象的指令。 请注意，当**刷新**通过其他 OpenMP 指令隐式的指令不能满足需求，以确保所需的排序的副作用，程序员负责提供其他、 显式**刷新**指令。  
  
 完成后的并行构造，团队中的线程同步的隐式的屏障，而且只有主线程继续执行。 在单一程序，可以指定任意数量的并行构造。 因此，程序可能分叉，并加入期间执行的许多时间。  
  
 OpenMP C/c + + API 允许程序员可以从调用中并行构造函数中使用指令。 指令未出现在并行构造的词法范围，但可能处于的动态范围称为*孤立*指令。 孤立的指令使程序员能够进行仅少量的更改到顺序的程序的并行执行程序的主要部分。 使用此功能，用户可以在程序调用关系树的顶层的并行构造的代码和使用指令以控制在任何已调用函数的执行。  
  
 C 和 c + + 的未同步的调用输出写入到同一文件的函数可能会导致的输出在其中编写不同的线程的数据显示在具有不确定性的顺序。 同样，若要输入从同一个文件中读取的函数的未同步的调用可以读取顺序具有不确定性的数据。 未同步的使用 I/O，以便每个线程访问另一个文件，会生成与串行执行 I/O 函数相同的结果。