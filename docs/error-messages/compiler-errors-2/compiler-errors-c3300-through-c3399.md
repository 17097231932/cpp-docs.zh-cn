---
title: 编译器错误 C3300 - C3399
ms.date: 04/21/2019
f1_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
helpviewer_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
ms.assetid: 190b7d29-ffe6-4261-921d-140da1935d00
ms.openlocfilehash: ca55e19534f722a7231a1d30c63e2dbb77d25ec7
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857727"
---
# <a name="compiler-errors-c3300-through-c3399"></a>编译器错误 C3300 - C3399

在本部分文档中的文章说明了由编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|Error|消息|
|-----------|-------------|
|编译器错误 C3300|'*符号*: IDL 的格式不正确*值*|
|编译器错误 C3301|'*组件类*： 组件类不能为'*符号*接口|
|编译器错误 C3302|'*标识符*： 标识符具有多个*数*字符|
|[编译器错误 C3303](compiler-error-c3303.md)|'*特性*： 特性只能在使用*类型*|
|编译器错误 C3304|已过时。|
|编译器错误 C3305|已过时。|
|编译器错误 C3306|'*模板*： 不允许未命名的类模板/泛型|
|编译器错误 C3307|'*模块*： 无法创建 IDL 模块|
|编译器错误 C3308|'*函数*： 不支持通过导入的类的调用直接|
|[编译器错误 C3309](compiler-error-c3309.md)|'*宏*/*关键字*： 模块名称不能是宏或关键字|
|编译器错误 C3310|'*标识符*： 模块名称冲突|
|编译器错误 C3311|模块特性必须在全局范围内定义|
|编译器错误 C3312|没有可调用 '*标识符*函数找到类型*类型*|
|编译器错误 C3313|'*标识符*： 变量不能具有类型*类型*|
|编译器错误 C3314|'*符号*： 不是受支持的 IDL 模块类型|
|编译器错误 C3315|'*函数*： 必须是成员函数|
|编译器错误 C3316|'*类型*： 未知大小的数组不能用于在基于范围的语句|
|编译器错误 C3317|'*标识符*： 重载函数不能用作语句中基于范围的表达式|
|编译器错误 C3318|'*类型*： 数组不能具有包含 auto 的元素类型|
|编译器错误 C3319|已过时。|
|[编译器错误 C3320](compiler-error-c3320.md)|'*类型*： 类型不能具有相同的名称和模块的 name 属性|
|编译器错误 C3321|初始值设定项列表是此上下文中的意外|
|[编译器错误 C3322](compiler-error-c3322.md)|'*属性*： 不是属性的有效属性*属性*|
|编译器错误 C3323|函数声明上不允许 alignas 和 __declspec （align）|
|编译器错误 C3324|'*属性*： 属性在属性中出现多次'*属性*|
|编译器错误 C3325|'*特性*： 属性具有的参数太多|
|编译器错误 C3326|'*值*： 不是有效的值为属性*属性*的属性'*属性*|
|编译器错误 C3327|'*属性*： 必须指定属性的属性的值*属性*|
|编译器错误 C3328|'*特性*： 属性不具有足够的参数|
|编译器错误 C3329|语法错误： 预期 '*token1*not*token2*|
|编译器错误 C3330|'*函数*： 函数不能返回数组'*类型*|
|编译器错误 C3331|'*标识符*： 参数上的属性只能在 COM 接口和组件类|
|编译器错误 C3332|'*属性*： 语法不一致，属性*属性*是同时要求，并且有默认值|
|[编译器错误 C3333](compiler-error-c3333.md)|'*库*： 不能 #import 损坏的类型库|
|[编译器错误 C3334](compiler-error-c3334.md)|无法 #import 损坏的类型库|
|编译器错误 C3335|'*标识符*:有最多只能包含一个默认接口用于 coclass'*类*|
|编译器错误 C3336|必须在类范围内执行此操作|
|编译器错误 C3337|'*标识符*: defaultvtable 必须是组件类的事件源*类*|
|编译器错误 C3338|'*标识符*:有最多只能包含一个默认接口，它也用于 coclass 的事件源*类*|
|编译器错误 C3339|模板 template 参数在参数列表之后需要 class 或 typename|
|[编译器错误 C3340](compiler-error-c3340.md)|'*标识符*： 接口不能是 restricted 和 default 中组件类*类*|
|编译器错误 C3341|'*接口*: defaultvtable 接口必须是 dual 或者自定义|
|[编译器错误 C3342](compiler-error-c3342.md)|'*标识符*： 不明确的特性|
|编译器错误 C3343|'*类*::*名称*： 特性标识符的字符太多|
|编译器错误 C3344|不能定义显式专用化，也不的部分专用化*符号*|
|[编译器错误 C3345](compiler-error-c3345.md)|'*名称*： 模块名称的标识符无效|
|编译器错误 C3346|在非命名空间范围导出的声明|
|[编译器错误 C3347](compiler-error-c3347.md)|'*自变量*： 所需属性中未指定参数*asttribute*|
|编译器错误 C3348|导出的模板不属于当前C++标准|
|编译器错误 C3349|'*类*::*成员*： 多路广播的特性已由提供程序实现*提供程序*|
|[编译器错误 C3350](compiler-error-c3350.md)|'*函数*： 委托构造函数需要*数*个参数|
|[编译器错误 C3351](compiler-error-c3351.md)|'*函数*： 如果将 NULL 对象实例传递给委托构造函数必须也传递静态成员函数的地址|
|[编译器错误 C3352](compiler-error-c3352.md)|'*函数*： 指定的函数与委托类型不匹配*类型*|
|[编译器错误 C3353](compiler-error-c3353.md)|'*标识符*： 委托只能从全局函数或托管/WinRT 类型的成员函数中创建|
|[编译器错误 C3354](compiler-error-c3354.md)|'*标识符*： 用来创建委托的函数不能有返回类型*类型*|
|编译器错误 C3355|'*类*::*成员*： 多路广播的特性侦听提供程序*provider1*，但由提供程序实现'*provider2*|
|[编译器错误 C3356](compiler-error-c3356.md)|'*标识符*： 不能调用的完全限定的名称与多路广播的特性|
|编译器错误 C3357|'*特性*： 特性不明确，必须使用完全限定的名称|
|[编译器错误 C3358](compiler-error-c3358.md)|'*符号*： 未找到符号|
|编译器错误 C3359|'*专用化*： 无法专用化模板|
|[编译器错误 C3360](compiler-error-c3360.md)|'*字符串*： 无法创建*名称*|
|编译器错误 C3361|没有在其中为上下文*操作*|
|编译器错误 C3362|'*类*::*成员*： 多路广播的特性尚未实现|
|[编译器错误 C3363](compiler-error-c3363.md)|'*标识符*: typeid 只能应用于类型|
|[编译器错误 C3364](compiler-error-c3364.md)|'*函数*： 委托构造函数的参数无效; 委托目标需要是指向成员函数的指针|
|[编译器错误 C3365](compiler-error-c3365.md)|运算符*运算符*： 不同类型的操作数*类型*'和'*类型*|
|[编译器错误 C3366](compiler-error-c3366.md)|'*成员*： 必须在类定义中定义的托管 WinRT 类型的静态数据成员|
|[编译器错误 C3367](compiler-error-c3367.md)|'*函数*： 不能使用静态函数创建未绑定的委托|
|[编译器错误 C3368](compiler-error-c3368.md)|'*声明符*: IDL 的调用约定无效|
|[编译器错误 C3369](compiler-error-c3369.md)|'*模块*: idl_module 已经定义|
|[编译器错误 C3370](compiler-error-c3370.md)|'*模块*: idl_module 尚未定义|
|[编译器错误 C3371](compiler-error-c3371.md)|“idl_module”: 此处只允许“name”属性|
|[编译器错误 C3372](compiler-error-c3372.md)|必须指定至少 1 个接口属性*特性*为组件类|
|[编译器错误 C3373](compiler-error-c3373.md)|属性*特性*除了接受任何参数为组件类|
|[编译器错误 C3374](compiler-error-c3374.md)|无法获取地址的 '*函数*除非创建委托实例|
|[编译器错误 C3375](compiler-error-c3375.md)|'*函数*： 不明确的委托函数|
|编译器错误 C3376|'*模板*： 允许仅静态数据成员模板|
|编译器错误 C3377|在新表达式中不允许 decltype （auto）|
|编译器错误 C3378|可仅从模块接口单元中导出声明|
|[编译器错误 C3379](compiler-error-c3379.md)|'*类*： 嵌套的类不能将程序集访问说明符作为其声明的一部分|
|[编译器错误 C3380](compiler-error-c3380.md)|'*说明符*： 无效的程序集访问说明符-只允许 public 或 private|
|[编译器错误 C3381](compiler-error-c3381.md)|'*说明符*： 程序集访问说明符仅在用 /clr 选项编译的代码中可用|
|[编译器错误 C3382](compiler-error-c3382.md)|不支持将“sizeof”与 /clr:safe 一同使用|
|[编译器错误 C3383](compiler-error-c3383.md)|不支持将“operator new”与 /clr:safe 一起使用|
|[编译器错误 C3384](compiler-error-c3384.md)|'*类型*： 值约束与 ref 约束互相排斥|
|[编译器错误 C3385](compiler-error-c3385.md)|'*函数*： 具有 DllImport 自定义特性的函数不能返回类的实例|
|[编译器错误 C3386](compiler-error-c3386.md)|'*类型*: /__declspec 到托管/WinRT 类型|
|[编译器错误 C3387](compiler-error-c3387.md)|'*成员*: /__declspec 到托管/WinRT 类型的成员|
|[编译器错误 C3388](compiler-error-c3388.md)|'*令牌*： 不允许作为约束，假定'*值*以继续进行分析|
|[编译器错误 C3389](compiler-error-c3389.md)|__declspec (*说明符*) 不能用于 /clr: pure 或 /clr: safe|
|[编译器错误 C3390](compiler-error-c3390.md)|'*类型*： 泛型参数的类型参数无效*参数*的泛型*generic_type*，必须是引用类型|
|[编译器错误 C3391](compiler-error-c3391.md)|'*类型*： 泛型参数的类型参数无效*参数*的泛型*generic_type*，必须为非空值类型|
|[编译器错误 C3392](compiler-error-c3392.md)|'*类型*： 泛型参数的类型参数无效*参数*的泛型*generic_type*，必须具有公共无参数构造函数|
|[编译器错误 C3393](compiler-error-c3393.md)|constraint 子句的语法错误: '*标识符*不是类型|
|[编译器错误 C3394](compiler-error-c3394.md)|constraint 子句的语法错误： 找到 '*符号*应为类型|
|[编译器错误 C3395](compiler-error-c3395.md)|'*函数*: __declspec （dllexport） 不能具有 __clrcall 调用约定应用于函数|
|[编译器错误 C3396](compiler-error-c3396.md)|'*类*。*成员*': 中找不到自定义属性*命名空间*|
|[编译器错误 C3397](compiler-error-c3397.md)|默认参数中不允许进行聚合初始化|
|[编译器错误 C3398](compiler-error-c3398.md)|'*运算符*： 不能从转换*类型*to*类型*。 源表达式必须是函数符号|
|[编译器错误 C3399](compiler-error-c3399.md)|'*类型*： 创建泛型参数的实例时无法提供变量|

## <a name="see-also"></a>请参阅

[C /C++编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器错误 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
