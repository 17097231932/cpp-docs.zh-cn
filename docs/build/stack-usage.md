---
title: x64 堆栈使用
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: b598c33fbdd56630ca3e5ef0da551f38a73baa26
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335534"
---
# <a name="x64-stack-usage"></a>x64 堆栈使用

RSP 当前地址之外的所有内存都被视为易失性：操作系统或调试器可能在用户调试会话或中断处理程序期间覆盖此内存。 因此，在尝试将值读取或写入堆栈帧之前，必须始终设置 RSP。

本节讨论本地变量的堆栈空间分配和**同法内部。**

## <a name="stack-allocation"></a>堆栈分配

函数的 prolog 负责为本地变量、保存的寄存器、堆栈参数和寄存器参数分配堆栈空间。

参数区域始终位于堆栈的底部（即使`alloca`使用），因此在任何函数调用期间，参数区域始终与返回地址相邻。 它包含至少四个条目，但始终有足够的空间来容纳任何可能调用的函数所需的所有参数。 请注意，始终为寄存器参数分配空间，即使参数本身永远不会归位于堆栈中也是如此;被叫者保证已经为其所有参数分配了空间。 寄存器参数需要主地址，因此在被调用的函数需要获取参数列表（va_list）或单个参数的地址时，可以使用连续区域。 此区域还提供一个方便的位置，以保存寄存器参数在 thunk 执行期间，并作为调试选项（例如，它使参数很容易在调试期间查找，如果它们存储在其主地址在 prolog 代码中）。 即使被调用函数的参数少于 4 个，这 4 个堆栈位置实际上也归被调用函数所有，并且除了保存参数寄存器值之外，被调用函数也可以用于其他目的。  因此，调用方可能不会跨函数调用在此堆栈区域中保存信息。

如果在函数中动态分配空间`alloca`（ ） ），则必须将非易失性寄存器用作帧指针来标记堆栈固定部分的基，并且必须在 prolog 中保存和初始化该寄存器。 请注意，使用`alloca`时，从同一调用方对同一被调用方的呼叫可能具有不同的主地址，以用于其寄存器参数。

堆栈将始终保持 16 字节对齐，但 prolog 中（例如，在推送返回地址后）以及特定帧函数类[的函数类型](#function-types)中指示的情况除外。

下面是堆栈布局的示例，其中函数 A 调用非叶函数 B。 函数 A 的 prolog 已经为堆栈底部 B 所需的所有寄存器和堆栈参数分配了空间。 调用推送返回地址，B 的 prolog 为其本地变量、非易失性寄存器分配空间，以及调用函数所需的空间。 如果 B`alloca`使用 ，则在本地变量/非易失寄存器保存区域和参数堆栈区域之间分配空间。

![AMD 转换示例](../build/media/vcamd_conv_ex_5.png "AMD 转换示例")

当函数 B 调用另一个函数时，返回地址将推至 RCX 的家庭地址正下方。

## <a name="dynamic-parameter-stack-area-construction"></a>动态参数堆栈区域构造

如果使用帧指针，则存在动态创建参数堆栈区域的选项。 这在 x64 编译器中当前未完成。

## <a name="function-types"></a>函数类型

基本上有两种类型的函数。 需要堆栈帧的函数称为*帧函数*。 不需要堆栈帧的函数称为*叶函数*。

帧函数是分配堆栈空间、调用其他函数、保存非易失寄存器或使用异常处理的函数。 它还需要一个函数表条目。 帧函数需要序言和分词。 帧函数可以动态分配堆栈空间，并可以使用帧指针。 帧函数具有此调用标准的全部功能。

如果帧函数不调用其他函数，则不需要对齐堆栈（在剖面[栈分配](#stack-allocation)中引用）。

叶函数是不需要函数表条目的函数。 它无法更改任何非易失性寄存器（包括 RSP），这意味着它无法调用任何函数或分配堆栈空间。 它允许在执行堆栈时保持堆栈未对齐。

## <a name="malloc-alignment"></a>马洛克对齐

[MALLoc](../c-runtime-library/reference/malloc.md)保证返回用于存储具有基本对齐且可放入分配的内存量的任何对象的适当对齐的内存。 *基本对齐*是小于或等于没有对齐规范的实现支持的最大对齐方式。 （在视觉C++中，这是`double`8 个字节所需的对齐方式。 在以 64 位平台为目标的代码中，它是 16 字节。例如，四字节分配将在支持任何四字节或较小对象的边界上对齐。

可视C++允许具有*扩展对齐的类型*，也称为*过度对齐*类型。 例如，SSE 类型[__m128](../cpp/m128.md)和`__m256`，使用`__declspec(align( n ))`大于 8 的位置`n`声明的类型具有扩展对齐方式。 适合需要扩展对齐的对象的边界上的内存对齐不受`malloc`保证。 要为过度对齐的类型分配内存，请使用[_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)和相关函数。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)需要 16 字节对齐，并且还需要使用帧指针。

分配的堆栈需要包括后所调用函数的参数的空间，如[堆栈分配](#stack-allocation)中所述。

## <a name="see-also"></a>另请参阅

[x64 软件约定](../build/x64-software-conventions.md)<br/>
[对齐](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
