---
title: 编译器错误 C3500 - C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446935"
---
# <a name="compiler-errors-c3500-through-c3999"></a>编译器错误 C3500 - C3999

文档的本节中的文章介绍了编译器生成的错误消息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>错误消息

|错误|Message|
|-----------|-------------|
|[编译器错误 C3500](compiler-error-c3500.md)|无效的 ProgID "*progid*"|
|[编译器错误 C3501](compiler-error-c3501.md)|没有为 ProgID "*progid*" 注册的 typelib|
|编译器错误 C3502|无法获取 ProgID "*progid*" 的 LIBID|
|编译器错误 C3503|在原始字符串文本中不允许使用字符 "0x*value*"|
|编译器错误 C3504|无法从字符串 "*string*" 创建 GUID|
|[编译器错误 C3505](compiler-error-c3505.md)|无法加载类型库 "*library*"|
|[编译器错误 C3506](compiler-error-c3506.md)|没有为 LIBID "*library*" 注册的 typelib|
|[编译器错误 C3507](compiler-error-c3507.md)|ProgID 长度不能超过39个字符： "*ProgID*";不包含除 "." 外的任何标点;也不以数字开头|
|[编译器错误 C3508](compiler-error-c3508.md)|"*type*"：不是有效的 Automation 类型|
|[编译器错误 C3509](compiler-error-c3509.md)|"*type*"：无效的 Automation 返回类型;当参数标记为 "retval" 时，返回类型必须是 "void"、"HRESULT" 或 "SCODE"|
|[编译器错误 C3510](compiler-error-c3510.md)|无法找到依赖类型库*库*|
|编译器错误 C3511|"*identifier*"：对委托构造函数的调用应是唯一的成员初始值设定项|
|编译器错误 C3512|原始字符串文本的分隔符序列应不超过16个字符|
|编译器错误 C3513|"*string*"：不支持的原始字符串文本分隔符字符|
|编译器错误 C3514|"*character*" （*值*）：不受支持的原始字符串文本分隔符字符|
|编译器错误 C3515|如果类模板部分专用化的参数是一个包扩展，则它应是最后一个参数|
|编译器错误 C3516|处理原始字符串文本时发现意外的文件尾;分隔符序列 "*string*" 不匹配|
|编译器错误 C3517|"*identifier*" 别名声明不能具有包含 "auto" 的类型|
|编译器错误 C3518|"*identifier*"：在直接列表初始化上下文中，"*type*" 的类型只能从单个初始值设定项表达式推导出|
|[编译器错误 C3519](compiler-error-c3519.md)|"*parameter*"： embedded_idl 特性的参数无效|
|编译器错误 C3520|"*identifier*"：必须在此上下文中扩展参数包|
|编译器错误 C3521|"*identifier*" 不是参数包|
|编译器错误 C3522|"*type*"：不能在此上下文中扩展参数包|
|编译器错误 C3523|"sizeof ..."需要将未扩展的参数包作为其参数|
|编译器错误 C3524|"*identifier*"： "sizeof" 不能应用于参数包。 您是否希望使用 "sizeof ..."？|
|编译器错误 C3525|"*parameter*"：如果类模板具有模板参数包，则它必须出现在模板参数列表的末尾|
|编译器错误 C3526|'...'不能应用于 "this"|
|编译器错误 C3527|"*identifier*" 不是 "sizeof ..." 的有效操作数。 您是否希望使用 "sizeof"？|
|编译器错误 C3528|"*identifier1*"：此包扩展中的元素数与 "*identifier2*" 中的元素数量不匹配|
|编译器错误 C3529|"*parameter*"：模板参数包不能具有默认参数|
|[编译器错误 C3530](compiler-error-c3530.md)|"*type*" 不能与任何其他类型说明符组合|
|[编译器错误 C3531](compiler-error-c3531.md)|"*identifier*"：类型包含 "*type*" 的符号必须具有初始值设定项|
|[编译器错误 C3532](compiler-error-c3532.md)|数组的元素类型不能是包含 "*type*" 的类型|
|[编译器错误 C3533](compiler-error-c3533.md)|参数不能具有包含 "*type*" 的类型|
|编译器错误 C3534|已过时。|
|[编译器错误 C3535](compiler-error-c3535.md)|无法从 "*type2*" 推导 "*type1*" 的类型|
|[编译器错误 C3536](compiler-error-c3536.md)|"*identifier*"：初始化之前无法使用|
|[编译器错误 C3537](compiler-error-c3537.md)|不能强制转换为包含 "*type*" 的类型|
|[编译器错误 C3538](compiler-error-c3538.md)|在声明符列表中，"*type*" 必须始终推导为同一类型|
|[编译器错误 C3539](compiler-error-c3539.md)|模板参数不能是包含 "*type*" 的类型|
|[编译器错误 C3540](compiler-error-c3540.md)|sizeof 不能应用于包含 "*type*" 的类型|
|[编译器错误 C3541](compiler-error-c3541.md)|不能将 typeid 应用于包含 "*type*" 的类型|
|编译器错误 C3542|"*identifier*"：虚成员函数不应具有包含 "*type*" 的返回类型|
|编译器错误 C3543|"*type*"：不包含参数包|
|编译器错误 C3544|"*parameter*"：参数包需要一个类型模板参数|
|编译器错误 C3545|"*parameter*"：参数包需要一个非类型模板参数|
|编译器错误 C3546|"..."：没有可用于扩展的参数包|
|编译器错误 C3547|无法使用模板参数 "*parameter*"，因为它跟随模板参数包，无法从 "*function*" 的函数参数推导出来|
|编译器错误 C3548|"*identifier*"：不能在此上下文中使用参数包|
|编译器错误 C3549|"*value*"：函数参数包不能具有默认参数|
|[编译器错误 C3550](compiler-error-c3550.md)|此上下文只允许纯“decltype(auto)”|
|[编译器错误 C3551](compiler-error-c3551.md)|如果使用尾随返回类型，则前导返回类型应为单类型说明符 "auto" （而不是 "*type*"）|
|[编译器错误 C3552](compiler-error-c3552.md)|expected 'decltype(auto)'|
|[编译器错误 C3553](compiler-error-c3553.md)|decltype 应为表达式而不是类型|
|[编译器错误 C3554](compiler-error-c3554.md)|"*type*" 不能与任何其他类型说明符组合|
|[编译器错误 C3555](compiler-error-c3555.md)|“decltype”的参数不正确|
|[编译器错误 C3556](compiler-error-c3556.md)|"*expression*"： "decltype" 的参数不正确|
|编译器错误 C3557|已过时。|
|编译器错误 C3558|已过时。|
|编译器错误 C3559|对 "*function*" 的递归调用：编译以下位置的 concurrency：:p arallel_for_each 的调用关系图时，检测到递归： "*function*"|
|编译器错误 C3560|"*function*"：编译以下位置的 concurrency：:p arallel_for_each 的调用关系图时，IL 不可用： "*function*"|
|编译器错误 C3561|编译并发的调用关系图时，在不是平铺的控制流中找到平铺屏障操作：:p arallel_for_each： "*function*"|
|编译器错误 C3562|内部函数 "*function*" 被限制为不超过*数字*参数|
|编译器错误 C3563|编译以下位置的 concurrency：:p arallel_for_each 的调用关系图时，检测到无限循环： "*function*"|
|编译器错误 C3564|编译并发的调用关系图时，读取未初始化的值：:p arallel_for_each： "*function*"|
|编译器错误 C3565|编译 concurrency：:p 的调用关系图时，tile_static 内存总量（*数字*字节）超过了*数字*字节的限制 arallel_for_each|
|编译器错误 C3566|编译以下位置的 concurrency：:p arallel_for_each 的调用关系图时，具有副作用的块嵌套太深： "*function*"|
|编译器错误 C3567|编译并发的调用关系图时，将在编译 arallel_for_each:p 的调用关系图时，按零进行分割或检测： "*function*"|
|编译器错误 C3568|在编译 concurrency：:p arallel_for_each 的调用关系图时，寄存器的总和超出了*数目*限制。 请简化你的计划|
|编译器错误 C3569|编译以下位置的 concurrency：:p arallel_for_each 的调用关系图时，检测到争用条件： "*function*"|
|编译器错误 C3570|使用/clr 进行编译时非法使用 amp 限制的范围|
|编译器错误 C3571|"*type*"：非法的计算域参数;不是类类型|
|编译器错误 C3572|"*type*"：非法的计算域参数;缺少公共成员： "static const int rank" 或 rank 值为非正数|
|编译器错误 C3573|传递给并发的 concurrency：： graphics：：采样器的*实例数不能超过:p* arallel_for_each|
|编译器错误 C3574|"*type*"：非法磁贴范围：必须是正数，（1） Z < = *number*;（2） Z*Y*X < = *number*|
|编译器错误 C3575|"*type*"：非法的计算域参数;缺少公共成员： "concurrency：： index <*number*> _map_index （const concurrency：： index <*number*> &） restrict （amp）"|
|编译器错误 C3576|"*type*"： concurrency：:d etails：： _Parallel_for_each 参数 #*number*的类型不受支持|
|编译器错误 C3577|concurrency：:p arallel_for_each 内核参数是非法的：无法解析对成员 "void operator （）（*类型*） restrict （amp）" 的调用|
|编译器错误 C3578|传递给 concurrency：:p arallel_for_each 的函数对象大小不能超过字节*数*|
|编译器错误 C3579|传递给 concurrency：:p arallel_for_each 的 concurrency：： array 和 concurrency：： graphics：：纹理的只读实例数不能超过*数*|
|编译器错误 C3580|传递给并发的 concurrency：： array 和 concurrency：： graphics：：纹理的可写实例数不*能超过:p* arallel_for_each|
|编译器错误 C3581|"*type*"： amp 限制代码中不支持的类型|
|编译器错误 C3582|已过时。|
|编译器错误 C3583|"*identifier*"：变量大小（*数字*字节）大于 amp 限制代码中支持的最大大小 *（字节*）|
|编译器错误 C3584|"*identifier*" 上 tile_static 的用法不受支持|
|编译器错误 C3585|"*identifier*" 在 amp 限制代码中包含不受支持的存储类|
|编译器错误 C3586|"*identifier*"： amp 限制代码中不支持使用全局或静态变量|
|编译器错误 C3587|amp 限制代码中不支持 dynamic_cast|
|编译器错误 C3588|amp 限制代码中不支持从 "*type1*" 到 "*type2*" 的强制转换|
|编译器错误 C3589|"*string*"： amp 限制代码中不支持使用字符串文本|
|编译器错误 C3590|"*token*"：如果 lambda 受 amp 限制，则不支持按引用捕获或 "this" 捕获|
|编译器错误 C3591|amp 限制代码中不支持 typeid 运算符|
|编译器错误 C3592|Amp 限制代码中不支持内联本机程序集（"__asm"）|
|编译器错误 C3593|amp 限制代码中不支持 "goto"|
|编译器错误 C3594|amp 限制代码中不支持异常处理（try、catch、throw 等）|
|编译器错误 C3595|amp 限制代码中的常量值超出了支持的范围|
|编译器错误 C3596|"*parameter*" （"*type*"）： lambda 捕获的变量在 amp 限制代码中有不受支持的类型|
|编译器错误 C3597|"*parameter*"：如果 lambda 为 amp 限制，则不允许通过值捕获 "*identifier*"|
|编译器错误 C3598|amp 限制代码中不支持标签语句|
|编译器错误 C3599|"*operator*"：在 amp 限制代码中，无法对指向布尔值的指针执行指针算法|
|编译器错误 C3600|"*function*"：在编译非平铺并发的调用关系图时，使用磁贴\_静态内存：:p arallel\_for_each： "*function*"|
|编译器错误 C3601|"*type*"：对于 amp 诊断函数 "*function*"，参数类型无效|
|编译器错误 C3602|编译并发的调用关系图时，检测到不受支持的控制流： "*函数*":p arallel_for_each|
|[编译器错误 C3603](compiler-error-c3603.md)|"*symbol*"：类型 "*type*" 尚不受支持|
|编译器错误 C3604|"*identifier*"：只能在 gc 堆上创建托管对象|
|编译器错误 C3605|编译:p 并发的调用关系图时，采样器的总数（捕获的*数量*和预定义的*数字*）超过了*数字*，arallel_for_each： "*function*"|
|编译器错误 C3606|已过时。|
|编译器错误 C3607|已过时。|
|编译器错误 C3608|已过时。|
|[编译器错误 C3609](compiler-error-c3609.md)|"*identifier*"： "密封/final" 函数必须是虚拟的|
|[编译器错误 C3610](compiler-error-c3610.md)|"*identifier*"：值类型必须是 "装箱"，才能调用方法 "*method*"|
|[编译器错误 C3611](compiler-error-c3611.md)|"*identifier*"：密封函数不能具有纯说明符|
|[编译器错误 C3612](compiler-error-c3612.md)|"*identifier*"：密封类不能具有任何纯虚方法|
|编译器错误 C3613|"->" 后缺少返回类型（假定为 "int"）|
|编译器错误 C3614|同一类中包大小的值不同;previous 为 "*value*"，新值为 "*value*"|
|[编译器错误 C3615](compiler-error-c3615.md)|constexpr 函数 "*function*" 不能导致常量表达式|
|编译器错误 C3616|已过时。|
|编译器错误 C3617|已过时。|
|[编译器错误 C3618](compiler-error-c3618.md)|"*声明*"：标记为 DllImport 的方法无法定义|
|[编译器错误 C3619](compiler-error-c3619.md)|不能在托管的/WinRT 类型内声明模板|
|编译器错误 C3620|"*type*"：在 WinRT 类型上不允许设置对齐方式|
|编译器错误 C3621|"*type*"： WinRT 类型仅允许默认包装值（*number*）|
|[编译器错误 C3622](compiler-error-c3622.md)|*类型*"：声明为"*关键字*"的类不能实例化|
|[编译器错误 C3623](compiler-error-c3623.md)|"*identifier*"：托管/WinRT 类型中不支持位域|
|[编译器错误 C3624](compiler-error-c3624.md)|"*type*"：使用此类型需要引用程序集/模块 "*identifier*"|
|[编译器错误 C3625](compiler-error-c3625.md)|"*class*"：本机类型不能从托管或 WinRT 类型 "*type*" 派生|
|[编译器错误 C3626](compiler-error-c3626.md)|"*identifier*"： "*关键字*" 关键字只能用于作为指向委托的指针的 COM 接口、成员函数和数据成员|
|[编译器错误 C3627](compiler-error-c3627.md)|只有值类型可以装箱|
|[编译器错误 C3628](compiler-error-c3628.md)|"*class*"：托管的/WinRT 类只支持公共继承|
|编译器错误 C3629|"*token*"：捕获默认值只能出现在 lambda 捕获列表的开头|
|[编译器错误 C3630](compiler-error-c3630.md)|处理令牌 "*token*" 时出错|
|[编译器错误 C3631](compiler-error-c3631.md)|"*event*"：无法重载托管/WinRT 事件|
|[编译器错误 C3632](compiler-error-c3632.md)|"*event*"：非法的*构造*事件样式|
|[编译器错误 C3633](compiler-error-c3633.md)|不能将 "*identifier*" 定义为托管 "*class*" 的成员|
|[编译器错误 C3634](compiler-error-c3634.md)|"*member*"：不能定义托管/WinRT 类的抽象方法|
|编译器错误 C3635|"*identifier*"：不能应用于托管的/WinRT 类（改用 "*identifier*"）|
|编译器错误 C3636|"*identifier*"：不能应用于此类型|
|[编译器错误 C3637](compiler-error-c3637.md)|"*function*"：友元函数定义不能是函数模板/泛型的专用化|
|[编译器错误 C3638](compiler-error-c3638.md)|"*operator*"：不能重新定义标准装箱和取消装箱转换运算符|
|编译器错误 C3639|已过时。|
|[编译器错误 C3640](compiler-error-c3640.md)|"*member*"：局部类的引用成员函数或虚拟成员函数必须进行定义|
|[编译器错误 C3641](compiler-error-c3641.md)|"*function*"：用/clr： pure 或/clr： safe 编译的函数的调用约定 "*约定*" 无效|
|[编译器错误 C3642](compiler-error-c3642.md)|"*function*"：无法从本机代码调用具有 __clrcall 调用约定的函数|
|编译器错误 C3643|已过时。|
|[编译器错误 C3644](compiler-error-c3644.md)|"*function*"：不能编译函数以生成托管代码|
|[编译器错误 C3645](compiler-error-c3645.md)|"*function*"：不能对编译为本机代码的函数使用 __clrcall|
|[编译器错误 C3646](compiler-error-c3646.md)|"*identifier*"：未知重写说明符|
|编译器错误 C3647|已过时。|
|[编译器错误 C3648](compiler-error-c3648.md)|托管类型不支持此显式重写语法|
|编译器错误 C3649|不允许对/ZW 使用此显式重写语法|
|[编译器错误 C3650](compiler-error-c3650.md)|"*member*"：不能用作显式重写，必须是基类的虚拟成员函数|
|[编译器错误 C3651](compiler-error-c3651.md)|"*member*"：不能用作显式重写，必须是基类的成员|
|[编译器错误 C3652](compiler-error-c3652.md)|"*member*"：显式重写的函数必须是虚拟的|
|[编译器错误 C3653](compiler-error-c3653.md)|"*identifier*"：不能用作命名重写：未找到正在被重写的函数;您是否忘记了使用：：运算符显式命名该函数？|
|[编译器错误 C3654](compiler-error-c3654.md)|"*token*"：显式重写中有语法错误|
|[编译器错误 C3655](compiler-error-c3655.md)|"*member*"：函数已显式重写|
|[编译器错误 C3656](compiler-error-c3656.md)|"*关键字*"：重写说明符不能重复|
|[编译器错误 C3657](compiler-error-c3657.md)|析构函数/终结器不能显式重写，也不能被显式重写|
|编译器错误 C3658|已过时。|
|编译器错误 C3659|"*member*"：不支持重写说明符 "*关键字*"|
|编译器错误 C3660|"*member1*"：隐藏继承成员 "*member2*"|
|[编译器错误 C3661](compiler-error-c3661.md)|显式重写列表找不到任何要重写的方法|
|[编译器错误 C3662](compiler-error-c3662.md)|"*member*"：重写说明符 "*关键字*" 只允许在托管的/WinRT 类的成员函数上使用|
|编译器错误 C3663|已过时。|
|编译器错误 C3664|"*member*"：不能用作显式重写，必须具有 "公共" 或 "受保护" 的可访问性|
|[编译器错误 C3665](compiler-error-c3665.md)|"*member*"：重写说明符 "*关键字*" 在析构函数/终结器上不允许|
|[编译器错误 C3666](compiler-error-c3666.md)|"*构造函数*"：不允许在构造函数上使用重写说明符 "*关键字*"|
|编译器错误 C3667|"*attribute*"：特性不支持包扩展|
|[编译器错误 C3668](compiler-error-c3668.md)|"*member*"：重写说明符 "override" 的方法没有重写任何基类方法|
|[编译器错误 C3669](compiler-error-c3669.md)|"*member*"：重写说明符 "override" 不允许在静态成员函数或构造函数上使用|
|[编译器错误 C3670](compiler-error-c3670.md)|"*member*"：无法重写不可访问的基类方法 "*member*"|
|[编译器错误 C3671](compiler-error-c3671.md)|"*member*"：函数不重写 "*member*"|
|[编译器错误 C3672](compiler-error-c3672.md)|伪析构函数表达式只能用作函数调用的一部分|
|[编译器错误 C3673](compiler-error-c3673.md)|"*class*"：类没有复制构造函数|
|编译器错误 C3674|找不到标准库模块 "*module*"|
|[编译器错误 C3675](compiler-error-c3675.md)|"*function*"：已定义 "*property*"，因此被保留|
|编译器错误 C3676|"*class*"： ref 类和基类具有不兼容的特性 "[*attribute*]"|
|编译器错误 C3677|"operator" 后的字符串文本不能具有编码前缀|
|编译器错误 C3678|"operator" 后的字符串文本必须是空字符串 "" "" ""|
|编译器错误 C3679|"operator" "" 的后面应输入文本后缀标识符|
|编译器错误 C3680|无法将用户定义的字符串文本与不匹配的文本后缀标识符连接起来|
|编译器错误 C3681|"fallthrough"：特性只能出现在封闭的 switch 语句中|
|编译器错误 C3682|"operator *identifier*"：文本运算符/文本运算符模板不能声明为具有 "C 链接"|
|编译器错误 C3683|不能同时用相同的文本后缀标识符定义原始文本运算符和文本运算符模板|
|编译器错误 C3684|"operator *identifier*"：文本运算符的声明具有无效的参数列表|
|编译器错误 C3685|"operator *identifier*"：文本运算符模板不能具有函数参数|
|编译器错误 C3686|"operator *identifier*"：文本运算符模板必须正好有一个作为参数包的模板参数|
|编译器错误 C3687|"operator *identifier*"：文本运算符模板必须具有 "char" 类型的非类型模板参数|
|编译器错误 C3688|文本后缀 "*后缀*" 无效;找不到文本运算符或文本运算符模板 "operator *identifier*"|
|编译器错误 C3689|"operator *identifier*"：文本运算符/文本运算符模板必须在全局范围或命名空间范围内|
|编译器错误 C3690|应为字符串文本，但找到的是用户定义的字符串文本|
|编译器错误 C3691|无效的文本前缀 "*prefix*"|
|编译器错误 C3692|已过时。|
|编译器错误 C3693|已过时。|
|编译器错误 C3694|已过时。|
|编译器错误 C3695|已过时。|
|编译器错误 C3696|"*关键字*"：不能在 "%" 上使用此限定符|
|[编译器错误 C3697](compiler-error-c3697.md)|"*关键字*"：不能在 "^" 上使用此限定符|
|[编译器错误 C3698](compiler-error-c3698.md)|"*type*"：不能将此类型用作 "*operator*" 的参数|
|[编译器错误 C3699](compiler-error-c3699.md)|"*operator*"：不能在类型 "*type*" 上使用此间接寻址|
|编译器错误 C3700|已过时。|
|[编译器错误 C3701](compiler-error-c3701.md)|"*function*"：事件源没有事件|
|[编译器错误 C3702](compiler-error-c3702.md)|COM 事件需要 ATL|
|[编译器错误 C3703](compiler-error-c3703.md)|"*event_handler*"：事件处理程序方法必须具有与源 "*事件*" 相同的存储类|
|[编译器错误 C3704](compiler-error-c3704.md)|"*member*"： vararg 方法无法激发事件|
|[编译器错误 C3705](compiler-error-c3705.md)|"*function*"：找不到事件接口|
|[编译器错误 C3706](compiler-error-c3706.md)|"*function*"：必须是用于激发 com 事件的 com 接口|
|[编译器错误 C3707](compiler-error-c3707.md)|"*member*"：调度接口方法必须有 dispid|
|[编译器错误 C3708](compiler-error-c3708.md)|"*function*"： "*关键字*" 的用法不正确;必须是兼容事件源的成员|
|[编译器错误 C3709](compiler-error-c3709.md)|"*function*"：在 __hook/__unhook 中指定事件的语法不正确|
|[编译器错误 C3710](compiler-error-c3710.md)|"*function*"：在 __hook/__unhook 中指定事件处理程序的语法不正确|
|[编译器错误 C3711](compiler-error-c3711.md)|"*event*"：非托管事件源方法必须返回 void 或者整型类型|
|[编译器错误 C3712](compiler-error-c3712.md)|"*event_handler*"：事件处理程序方法必须返回与源 "*事件*" 相同的类型|
|[编译器错误 C3713](compiler-error-c3713.md)|"*event_handler*"：事件处理程序方法必须具有与源 "*事件*" 相同的函数参数|
|[编译器错误 C3714](compiler-error-c3714.md)|"*event_handler*"：事件处理程序方法必须具有与源 "*事件*" 相同的调用约定|
|[编译器错误 C3715](compiler-error-c3715.md)|"*指针*"：必须是指向 "*type*" 的指针|
|编译器错误 C3716|已过时。|
|[编译器错误 C3717](compiler-error-c3717.md)|"*member*"：不能定义激发事件的方法|
|[编译器错误 C3718](compiler-error-c3718.md)|只能在接收类的成员函数的上下文中调用 "__*关键字*"|
|[编译器错误 C3719](compiler-error-c3719.md)|"*member*"：基于接口的事件源只能用于 COM 事件|
|编译器错误 C3720|"*type*"：只能在双重或调度接口上实现 IDispatch|
|[编译器错误 C3721](compiler-error-c3721.md)|"*签名*"：事件的签名不兼容|
|[编译器错误 C3722](compiler-error-c3722.md)|不允许泛型事件|
|[编译器错误 C3723](compiler-error-c3723.md)|"*function*"：未能解析事件|
|[编译器错误 C3724](compiler-error-c3724.md)|必须 #include \<windows .h >，以将多线程处理与事件一起使用|
|编译器错误 C3725|已过时。|
|编译器错误 C3726|已过时。|
|[编译器错误 C3727](compiler-error-c3727.md)|"*event*"：托管事件必须是成员函数或是指向委托的指针的数据成员|
|[编译器错误 C3728](compiler-error-c3728.md)|"*event*"：事件没有引发方法|
|编译器错误 C3729|已过时。|
|编译器错误 C3730|已过时。|
|[编译器错误 C3731](compiler-error-c3731.md)|事件 "*event*" 与处理程序 "*event_handler*" 不兼容;事件源和事件处理程序必须具有相同的事件类型|
|[编译器错误 C3732](compiler-error-c3732.md)|"*interface*"：激发 COM 事件的自定义接口不能从 IDispatch 继承|
|[编译器错误 C3733](compiler-error-c3733.md)|"*event*"：指定 COM 事件的语法不正确;忘记了 "__interface" 了吗？|
|[编译器错误 C3734](compiler-error-c3734.md)|"*class*"：托管的/WinRT 类不能是组件类|
|编译器错误 C3735|已过时。|
|[编译器错误 C3736](compiler-error-c3736.md)|"*member*"：必须是方法，在托管事件中也可以是数据成员|
|[编译器错误 C3737](compiler-error-c3737.md)|"*identifier*"：委托不能有显式调用约定|
|[编译器错误 C3738](compiler-error-c3738.md)|"*约定*"：显式实例化的调用约定必须与被实例化的模板的调用约定匹配|
|[编译器错误 C3739](compiler-error-c3739.md)|"*class*"：仅当 event_receiver 的 "布局\_相关的" 参数为 true 时才支持语法|
|[编译器错误 C3740](compiler-error-c3740.md)|"*template*"：模板不能源或接收事件|
|[编译器错误 C3741](compiler-error-c3741.md)|"*class*"：当 event_receiver 的 "布局\_相关的" 参数为 true 时，必须是 coclass|
|编译器错误 C3742|"*token1*"： "*attribute*" 的属性参数中的标记顺序不均衡，应为 "*token2*"|
|[编译器错误 C3743](compiler-error-c3743.md)|当 event_receiver 的 "layout_dependent" 参数为 true 时，只能挂钩/解除挂钩整个接口|
|[编译器错误 C3744](compiler-error-c3744.md)|对于托管事件，__unhook 必须具有至少3个参数|
|[编译器错误 C3745](compiler-error-c3745.md)|"*function*"：只有事件才能被 "引发"|
|编译器错误 C3746|标准属性 "*identifier*" 在属性列表中最多只能出现一次|
|[编译器错误 C3747](compiler-error-c3747.md)|缺少默认模板/泛型参数：参数*号*|
|[编译器错误 C3748](compiler-error-c3748.md)|"*interface*"：非托管接口可能无法激发事件|
|[编译器错误 C3749](compiler-error-c3749.md)|"*attribute*"：自定义特性不能在函数内部使用|
|编译器错误 C3750|"*token*"：属性列表中的意外标记|
|编译器错误 C3751|"*identifier*"：属性列表中的意外标识符|
|[编译器错误 C3752](compiler-error-c3752.md)|"*attribute*"：不能对特性进行分类;不应在此上下文中使用 "*关键字*"|
|[编译器错误 C3753](compiler-error-c3753.md)|不允许使用泛型属性|
|[编译器错误 C3754](compiler-error-c3754.md)|委托构造函数：成员函数 "*member*" 不能在类型 "*type*" 的实例上调用|
|[编译器错误 C3755](compiler-error-c3755.md)|"*identifier*"：不能定义委托|
|编译器错误 C3756|已过时。|
|编译器错误 C3757|"*type*"：类型不允许用于 "constexpr" 函数|
|编译器错误 C3758|"*member*"：虚函数不能声明为 "constexpr"|
|编译器错误 C3759|"*member*"：非文本类型的成员函数不能声明为 "constexpr"|
|编译器错误 C3760|请使用 __property 关键字声明 managed/WinRT "*class*" 中的属性|
|[编译器错误 C3761](compiler-error-c3761.md)|"*function*"： "retval" 只能出现在函数的最后一个参数上|
|[编译器错误 C3762](compiler-error-c3762.md)|无法处理特性 "*attribute*"|
|[编译器错误 C3763](compiler-error-c3763.md)|"*type*"： "retval" 和 "out" 只能出现在数据指针类型上|
|[编译器错误 C3764](compiler-error-c3764.md)|"*member*"：不能重写基类方法 "*member*"|
|[编译器错误 C3765](compiler-error-c3765.md)|"*event*"：不能在标记为 event_receiver 的类/结构 "*type*" 中定义事件|
|[编译器错误 C3766](compiler-error-c3766.md)|"*type*" 必须提供接口方法 "*function*" 的实现|
|[编译器错误 C3767](compiler-error-c3767.md)|"*function*"：候选函数不可访问|
|[编译器错误 C3768](compiler-error-c3768.md)|无法在纯托管代码中获取虚拟 vararg 函数的地址|
|[编译器错误 C3769](compiler-error-c3769.md)|"*identifier*"：嵌套类不能与直接封闭类同名|
|编译器错误 C3770|"*type*"：不是有效的基类|
|[编译器错误 C3771](compiler-error-c3771.md)|"*identifier*"：在最近的命名空间范围内无法找到友元声明|
|[编译器错误 C3772](compiler-error-c3772.md)|"*identifier*"：友元模板声明无效|
|编译器错误 C3773|请使用/await 编译器开关来启用协同程序|
|编译器错误 C3774|找不到 "*scope*：：*Identifier*"：请包含*页眉*标头|
|编译器错误 C3775|"*function*" 的返回类型不应为 "*type*"|
|编译器错误 C3776|无法在具有非 void 最终返回类型的协同程序中返回 void 类型的表达式|
|编译器错误 C3777|"*function*"：协同程序无法采用变量参数列表|
|编译器错误 C3778|alloca：不能在协同程序中使用|
|编译器错误 C3779|"*function*"：返回 "*type*" 的函数不能在定义之前使用|
|编译器错误 C3780|"*function*"：返回 "*type*" 的转换函数在定义之前无法使用|
|编译器错误 C3781|"*关键字*"：不能在 "*type*" 类型的协同程序中使用。 *关键字*或*关键字*必须出现在关联的 promise_type 中|
|编译器错误 C3782|*类型*：协同程序的承诺不得同时包含*关键字*和*关键字*|
|编译器错误 C3783|"*identifier*"：不能是协同程序|
|编译器错误 C3784|*关键字*表达式不能出现在此上下文中|
|编译器错误 C3785|"std：： integer_sequence" 的第一个模板参数必须是整数类型|
|编译器错误 C3786|"std：： make_integer_sequence" 的第二个模板参数必须为大于或等于零的整数常量|
|编译器错误 C3787|无法推导此协同程序的返回类型|
|编译器错误 C3788|已过时。|
|编译器错误 C3789|已过时。|
|编译器错误 C3790|已过时。|
|编译器错误 C3791|已过时。|
|编译器错误 C3792|已过时。|
|编译器错误 C3793|已过时。|
|编译器错误 C3794|已过时。|
|编译器错误 C3795|已过时。|
|编译器错误 C3796|已过时。|
|[编译器错误 C3797](compiler-error-c3797.md)|"*关键字*"：事件声明不能具有重写说明符（而应将其放在事件的 add/remove/raise 方法上）|
|[编译器错误 C3798](compiler-error-c3798.md)|"*关键字*"：属性声明不能具有重写说明符（而应将其放在属性 get/set 方法上）|
|[编译器错误 C3799](compiler-error-c3799.md)|索引属性不能具有空参数列表|
|[编译器错误 C3800](compiler-error-c3800.md)|"*声明*"：不能混合属性和事件|
|编译器错误 C3801|"*attribute*"：特性不能有参数子句|
|编译器错误 C3802|已过时。|
|[编译器错误 C3803](compiler-error-c3803.md)|"*property*"：属性的类型与它的某个访问器 "*访问器*" 的类型不兼容|
|[编译器错误 C3804](compiler-error-c3804.md)|"*member*"：属性的访问器方法必须是全部静态或全部非静态的|
|[编译器错误 C3805](compiler-error-c3805.md)|"*token*"：意外标记，应输入 "}" 或 "，"|
|编译器错误 C3806|"*token*"：意外标记，应为 "{" 或成员初始值设定项|
|[编译器错误 C3807](compiler-error-c3807.md)|"*type*"：具有 ComImport 特性的类不能从 "*type*" 派生，只允许使用接口实现|
|[编译器错误 C3808](compiler-error-c3808.md)|"*type*"：具有 ComImport 特性的类不能定义成员 "*member*"，只允许使用 abstract 或 dllimport 函数|
|[编译器错误 C3809](compiler-error-c3809.md)|"*type*"：托管或 WinRT 类型不能有任何友元函数/类/接口|
|编译器错误 C3810|已过时。|
|编译器错误 C3811|已过时。|
|[编译器错误 C3812](compiler-error-c3812.md)|"__property" 必须是属性声明中的第一个标记|
|[编译器错误 C3813](compiler-error-c3813.md)|属性声明只能出现在托管/WinRT 类型的定义中|
|编译器错误 C3814|已过时。|
|[编译器错误 C3815](compiler-error-c3815.md)|方法 "*member*" 的返回类型必须与 setter 的最后一个参数的类型匹配|
|[编译器错误 C3816](compiler-error-c3816.md)|"类/结构*成员*" 以前是用不同的托管/WinRT 修饰符声明或定义的|
|[编译器错误 C3817](compiler-error-c3817.md)|"*声明*"：属性只能应用于函数|
|[编译器错误 C3818](compiler-error-c3818.md)|数组属性声明 "*property*" 不应重载索引属性 "*property*"|
|编译器错误 C3819|已过时。|
|[编译器错误 C3820](compiler-error-c3820.md)|"*identifier*"：初始值设定项必须是托管的|
|[编译器错误 C3821](compiler-error-c3821.md)|"*function*"：托管类型或函数不能用于非托管函数|
|编译器错误 C3822|已过时。|
|编译器错误 C3823|已过时。|
|[编译器错误 C3824](compiler-error-c3824.md)|"*type*"：此类型不能出现在此上下文中（函数参数、返回类型或静态成员）|
|[编译器错误 C3825](compiler-error-c3825.md)|"*type*"：托管的/winrt 类只能支持托管/winrt 事件|
|编译器错误 C3826|已过时。|
|编译器错误 C3827|标准特性 "已弃用" 可能没有参数或一个描述原因的字符串文本|
|[编译器错误 C3828](compiler-error-c3828.md)|不能为类型 "*type*" 的 "*关键字*" 表达式指定位置参数|
|编译器错误 C3829|标准特性 "noreturn" 只能应用于函数|
|[编译器错误 C3830](compiler-error-c3830.md)|"*type1*"：不能从 "*type2*" 继承，值类型只能从接口类继承|
|[编译器错误 C3831](compiler-error-c3831.md)|"*identifier*"： "*type*" 不能有固定的数据成员或返回钉住指针的成员函数|
|[编译器错误 C3832](compiler-error-c3832.md)|"*typelib*"：类型库看起来就像是为32位指针生成的;请更改 "ptrsize" 限定符|
|[编译器错误 C3833](compiler-error-c3833.md)|"*type*"：*标识符*的目标类型无效|
|[编译器错误 C3834](compiler-error-c3834.md)|非法显式转换为钉住指针;改为使用固定的本地变量|
|编译器错误 C3835|已过时。|
|[编译器错误 C3836](compiler-error-c3836.md)|静态构造函数不允许有成员初始值设定项列表|
|编译器错误 C3837|不允许在此上下文中使用属性|
|[编译器错误 C3838](compiler-error-c3838.md)|无法从 "*type*" 继承|
|[编译器错误 C3839](compiler-error-c3839.md)|无法更改托管/WinRT 类型中的对齐方式|
|编译器错误 C3840|已过时。|
|编译器错误 C3841|已过时。|
|[编译器错误 C3842](compiler-error-c3842.md)|"*identifier*"：不支持托管/WinRT 类型的成员函数上的 "const" 和 "volatile" 限定符|
|编译器错误 C3843|"*identifier*"：不支持在托管/WinRT 类型的成员函数上引用限定符|
|编译器错误 C3844|"*identifier*"：无法从 "*source*" 导入符号：因为当前范围内已存在 "*identifier*"|
|编译器错误 C3845|已过时。|
|[编译器错误 C3846](compiler-error-c3846.md)|"*identifier*"：无法从 "*source*" 导入符号：因为 "*identifier*" 已从另一个程序集 "*assembly*" 中导入|
|编译器错误 C3847|已过时。|
|[编译器错误 C3848](compiler-error-c3848.md)|类型为 "*type*" 的表达式会丢失一些常量可变限定符，以便调用 "*identifier*"|
|[编译器错误 C3849](compiler-error-c3849.md)|"*type*" 类型的表达式中的函数样式调用会*丢失所有可用*的可用运算符重载的 const 和/或 volatile 限定符|
|[编译器错误 C3850](compiler-error-c3850.md)|"*token*"：通用字符名称指定的字符无效|
|[编译器错误 C3851](compiler-error-c3851.md)|"*token*"：通用字符名称不能指定基本字符集中的字符|
|[编译器错误 C3852](compiler-error-c3852.md)|"*member*" 类型的类型为 "*type*"：聚合初始化未能初始化此成员|
|[编译器错误 C3853](compiler-error-c3853.md)|"="：通过指向函数的引用重新初始化引用或分配是非法的|
|[编译器错误 C3854](compiler-error-c3854.md)|"=" 左边的表达式的计算结果为函数。 不能分配给函数（函数不是左值）|
|[编译器错误 C3855](compiler-error-c3855.md)|"*function*"：模板/泛型参数 "*identifier*" 与声明不兼容|
|[编译器错误 C3856](compiler-error-c3856.md)|"*class*"：类不是类模板/泛型|
|[编译器错误 C3857](compiler-error-c3857.md)|"*template*"：不允许使用多个模板/泛型参数列表|
|[编译器错误 C3858](compiler-error-c3858.md)|"*identifier*"：无法在当前范围内重新声明|
|[编译器错误 C3859](compiler-error-c3859.md)|超出了 PCH 的虚拟内存范围;请使用 "-Zm*number*" 或更大的命令行选项重新编译|
|[编译器错误 C3860](compiler-error-c3860.md)|类模板/通用名称后面的模板/泛型参数列表必须按模板/泛型参数列表中使用的顺序列出参数|
|[编译器错误 C3861](compiler-error-c3861.md)|"*identifier*"：找不到标识符|
|[编译器错误 C3862](compiler-error-c3862.md)|"*function*"：不能使用/clr： pure 或/clr： safe 编译非托管函数|
|编译器错误 C3863|数组类型 "*type*" 不可赋值|
|编译器错误 C3864|已过时。|
|[编译器错误 C3865](compiler-error-c3865.md)|"*关键字*"：只能用在本机成员函数上|
|[编译器错误 C3866](compiler-error-c3866.md)|析构函数/终结器调用缺少参数列表|
|[编译器错误 C3867](compiler-error-c3867.md)|"*function*"：非标准语法;使用 "&" 创建指向成员的指针|
|[编译器错误 C3868](compiler-error-c3868.md)|"*type*"：泛型参数 "*parameter*" 的约束与声明上的约束不同|
|[编译器错误 C3869](compiler-error-c3869.md)|gcnew 约束缺少空参数列表 "（）"|
|编译器错误 C3870|"*parameter*"： "__declspec （*说明符*）" 只能应用于整型参数|
|编译器错误 C3871|"*parameter*"： "__declspec （guard （溢出））" 仅在函数的前64参数上受支持|
|[编译器错误 C3872](compiler-error-c3872.md)|"0x*value*"：不允许在标识符中使用此字符|
|[编译器错误 C3873](compiler-error-c3873.md)|"0x*value*"：不允许将此字符作为标识符的第一个字符|
|[编译器错误 C3874](compiler-error-c3874.md)|"*identifier*" 的返回类型应为 "*type1*"，而不是 "*type2*"|
|编译器错误 C3875|缺少参数列表的非静态成员函数的调用|
|编译器错误 C3876|已过时。|
|编译器错误 C3877|已过时。|
|编译器错误 C3878|已过时。|
|编译器错误 C3879|"*member*"：不能是 initonly 数据成员|
|[编译器错误 C3880](compiler-error-c3880.md)|"*member*"：不能是 literal 数据成员|
|编译器错误 C3881|只能从直接基继承构造函数|
|编译器错误 C3882|"*class*"：构造函数已继承自 "*class*"|
|编译器错误 C3883|"*member*"：必须初始化 initonly 静态数据成员|
|编译器错误 C3884|"*type*"：未知大小的数组不能进行值初始化|
|编译器错误 C3885|"*type*"：不能用空的初始值设定项列表初始化未知大小的数组|
|[编译器错误 C3886](compiler-error-c3886.md)|"*member*"：必须初始化 literal 数据成员|
|[编译器错误 C3887](compiler-error-c3887.md)|"*member*"： literal 数据成员的初始值设定项必须是常量表达式|
|[编译器错误 C3888](compiler-error-c3888.md)|"*member*"： C++/cli 不支持与此 literal 数据成员关联的常量表达式|
|编译器错误 C3889|已过时。|
|[编译器错误 C3890](compiler-error-c3890.md)|"*member*"：不能采用 literal 数据成员的地址|
|[编译器错误 C3891](compiler-error-c3891.md)|"*member*"： literal 数据成员不能用作左值|
|[编译器错误 C3892](compiler-error-c3892.md)|"*variable*"：不能赋给常量变量|
|[编译器错误 C3893](compiler-error-c3893.md)|"*member*"： initonly 数据成员的左值只允许在类 "*class*" 的实例构造函数中使用|
|[编译器错误 C3894](compiler-error-c3894.md)|"*member*"： initonly 静态数据成员的左值只允许在类 "*class*" 的类构造函数中使用|
|[编译器错误 C3895](compiler-error-c3895.md)|"*member*"：*类型*数据成员不能是 "volatile"|
|[编译器错误 C3896](compiler-error-c3896.md)|"*member*"：不正确的初始值设定项：此 literal 数据成员只能用 "nullptr" 进行初始化|
|编译器错误 C3897|已过时。|
|[编译器错误 C3898](compiler-error-c3898.md)|"*member*"：*类型*数据成员只能是托管类型的成员|
|[编译器错误 C3899](compiler-error-c3899.md)|"*member*"： initonly 数据成员的左值不允许直接在类 "*class*" 中的并行区域内使用|
|[编译器错误 C3900](compiler-error-c3900.md)|"*member*"：不允许在当前范围内使用|
|[编译器错误 C3901](compiler-error-c3901.md)|"*function*"：必须有返回类型 "*type*"|
|[编译器错误 C3902](compiler-error-c3902.md)|"*function*"：最后一个参数的类型必须是 "*type*"|
|[编译器错误 C3903](compiler-error-c3903.md)|"*property*"：没有 set 或 get 方法|
|[编译器错误 C3904](compiler-error-c3904.md)|"*property*"：必须指定*number*个参数|
|编译器错误 C3905|内部类型 "*type*" 不支持未对齐的访问|
|编译器错误 C3906|对于 vararg 或非原型函数，内部类型 "*type*" 不是受支持的返回类型或参数类型|
|编译器错误 C3907|已过时。|
|[编译器错误 C3908](compiler-error-c3908.md)|访问级别的限制低于 "*identifier*" 的限制|
|[编译器错误 C3909](compiler-error-c3909.md)|托管/WinRT 事件声明必须以托管/WinRT 类型发生|
|[编译器错误 C3910](compiler-error-c3910.md)|"*event*"：必须定义成员 "*member*"|
|[编译器错误 C3911](compiler-error-c3911.md)|"*member*"：函数必须是 "*type*" 类型|
|[编译器错误 C3912](compiler-error-c3912.md)|"*event*"：事件类型必须是委托类型|
|[编译器错误 C3913](compiler-error-c3913.md)|必须将默认属性编入索引|
|[编译器错误 C3914](compiler-error-c3914.md)|默认属性不能是静态的|
|[编译器错误 C3915](compiler-error-c3915.md)|"*identifier*" 没有默认索引的属性（类索引器）|
|编译器错误 C3916|已过时。|
|[编译器错误 C3917](compiler-error-c3917.md)|"*token*"：已过时的*构造*声明样式（您是否希望改用 "[' ']"？）|
|[编译器错误 C3918](compiler-error-c3918.md)|用法要求 "*identifier*" 是数据成员|
|[编译器错误 C3919](compiler-error-c3919.md)|"*function*"：函数必须具有类型 "*return_type* （*类型*）"|
|[编译器错误 C3920](compiler-error-c3920.md)|"*operator*"：不能定义后缀增量/减量 Clr/winrt 运算符。调用后缀 clr/winrt 运算符将调用相应的前缀 Clr/winrt 运算符（op_Increment/op_Decrement），但具有后缀语义|
|编译器错误 C3921|已过时。|
|编译器错误 C3922|已过时。|
|[编译器错误 C3923](compiler-error-c3923.md)|"*member*"：局部类、结构或联合定义不允许在托管的/WinRT 类的成员函数中使用|
|编译器错误 C3924|参数 # 委托构造函数调用 "*构造函数*" 的*数目*错误：|
|编译器错误 C3925|"*指令*" 指令后应为循环（for、while 或 do）|
|编译器错误 C3926|"parallel" 指令中的常量无效|
|编译器错误 C3927|"->"：非函数声明符后不允许尾随返回类型|
|编译器错误 C3928|"->"：带圆括号的声明符后不允许尾随返回类型|
|编译器错误 C3929|已过时。|
|编译器错误 C3930|"*function*"：没有重载函数具有与环境上下文 "*context*" 兼容的限制说明符|
|编译器错误 C3931|"*type*"：无法调用其限制说明符与环境上下文不兼容的函数|
|编译器错误 C3932|已过时。|
|编译器错误 C3933|"*class*"：析构函数的限制说明符必须涵盖所有构造函数上的限制的联合|
|编译器错误 C3934|采用 "main" 格式的函数不能包含除 restrict （cpu）以外的限制说明符|
|编译器错误 C3935|"*identifier*"：重定义;重叠限制说明符|
|编译器错误 C3936|"*identifier*"：无法识别的限制说明符|
|编译器错误 C3937|不允许空限制说明符|
|编译器错误 C3938|"*identifier*"： extern \042C\042 函数不支持多个限制说明符|
|编译器错误 C3939|"*identifier*"：不允许指向成员函数的指针、函数指针、对具有 "amp" 限制说明符的函数的引用|
|编译器错误 C3940|"*identifier*"：找不到标识符-编译器和库版本之间可能不匹配。 请确保 vccorlib.h/.lib、vccorlib120 和 c1xx 匹配|
|编译器错误 C3941|"*condition*"：需要 "/clr" 命令行选项|
|编译器错误 C3942|已过时。|
|编译器错误 C3943|已过时。|
|编译器错误 C3944|已过时。|
|编译器错误 C3945|"*type*"：无法引发或捕捉不会从 Platform：： Exception 派生的 winrt 对象|
|编译器错误 C3946|"*type*"：无法向此类型应用 typeid|
|编译器错误 C3947|"*typeid*"： typeid 无法应用于包扩展|
|编译器错误 C3948|"*关键字*"：包扩展不能出现在此上下文中|
|编译器错误 C3949|包扩展 "..." 不能出现在带圆括号的抽象声明符中|
|编译器错误 C3950|已过时。|
|编译器错误 C3951|不能在投影的 WinRT 类型 "*type*" 中使用指向成员的指针。 改为使用委托。|
|编译器错误 C3952|"*type*"： WinRT 不支持 "in/out" 数组。 在公共 Api 上，使用 "const Array\<T > ^" 作为 "in" 和 "WriteOnlyArray\<T >" 或 "Array\<T > ^ *" 作为 "out"|
|编译器错误 C3953|在 WinRT 模块中不能使用托管类 "*type*"。|
|编译器错误 C3954|"*type*"：从 WinRT 类型的已发布方法中返回的数组必须使用 "Array\<t > ^" 形式|
|编译器错误 C3955|"*type*"：公共构造函数不能包含 "out" 参数或 "WriteOnlyArray\<t >"|
|编译器错误 C3956|"*type*"：类型标记为独占到 "*type*"，不能用作 "*derived_type*" 的基|
|编译器错误 C3957|"*type*"：不能对 WinRT 类型使用 "new";改为使用 "ref new"|
|编译器错误 C3958|"*type*"：不能对 WinRT 类型使用 "gcnew";改为使用 "ref new"|
|编译器错误 C3959|"ref new" 只能用于创建 WinRT 类型的对象|
|编译器错误 C3960|已过时。|
|编译器错误 C3961|不支持静态构造函数|
|编译器错误 C3962|不支持泛型类|
|编译器错误 C3963|不支持多维数组|
|编译器错误 C3964|不支持交错数组|
|编译器错误 C3965|不支持参数数组|
|编译器错误 C3966|"*function*"：不支持泛型函数|
|编译器错误 C3967|从模块 "*module*" 导入 "*identifier*" 时出错|
|编译器错误 C3968|标记 "*token*" 无效，因为模块名称分隔符;改用句点（"."）|
|编译器错误 C3969|模块名称不一致： "*module1*" 和 "*module1*"|
|编译器错误 C3970|"*identifier*"： "*关键字*" 只能应用到全局范围或命名空间范围的 "ref class" 或 "ref struct"|
|编译器错误 C3971|"*type*"：部分定义不能出现在完整定义之后|
|编译器错误 C3972|"*type*"： "partial" 只能应用于类声明或定义|
|编译器错误 C3973|已过时。|
|编译器错误 C3974|已过时。|
|编译器错误 C3975|"class/struct*标识符*" 以前是用不同的修饰符声明或定义的|
|编译器错误 C3976|必须将 "*identifier1*" 声明为 "public" 才能使用 "*identifier2*"|
|编译器错误 C3977|使用需要引用定义 "*identifier*" 的程序集|
|编译器错误 C3978|"*identifier*"：静态属性不允许作为 WinRT 接口或值类型的成员|
|编译器错误 C3979|"*type*"：使用特性 "*attribute*" 而不是 "*value*"|
|编译器错误 C3980|"*type*" 不能发送到元数据中|
|编译器错误 C3981|"*type*"：值类型不能具有任何静态数据成员 "*identifier*"|
|编译器错误 C3982|"*type*"：值类型不能具有任何非公共数据成员 "*identifier*"|
|编译器错误 C3983|"*type*"：值类型不能具有任何公共非数据成员 "*identifier*"|
|编译器错误 C3984|"*type*"：非值类型不能具有任何公共数据成员 "*identifier*"|
|编译器错误 C3985|"*identifier*"：公共成员的签名包含私有类型 "*member*"|
|编译器错误 C3986|"*identifier*"：公共成员的签名包含本机类型 "*member*"|
|编译器错误 C3987|"*identifier*"：公共成员的签名包含本机类型 "*type*"|
|编译器错误 C3988|"*type*"：本机类型不能是公共的|
|编译器错误 C3989|"*type*"：嵌套类型不能是公共的|
|编译器错误 C3990|"*type*"：特性 "*attribute*" 不能是私有或嵌套的|
|编译器错误 C3991|"*type*"：无法实现非公共或嵌套的接口 "*interface*"|
|编译器错误 C3992|"*identifier*"：公共成员的签名包含无效类型 "*type*"|
|编译器错误 C3993|"*type*"：值类型必须至少包含一个公共字段|
|编译器错误 C3994|"*type*"：值类型无法实现接口或具有虚拟函数|
|编译器错误 C3995|"*type*"：值类型不能具有任何事件成员 "*identifier*"|
|编译器错误 C3996|已过时。|
|编译器错误 C3998|"c + +*版本*" C++ ：不受支持的版本;默认为 "c + +*版本*"|
|编译器错误 C3999|未知错误，请选择 "视觉C++帮助" 菜单上的 "技术支持" 命令，或打开技术支持帮助文件以获取详细信息|

## <a name="see-also"></a>另请参阅

[C/C++编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器错误 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
