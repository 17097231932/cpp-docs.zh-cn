---
title: "D. 使用计划子句 |Microsoft 文档"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: bf3d8f51-ea05-4803-bf55-657c12e91efe
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: b51eeb36a4cffafde0e90586fec08d28b9672e5d
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/21/2017
---
# <a name="d-using-the-schedule-clause"></a>D. 使用计划子句
并行区域具有至少一个屏障、 在其末尾，并且可能具有在它的其他屏障。 在每个屏障的其他团队成员必须等待到达最后一个线程。 为了尽量减少此等待时间，以便所有线程都到达屏障在了解同一时间应分发共享的工作。 如果某些的共享中包含工作**为**构造，`schedule`子句可用于此目的。  
  
 相同的对象中，选择的计划的重复的引用时**为**构造可能主要由内存系统，如状态和大小的缓存以及是否内存访问的各种特性时间是统一或非均匀。 此类注意事项可能会使更可取的方法具有一致地指在一系列的循环，数组的元素属于同一套每个线程，即使某些线程分配在某些循环相对较少工作。 这可以通过使用**静态**具有相同边界的 for 循环的计划。 在下面的示例，请注意，即使在第二个循环，下限作为使用零**k**将更自然如果计划不重要。  
  
```  
#pragma omp parallel  
{  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    a[i] = work1(i);  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    if(i>=k) a[i] += work2(i);  
}  
```  
  
 在剩余的示例中，假定该内存访问不是基准的考虑，并且，除非另行说明，所有线程都接收可比较的计算资源。 在这些情况下，计划的选择**为**构造取决于要之间前面最近执行的所有共享工作屏障和隐式的关闭屏障或最接近的后续屏障，如果没有`nowait`子句。 对于每个类型的计划，是简短的示例显示如何该计划类型可能是最佳选择。 简要介绍遵循每个示例。  
  
 **静态**日程安排也是适用于简单的情况下，并行区域包含单个**为**构造，每次迭代只需相同数量的工作。  
  
```  
#pragma omp parallel for schedule(static)  
for(i=0; i<n; i++) {  
  invariant_amount_of_work(i);  
}  
```  
  
 **静态**计划的特点是属性的每个线程获取大约相同数量的迭代与其他任何线程，并且每个线程可以独立地确定分配给它的迭代。 因此需要同步来分发工作，并假设每次迭代需要相同数量的工作，所有线程应都完成在大约在同一时间。  
  
 为团队的`p`线程，让*ceiling(n/p)*是整数*q*，以及满足*n = p\*q-r*与*0 < = r < p*. 一种实现**静态**为此示例将分配计划*q*迭代与第一个*p-1*线程，和*q r*到最后一个线程的迭代。  另一个可接受的实现会将分配*q*迭代与第一个*p-r*线程，和*q-1*到剩余迭代*r*线程。 它说明了为什么程序不应依赖于特定实现的详细信息。  
  
 **动态**计划适合的大小写**为**构造与要求不同，或甚至不可预测性工作的金额迭代。  
  
```  
#pragma omp parallel for schedule(dynamic)  
  for(i=0; i<n; i++) {  
    unpredictable_amount_of_work(i);  
}  
```  
  
 **动态**计划表征没有线程等待在屏障长度超过它采用另一个线程来执行其最后一个迭代的属性。 这要求为迭代分配一次一个地线程变得可用，为每个分配的同步。 可通过指定最小的块区大小减少同步开销*k*大于 1，以便分配线程*k*一次之前少于*k*保持。 这可保证在超过它采用另一个线程 （最多） 执行其最后一个区块的屏障上等待任何线程*k*迭代。  
  
 **动态**计划将很有用的线程得到不同的计算资源，它具有不同数量的每个迭代的工作的效果大体相同。 同样，动态计划也很有用如果线程到达**为**在不同时间，但在某些情况下构造**引导式**计划可能更可取。  
  
 **引导式**计划适合于这种情况在不同时间，可能会到达线程**为**构造每个迭代要求有关相同数量的工作。 可能的原因是，例如，**为**构造前面都有一个或多个部分或**为**将构造带`nowait`子句。  
  
```  
#pragma omp parallel  
{  
  #pragma omp sections nowait  
  {  
    // ...  
  }  
  #pragma omp for schedule(guided)  
  for(i=0; i<n; i++) {  
    invariant_amount_of_work(i);  
  }  
}  
```  
  
 如**动态**、**引导式**计划没有线程在超过它采用另一个线程来执行其最后一个迭代或最后一个屏障上等待的保证*k*如果的块区大小的迭代*k*指定。 在这种日程表之间**引导式**计划的特点是属性，它需要最少的同步。 块区大小为*k*，典型的实现会将分配*q = ceiling(n/p)*迭代到第一个可用线程，设置 *n* 到较大的*n-q*和*p\*k*，并重复，直到所有迭代都分配。  
  
 时选择最佳的计划不是因为这些示例，它是以明文**运行时**计划将为试验不同的计划和区块大小而无需修改和重新编译该程序提供方便。 它还可有用时获得最佳的计划 （在某种可预测的方式） 依赖于向其应用程序的输入数据。  
  
 若要查看的不同计划权衡示例，请考虑共享 8 线程间的 1000年次迭代。 假定每次迭代中工作的固定量并将其用作的时间单位。  
  
 如果在同一时间，所有线程都启动**静态**计划将导致构造来执行 125 单位，不进行同步。 但是，假定一个线程是在传入的后期的 100 个单位。 然后剩余的 7 个线程等待 100 个单位，屏障、 和的整个构造的执行时间增加到 225。  
  
 因为同时**动态**和**引导式**计划确保没有线程等待在屏障的多个单元，延迟的线程导致构造来增加仅到 138 其执行时间单位，可能是增加从同步延迟造成的。 如果此类延迟不可以忽略不计，它变得非常重要的同步数为 1000年**动态**但仅为 41**引导式**，假定一个默认块区大小。 块区大小为 25，**动态**和**引导式**同时分别完成 150 个单位，以及从所需同步时，只有 40 个和 20，哪些现在数任何延迟。