---
title: "CDC 类 |Microsoft 文档"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- Windows [C++], device contexts
- Windows 95 [C++], screen coordinates
- device contexts [C++], CDC class
- screen coordinates in device contexts
- coordinates in Windows 95/98 [C++]
- Windows 98 [C++], screen coordinates
- CDC class
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
caps.latest.revision: 21
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 3f91eafaf3b5d5c1b8f96b010206d699f666e224
ms.openlocfilehash: edbb8c4b62fc6536971f275c8079a3a91caccaa2
ms.contentlocale: zh-cn
ms.lasthandoff: 04/01/2017

---
# <a name="cdc-class"></a>CDC 类
定义设备上下文对象的类。  
  
## <a name="syntax"></a>语法  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>成员  
  
### <a name="public-constructors"></a>公共构造函数  
  
|名称|描述|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|构造 `CDC` 对象。|  
  
### <a name="public-methods"></a>公共方法  
  
|名称|描述|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|终止当前的打印作业，并擦除所有内容自上次调用的应用程序已写入到设备`StartDoc`成员函数。|  
|[CDC::AbortPath](#abortpath)|关闭并放弃的设备上下文中的任何路径。|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|将批注缓冲区中复制到指定的增强型格式图元文件。|  
|[CDC::AlphaBlend](#alphablend)|显示具有透明或半透明的像素为单位的位图。|  
|[CDC::AngleArc](#anglearc)|绘制一条直线段和一段弧线，并将当前的位置移动到弧线的结束点。|  
|[CDC::Arc](#arc)|绘制一条椭圆弧。|  
|[CDC::ArcTo](#arcto)|绘制一条椭圆弧。 此函数是类似于`Arc`，只不过更新当前位置。|  
|[CDC::Attach](#attach)|将 Windows 设备上下文附加到这`CDC`对象。|  
|[Cdc:: beginpath](#beginpath)|在设备上下文中打开路径括号。|  
|[Cdc:: bitblt](#bitblt)|从指定的设备上下文中复制位图。|  
|[CDC::Chord](#chord)|绘制线 （受椭圆和一条线段的交集的闭合图形）。|  
|[CDC::CloseFigure](#closefigure)|关闭开放的图形路径中。|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|创建与另一个设备上下文兼容的内存设备上下文。 可用于准备在内存中的映像。|  
|[CDC::CreateDC](#createdc)|创建特定设备的设备上下文。|  
|[CDC::CreateIC](#createic)|创建特定设备的信息上下文。 这提供了一种不创建设备上下文中获取有关设备的信息的快速方法。|  
|[CDC::DeleteDC](#deletedc)|删除与此关联的 Windows 设备上下文`CDC`对象。|  
|[CDC::DeleteTempMap](#deletetempmap)|由调用`CWinApp`空闲时间处理程序以删除任何临时`CDC`创建对象`FromHandle`。 此外将分离的设备上下文。|  
|[CDC::Detach](#detach)|分离 Windows 设备上下文中的，从这`CDC`对象。|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|将转换到的设备单位**HIMETRIC**单位。|  
|[CDC::DPtoLP](#dptolp)|将设备单位转换为逻辑单元。|  
|[CDC::Draw3dRect](#draw3drect)|绘制三维矩形。|  
|[CDC::DrawDragRect](#drawdragrect)|清除并重新绘制矩形，如拖动它。|  
|[CDC::DrawEdge](#drawedge)|绘制的矩形的边缘。|  
|[CDC::DrawEscape](#drawescape)|绘制不通过图形设备接口 (GDI) 直接可用视频显示功能的访问。|  
|[CDC::DrawFocusRect](#drawfocusrect)|中用于指示焦点的样式绘制的矩形。|  
|[CDC::DrawFrameControl](#drawframecontrol)|绘制一个帧控件。|  
|[CDC::DrawIcon](#drawicon)|绘制一个图标。|  
|[CDC::DrawState](#drawstate)|显示图像，并将应用视觉效果来指示状态。|  
|[CDC::DrawText](#drawtext)|绘制带格式文本中指定的矩形。|  
|[CDC::DrawTextEx](#drawtextex)|绘制带格式文本中使用其他格式的指定矩形。|  
|[CDC::Ellipse](#ellipse)|绘制椭圆形。|  
|[CDC::EndDoc](#enddoc)|结束启动的打印作业`StartDoc`成员函数。|  
|[CDC::EndPage](#endpage)|通知的设备驱动程序结束页。|  
|[CDC::EndPath](#endpath)|关闭路径括号并选择到设备上下文中定义的括号的路径。|  
|[Cdc:: enumobjects](#enumobjects)|枚举钢笔和画笔设备上下文中可用。|  
|[CDC::Escape](#escape)|允许应用程序访问未直接提供的 GDI 通过特定设备的功能。 此外允许对 Windows 转义函数的访问。 转义调用应用程序进行转换，并且发送到设备驱动程序。|  
|[CDC::ExcludeClipRect](#excludecliprect)|创建新的剪辑区域组成减去指定的矩形的现有剪辑区域。|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|通过从剪辑区域排除窗口中的更新的区域，可以防止绘制的窗口的无效区域内。|  
|[CDC::ExtFloodFill](#extfloodfill)|使用当前画笔填充一块区域。 提供更大的灵活性比[CDC::FloodFill](#floodfill)成员函数。|  
|[CDC::ExtTextOut](#exttextout)|将使用当前选定的字体的矩形区域中的一个字符串。|  
|[CDC::FillPath](#fillpath)|关闭当前路径中的任何开放图形，并使用当前画笔和多边形填充模式填充的路径的内部。|  
|[CDC::FillRect](#fillrect)|通过使用特定的画笔填充给定的矩形。|  
|[CDC::FillRgn](#fillrgn)|用指定的画笔填充特定区域。|  
|[CDC::FillSolidRect](#fillsolidrect)|使用纯色填充的矩形。|  
|[CDC::FlattenPath](#flattenpath)|转换到当前的设备上下文中，选择的路径中的任何曲线并将每个曲线转换成的行序列。|  
|[CDC::FloodFill](#floodfill)|使用当前画笔填充一块区域。|  
|[CDC::FrameRect](#framerect)|绘制矩形周围的边框。|  
|[CDC::FrameRgn](#framergn)|使用画笔特定区域周围绘制的边框。|  
|[CDC::FromHandle](#fromhandle)|返回一个指向`CDC`对象提供的设备上下文句柄时。 如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。|  
|[CDC::GetArcDirection](#getarcdirection)|返回设备上下文的当前弧线方向。|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|检索当前的纵横比筛选器的设置。|  
|[CDC::GetBkColor](#getbkcolor)|检索当前的背景色。|  
|[CDC::GetBkMode](#getbkmode)|检索背景模式。|  
|[CDC::GetBoundsRect](#getboundsrect)|返回指定的设备上下文的当前累积绑定矩形。|  
|[CDC::GetBrushOrg](#getbrushorg)|检索当前画笔的原点。|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|检索的宽度，以逻辑单元的当前字体从给定范围中的连续字符。|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|检索的宽度，以在指定范围从当前 TrueType 字体中的连续的标志符号索引的逻辑单元。|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|检索各种类型的字符字符串的信息。|  
|[CDC::GetCharWidth](#getcharwidth)|从当前的字体中检索给定范围中的连续字符的小数部分的宽度。|  
|[CDC::GetCharWidthI](#getcharwidthi)|检索的宽度，以逻辑坐标，从当前的字体在指定范围中的连续的标志符号索引。|  
|[CDC::GetClipBox](#getclipbox)|检索当前的剪辑边界周围 tightest 边界的矩形的尺寸。|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|检索设备上下文的颜色调整值。|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|将指针返回到当前所选`CBitmap`对象。|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|将指针返回到当前所选`CBrush`对象。|  
|[CDC::GetCurrentFont](#getcurrentfont)|将指针返回到当前所选`CFont`对象。|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|将指针返回到当前所选`CPalette`对象。|  
|[CDC::GetCurrentPen](#getcurrentpen)|将指针返回到当前所选`CPen`对象。|  
|[CDC::GetCurrentPosition](#getcurrentposition)|检索钢笔的当前位置 （以逻辑坐标表示）。|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|检索当前画笔的颜色。|  
|[CDC::GetDCPenColor](#getdcpencolor)|检索当前的钢笔颜色。|  
|[CDC::GetDeviceCaps](#getdevicecaps)|检索指定的类型的给定的显示设备的功能特定于设备的信息。|  
|[CDC::GetFontData](#getfontdata)|从可缩放的字体文件检索字体指标信息。 通过指定偏移量到字体文件和要返回的信息的长度标识要检索的信息。|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|返回有关指定的显示上下文的当前选定字体的信息。|  
|[CDC::GetGlyphOutline](#getglyphoutline)|检索的大纲曲线或当前的字体中的大纲字符的位图。|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|检索指定的设备上下文的当前图形模式。|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|检索一个半色调画笔。|  
|[CDC::GetKerningPairs](#getkerningpairs)|检索对指定的设备上下文中当前选定的字体的字距调整的字符。|  
|[CDC::GetLayout](#getlayout)|检索设备上下文 (DC) 的布局。 布局可以是左到右 （默认值） 或从右到左 （镜像）。|  
|[CDC::GetMapMode](#getmapmode)|检索当前的映射模式。|  
|[CDC::GetMiterLimit](#getmiterlimit)|返回设备上下文的斜接限制。|  
|[CDC::GetNearestColor](#getnearestcolor)|检索指定的逻辑颜色可以表示给定的设备到最接近的逻辑颜色。|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|检索字体为 TrueType 字体的度量值信息。|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|从当前字体使用输出的设备上下文中检索一组连续的字符中的单个字符的宽度。|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|计算的宽度和高度上输出设备上下文的字符字符串。|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|计算的宽度和高度的行上使用的当前字体以确定维度的输出设备上下文的文本。|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|从输出设备上下文中检索当前字体的度量值。|  
|[CDC::GetPath](#getpath)|检索定义的终结点的行和在被选入设备上下文的路径中找到的曲线的控点的坐标。|  
|[CDC::GetPixel](#getpixel)|检索指定点处的像素的 RGB 颜色值。|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|检索当前的多边形填充模式。|  
|[CDC::GetROP2](#getrop2)|检索当前的绘制模式。|  
|[CDC::GetSafeHdc](#getsafehdc)|返回[CDC::m_hDC](#m_hdc)，输出设备上下文。|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|检索当前的位图拉伸模式。|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|计算的宽度和高度属性设备上下文的字符字符串。|  
|[CDC::GetTextAlign](#gettextalign)|检索文本对齐方式标志。|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|检索 intercharacter 间距量的当前设置。|  
|[CDC::GetTextColor](#gettextcolor)|检索当前的文本颜色。|  
|[CDC::GetTextExtent](#gettextextent)|计算的宽度和高度的行上使用的当前字体以确定维度的属性设备上下文的文本。|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|检索中将不超出指定的空间和为每个这些字符与文本范围填充数组的指定字符串的字符数。|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|检索的宽度和高度指定的标志符号索引数组。|  
|[CDC::GetTextFace](#gettextface)|以 null 结尾的字符串复制到缓冲区的当前字体的字体名称。|  
|[CDC::GetTextMetrics](#gettextmetrics)|从特性设备上下文中检索当前字体的度量值。|  
|[CDC::GetViewportExt](#getviewportext)|检索 x-和 y-区的视区。|  
|[CDC::GetViewportOrg](#getviewportorg)|检索视区原点 x 和 y 坐标。|  
|[CDC::GetWindow](#getwindow)|返回与显示设备上下文关联的窗口。|  
|[CDC::GetWindowExt](#getwindowext)|检索 x-和 y 的范围内的关联的窗口。|  
|[CDC::GetWindowOrg](#getwindoworg)|检索的源关联的窗口的 x 和 y 坐标。|  
|[CDC::GetWorldTransform](#getworldtransform)|检索页面空间转换到的当前世界空间。|  
|[CDC::GradientFill](#gradientfill)|用 gradating 颜色填充矩形和三角形结构。|  
|[Cdc:: graystring](#graystring)|绘制灰色 （显示为灰色） 中的给定位置的文本。|  
|[CDC::HIMETRICtoDP](#himetrictodp)|将转换**HIMETRIC**分成多个设备单位的单位。|  
|[CDC::HIMETRICtoLP](#himetrictolp)|将转换**HIMETRIC**给逻辑单元的单位。|  
|[CDC::IntersectClipRect](#intersectcliprect)|通过为当前区域和一个矩形的交集创建新的剪辑区域。|  
|[CDC::InvertRect](#invertrect)|反转的矩形的内容。|  
|[CDC::InvertRgn](#invertrgn)|反转区域中的颜色。|  
|[CDC::IsPrinting](#isprinting)|确定是否正在使用的设备上下文进行打印。|  
|[CDC::LineTo](#lineto)|从当前位置到，但不是包括、 点绘制一条线。|  
|[CDC::LPtoDP](#lptodp)|将设备单位转换为逻辑单元。|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|将转换到逻辑单元**HIMETRIC**单位。|  
|[CDC::MaskBlt](#maskblt)|将使用给定的掩码和光栅操作的源和目标位图颜色数据合并。|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|更改的世界转换的设备上下文，使用指定的模式。|  
|[CDC::MoveTo](#moveto)|将当前位置移动。|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|将移动给定的设备的剪辑区域。|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|修改相对于当前的视区原点坐标视区原点。|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|修改窗口原点相对于当前窗口原点的坐标。|  
|[CDC::PaintRgn](#paintrgn)|用所选的画笔填充区域。|  
|[CDC::PatBlt](#patblt)|创建位模式。|  
|[CDC::Pie](#pie)|绘制饼形 wedge。|  
|[CDC::PlayMetaFile](#playmetafile)|在给定设备上播放指定的图元文件的内容。 增强的版本`PlayMetaFile`显示存储在给定的增强型格式图元文件中的图片。 图元文件就可以播放任意次数。|  
|[CDC::PlgBlt](#plgblt)|执行颜色数据的位的位块传输的源设备上下文中指定的矩形从到在给定的设备上下文中指定的平行四边形。|  
|[CDC::PolyBezier](#polybezier)|绘制一个或多个 Bzier 样条。 当前的位置不使用，也不更新。|  
|[CDC::PolyBezierTo](#polybezierto)|绘制一个或多个 Bzier 样条，并将当前的位置移动到最后一个 Bzier 样条曲线的结束点。|  
|[CDC::PolyDraw](#polydraw)|绘制一套直线线段和 Bzier 样条。 此函数将更新当前的位置。|  
|[CDC::Polygon](#polygon)|绘制多边形包含两个或多个点 （顶点） 线路连接。|  
|[CDC::Polyline](#polyline)|绘制一组连接的指定的点的线段。|  
|[CDC::PolylineTo](#polylineto)|绘制一个或多个直线，并将当前的位置移动到的最后一行的结束点。|  
|[CDC::PolyPolygon](#polypolygon)|创建两个或多个使用当前的多边形填充模式填充的多边形。 多边形可能不连续，或者它们可能重叠。|  
|[CDC::PolyPolyline](#polypolyline)|绘制多个序列的连接的直线线段。 当前的位置不使用也不更新此函数。|  
|[CDC::PtVisible](#ptvisible)|指定给定的点是否的剪辑区域内。|  
|[CDC::RealizePalette](#realizepalette)|将当前逻辑调色板中的调色板条目映射到系统调色板。|  
|[CDC::Rectangle](#rectangle)|使用当前的钢笔绘制一个矩形，并使用当前画笔进行填充。|  
|[CDC::RectVisible](#rectvisible)|确定的剪辑区域内是否位于给定任何的矩形部分。|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|版本`m_hAttribDC`，特性设备上下文。|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|版本`m_hDC`，输出设备上下文。|  
|[CDC::ResetDC](#resetdc)|更新`m_hAttribDC`设备上下文。|  
|[CDC::RestoreDC](#restoredc)|还原到以前的状态与保存的设备上下文`SaveDC`。|  
|[CDC::RoundRect](#roundrect)|使用当前的钢笔和填充使用当前画笔的圆角绘制的矩形。|  
|[CDC::SaveDC](#savedc)|保存设备上下文的当前的状态。|  
|[CDC::ScaleViewportExt](#scaleviewportext)|修改相对于当前值的视区范围。|  
|[CDC::ScaleWindowExt](#scalewindowext)|修改范围相对于当前值，该窗口。|  
|[CDC::ScrollDC](#scrolldc)|水平和垂直滚动的矩形的位数。|  
|[CDC::SelectClipPath](#selectclippath)|选择作为设备上下文，使用指定的模式来组合与任何现有的剪辑区域的新区域的剪辑区域的当前路径。|  
|[CDC::SelectClipRgn](#selectcliprgn)|通过使用指定的模式组合为当前剪辑区域与给定的区域。|  
|[Cdc:: selectobject](#selectobject)|选择一个 GDI 绘制对象，如钢笔。|  
|[CDC::SelectPalette](#selectpalette)|选择逻辑调色板。|  
|[CDC::SelectStockObject](#selectstockobject)|选择其中一种预定义的常用钢笔、 画笔或由 Windows 提供的字体。|  
|[Cdc:: setabortproc](#setabortproc)|设置 Windows 会调用如果必须中止打印作业的程序员提供的回调函数。|  
|[CDC::SetArcDirection](#setarcdirection)|设置要用于弧线和矩形函数的绘制方向。|  
|[CDC::SetAttribDC](#setattribdc)|集`m_hAttribDC`，特性设备上下文。|  
|[CDC::SetBkColor](#setbkcolor)|设置当前的背景色。|  
|[CDC::SetBkMode](#setbkmode)|设置后台模式。|  
|[CDC::SetBoundsRect](#setboundsrect)|控制指定的设备上下文的边界矩形信息的累计。|  
|[CDC::SetBrushOrg](#setbrushorg)|指定为选入设备上下文的下一步画笔的原点。|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|设置使用指定的值的设备上下文的颜色调整值。|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|设置当前画笔的颜色。|  
|[CDC::SetDCPenColor](#setdcpencolor)|设置当前的钢笔颜色。|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|设置指定的设备上下文的当前图形模式。|  
|[CDC::SetLayout](#setlayout)|设备上下文 (DC) 的布局更改。|  
|[CDC::SetMapMode](#setmapmode)|设置当前的映射模式。|  
|[CDC::SetMapperFlags](#setmapperflags)|更改字体映射器时它映射到物理字体的逻辑字体使用的算法。|  
|[CDC::SetMiterLimit](#setmiterlimit)|设置用于设备上下文的斜接联接的长度的限制。|  
|[CDC::SetOutputDC](#setoutputdc)|集`m_hDC`，输出设备上下文。|  
|[CDC::SetPixel](#setpixel)|设置指定的颜色最接近的指定点处的像素。|  
|[CDC::SetPixelV](#setpixelv)|到指定的颜色最接近的指定坐标处设置像素。 `SetPixelV`比快`SetPixel`因为它不需要返回实际绘制的点的颜色值。|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|设置在多边形填充模式。|  
|[CDC::SetROP2](#setrop2)|设置的当前绘图模式。|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|将位图拉伸模式设置。|  
|[CDC::SetTextAlign](#settextalign)|设置文本对齐方式标志。|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|设置 intercharacter 间距的大小。|  
|[CDC::SetTextColor](#settextcolor)|设置文本颜色。|  
|[CDC::SetTextJustification](#settextjustification)|将空间添加到字符串中的中断字符。|  
|[CDC::SetViewportExt](#setviewportext)|设置 x-和 y-区的视区。|  
|[CDC::SetViewportOrg](#setviewportorg)|设置视区原点。|  
|[CDC::SetWindowExt](#setwindowext)|设置 x-和 y 的范围内的关联的窗口。|  
|[CDC::SetWindowOrg](#setwindoworg)|设置的设备上下文则窗口原点。|  
|[CDC::SetWorldTransform](#setworldtransform)|将当前的全局空间设置为页面空间转换。|  
|[CDC::StartDoc](#startdoc)|通知的设备驱动程序正在启动新的打印作业。|  
|[CDC::StartPage](#startpage)|通知的设备驱动程序正在启动一个新页。|  
|[CDC::StretchBlt](#stretchblt)|将位图从一个源矩形和设备移到目标矩形，拉伸或压缩位图，如有必要以适应目标矩形的尺寸。|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|关闭任何开放的路径中的图形、 通过使用当前的钢笔，袭击轮廓的路径和填充其内部使用的当前画笔。|  
|[CDC::StrokePath](#strokepath)|通过使用当前的钢笔呈现指定的路径。|  
|[CDC::TabbedTextOut](#tabbedtextout)|将字符字符串中指定的位置，将选项卡扩展到指定数组的制表位位置中的值。|  
|[CDC::TextOut](#textout)|将使用当前选定的字体中指定位置处的字符字符串。|  
|[CDC::TransparentBlt](#transparentblt)|从指定的源设备上下文的颜色数据位块传输到目标设备上下文中呈现透明在传输中指定的颜色。|  
|[CDC::UpdateColors](#updatecolors)|更新在客户端区域中的按像素基于系统调色板颜色通过匹配当前的设备上下文的工作区。|  
|[CDC::WidenPath](#widenpath)|将当前路径重新定义为将如果路径已描边使用实际选入设备上下文的钢笔绘制区域。|  
  
### <a name="public-operators"></a>公共运算符  
  
|名称|说明|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|检索设备上下文的句柄。|  
  
### <a name="public-data-members"></a>公共数据成员  
  
|名称|描述|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|使用此属性设备上下文`CDC`对象。|  
|[CDC::m_hDC](#m_hdc)|使用此输出设备上下文`CDC`对象。|  
  
## <a name="remarks"></a>备注  
 `CDC`对象提供用于为使用与窗口的工作区相关联的显示上下文使用的设备上下文，例如显示或打印机，以及成员的成员函数。  
  
 执行的函数的经过成员的所有绘图`CDC`对象。 此类提供成员函数，对于设备上下文的操作，使用绘图工具，类型安全图形设备接口 (GDI) 对象选择，然后使用颜色和调色板。 它还提供用于获取和设置的绘制特性，映射，并使用视区中，使用窗口的范围内，转换坐标、 使用区域，剪辑、 绘制线条，并绘制简单形状、 省略号和多边形的成员函数。 此外提供用于绘制文本、 使用字体、 使用打印机转义、 滚动和播放图元文件的成员函数。  
  
 若要使用`CDC`对象构造它，，然后调用其成员的并行使用设备上下文的 Windows 函数的函数。  
  
> [!NOTE]
>  在 Windows 95/98，所有的屏幕坐标被限制为 16 位。 因此，`int`传递给`CDC`成员函数必须介于范围-32768 到 32767 之间。  
  
 对于特定的用途，Microsoft 基础类库提供了几个类派生自`CDC`。 `CPaintDC`封装对调用`BeginPaint`和`EndPaint`。 `CClientDC`管理与客户端区域窗口相关联的显示上下文。 `CWindowDC`管理与整个窗口中，包括其帧和控件相关联的显示上下文。 `CMetaFileDC`将设备上下文与图元文件相关联。  
  
 `CDC`提供两个成员函数， [GetLayout](#getlayout)和[SetLayout](#setlayout)，为反转从窗口中不会继承其布局的设备上下文的布局。 此类右到左的方向是必需的区域性，如阿拉伯语或希伯来语字符布局不欧洲的标准编写的应用程序。  
  
 `CDC`包含两个设备上下文， [m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，而后者在创建`CDC`对象，请参阅在同一设备。 `CDC`所有输出 GDI 将调用都定向到`m_hDC`和大多数属性 GDI 调用`m_hAttribDC`。 (属性调用的一个示例是`GetTextColor`，虽然`SetTextColor`是一个输出调用。)  
  
 例如，框架将使用这些两个设备上下文实现`CMetaFileDC`将输出发送到图元文件读取属性从物理设备时的对象。 打印预览在框架中以类似的方式实现。 在特定于应用程序代码中，还可以使用两个设备上下文以类似的方式。  
  
 有的时间时可能需要从这两个文本指标信息`m_hDC`和`m_hAttribDC`设备上下文。 函数的以下对提供此功能︰  
  
|使用 m_hAttribDC|使用 m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 有关详细信息`CDC`，请参阅[设备上下文](../../mfc/device-contexts.md)。  
  
## <a name="inheritance-hierarchy"></a>继承层次结构  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>要求  
 **标头:** afxwin.h  
  
##  <a name="abortdoc"></a>CDC::AbortDoc  
 终止当前打印作业，并清除自上次调用应用程序已写入到设备的所有内容[StartDoc](#startdoc)成员函数。  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>返回值  
 一个值大于或等于如果成功，则为 0 或负数的值，如果出现错误。 以下列表显示常见的错误值以及它们的含义︰  
  
- **SP_ERROR**常规错误。  
  
- **SP_OUTOFDISK**没有足够的磁盘空间是当前适用于后台处理，并在无更多空间将变为可用。  
  
- **SP_OUTOFMEMORY**没有足够的内存是适用于后台处理。  
  
- **SP_USERABORT**用户终止通过打印管理器作业。  
  
### <a name="remarks"></a>备注  
 此成员函数将替换`ABORTDOC`打印机转义。  
  
 **AbortDoc**应该用于终止以下︰  
  
-   未指定中止函数使用的打印操作[SetAbortProc](#setabortproc)。  
  
-   尚未到达其第一个的打印操作**NEWFRAME**或**NEXTBAND**转义调用。  
  
 如果应用程序会遭遇打印错误或已取消的打印操作，它必须不尝试通过使用终止操作[EndDoc](#enddoc)或**AbortDoc**类的成员函数`CDC`。 GDI 自动终止操作，然后再返回的错误值。  
  
 如果应用程序将显示一个对话框，允许用户取消打印操作，则必须调用**AbortDoc**之前销毁对话框。  
  
 如果使用打印管理器已启动打印作业，则调用**AbortDoc**清除整个假脱机作业-打印机接收执行任何操作。 如果不使用打印管理器已启动打印作业，数据可能已发送到打印机之前**AbortDoc**已调用。 在这种情况下，打印机驱动程序将已重置打印机 （如果可能） 和关闭打印作业。  
  
### <a name="example"></a>示例  
  请参阅示例[CDC::StartDoc](#startdoc)。  
  
##  <a name="abortpath"></a>CDC::AbortPath  
 关闭并放弃的设备上下文中的任何路径。  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 如果在设备上下文中没有一个开放路径方括号，关闭该路径括号，并且路径将被丢弃。 如果在设备上下文中没有闭合的路径，路径将被丢弃。  
  
##  <a name="addmetafilecomment"></a>CDC::AddMetaFileComment  
 将批注缓冲区中复制到指定的增强型格式图元文件。  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>参数  
 *nDataSize*  
 以字节为单位指定注释缓冲区的长度。  
  
 *pCommentData*  
 指向包含注释的缓冲区。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 注释可以包含任何隐私信息 — 例如，图和日期的它已创建了源。 注释应该开始使用应用程序签名，其后的数据。 注释不应包含特定于位置的数据。 特定于位置的数据指定的位置的一个记录，它应不会包括与因为一个图元文件可能嵌入到另一个图元文件中。 此函数仅用于增强型图元文件。  
  
##  <a name="alphablend"></a>CDC::AlphaBlend  
 调用此成员函数以显示具有透明或半透明的像素为单位的位图。  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>参数  
 `xDest`  
 指定逻辑单位，目标矩形的左上角的 x 坐标。  
  
 `yDest`  
 指定逻辑单位，目标矩形的左上角的 y 坐标。  
  
 `nDestWidth`  
 指定的宽度，以逻辑单元，目标矩形。  
  
 `nDestHeight`  
 指定逻辑单位，目标矩形的高度。  
  
 `pSrcDC`  
 指向源设备上下文的指针。  
  
 `xSrc`  
 指定逻辑单位，源矩形的左上角的 x 坐标。  
  
 `ySrc`  
 指定逻辑单位，源矩形的左上角的 y 坐标。  
  
 `nSrcWidth`  
 指定逻辑单位，源矩形的宽度。  
  
 `nSrcHeight`  
 指定逻辑单位，源矩形的高度。  
  
 *blend*  
 指定[BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393)结构。  
  
### <a name="return-value"></a>返回值  
 **TRUE**如果成功，否则为**FALSE**。  
  
### <a name="remarks"></a>备注  
 请参阅[AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关详细信息。  
  
##  <a name="anglearc"></a>CDC::AngleArc  
 绘制一条直线段和一段弧线。  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的圆的中心中的逻辑 x 坐标。  
  
 *y*  
 指定的圆的中心中的逻辑 y 坐标。  
  
 *nRadius*  
 指定逻辑单元的圆的半径。 此值必须为正数。  
  
 *fStartAngle*  
 指定以相对于 x 轴度为单位的起始角度。  
  
 *fSweepAngle*  
 指定以相对于起始角度度为单位的扫描角度。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 直线段取自到弧线的开头的当前位置。 沿包含给定的 radius 和中心圆圈，圆圈的外围绘制弧。 由给定的开始和扫描角度定义弧的长度。  
  
 `AngleArc`将当前的位置移动到弧线的结束点。 此函数绘制弧可能似乎是椭圆，具体取决于当前的转换和映射模式。 在绘制圆弧之前, 此函数绘制直线线段从当前位置到弧线的开头。 通过构造指定的中心点围绕指定半径虚部圆绘制弧。 通过从该圆形的 x 轴逆时针旋转度量的起始角度的度数确定弧线的起始点。 通过从起始点逆时针旋转度量中扫描角度度数位于同样到结束的点。  
  
 如果扫描角度大于 360 度弧是扫频多次。 此函数通过使用当前的钢笔绘制线条。 不填充图。  
  
##  <a name="arc"></a>CDC::Arc  
 绘制一条椭圆弧。  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 x 坐标。  
  
 `y1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 y 坐标。  
  
 `x2`  
 指定 （在逻辑单位） 的边界矩形右下角的 x 坐标。  
  
 `y2`  
 指定 （在逻辑单位） 的边界矩形右下角的 y 坐标。  
  
 *x3*  
 指定的定义弧的点的 x 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。  
  
 `y3`  
 指定的定义弧的点的 y 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。  
  
 `x4`  
 指定定义弧的终结点 （在逻辑单位） 的点的 x 坐标。 此时没有要将其完全置于圆弧。  
  
 `y4`  
 指定定义弧的终结点 （在逻辑单位） 的点的 y 坐标。 此时没有要将其完全置于圆弧。  
  
 `lpRect`  
 指定的边框 （以逻辑单位）。 你可以传递`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 `ptStart`  
 指定定义弧的点 x 和 y 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。 你可以传递[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
 `ptEnd`  
 指定定义圆弧的终点 （以逻辑单位） 的点 x 和 y 坐标。 此时没有要将其完全置于圆弧。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 通过使用函数绘制弧是椭圆的由指定的边框定义的段。  
  
 圆弧的实际起始点是从通过指定的起始点的绑定矩形的中心绘制的射线与椭圆的交点的点。 圆弧的实际结束点是从通过指定的结束点的绑定矩形的中心绘制的射线与椭圆的交点的点。 以逆时针方向绘制弧。 由于一段弧线，不是闭合的图形，不填充。 宽度和的矩形的高度必须大于 2 个单位和小于 32,767 单位。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>CDC::ArcTo  
 绘制一条椭圆弧。  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 x 坐标。  
  
 `y1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 y 坐标。  
  
 `x2`  
 指定 （在逻辑单位） 的边界矩形右下角的 x 坐标。  
  
 `y2`  
 指定 （在逻辑单位） 的边界矩形右下角的 y 坐标。  
  
 *x3*  
 指定的定义弧的点的 x 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。  
  
 `y3`  
 指定的定义弧的点的 y 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。  
  
 `x4`  
 指定定义弧的终结点 （在逻辑单位） 的点的 x 坐标。 此时没有要将其完全置于圆弧。  
  
 `y4`  
 指定定义弧的终结点 （在逻辑单位） 的点的 y 坐标。 此时没有要将其完全置于圆弧。  
  
 `lpRect`  
 指定的边框 （以逻辑单位）。 你可以将传递到指针[RECT](../../mfc/reference/rect-structure1.md)数据结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 `ptStart`  
 指定定义弧的点 x 和 y 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于圆弧。 你可以传递[点](../../mfc/reference/point-structure1.md)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
 `ptEnd`  
 指定定义圆弧的终点 （以逻辑单位） 的点 x 和 y 坐标。 此时没有要将其完全置于圆弧。 你可以传递**点**数据结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此函数是类似于`CDC::Arc`，只不过更新当前位置。 点 ( `x1`， `y1`) 和 ( `x2`， `y2`) 指定的绑定矩形。 通过给定的边框而形成的椭圆定义圆弧的曲线。 圆弧逆时针延展 （默认弧线方向） 从点相交的中心到边框中的径向一行 ( *x3*， `y3`)。 相交的中心到边框中的径向一行在弧线结束 ( `x4`， `y4`)。 如果起始点和结束点是相同的将绘制整个椭圆。  
  
 从当前位置到弧线的起始点绘制线条。 如果未发生错误，则会将当前位置设置为弧线的结束点。 使用当前的钢笔; 绘制弧不填充。  
  
##  <a name="attach"></a>CDC::Attach  
 使用此成员函数将附加`hDC`到`CDC`对象。  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>参数  
 `hDC`  
 Windows 设备上下文。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 `hDC`存储在同时`m_hDC`，输出设备上下文，并在`m_hAttribDC`，特性设备上下文。  
  
##  <a name="beginpath"></a>Cdc:: beginpath  
 在设备上下文中打开路径括号。  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 打开路径括号后，应用程序可以开始调用 GDI 绘制函数在路径中定义位于的点。 应用程序可以通过调用关闭一个开放路径方括号`EndPath`成员函数。 在应用程序调用`BeginPath`，任何以前的路径将被丢弃。  
  
 请参阅[BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关定义路径中的点的绘制函数的列表。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>Cdc:: bitblt  
 将来自源设备上下文的位图复制到此当前设备上下文中。  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定目标矩形的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定目标矩形的左上角中的逻辑 y 坐标。  
  
 `nWidth`  
 指定目标矩形和源位图的宽度 （以逻辑单位）。  
  
 `nHeight`  
 指定目标矩形和源位图的高度 （以逻辑单位）。  
  
 `pSrcDC`  
 指向`CDC`标识将从中复制位图的设备上下文的对象。 它必须是**NULL**如果*dwRop*指定不包含源的光栅操作。  
  
 `xSrc`  
 指定了源位图的左上角中的逻辑 x 坐标。  
  
 `ySrc`  
 指定了源位图的左上角中的逻辑 y 坐标。  
  
 *dwRop*  
 指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、 可能的源位图和目标位图的输出操作中的颜色。 请参阅[BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关的光栅操作代码的列表*dwRop*及其说明  
  
 光栅操作代码的完整列表，请参阅[有关光栅操作代码](http://msdn.microsoft.com/library/windows/desktop/dd162892)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 应用程序可以对齐 windows 或在字节边界，以确保上的客户端区域`BitBlt`在字节对齐矩形上发生操作。 (设置**CS_BYTEALIGNWINDOW**或**CS_BYTEALIGNCLIENT**标志时注册窗口类。)  
  
 `BitBlt`在字节对齐矩形上的操作是远远快于`BitBlt`上均不为字节对齐的矩形的操作。 如果你想要指定类样式，例如你自己的设备上下文的字节对齐方式，你将需要注册窗口类而不是依赖于可为你执行此操作的 Microsoft 基础类。 使用全局函数[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。  
  
 GDI 转换`nWidth`和`nHeight`、 一次使用目标设备上下文，以及一次通过使用源设备上下文。 GDI 生成扩展盘区不匹配，如果使用 Windows`StretchBlt`函数来压缩或拉伸根据需要与源位图。  
  
 如果目标、 源位图和模式位图没有相同的颜色格式，`BitBlt`函数将转换源位图和模式位图，以匹配目标。 在转换过程中将使用目标位图前景色和背景色。  
  
 当`BitBlt`函数将单色位图转换为颜色，它会将白色位 (1) 设置为背景色，黑色位 (0) 到的前景色。 将使用的目标设备上下文的前景色和背景色。 若要将彩色位图转换为单色，`BitBlt`将与为白色背景色匹配的像素设置和其他所有像素都设置为黑色。 `BitBlt`使用颜色设备上下文的前景色和背景色将从颜色转换为单色。  
  
 请注意，并非所有的设备上下文支持`BitBlt`。 若要检查是否支持给定的设备上下文`BitBlt`，使用`GetDeviceCaps`成员函数并指定**RASTERCAPS**索引。  
  
### <a name="example"></a>示例  
  请参阅示例[CDC::CreateCompatibleDC](#createcompatibledc)。  
  
##  <a name="cdc"></a>CDC::CDC  
 构造 `CDC` 对象。  
  
```  
CDC();
```  
  
##  <a name="chord"></a>CDC::Chord  
 绘制线 （受椭圆和一条线段的交集的闭合图形）。  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定的电源线的左上角的 x 坐标的边框 （以逻辑单位）。  
  
 `y1`  
 指定的电源线的左上角的 y 坐标的边框 （以逻辑单位）。  
  
 `x2`  
 指定的电源线的右下角的 x 坐标的边框 （以逻辑单位）。  
  
 `y2`  
 指定的电源线的右下角的 y 坐标的边框 （以逻辑单位）。  
  
 *x3*  
 指定定义电源线点的 x 坐标的起点 （以逻辑单位）。  
  
 `y3`  
 指定定义电源线点的 y 坐标的起点 （以逻辑单位）。  
  
 `x4`  
 指定定义 （以逻辑单位） 的电源线的终结点的点的 x 坐标。  
  
 `y4`  
 指定定义 （以逻辑单位） 的电源线的终结点的点的 y 坐标。  
  
 `lpRect`  
 指定的边框 （以逻辑单位）。 你可以传递`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 `ptStart`  
 指定定义电源线点 x 和 y 坐标的起点 （以逻辑单位）。 此时没有要将其完全置于电源线。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
 `ptEnd`  
 指定定义 （以逻辑单位） 的电源线的结束点的点 x 和 y 坐标。 此时没有要将其完全置于电源线。 你可以传递[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 ( `x1`， `y1`) 和 ( `x2`， `y2`) 参数的左上角和右下角，分别指定边界是电源线的一部分的椭圆的矩形。 ( *X3*， `y3`) 和 ( `x4`， `y4`) 参数指定的椭圆的直线的终结点。 电源线是使用所选的钢笔绘制，并通过使用选择的画笔填充。  
  
 通过绘制图`Chord`函数最多扩展，但不包括右侧和底部坐标。 这意味着图的高度是`y2`  -  `y1`图形的宽度为`x2`  -  `x1`。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>CDC::CloseFigure  
 关闭开放的图形路径中。  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 函数通过从当前位置到图的第一个点绘制一条线闭合图形 (通常情况下，通过最新调用指定的点`MoveTo`成员函数)，并通过使用线段联接样式连接中的行。 如果通过使用闭合图形`LineTo`成员函数而不是`CloseFigure`，端帽用于创建而不是联接角。 `CloseFigure`应仅调用如果在设备上下文中没有一个开放路径方括号。  
  
 路径中的图形是打开的除非显式将其关闭使用此函数。 （图可以打开即使当前点和图的起始点是相同的。）任何行或添加到后的路径的曲线`CloseFigure`开始一个新图形。  
  
##  <a name="createcompatibledc"></a>CDC::CreateCompatibleDC  
 创建与由指定的设备兼容的内存设备上下文`pDC`。  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>参数  
 `pDC`  
 一个指向设备上下文的指针。 如果`pDC`是**NULL**，该函数将创建与系统显示兼容的内存设备上下文。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 内存设备上下文是内存的表示显示图面块。 它可以用于准备在内存中的映像，然后将其复制到兼容的设备的实际设备图面。  
  
 当创建内存设备上下文时，GDI 会自动为其选择 1-1 的单色股票位图。 可以与内存设备上下文中使用 GDI 输出函数，仅当创建位图且将其选定到该上下文。  
  
 此函数仅用于创建支持光栅操作的设备的兼容设备上下文。 请参阅[cdc:: bitblt](#bitblt)设备上下文之间的位块传输有关的信息的成员函数。 若要确定设备上下文是否支持光栅操作，请参阅**RC_BITBLT**成员函数中的光栅功能`CDC::GetDeviceCaps`。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>CDC::CreateDC  
 创建指定的设备的设备上下文。  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>参数  
 `lpszDriverName`  
 指向以 null 结尾的字符串，指定设备驱动程序 (例如，"EPSON") 的文件名 （不含扩展名）。 你还可以传递`CString`为此参数的对象。  
  
 `lpszDeviceName`  
 指向以 null 结尾的字符串，指定特定设备必须支持 （例如，"EPSON FX-80"） 的名称。 `lpszDeviceName`如果模块支持多个设备，则使用参数。 你还可以传递`CString`为此参数的对象。  
  
 `lpszOutput`  
 指向以 null 结尾的字符串，指定物理输出媒体 （文件或输出端口） 的文件或设备名称。 你还可以传递`CString`为此参数的对象。  
  
 `lpInitData`  
 指向`DEVMODE`结构，它包含设备驱动程序的特定于设备的初始化数据。 Windows **DocumentProperties**函数将检索给定设备为填写此结构。 `lpInitData`参数必须是**NULL**如果设备驱动程序是使用指定用户通过控制面板的默认初始化 （如果有）。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 打印。H 标头文件是必需的如果[DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565)使用结构。  
  
 设备名称遵循这些约定︰ 结束冒号 （:），建议，但不强制。 Windows 提取终止冒号，以便以冒号结尾的设备名称映射到与不带冒号相同的名称相同的端口。 驱动程序和端口名称不能包含前导空格或尾随空格。 与信息上下文，不能使用 GDI 输出函数。  
  
##  <a name="createic"></a>CDC::CreateIC  
 创建指定的设备的信息上下文。  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>参数  
 `lpszDriverName`  
 指向以 null 结尾的字符串，指定设备驱动程序 (例如，"EPSON") 的文件名 （不含扩展名）。 你可以将传递`CString`为此参数的对象。  
  
 `lpszDeviceName`  
 指向以 null 结尾的字符串，指定特定设备必须支持 （例如，"EPSON FX-80"） 的名称。 `lpszDeviceName`如果模块支持多个设备，则使用参数。 你可以将传递`CString`为此参数的对象。  
  
 `lpszOutput`  
 指向以 null 结尾的字符串，指定物理输出媒体 （文件或端口） 的文件或设备名称。 你可以将传递`CString`为此参数的对象。  
  
 `lpInitData`  
 指向设备驱动程序的特定于设备的初始化数据。 `lpInitData`参数必须是**NULL**如果设备驱动程序是使用指定用户通过控制面板的默认初始化 （如果有）。 请参阅`CreateDC`特定于设备的初始化的数据格式。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 信息上下文提供了一种不创建设备上下文中获取有关设备的信息的快速方法。  
  
 设备名称遵循这些约定︰ 结束冒号 （:），建议，但不强制。 Windows 提取终止冒号，以便以冒号结尾的设备名称映射到与不带冒号相同的名称相同的端口。 驱动程序和端口名称不能包含前导空格或尾随空格。 与信息上下文，不能使用 GDI 输出函数。  
  
##  <a name="deletedc"></a>CDC::DeleteDC  
 一般情况下，不调用此函数;析构函数将为您完成它。  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>返回值  
 如果成功，则完成此函数则不为否则为 0。  
  
### <a name="remarks"></a>备注  
 `DeleteDC`成员函数删除与之关联的 Windows 设备上下文`m_hDC`在当前`CDC`对象。 如果此`CDC`对象是给定设备的最后一个活动的设备上下文，设备会通知并释放使用的设备的所有存储和系统资源。  
  
 应用程序不应调用`DeleteDC`如果入设备上下文所选对象。 删除之前，首先必须从设备上下文选择对象。  
  
 应用程序必须删除设备上下文的句柄已获取通过调用[cwnd:: Getdc](../../mfc/reference/cwnd-class.md#getdc)。 相反，它必须调用[cwnd:: Releasedc](../../mfc/reference/cwnd-class.md#releasedc)以释放设备上下文。 [CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)类用于包装此功能。  
  
 `DeleteDC`函数通常用于删除与创建的设备上下文[CreateDC](#createdc)， [CreateIC](#createic)，或[CreateCompatibleDC](#createcompatibledc)。  
  
### <a name="example"></a>示例  
  请参阅示例[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="deletetempmap"></a>CDC::DeleteTempMap  
 自动调用`CWinApp`空闲时间处理程序，`DeleteTempMap`删除任何临时`CDC`创建的对象`FromHandle`，但不会销毁设备上下文句柄 ( `hDC`s) 暂时与`CDC`对象。  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>CDC::Detach  
 调用此函数可分离`m_hDC`（输出设备上下文） 从`CDC`对象，并将同时`m_hDC`和`m_hAttribDC`到**NULL**。  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>返回值  
 Windows 设备上下文。  
  
##  <a name="dptohimetric"></a>CDC::DPtoHIMETRIC  
 使用此函数，当你向**HIMETRIC**给 OLE，转换到的像素为单位的大小**HIMETRIC**。  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 如果设备上下文对象的映射模式是`MM_LOENGLISH`， `MM_HIENGLISH`， `MM_LOMETRIC`，或`MM_HIMETRIC`，则转换基于中物理英寸的像素数。 如果映射模式是其他非约束模式之一 (例如， `MM_TEXT`)，则转换基于在逻辑英寸像素数。  
  
##  <a name="dptolp"></a>CDC::DPtoLP  
 将设备单位转换为逻辑单元。  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。  
  
 `nCount`  
 数组中的点的数目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于简单的情况下，将从设备点的一个矩形转换为逻辑点。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 函数映射的每个点的坐标或维度的大小，从设备坐标系统到 GDI 的逻辑坐标系统。 转换取决于当前的映射模式和来源和设备的窗口和视区的范围的设置。  
  
##  <a name="draw3drect"></a>CDC::Draw3dRect  
 调用此成员函数以绘制三维矩形。  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指定的边框 （以逻辑单位）。 你可以将传递到指针[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 *clrTopLeft*  
 指定三维矩形的顶部和左侧边的颜色。  
  
 `clrBottomRight`  
 指定的底部颜色和左右两边的三维矩形。  
  
 *x*  
 指定的三维矩形的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定的三维矩形的左上角中的逻辑 y 坐标。  
  
 cx  
 指定三维矩形的宽度。  
  
 cy  
 指定三维矩形的高度。  
  
### <a name="remarks"></a>备注  
 将使用指定的颜色顶部和左侧边缘绘制矩形*clrTopLeft*和的底部和中指定的颜色的右侧`clrBottomRight`。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>CDC::DrawDragRect  
 调用此成员函数重复重绘拖动矩形。  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，它指定的矩形的逻辑坐标 — 在此情况下，重新绘制的矩形的结束位置。  
  
 `size`  
 指定外部边框到左上角的矩形的内部边框 （即，边框的粗细） 偏移的量从左上角。  
  
 `lpRectLast`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，它指定的矩形的位置的逻辑坐标 — 在此情况下，重新绘制的矩形的原始位置。  
  
 *sizeLast*  
 指定的外部边框重绘的原始矩形的内部边框 （即，边框的粗细） 的左上角向左上角的偏移。  
  
 `pBrush`  
 指向画笔对象的指针。 设置为**NULL**若要使用的默认半色调画笔。  
  
 *pBrushLast*  
 指向使用的最后一个画笔对象的指针。 设置为**NULL**若要使用的默认半色调画笔。  
  
### <a name="remarks"></a>备注  
 若要为提供直观反馈示例鼠标位置，请调用其循环。 当调用`DrawDragRect`，以前的矩形将被删除，绘制一个新。 例如，为用户在屏幕上，拖动矩形`DrawDragRect`将会删除原始矩形并且重绘其新位置中的新建一个。 默认情况下，`DrawDragRect`以消除闪烁并创建平稳移动矩形的外观，通过半色调画笔绘制矩形。  
  
 首次调用`DrawDragRect`、`lpRectLast`参数应为**NULL**。  
  
##  <a name="drawedge"></a>CDC::DrawEdge  
 调用此成员函数要绘制的指定的类型和样式的矩形的边缘。  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向的指针**RECT**包含矩形的逻辑坐标的结构。  
  
 *nEdge*  
 指定要绘制的内部和外部边缘的类型。 此参数必须是一个内部边框标志和一个外部边框标志的组合。 请参阅[DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关参数的类型的表。  
  
 `nFlags`  
 指定要绘制的边框类型的标记。 请参阅`DrawEdge`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关参数的值的表。 为对角线行、 **BF_RECT**标志指定受矩形参数向量的终结点。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
##  <a name="drawescape"></a>CDC::DrawEscape  
 绘制不通过图形设备接口 (GDI) 直接可用视频显示功能的访问。  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>参数  
 `nEscape`  
 指定要执行的转义函数。  
  
 `nInputSize`  
 指定指向的数据的字节数`lpszInputData`参数。  
  
 `lpszInputData`  
 指向以输入所需的指定转义的结构。  
  
### <a name="return-value"></a>返回值  
 指定的函数的结果。 大于零，如果成功，除**QUERYESCSUPPORT**绘制的转义，实现仅; 或为零的检查不实现转义; 或小于零如果检测到错误发生。  
  
### <a name="remarks"></a>备注  
 在应用程序调用`DrawEscape`，由标识数据`nInputSize`和`lpszInputData`直接传递到指定的显示驱动程序。  
  
##  <a name="drawfocusrect"></a>CDC::DrawFocusRect  
 中用于指示矩形具有焦点的样式绘制的矩形。  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，它指定要绘制的矩形的逻辑坐标。  
  
### <a name="remarks"></a>备注  
 由于这是布尔 XOR 函数，与同一矩形第二次调用此函数从显示中删除矩形。 此函数所绘制的矩形无法滚动。 若要滚动包含此函数所绘制的矩形区域，先调用`DrawFocusRect`若要从显示中删除该矩形，区域中，然后向下滚动，然后调用`DrawFocusRect`再次以在新的位置绘制矩形。  
  
> [!CAUTION]
> `DrawFocusRect`只适用于`MM_TEXT`模式。 在其他模式下，此函数不正确，绘制聚焦框，但它不返回错误值。  
  
##  <a name="drawframecontrol"></a>CDC::DrawFrameControl  
 调用此成员函数要绘制的指定的类型和样式的框架控件。  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向的指针**RECT**包含矩形的逻辑坐标的结构。  
  
 `nType`  
 指定要绘制的帧控件的类型。 请参阅*uType*中的参数[DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关此参数的可能值的列表。  
  
 `nState`  
 指定框架控件的初始状态。 可以是一个或多个值所述的*uState*中的参数`DrawFrameControl`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 使用`nState`值**DFCS_ADJUSTRECT**调整要排除的推送按钮的周围边缘的边框。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 在某些情况下，`nState`取决于`nType`参数。 以下列表显示四个之间的关系`nType`值和`nState`:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE**三态按钮  
  
    - **DFCS_BUTTONCHECK**复选框  
  
    - **DFCS_BUTTONPUSH**下压按钮  
  
    - **DFCS_BUTTONRADIO**单选按钮  
  
    - **DFCS_BUTTONRADIOIMAGE**单选按钮图像 （非方形需要映像）  
  
    - **DFCS_BUTTONRADIOMASK**单选按钮的掩码 （非方形需要掩码）  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE**关闭按钮  
  
    - **DFCS_CAPTIONHELP**帮助按钮  
  
    - **DFCS_CAPTIONMAX**最大化按钮  
  
    - **DFCS_CAPTIONMIN**最小化按钮  
  
    - **DFCS_CAPTIONRESTORE**还原按钮  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW**子菜单箭头  
  
    - **DFCS_MENUBULLET**项目符号  
  
    - **DFCS_MENUCHECK**复选标记  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX**组合框滚动条  
  
    - **DFCS_SCROLLDOWN**向下滚动条箭头  
  
    - **DFCS_SCROLLLEFT**左的滚动条箭头  
  
    - **DFCS_SCROLLRIGHT**滚动条的向右箭头  
  
    - **DFCS_SCROLLSIZEGRIP**窗口右下角的大小调整手柄  
  
    - **DFCS_SCROLLUP**向上滚动条箭头  
  
### <a name="example"></a>示例  
 此代码在你的窗口右下角中绘制大小控制手柄。 它适合于`OnPaint`的对话框中，也不能不具有任何样式通常不包含可能会为其提供大小控制手柄的其他控件 （如状态栏中） 的处理程序。  
  
 [!code-cpp[NVC_MFCDocView # 34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>CDC::DrawIcon  
 在当前所表示的设备上绘制图标`CDC`对象。  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定图标的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定图标的左上角中的逻辑 y 坐标。  
  
 `hIcon`  
 标识要绘制的图标的句柄。  
  
 `point`  
 指定逻辑 x 坐标和 y 坐标的图标的左上角。 你可以将传递[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果成功，则完成此函数则不为否则为 0。  
  
### <a name="remarks"></a>备注  
 该函数将在指定的位置的位置的图标的左上角*x*和*y*。 位置受到设备上下文的当前映射模式。  
  
 图标资源必须先前已加载使用函数`CWinApp::LoadIcon`， `CWinApp::LoadStandardIcon`，或`CWinApp::LoadOEMIcon`。 `MM_TEXT`必须使用此函数之前选择的映射模式。  
  
### <a name="example"></a>示例  
  请参阅示例[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。  
  
##  <a name="drawstate"></a>CDC::DrawState  
 调用此成员函数以显示图像并应用视觉效果以指示的状态，例如已禁用或默认状态。  
  
> [!NOTE]
>  所有`nFlag`状态除外**DSS_NORMAL**，图像转换为单色之前应用的视觉效果。  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>参数  
 `pt`  
 指定的映像的位置。  
  
 `size`  
 指定映像的大小。  
  
 `hBitmap`  
 指向位图的句柄。  
  
 `nFlags`  
 指定的图像类型和状态的标志。 请参阅[DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]可能`nFlags`类型和状态。  
  
 `hBrush`  
 画笔句柄。  
  
 `pBitmap`  
 指向 CBitmap 对象的指针。  
  
 `pBrush`  
 指向 CBrush 对象的指针。  
  
 `hIcon`  
 图标句柄。  
  
 `lpszText`  
 指向文本的指针。  
  
 *bPrefixText*  
 可能包含快捷键助记键的文本。 `lData`参数指定的字符串的地址和`nTextLen`参数指定的长度。 如果`nTextLen`为 0，则假定该字符串为以 null 结尾。  
  
 `nTextLen`  
 指向的文本字符串的长度`lpszText`。 如果`nTextLen`为 0，则假定该字符串为以 null 结尾。  
  
 *lpDrawProc*  
 指向用于呈现图像的回调函数的指针。 此参数是必需的当在中输入图像`nFlags`是**DST_COMPLEX**。 它是可选的可以是**NULL**映像类型是否为**DST_TEXT**。 对于所有其他映像类型，则忽略此参数。 回调函数的详细信息，请参阅[DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497)函数中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `lData`  
 指定映像的信息。 此参数的含义取决于图像类型。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
##  <a name="drawtext"></a>CDC::DrawText  
 调用此成员函数可设置在给定矩形中的文本格式。 若要指定其他的格式设置选项，请使用[CDC::DrawTextEx](#drawtextex)。  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向要绘制的字符串。 如果`nCount`为-1，字符串必须是以 null 结尾。  
  
 `nCount`  
 在字符串中指定字符的数。 如果`nCount`为-1，然后`lpszString`假定要指向以 null 结尾的字符串的长指针和`DrawText`自动计算的字符数。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含在其中的文本是要设置格式的矩形 （以逻辑坐标表示）。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定的字符。  
  
 `nFormat`  
 指定的设置文本格式的方法。 它可以是针对所述的值的任意组合`uFormat`中的参数[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 （组合使用按位 OR 运算符）︰  
  
> [!NOTE]
>  某些`uFormat`标志组合可能会导致要修改所传递的字符串。 使用**DT_MODIFYSTRING**使用**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能会导致字符串被修改，导致中的断言`CString`重写。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`不能与使用`DT_TABSTOP`值。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功的文本的高度。  
  
### <a name="remarks"></a>备注  
 它设置文本的格式由选项卡站点扩展到适当的空格，对齐到左、 右、 文本或给定矩形的中心，并将文本分解为适合给定矩形的行。 指定的格式设置类型`nFormat`。  
  
 此成员函数使用的设备上下文的选定的字体、 文本颜色和背景色来绘制文本。 除非`DT_NOCLIP`使用格式，`DrawText`剪裁文本，以便文本不出现的给定矩形外部。 具有多个行，除非所有格式设置假定`DT_SINGLELINE`给定格式。  
  
 如果选定的字体的指定矩形太大`DrawText`成员函数不会尝试替换较小的字体。  
  
 如果`DT_CALCRECT`指定标志，指定的矩形`lpRect`将更新以反映的宽度和高度需要绘制文本。  
  
 如果**TA_UPDATECP**已设置文本对齐方式标记 (请参阅[CDC::SetTextAlign](#settextalign))，`DrawText`将显示从开始在当前的位置，而不在给定矩形的左侧的文本。 `DrawText`不会换行文本时**TA_UPDATECP**已设置标志 (即，`DT_WORDBREAK`标志将产生任何影响)。  
  
 可以设置文本颜色[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="drawtextex"></a>CDC::DrawTextEx  
 设置给定矩形内的文本的格式。  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向要绘制的字符串。 如果`nCount`为-1，字符串必须是终止 null。  
  
 `nCount`  
 在字符串中指定字符的数。 如果`nCount`为-1，然后`lpszString`假定要指向以 null 结尾的字符串的长指针和`DrawText`自动计算的字符数。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象，其中包含在其中的文本是要设置格式的矩形 （以逻辑坐标表示）。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)对象，其中包含要绘制的指定的字符。  
  
 `nFormat`  
 指定的设置文本格式的方法。 它可以是针对所述的值的任意组合`uFormat`中的参数[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 (使用按位组合`OR`运算符):  
  
> [!NOTE]
>  某些`uFormat`标志组合可能会导致要修改所传递的字符串。 使用**DT_MODIFYSTRING**使用**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能会导致字符串被修改，导致中的断言`CString`重写。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`不能与使用`DT_TABSTOP`值。  
  
 `lpDTParams`  
 指向[DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500)结构，它指定其他格式设置选项。 此参数可以为**NULL**。  
  
### <a name="remarks"></a>备注  
 它设置文本的格式由选项卡站点扩展到适当的空格，对齐到左、 右、 文本或给定矩形的中心，并将文本分解为适合给定矩形的行。 指定的格式设置类型`nFormat`和`lpDTParams`。 有关详细信息，请参阅[CDC::DrawText](#drawtext)和[DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 可以设置文本颜色[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="ellipse"></a>CDC::Ellipse  
 绘制椭圆形。  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定的椭圆的边框的左上角中的逻辑 x 坐标。  
  
 `y1`  
 指定的椭圆的边框的左上角中的逻辑 y 坐标。  
  
 `x2`  
 指定的椭圆的边界矩形右下角中的逻辑 x 坐标。  
  
 `y2`  
 指定的椭圆的边界矩形右下角中的逻辑 y 坐标。  
  
 `lpRect`  
 指定的椭圆的边框。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 椭圆的中心是由指定的边界矩形的中心`x1`， `y1`， `x2`，和`y2`，或`lpRect`。 使用的当前钢笔绘制椭圆和并用当前画笔填充其内部。  
  
 此函数所绘制图最多扩展，但不包括右侧和底部坐标。 这意味着图的高度是`y2`  -  `y1`图形的宽度为`x2`  -  `x1`。  
  
 如果边界矩形的高度或宽度为 0，绘制没有椭圆。  
  
##  <a name="enddoc"></a>CDC::EndDoc  
 结束调用启动的打印作业[StartDoc](#startdoc)成员函数。  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>返回值  
 大于或等于 0，如果该函数成功或如果发生错误的负值。  
  
### <a name="remarks"></a>备注  
 此成员函数将替换**ENDDOC**打印机转义，并应在完成成功的打印作业之后立即调用。  
  
 如果应用程序会遭遇打印错误或已取消的打印操作，它必须不尝试通过使用终止操作`EndDoc`或[AbortDoc](#abortdoc)。 GDI 自动终止操作，然后再返回的错误值。  
  
 此函数不应在图元文件内使用。  
  
### <a name="example"></a>示例  
  请参阅示例[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpage"></a>CDC::EndPage  
 通知设备应用程序已完成写入页。  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>返回值  
 大于或等于 0，如果该函数成功或如果发生错误的负值。  
  
### <a name="remarks"></a>备注  
 此成员函数通常用于定向设备驱动程序以向前移动到新页。  
  
 此成员函数将替换**NEWFRAME**打印机转义。 与不同**NEWFRAME**，始终在打印页之后调用此函数。  
  
### <a name="example"></a>示例  
  请参阅示例[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpath"></a>CDC::EndPath  
 关闭路径括号并选择到设备上下文中定义的括号的路径。  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="example"></a>示例  
  请参阅示例[cdc:: beginpath](#beginpath)。  
  
##  <a name="enumobjects"></a>Cdc:: enumobjects  
 枚举钢笔和画笔设备上下文中可用。  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>参数  
 *nObjectType*  
 指定的对象类型。 它可以具有值**OBJ_BRUSH**或**OBJ_PEN**。  
  
 `lpfn`  
 是应用程序提供的回调函数的过程实例地址。 请参阅下面的"备注"部分。  
  
 `lpData`  
 指向应用程序提供数据。 数据被传递给回调函数以及对象信息。  
  
### <a name="return-value"></a>返回值  
 指定返回的最后一个值[回调函数](../../mfc/reference/callback-function-for-cdc-enumobjects.md)。 其含义是用户定义的。  
  
### <a name="remarks"></a>备注  
 对于给定类型的每个对象，你传递的回调函数称为该对象的信息。 系统调用的回调函数，直到没有更多对象或回调函数返回 0。  
  
 请注意 Microsoft Visual c + + 的新增功能，可以使用普通函数，该函数传递给`EnumObjects`。 地址传递给`EnumObjects`是指向与导出的函数的指针**导出**和使用 Pascal 调用约定。 在保护模式应用程序，无需使用 Windows MakeProcInstance 函数中创建此函数，或在与 FreeProcInstance Windows 函数一起使用后释放函数。  
  
 您还不需要导出中的函数名称**导出**应用程序的模块定义文件中的语句。 你可以改用**导出**函数修饰符，如  
  
 **int 回调导出**AFunction **(LPSTR**， **LPSTR);**  
  
 若要使编译器发出导出的正确导出记录由不带别名名称。 这适用于大多数需求。 对于某些特殊的情况下，例如导出的函数的序号比较还是别名导出，你仍需要使用**导出**模块定义文件中的语句。  
  
 有关 Microsoft Foundation 编译程序，你通常将使用 /GA 和 /GEs 编译器选项。 /Gw 编译器选项不与 Microsoft 基础类使用。 (如果使用 Windows 函数**MakeProcInstance**，你将需要显式强制转换返回的函数指针从**FARPROC**到需要此 API 中的类型。)回调注册接口现在是类型安全的 （您必须在函数指针指向正确的一种特定的回调的函数中传递的）。  
  
 另请注意所有回调函数必须都捕获返回到 Windows，因为不能跨回调边界引发异常之前的 Microsoft 基础异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>CDC::Escape  
 此成员函数是 Win32 编程几乎已过时。  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>参数  
 `nEscape`  
 指定要执行的转义函数。  
  
 有关转义函数的完整列表，请参阅[转义](http://msdn.microsoft.com/library/windows/desktop/dd162701)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `nCount`  
 指定指向的数据的字节数`lpszInData`。  
  
 `lpszInData`  
 指向此转义所需的输入的数据结构。  
  
 `lpOutData`  
 指向以将此转义从接收输出的结构。 `lpOutData`参数是**NULL**如果不返回任何数据。  
  
 `nInputSize`  
 指定指向的数据的字节数`lpszInputData`参数。  
  
 `lpszInputData`  
 指向以输入所需的指定转义的结构。  
  
 `nOutputSize`  
 指定指向的数据的字节数`lpszOutputData`参数。  
  
 `lpszOutputData`  
 指向此转义从接收输出的结构。 此参数应为**NULL**如果不返回任何数据。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，但返回一个正值**QUERYESCSUPPORT**转义，只检查实现。 如果未实现转义，则返回零。 如果出错，则返回一个负值。 以下是常见的错误值︰  
  
- **SP_ERROR**常规错误。  
  
- **SP_OUTOFDISK**没有足够的磁盘空间是当前适用于后台处理，并在无更多空间将变为可用。  
  
- **SP_OUTOFMEMORY**没有足够的内存是适用于后台处理。  
  
- **SP_USERABORT**用户结束通过打印管理器作业。  
  
### <a name="remarks"></a>备注  
 原始打印机转义，仅**QUERYESCSUPPORT** Win32 应用程序支持。 所有其他打印机转义已过时，并仅为使用 16 位应用程序的兼容性支持。  
  
 有关 Win32 编程中，`CDC`现在提供取代其相应的打印机转义的六个成员函数︰  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [Cdc:: setabortproc](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 此外， [CDC::GetDeviceCaps](#getdevicecaps)支持取代其他打印机转义的 Win32 索引。 请参阅[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关详细信息。  
  
 此成员函数允许应用程序访问的特定设备不可直接通过 GDI 的功能。  
  
 如果你的应用程序使用预定义的转义值，则使用的第一个版本。 如果你的应用程序定义私有转义值，请使用第二个版本。 请参阅[ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关第二个版本的详细信息。  
  
##  <a name="excludecliprect"></a>CDC::ExcludeClipRect  
 创建新的剪辑区域组成减去指定的矩形的现有剪辑区域。  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定的矩形的左上角中的逻辑 x 坐标。  
  
 `y1`  
 指定的矩形的左上角中的逻辑 y 坐标。  
  
 `x2`  
 指定矩形右下角中的逻辑 x 坐标。  
  
 `y2`  
 指定矩形右下角中的逻辑 y 坐标。  
  
 `lpRect`  
 指定的矩形。 也可以是`CRect`对象。  
  
### <a name="return-value"></a>返回值  
 指定新的剪辑区域的类型。 它可以是任何以下值︰  
  
- **COMPLEXREGION**区域有重叠的边框。  
  
- **错误**已创建的任何区域。  
  
- **NULLREGION**区域为空。  
  
- **SIMPLEREGION**区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 所指定的数值的绝对值的矩形的宽度`x2`  -  `x1`，不能超过 32,767 单位。 此限制适用于以及矩形的高度。  
  
##  <a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn  
 通过从与关联的剪辑区域排除窗口中的更新的区域阻止窗口的无效区域内绘制`CDC`对象。  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>参数  
 `pWnd`  
 指向正在更新其窗口的窗口对象。  
  
### <a name="return-value"></a>返回值  
 排除区域的类型。 它可以是以下值之一︰  
  
- **COMPLEXREGION**区域有重叠的边框。  
  
- **错误**已创建的任何区域。  
  
- **NULLREGION**区域为空。  
  
- **SIMPLEREGION**区域具有不重叠的边框。  
  
##  <a name="extfloodfill"></a>CDC::ExtFloodFill  
 用当前画笔填充显示图面的区域。  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的填充的开始处的点的逻辑 x 坐标。  
  
 *y*  
 指定的填充的开始处的点的逻辑 y 坐标。  
  
 `crColor`  
 指定的边界或要填充的区域的颜色。 解释`crColor`取决于值`nFillType`。  
  
 `nFillType`  
 指定要执行填充的类型。 它必须是以下值之一︰  
  
- **FLOODFILLBORDER**填充区域的边界是通过指定的颜色`crColor`。 此样式等同于由在填充`FloodFill`。  
  
- **FLOODFILLSURFACE**由指定的颜色填充区域定义`crColor`。 填充由里向外，在中继续所有方向，只要遇到颜色。 此样式可用于使用彩色边界填充区域。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则非零如果在填充无法完成，如果给定的点的边界则否则为 0 指定颜色`crColor`(如果**FLOODFILLBORDER**请求)，如果给定的点没有指定的颜色`crColor`(如果**FLOODFILLSURFACE**请求)，或如果点剪切区域外部。  
  
### <a name="remarks"></a>备注  
 此成员函数提供了更大的灵活性比`FloodFill`因为你可以指定中的填充类型`nFillType`。  
  
 如果`nFillType`设置为**FLOODFILLBORDER**，假定区域完全受指定的颜色`crColor`。 函数以指定的点开始*x*和*y*并填充到颜色边界的所有方向。  
  
 如果`nFillType`设置为**FLOODFILLSURFACE**，该函数以指定的点开始*x*和*y* ，并在所有的说明，填充所有包含指定的颜色的相邻区域继续`crColor`。  
  
 仅内存设备上下文和支持光栅显示技术支持的设备`ExtFloodFill`。 有关详细信息，请参阅[GetDeviceCaps](#getdevicecaps)成员函数。  
  
##  <a name="exttextout"></a>CDC::ExtTextOut  
 调用此成员函数可以编写使用当前选定的字体的矩形区域中的一个字符串。  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 将指定字符串中指定的第一个字符的字符单元格中的逻辑 x 坐标。  
  
 *y*  
 将指定字符串中指定的第一个字符的字符单元格顶部中的逻辑 y 坐标。  
  
 `nOptions`  
 指定的矩形类型。 此参数可以为一个，同时，还是两者皆否的以下值︰  
  
- **ETO_CLIPPED**指定文本将被剪裁到矩形。  
  
- **ETO_OPAQUE**指定当前的背景色填充的矩形。 (你可以设置和查询与当前的背景色[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成员函数。)  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构，它确定矩形的尺寸。 此参数可以为**NULL**。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 `lpszString`  
 指向要绘制的指定的字符字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。  
  
 `lpDxWidths`  
 指向的值，用于指示来源的相邻字符单元格之间的距离的数组时。 例如， `lpDxWidths`[*我*] 逻辑单元将分隔字符单元格中的来源*我*和字符单元格中*我*+ 1。 如果`lpDxWidths`是**NULL**，`ExtTextOut`使用字符之间的默认间距。  
  
 `str`  
 A`CString`对象，其中包含要绘制的指定的字符。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 矩形区域可以是不透明的 （用当前的背景色填充），并且它可以是剪辑区域。  
  
 如果`nOptions`为 0 和`lpRect`是**NULL**，函数将文本写入到的设备上下文，而无需使用矩形区域。 默认情况下，函数不使用或更新当前位置。 如果应用程序需要更新当前位置，当它调用`ExtTextOut`，应用程序可以调用`CDC`成员函数[SetTextAlign](#settextalign)与`nFlags`设置为**TA_UPDATECP**。 当设置此标志时，Windows 将忽略*x*和*y*对后续调用`ExtTextOut`并改为使用当前的位置。 当应用程序使用**TA_UPDATECP**更新当前位置，`ExtTextOut`到之前的文本行的末尾或指定指向该数组的最后一个元素的位置设置当前位置`lpDxWidths`，两者中较大。  
  
##  <a name="fillpath"></a>CDC::FillPath  
 关闭当前路径中的任何开放图形，并使用当前画笔和多边形填充模式填充的路径的内部。  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 填充其内部后，将从设备上下文中丢弃路径。  
  
##  <a name="fillrect"></a>CDC::FillRect  
 调用此成员函数以填充给定的矩形使用指定的画笔。  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构，它包含要填充的矩形的逻辑坐标。 你还可以传递[CRect](../../atl-mfc-shared/reference/crect-class.md)为此参数的对象。  
  
 `pBrush`  
 标识要填充的矩形的画笔。  
  
### <a name="remarks"></a>备注  
 函数填充完成矩形，包括左端和顶端边框，但它并未填满的右侧和底部边界。  
  
 画笔需要为创建使用[CBrush](../../mfc/reference/cbrush-class.md)成员函数[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)， [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)，和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)，或通过检索`GetStockObject`Windows 函数。  
  
 当填充指定的矩形，`FillRect`不包括矩形的右下方。 GDI 达，填充一个矩形，但不包括右侧列和底部行，而不考虑当前的映射模式。 `FillRect`比较的值**顶部**，**底部**，**左**，和**右**指定矩形的成员。 如果**底部**小于或等于**顶部**，或者如果**右**小于或等于**左**，不绘制矩形。  
  
 `FillRect`类似于[CDC::FillSolidRect](#fillsolidrect); 但是，`FillRect`采用画笔，因此可以用于用纯色、 抖的色、 阴影的画笔或图案填充的矩形。 `FillSolidRect`使用仅纯色 (由**COLORREF**参数)。 `FillRect`通常低于`FillSolidRect`。  
  
##  <a name="fillrgn"></a>CDC::FillRgn  
 填充由指定的区域`pRgn`与由指定画笔`pBrush`。  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>参数  
 `pRgn`  
 指向要填充的区域的指针。 逻辑单元中指定了给定区域的坐标。  
  
 `pBrush`  
 标识要用于填充区域的画笔。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 也必须使用创建画笔`CBrush`成员函数`CreateHatchBrush`， `CreatePatternBrush`， `CreateSolidBrush`，或通过检索**GetStockObject**。  
  
### <a name="example"></a>示例  
  请参阅示例[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。  
  
##  <a name="fillsolidrect"></a>CDC::FillSolidRect  
 调用此成员函数以使用指定的纯色填充给定的矩形。  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指定的边框 （以逻辑单位）。 你可以将传递到指针[RECT](../../mfc/reference/rect-structure1.md)数据结构或`CRect`为此参数的对象。  
  
 `clr`指定要用于填充矩形的颜色。  
  
 *x*  
 指定的矩形的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定目标矩形的左上角中的逻辑 y 坐标。  
  
 `cx`  
 指定的矩形的宽度。  
  
 `cy`  
 指定的矩形的高度。  
  
### <a name="remarks"></a>备注  
 `FillSolidRect`非常类似于[CDC::FillRect](#fillrect); 但是，`FillSolidRect`使用仅纯色 (由**COLORREF**参数)，而`FillRect`采用画笔，因此可以用于用纯色、 抖的色、 阴影的画笔或图案填充的矩形。 `FillSolidRect`通常的速度快于`FillRect`。  
  
> [!NOTE]
>  当调用`FillSolidRect`，以前使用设置背景色[SetBkColor](#setbkcolor)，设置为指示的颜色`clr`。  
  
##  <a name="flattenpath"></a>CDC::FlattenPath  
 转换到当前的设备上下文中，选择的路径中的任何曲线并将每个曲线转换成的行序列。  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
##  <a name="floodfill"></a>CDC::FloodFill  
 用当前画笔填充显示图面的区域。  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的填充的开始处的点的逻辑 x 坐标。  
  
 *y*  
 指定的填充的开始处的点的逻辑 y 坐标。  
  
 `crColor`  
 指定边界的颜色。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则非零否则给定的点具有指定的边界颜色时无法完成在填充，返回 0 `crColor`，或者点剪切区域外部。  
  
### <a name="remarks"></a>备注  
 若要为绑定指定由假定区域`crColor`。 `FloodFill`函数以指定的点开始*x*和*y*和在到颜色边界的所有方向上继续。  
  
 仅内存设备上下文和支持光栅显示技术支持的设备`FloodFill`成员函数。 璝惠**RC_BITBLT**功能，请参阅`GetDeviceCaps`成员函数。  
  
 `ExtFloodFill`函数提供了类似的功能，但更大的灵活性。  
  
##  <a name="framerect"></a>CDC::FrameRect  
 绘制由指定的矩形周围的边框`lpRect`。  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)包含矩形的左上角和右下角的逻辑坐标的对象。 你还可以传递`CRect`为此参数的对象。  
  
 `pBrush`  
 标识要用于组帧矩形的画笔。  
  
### <a name="remarks"></a>备注  
 该函数使用给定的画笔来绘制边框。 宽度和高度边框始终是 1 个逻辑单位。  
  
 如果矩形的**底部**坐标小于或等于**顶部**，或者如果**右**小于或等于**左**，不绘制矩形。  
  
 通过绘制的边框`FrameRect`处于同一位置绘制边框**矩形**使用相同的坐标的成员函数 (如果**矩形**使用钢笔即宽 1 个逻辑单位)。 矩形的内部不由填写`FrameRect`。  
  
##  <a name="framergn"></a>CDC::FrameRgn  
 指定的区域周围绘制边框`pRgn`使用指定的画笔`pBrush`。  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>参数  
 `pRgn`  
 指向`CRgn`对象，它标识要括在边框中的区域。 逻辑单元中指定了给定区域的坐标。  
  
 `pBrush`  
 指向`CBrush`对象，它标识要用于绘制边框的画笔。  
  
 `nWidth`  
 以设备为单位的垂直画笔笔划中指定边框的宽度。  
  
 `nHeight`  
 以设备为单位的水平画笔笔划中指定的边框的高度。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="example"></a>示例  
  请参阅示例[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)。  
  
##  <a name="fromhandle"></a>CDC::FromHandle  
 返回一个指向`CDC`对象提供的设备上下文句柄时。  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>参数  
 `hDC`  
 包含 Windows 设备上下文的句柄。  
  
### <a name="return-value"></a>返回值  
 指针可能是临时，并且不应超出立即使用存储。  
  
### <a name="remarks"></a>备注  
 如果 `CDC` 对象未附加到该句柄，则会创建并附加一个临时 `CDC` 对象。  
  
### <a name="example"></a>示例  
  请参阅示例[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="getarcdirection"></a>CDC::GetArcDirection  
 返回设备上下文的当前弧线方向。  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果成功，则指定当前弧线方向。 以下是有效的返回值︰  
  
- **AD_COUNTERCLOCKWISE**弧线和逆时针旋转绘制的矩形。  
  
- **AD_CLOCKWISE**弧线和沿顺时针方向绘制的矩形。  
  
 如果发生错误，则返回值为零。  
  
### <a name="remarks"></a>备注  
 弧线和矩形函数使用弧线方向。  
  
##  <a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter  
 检索当前的纵横比筛选器的设置。  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>返回值  
 A`CSize`对象，它表示由当前的纵横比为筛选器纵横比。  
  
### <a name="remarks"></a>备注  
 纵横比，则由设备的像素宽度和高度形成的比率。 有关设备的纵横比的信息用于创建、 选择和显示的字体。 Windows 提供一个特殊的筛选器，纵横比筛选器，以选择用于特定的纵横比从所有可用的字体的字体。 筛选器使用指定的纵横比`SetMapperFlags`成员函数。  
  
##  <a name="getbkcolor"></a>CDC::GetBkColor  
 返回当前的背景色。  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>返回值  
 RGB 颜色值。  
  
### <a name="remarks"></a>备注  
 如果后台模式下是**不透明**，系统使用的背景色填充样式的行中的空白、 阴影的画笔中行和中字符单元格的背景之间的间隙。 转换颜色和单色设备上下文之间的位图时，系统还会使用的背景色。  
  
##  <a name="getbkmode"></a>CDC::GetBkMode  
 返回背景模式。  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>返回值  
 当前的后台模式下，可以是**不透明**或**透明**。  
  
### <a name="remarks"></a>备注  
 后台模式下定义系统是否在绘制文本、 阴影的画笔或不是一条实线任何笔样式之前删除现有的绘图图面上的背景色。  
  
##  <a name="getboundsrect"></a>CDC::GetBoundsRect  
 返回指定的设备上下文的当前累积绑定矩形。  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>参数  
 `lpRectBounds`  
 指向一个缓冲区，将收到的当前边框。 矩形将以逻辑坐标表示返回。  
  
 `flags`  
 指定是否要清除它返回之后的边框。 此参数应为零，或将设置为以下值︰  
  
- **DCB_RESET**强制它返回之后要清除的边框。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则指定的边框的当前状态。 它可以是以下值的组合︰  
  
- **DCB_ACCUMULATE**边界矩形累积发生。  
  
- **DCB_RESET**边框为空。  
  
- **DCB_SET**边框不为空。  
  
- **DCB_ENABLE**边界累积亮起。  
  
- **DCB_DISABLE**边界累积处于关闭状态。  
  
##  <a name="getbrushorg"></a>CDC::GetBrushOrg  
 检索当前选择的设备上下文的画笔的原点 （以设备为单位）。  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>返回值  
 当前的来源为 （以设备为单位） 的画笔[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。  
  
### <a name="remarks"></a>备注  
 初始画笔原点位于 (0，0) 的工作区。 返回的值相对于在桌面窗口源设备单位指定此点。  
  
##  <a name="getcharacterplacement"></a>CDC::GetCharacterPlacement  
 检索各种类型的字符字符串的信息。  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpString`  
 指向要处理的字符字符串的指针。  
  
 `nCount`  
 指定的字符串的长度。 有关 ANSI 版本中，它是字节计数和 Unicode 函数，它是字数统计。 有关详细信息，请参阅[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)。  
  
 `nMaxExtent`  
 到其处理字符串中指定的最大范围 （以逻辑单位）。 将忽略字符，如果处理，将超过此范围。 任何所需的排序或标志符号数组的计算结果仅适用于包含的字符。 仅当 GCP_MAXEXTENT 值指定在使用此参数`dwFlags`参数。 函数处理的输入的字符串，每个字符和其范围被添加到输出，范围内和其他数组仅当总的范围不超过最大值。 一旦达到限制时，将停止处理。  
  
 lpResults  
 指向[GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx)接收该函数的结果的结构。  
  
 `dwFlags`  
 指定如何处理成所需的数组的字符串。 此参数可以为一个或多个值中列出`dwFlags`部分[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)主题。  
  
 `str`  
 指向的指针[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象传递给过程。  
  
### <a name="return-value"></a>返回值  
 如果函数成功，返回值将是字符串的的宽度和高度的逻辑单元中。  
  
 如果函数失败，则返回值为零。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getcharabcwidths"></a>CDC::GetCharABCWidths  
 从当前 TrueType 字体中检索指定范围中的连续字符的宽度。  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>参数  
 `nFirstChar`  
 从当前字体为其返回字符宽度的字符范围中指定的第一个字符。  
  
 `nLastChar`  
 从当前字体为其返回字符宽度的字符范围中指定的最后一个字符。  
  
 `lpabc`  
 指向数组的[ABC](../../mfc/reference/abc-structure.md)在函数返回时接收字符宽度的结构。 此数组必须包含至少作为许多**ABC**作为指定的范围中有字符结构`nFirstChar`和`nLastChar`参数。  
  
 *lpABCF*  
 点到应用程序提供与非数组的缓冲区[ABCFLOAT](../../mfc/reference/abcfloat-structure.md)结构，以在函数返回时接收字符宽度。 此函数返回宽度位于 IEEE 浮点格式。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 逻辑单元将返回宽度。 此函数成功仅使用 TrueType 字体。  
  
 在选定的特定点大小后，TrueType 光栅器提供了"ABC"字符间距。 "A"间距是放置标志符号之前添加到当前位置的距离。 "B"间距是黑色部件的标志符号的宽度。 "C"间距将添加到当前位置，以应对标志符号右侧的空白区域。 高级宽度的总给定由 A + B + c。  
  
 当`GetCharABCWidths`成员函数将检索负"A"或"C"宽度的字符，该字符包括空白部分或延伸量。  
  
 要转换为字体设计单位 ABC 宽度，应用程序应创建一种字体的高度 (根据中的指定**lfHeight**的成员[LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037)结构) 中存储的值等于**ntmSizeEM**的成员[NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741)结构。 (值**ntmSizeEM**成员可通过调用检索[EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) Windows 函数。)  
  
 默认字符 ABC 宽度用于当前选定字体的范围外的字符。  
  
 若要检索的非 TrueType 字体中的字符的宽度，应用程序应使用[GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows 函数。  
  
##  <a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI  
 检索的宽度，以在指定范围从当前 TrueType 字体中的连续的标志符号索引的逻辑单元。  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>参数  
 `giFirst`  
 从当前字体的连续的标志符号索引的组中指定的第一个标志符号索引。 此参数才会使用`pgi`参数是**NULL**。  
  
 `cgi`  
 指定标志符号索引的数。  
  
 `pgi`  
 指向包含标志符号索引数组的指针。 如果值为**NULL**、`giFirst`改为使用参数。 `cgi`参数此数组中指定的标志符号索引数。  
  
 `lpabc`  
 指向数组的指针[ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454)接收字符宽度的结构。 此数组必须包含至少作为许多**ABC**作为有指定的标志符号索引结构`cgi`参数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getcharwidth"></a>CDC::GetCharWidth  
 从当前的字体，检索的一组连续的字符中的单个字符宽度使用`m_hAttribDC`，输入的设备上下文。  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>参数  
 `nFirstChar`  
 指定一组连续的当前字体中字符的第一个字符。  
  
 `nLastChar`  
 指定一组连续的当前字体中的字符中的最后一个字符。  
  
 `lpBuffer`  
 指向一个缓冲区，将在当前的字体中收到的一组连续的字符的宽度值。  
  
 *lpFloatBuffer*  
 指向一个缓冲区来接收字符宽度。 在 32 位 IEEE 浮点格式是返回的宽度。 （宽度测量沿基一行字符。）  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 例如，如果`nFirstChar`标识字母 a 和`nLastChar`标识的所有小写字符的字母 z，此函数会检索。  
  
 该函数将值存储在通过指向的缓冲区`lpBuffer`。 此缓冲区必须足够大以保存所有宽度。 也就是说，必须有至少 26 条目中给出的示例。  
  
 如果特定字体中不存在连续的字符组中的字符，它将分配默认字符的宽度值。  
  
##  <a name="getcharwidthi"></a>CDC::GetCharWidthI  
 检索的宽度，以逻辑坐标，从当前的字体在指定范围中的连续的标志符号索引。  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>参数  
 `giFirst`  
 从当前字体的连续的标志符号索引的组中指定的第一个标志符号索引。 此参数才会使用`pgi`参数是**NULL**。  
  
 `cgi`  
 指定标志符号索引的数。  
  
 `pgi`  
 指向包含标志符号索引数组的指针。 如果值为**NULL**、`giFirst`改为使用参数。 `cgi`参数此数组中指定的标志符号索引数。  
  
 `lpBuffer`  
 指向接收宽度的缓冲区的指针。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getclipbox"></a>CDC::GetClipBox  
 检索当前的剪辑边界周围 tightest 边界的矩形的尺寸。  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)是否要接收的矩形尺寸的对象。  
  
### <a name="return-value"></a>返回值  
 剪辑区域的类型。 它可以是任何以下值︰  
  
- **COMPLEXREGION**剪辑区域有重叠的边框。  
  
- **错误**设备上下文无效。  
  
- **NULLREGION**剪辑区域为空。  
  
- **SIMPLEREGION**剪辑区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 复制到通过指向的缓冲区的维度`lpRect`。  
  
##  <a name="getcoloradjustment"></a>CDC::GetColorAdjustment  
 检索设备上下文的颜色调整值。  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)数据结构，用于接收颜色调整值。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
##  <a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap  
 将指针返回到当前所选`CBitmap`对象。  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CBitmap`对象，如果成功，否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 此成员函数可能会返回临时对象。  
  
##  <a name="getcurrentbrush"></a>CDC::GetCurrentBrush  
 将指针返回到当前所选`CBrush`对象。  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CBrush`对象，如果成功，否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 此成员函数可能会返回临时对象。  
  
##  <a name="getcurrentfont"></a>CDC::GetCurrentFont  
 将指针返回到当前所选`CFont`对象。  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CFont`对象，如果成功，否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 此成员函数可能会返回临时对象。  
  
##  <a name="getcurrentpalette"></a>CDC::GetCurrentPalette  
 将指针返回到当前所选`CPalette`对象。  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CPalette`对象，如果成功，否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 此成员函数可能会返回临时对象。  
  
##  <a name="getcurrentpen"></a>CDC::GetCurrentPen  
 将指针返回到当前所选`CPen`对象。  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CPen`对象，如果成功，否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 此成员函数可能会返回临时对象。  
  
##  <a name="getcurrentposition"></a>CDC::GetCurrentPosition  
 检索当前的位置 （以逻辑坐标表示）。  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>返回值  
 作为当前位置`CPoint`对象。  
  
### <a name="remarks"></a>备注  
 可以用来设置当前位置`MoveTo`成员函数。  
  
##  <a name="getdcbrushcolor"></a>CDC::GetDCBrushColor  
 检索当前画笔的颜色。  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果函数成功，则返回值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)当前画笔的颜色的值。  
  
 如果函数失败，返回值是**CLR_INVALID**。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getdcpencolor"></a>CDC::GetDCPenColor  
 检索当前的钢笔颜色。  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果函数成功，则返回值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)当前的钢笔颜色的值。  
  
 如果函数失败，返回值是**CLR_INVALID**。  
  
### <a name="remarks"></a>备注  
 此成员函数使用 Win32 函数[GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getdevicecaps"></a>CDC::GetDeviceCaps  
 检索各种各样的显示设备的特定于设备的信息。  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>参数  
 `nIndex`  
 指定要返回的信息的类型。 请参阅[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关值的列表。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，请求的功能的值。  
  
### <a name="example"></a>示例  
  请参阅示例[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)。  
  
##  <a name="getfontdata"></a>CDC::GetFontData  
 从可缩放的字体文件检索字体指标信息。  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>参数  
 `dwTable`  
 指定要返回的度量值表的名称。 此参数可以为其中一个度量值表中发布的 Microsoft Corporation 的 TrueType 字体文件规范所述。 如果此参数为 0，字体文件开头检索的信息。  
  
 `dwOffset`  
 指定从其开始检索信息的表的开头的偏移量。 如果此参数为 0，则将检索信息由指定的表开头`dwTable`参数。 如果此值为大于或等于的表，大小`GetFontData`返回 0。  
  
 `lpData`  
 指向一个缓冲区，将收到的字体信息。 如果此值为**NULL**，该函数将返回中指定的字体数据所需的缓冲区的大小`dwTable`参数。  
  
 `cbData`  
 指定的长度以字节为单位，要检索的信息。 如果此参数为 0，`GetFontData`返回中指定的数据的大小`dwTable`参数。  
  
### <a name="return-value"></a>返回值  
 指定指向的缓冲区中返回的字节数`lpData`如果该函数成功; 否则为-1。  
  
### <a name="remarks"></a>备注  
 通过指定偏移量到字体文件和要返回的信息的长度标识要检索的信息。  
  
 有时，应用程序可以使用`GetFontData`成员函数将与文档一起保存 TrueType 字体。 为此，应用程序确定是否字体可嵌入，，然后检索整个字体文件中，指定 0 表示`dwTable`， `dwOffset`，和`cbData`参数。  
  
 应用程序可以确定是否可以通过检查嵌入字体**otmfsType**的成员[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)结构。 如果位 1 **otmfsType**设置，嵌入不允许的字体。 如果清除位 1，则可以嵌入字体。 如果设置位 2，嵌入为只读。  
  
 如果应用程序尝试使用此函数可检索有关非 TrueType 字体，`GetFontData`成员函数将返回-1。  
  
##  <a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo  
 返回有关指定的显示上下文的当前选定字体的信息。  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>返回值  
 返回值确定当前选定字体的特征。 有关可能的值的完整列表，请参阅[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getglyphoutline"></a>CDC::GetGlyphOutline  
 检索的大纲曲线或当前的字体中的大纲字符的位图。  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>参数  
 `nChar`  
 指定为其信息是要返回的字符。  
  
 `nFormat`  
 指定在其中的功能是返回的信息的格式。 它可以是以下值之一，或 0:  
  
|值|含义|  
|-----------|-------------|  
|**GGO_BITMAP**|返回的标志符号位图。 当函数返回时，通过指向的缓冲区`lpBuffer`包含其行在字边界启动一个 1 位每个像素的位图。|  
|**GGO_NATIVE**|返回在光栅化程序的本机格式，使用设备单元中的曲线数据点。 指定此值，当中指定的任何转换`lpmat2`将被忽略。|  
  
 时的值`nFormat`为 0，则该函数会填写[GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955)结构，但未返回字形轮廓的数据。  
  
 *lpgm*  
 指向**GLYPHMETRICS**结构，它描述在字符单元格中的标志符号的位置。  
  
 `cbBuffer`  
 指定该函数将大纲字符的信息复制到其中的缓冲区的大小。 如果此值为 0 和`nFormat`参数可以是**GGO_BITMAP**或**GGO_NATIVE**值，该函数将返回所需的缓冲区大小。  
  
 `lpBuffer`  
 指向函数将大纲字符的信息复制到其中的缓冲区。 如果`nFormat`指定**GGO_NATIVE**形式复制值，信息**TTPOLYGONHEADER**和**TTPOLYCURVE**结构。 如果此值为**NULL**和`nFormat`是**GGO_BITMAP**或**GGO_NATIVE**值，该函数将返回所需的缓冲区大小。  
  
 `lpmat2`  
 指向[MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048)结构，其中包含的字符的转换矩阵。 此参数不能为**NULL**，即使当**GGO_NATIVE**为指定值`nFormat`。  
  
### <a name="return-value"></a>返回值  
 大小，以字节为单位，如果检索信息所需的缓冲区`cbBuffer`为 0 或`lpBuffer`是**NULL**。 否则，为正值，如果该函数成功，否则为-1 时出错。  
  
### <a name="remarks"></a>备注  
 应用程序可以旋转位图格式检索通过指定指向的结构中的 2-2 转换矩阵的字符数`lpmat2`。  
  
 字形轮廓返回为一系列的轮廓。 每个分布定义的[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)结构跟尽可能多**TTPOLYCURVE**结构需要对其进行描述。 作为返回的所有点[POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806)结构和表示绝对位置，不是相对的移动。 起始点所提供的**pfxStart**的成员[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)结构是开始轮廓线的轮廓的点。 [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157)遵循的结构很折线记录或样条记录。 折线记录是一系列点;点之间绘制的直线描述轮廓的字符。 样条记录表示二次曲线由 TrueType （即，二次 b 样条）。  
  
##  <a name="getgraphicsmode"></a>CDC::GetGraphicsMode  
 检索指定的设备上下文的当前图形模式。  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果成功返回当前图形模式。 此方法可以返回的值的列表，请参阅[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
 失败，则返回 0。  
  
 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 此方法会包装 Windows GDI 函数[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
##  <a name="gethalftonebrush"></a>CDC::GetHalftoneBrush  
 调用此成员函数可检索半色调画笔。  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>返回值  
 指向的指针`CBrush`对象成功; 否则为如果**NULL**。  
  
### <a name="remarks"></a>备注  
 半色调画笔显示或者若要创建为抖色的样式的前景色和背景颜色的像素。 下面是一个示例创建的半色调画笔为抖色样式。  
  
 ![抖动的钢笔笔画详细](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>CDC::GetKerningPairs  
 检索对指定的设备上下文中当前选定的字体的字距调整的字符。  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>参数  
 `nPairs`  
 指定的数[KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024)指向结构`lpkrnpair`。 该函数将不会复制超过指定值的更多字距调整对`nPairs`。  
  
 `lpkrnpair`  
 指向数组的**KERNINGPAIR**接收字距调整的结构对在函数返回时。 此数组必须包含至少为许多结构所指定`nPairs`。 如果此参数为**NULL**，该函数返回的字距调整字体对总数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，请指定的字距调整对检索数或对在字体的字距调整的总次数。 如果函数失败或有没有字距调整对字体，则返回零。  
  
##  <a name="getlayout"></a>CDC::GetLayout  
 调用此成员函数可确定文本和图形设备上下文，如打印机或图元文件的布局。  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果成功，布局会标记为当前的设备上下文。 否则为**GDI_ERROR**。 有关扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。 布局标志的列表，请参阅[CDC::SetLayout](#setlayout)。  
  
### <a name="remarks"></a>备注  
 默认的布局是从左到右。  
  
##  <a name="getmapmode"></a>CDC::GetMapMode  
 检索当前的映射模式。  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>返回值  
 映射模式中。  
  
### <a name="remarks"></a>备注  
 映射模式的说明，请参阅`SetMapMode`成员函数。  
  
> [!NOTE]
>  如果调用[SetLayout](#setlayout)更改为从右向左的布局的 DC **SetLayout**会自动更改到的映射模式`MM_ISOTROPIC`。 因此，对任何后续调用`GetMapMode`将返回`MM_ISOTROPIC`。  
  
##  <a name="getmiterlimit"></a>CDC::GetMiterLimit  
 返回设备上下文的斜接限制。  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 在绘制几何线条具有斜接联接时，则使用斜接限制。  
  
##  <a name="getnearestcolor"></a>CDC::GetNearestColor  
 返回与指定的逻辑颜色最匹配的纯色。  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>参数  
 `crColor`  
 指定要匹配的颜色。  
  
### <a name="return-value"></a>返回值  
 RGB （红色、 绿色和蓝色） 颜色值，该值定义实线颜色接近`crColor`设备可以表示的值。  
  
### <a name="remarks"></a>备注  
 给定的设备必须能够表示此颜色。  
  
##  <a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics  
 检索 TrueType 字体的度量值信息。  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpotm`  
 指向数组的[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)结构。 如果此参数为**NULL**，该函数将返回所需的检索到的度量值数据的缓冲区的大小。  
  
 `cbData`  
 指定的大小，以字节为单位信息返回到的缓冲区。  
  
 `lpotm`  
 指向**OUTLINETEXTMETRIC**结构。 如果此参数为**NULL**，该函数将返回检索度量值信息所需的缓冲区的大小。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)结构包含 TrueType 格式中，使用提供的字体度量值信息的大多数包括[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)结构。 最后四个成员**OUTLINETEXTMETRIC**结构是指向字符串的指针。 应用程序应为这些字符串除了其他成员所需的空间分配空间。 由于没有的字符串的大小没有系统施加限制，分配内存的最简单方法是通过指定检索所需的大小**NULL**为`lpotm`中首次调用`GetOutlineTextMetrics`函数。  
  
##  <a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth  
 使用输出设备上下文， `m_hDC`，并从当前字体检索一组连续的字符中的单个字符的宽度。  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>参数  
 `nFirstChar`  
 指定一组连续的当前字体中字符的第一个字符。  
  
 `nLastChar`  
 指定一组连续的当前字体中的字符中的最后一个字符。  
  
 `lpBuffer`  
 指向一个缓冲区，将在当前的字体中收到的一组连续的字符的宽度值。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 例如，如果`nFirstChar`标识字母 a 和`nLastChar`标识的所有小写字符的字母 z，此函数会检索。  
  
 该函数将值存储在通过指向的缓冲区`lpBuffer`。 此缓冲区必须足够大以保存所有的宽度。也就是说，必须有至少 26 条目中给出的示例。  
  
 如果特定字体中不存在连续的字符组中的字符，它将分配默认字符的宽度值。  
  
##  <a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent  
 调用此成员函数来计算的宽度和高度的字符字符串使用[m_hDC](#m_hdc)，输出设备上下文。  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向要测量的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。 如果`nCount`为-1，计算长度。  
  
 `nTabPositions`  
 指定的指向数组中的制表位位置数`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 指向包含逻辑单元的制表位职位的整数的数组。 必须按升序排列; 排序的制表位最小 x 值应为数组中的第一个项目。 不允许向后制表位。  
  
 `str`  
 A`CString`包含指定的字符要测量的对象。  
  
### <a name="return-value"></a>返回值  
 尺寸 （以逻辑单位） 中的字符串[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 如果该字符串包含一个或多个选项卡字符，将字符串的宽度取决于指定的制表位`lpnTabStopPositions`。 该函数使用当前选定的字体来计算字符串的维度。  
  
 为当前剪辑区域的宽度和高度由不偏移量`GetOutputTabbedTextExtent`函数。  
  
 由于某些设备不要将字符放在正则单元格数组中 （即，它们对大于字距调整字符） 的字符串中字符的范围的总和可能不等于字符串的范围。  
  
 如果`nTabPositions`为 0 和`lpnTabStopPositions`是**NULL**，选项卡扩展为八个平均字符宽度。 如果`nTabPositions`为 1，制表位将分隔到数组中的第一个值指定的距离`lpnTabStopPositions`点。 如果`lpnTabStopPositions`指向多个单个值，制表位设置为每个值在数组中，最多指定的数`nTabPositions`。  
  
##  <a name="getoutputtextextent"></a>CDC::GetOutputTextExtent  
 调用此成员函数以使用输出设备上下文， [m_hDC](#m_hdc)，和计算的宽度和高度的一行文本，使用当前的字体。  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向字符的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。 如果`nCount`为-1，计算长度。  
  
 `str`  
 A`CString`包含指定的字符要测量的对象。  
  
### <a name="return-value"></a>返回值  
 尺寸 （以逻辑单位） 的字符串中返回[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 宽度和高度由当前的剪辑区域不会影响`GetOutputTextExtent`。  
  
 由于某些设备不要将字符放在正则单元格数组中 （即，它们执行字距调整） 的字符串中字符的范围的总和可能不等于字符串的范围。  
  
##  <a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics  
 检索当前的字体使用的度量值`m_hDC`，输出设备上下文。  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量值的结构。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
##  <a name="getpath"></a>CDC::GetPath  
 检索定义的终结点的行和在被选入设备上下文的路径中找到的曲线的控点的坐标。  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)数据结构或`CPoint`位于其中的行终结点和曲线控制点的对象。  
  
 `lpTypes`  
 指向的顶点的类型的放置位置的字节数组。 值是以下之一︰  
  
- **PT_MOVETO**相应点中的指定`lpPoints`开始一个不连续的图形。  
  
- **PT_LINETO**上一个点和相应点中的指定`lpPoints`是一条线的终结点。  
  
- **PT_BEZIERTO**相应点中的指定`lpPoints`控制点或 Bzier 曲线的结束点。  
  
 **PT_BEZIERTO**始终出现在的三个组中的类型。 立即在这些符号前面的路径中的点定义 Bzier 曲线的起始点。 前两个**PT_BEZIERTO**了点，控点，并且第三个**PT_BEZIERTO**点是终结点 (如果硬编码)。  
  
     A **PT_LINETO**或**PT_BEZIERTO**可能与以下标志结合类型 (通过使用按位运算符`OR`) 以指示相应的点是在图中的最后一个点，应关闭图︰  
  
- **PT_CLOSEFIGURE**指定相应的行后自动关闭图或绘制曲线。 从行或曲线终结点到对应到最后一个点绘制一条线关闭图**PT_MOVETO**。  
  
 `nCount`  
 指定的总次数[点](../../mfc/reference/point-structure1.md)可能中放置的数据结构`lpPoints`数组。 此值必须为可能放置中的字节数相同`lpTypes`数组。  
  
### <a name="return-value"></a>返回值  
 如果`nCount`参数不为零，点枚举数。 如果`nCount`为 0，在路径中的点的总数 (和`GetPath`的缓冲区写入任何内容)。 如果`nCount`为非零且小于点的数量比在路径中，返回值为-1。  
  
### <a name="remarks"></a>备注  
 设备上下文必须包含已关闭的路径。 在逻辑坐标中返回的路径点。 因此点存储在设备坐标中的路径`GetPath`点从变为设备坐标逻辑坐标表示通过使用当前转换的反向属性。 `FlattenPath`成员函数可能调用之前`GetPath`，将在路径中的所有曲线转换为直线线段。  
  
### <a name="example"></a>示例  
  请参阅示例[cdc:: beginpath](#beginpath)。  
  
##  <a name="getpixel"></a>CDC::GetPixel  
 检索由指定的点处的像素的 RGB 颜色值*x*和*y*。  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定要检查的点的逻辑 x 坐标。  
  
 *y*  
 指定要检查的点的逻辑 y 坐标。  
  
 `point`  
 指定逻辑 x 坐标和 y 坐标的点必须检查。  
  
### <a name="return-value"></a>返回值  
 两个版本的函数，给定的点的颜色的 RGB 颜色值。 如果坐标不在的剪辑区域指定一个点，则为-1。  
  
### <a name="remarks"></a>备注  
 点必须在的剪辑区域中。 如果点不在的剪辑区域，该函数将不起作用，并返回-1。  
  
 并非所有设备都支持**GetPixel**函数。 有关详细信息，请参阅**RC_BITBLT**光栅功能下的[GetDeviceCaps](#getdevicecaps)成员函数。  
  
 **GetPixel**成员函数具有两个窗体。 第一个采用两个坐标值;第二个接受[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。  
  
##  <a name="getpolyfillmode"></a>CDC::GetPolyFillMode  
 检索当前的多边形填充模式。  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>返回值  
 当前的多边形填充模式中，**备用**或**绕**，如果函数运行成功。  
  
### <a name="remarks"></a>备注  
 请参阅`SetPolyFillMode`多边形填充模式的描述的成员函数。  
  
##  <a name="getrop2"></a>CDC::GetROP2  
 检索当前的绘制模式。  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>返回值  
 绘制模式。 绘图模式值列表，请参阅`SetROP2`成员函数。  
  
### <a name="remarks"></a>备注  
 绘图模式指定如何显示图面上已颜色组合的钢笔颜色和填充的对象的内部。  
  
##  <a name="getsafehdc"></a>CDC::GetSafeHdc  
 调用此成员函数可获取[m_hDC](#m_hdc)，输出设备上下文。  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>返回值  
 设备上下文的句柄。  
  
### <a name="remarks"></a>备注  
 此成员函数也适用于 null 指针。  
  
##  <a name="getstretchbltmode"></a>CDC::GetStretchBltMode  
 检索当前的位图拉伸模式。  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>返回值  
 返回值将指定的当前位图拉伸模式- **STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS** -如果该函数成功。  
  
### <a name="remarks"></a>备注  
 位图拉伸模式定义信息从拉伸或压缩位图的删除途径`StretchBlt`成员函数。  
  
 **STRETCH_ANDSCANS**和**STRETCH_ORSCANS**模式通常用于保留单色位图中的前景色像素。 **STRETCH_DELETESCANS**模式通常用于保留颜色位图中的颜色。  
  
##  <a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent  
 调用此成员函数来计算的宽度和高度的字符字符串使用[m_hAttribDC](#m_hattribdc)，特性设备上下文。  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向字符字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。 如果`nCount`为-1，计算长度。  
  
 `nTabPositions`  
 指定的指向数组中的制表位位置数`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 指向包含逻辑单元的制表位职位的整数的数组。 必须按升序排列; 排序的制表位最小 x 值应为数组中的第一个项目。 不允许向后制表位。  
  
 `str`  
 A`CString`对象，其中包含要绘制的指定的字符。  
  
### <a name="return-value"></a>返回值  
 尺寸 （以逻辑单位） 中的字符串[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 如果该字符串包含一个或多个选项卡字符，将字符串的宽度取决于指定的制表位`lpnTabStopPositions`。 该函数使用当前选定的字体来计算字符串的维度。  
  
 为当前剪辑区域的宽度和高度由不偏移量`GetTabbedTextExtent`函数。  
  
 由于某些设备不要将字符放在正则单元格数组中 （即，它们对大于字距调整字符） 的字符串中字符的范围的总和可能不等于字符串的范围。  
  
 如果`nTabPositions`为 0 和`lpnTabStopPositions`是**NULL**，选项卡扩展到八倍的平均字符宽度。 如果`nTabPositions`为 1，制表位将分隔到数组中的第一个值指定的距离`lpnTabStopPositions`点。 如果`lpnTabStopPositions`指向多个单个值，制表位设置为每个值在数组中，最多指定的数`nTabPositions`。  
  
##  <a name="gettextalign"></a>CDC::GetTextAlign  
 检索设备上下文的文本对齐方式标志的状态。  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>返回值  
 文本对齐方式标志的状态。 返回值是一个或多个以下值︰  
  
- **TA_BASELINE**指定对齐方式的 x 轴和边界矩形中所选字体的基线。  
  
- **TA_BOTTOM**指定 x 轴和底部的边框的对齐方式。  
  
- **TA_CENTER**指定对齐方式的 y 轴和边界的矩形的中心。  
  
- **TA_LEFT**指定 y 轴和边界的矩形的左侧对齐方式。  
  
- **TA_NOUPDATECP**指定当前的位置不会更新。  
  
- **TA_RIGHT**指定对齐方式的 y 轴和的边框的右侧。  
  
- **TA_TOP**指定 x 轴和边界的矩形的顶部对齐方式。  
  
- **TA_UPDATECP**指定更新当前位置。  
  
### <a name="remarks"></a>备注  
 文本对齐方式标志确定如何`TextOut`和`ExtTextOut`成员函数对齐文本与字符串的起始点的一个字符串。 文本对齐方式标志不一定是单一位标志，并且可能等于 0。 若要测试是否设置一个标志，应用程序应遵循以下步骤︰  
  
1.  适用于标志和其相关的标志，分组，如下所示的按位 OR 运算符︰  
  
    - **TA_LEFT**， **TA_CENTER**，和**TA_RIGHT**  
  
    - **TA_BASELINE**， **TA_BOTTOM**，和**TA_TOP**  
  
    - **TA_NOUPDATECP**和**TA_UPDATECP**  
  
2.  应用的按位-和结果和返回值的运算符`GetTextAlign`。  
  
3.  此结果和标志的相等性测试。  
  
##  <a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra  
 检索 intercharacter 间距量的当前设置。  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>返回值  
 Intercharacter 的间距大小。  
  
### <a name="remarks"></a>备注  
 GDI 将此间距添加到每个字符，包括分行符，当它的设备上下文中写入一行文本。  
  
 Intercharacter 间距量的默认值为 0。  
  
##  <a name="gettextcolor"></a>CDC::GetTextColor  
 检索当前的文本颜色。  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>返回值  
 当前以 RGB 颜色值的文本颜色。  
  
### <a name="remarks"></a>备注  
 文本颜色是使用 GDI 文本输出成员函数绘制的字符的前景色[TextOut](#textout)， [ExtTextOut](#exttextout)，和[TabbedTextOut](#tabbedtextout)。  
  
##  <a name="gettextextent"></a>CDC::GetTextExtent  
 调用此成员函数来计算的宽度和高度的当前字体用于确定维度的文本行。  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpszString`  
 指向字符的字符串。 你还可以传递[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。  
  
 `str`  
 A`CString`对象，其中包含指定的字符。  
  
### <a name="return-value"></a>返回值  
 尺寸 （以逻辑单位） 中的字符串[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 从检索的信息[m_hAttribDC](#m_hattribdc)，特性设备上下文。  
  
 默认情况下，`GetTextExtent`假定沿水平行中设置它为其检索维度的文本 （即，行距为 0）。 如果你创建指定非零行距字体，你必须转换显式要获取字符串的维度的文本的角度。  
  
 宽度和高度由当前的剪辑区域不会影响`GetTextExtent`。  
  
 由于某些设备不要将字符放在正则单元格数组中 （即，它们执行字距调整） 的字符串中字符的范围的总和可能不等于字符串的范围。  
  
##  <a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI  
 检索中将不超出指定的空间和为每个这些字符与文本范围填充数组的指定字符串的字符数。  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `pgiIn`  
 指向数组的范围为要检索的标志符号索引的指针。  
  
 `cgi`  
 指向数组中指定的标志符号数`pgiIn`。  
  
 `nMaxExtent`  
 指定的最大允许宽度中的带格式的字符串的逻辑单元。  
  
 `lpnFit`  
 指向接收的最大可容纳在指定的空间中的字符数的计数的整数的指针`nMaxExtent`。 当`lpnFit`是**NULL**，`nMaxExtent`将被忽略。  
  
 *alpDx*  
 指向接收部分标志符号扩展盘区的整数数组的指针。 数组中的每个元素提供逻辑单位，标志符号索引数组的开头和一个符合指定的空间中的标志符号之间的距离`nMaxExtent`。 尽管此数组应具有至少尽可能多的元素，作为指定的标志符号索引`cgi`，该函数填充仅对任意多个标志符号索引由指定的范围的数组`lpnFit`。 如果*lpnDx*是**NULL**，该函数不会计算部分字符串宽度。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)接收标志符号索引数组的维度中逻辑单元的结构。 此值不能**NULL**。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="gettextextentpointi"></a>CDC::GetTextExtentPointI  
 检索的宽度和高度指定的标志符号索引数组。  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `pgiIn`  
 指向数组的范围为要检索的标志符号索引的指针。  
  
 `cgi`  
 指向数组中指定的标志符号数`pgiIn`。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)接收标志符号索引数组的维度中逻辑单元的结构。 此值不能**NULL**。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此成员函数模拟函数的功能[GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="gettextface"></a>CDC::GetTextFace  
 调用此成员函数要复制到缓冲区的当前字体的字体名称。  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>参数  
 `nCount`  
 指定缓冲区的大小 （以字节为单位）。 如果超过此参数指定的字节数的字体名称，名称被截断。  
  
 *lpszFacename*  
 指向字体名称的缓冲区。  
  
 `rString`  
 对引用[CString](../../atl-mfc-shared/reference/cstringt-class.md)对象。  
  
### <a name="return-value"></a>返回值  
 将复制到缓冲区，不包括终止 null 字符的字节数。 如果发生错误，则为 0。  
  
### <a name="remarks"></a>备注  
 字体名称将复制作为以 null 结尾的字符串。  
  
##  <a name="gettextmetrics"></a>CDC::GetTextMetrics  
 检索使用属性的设备上下文的当前字体的度量值。  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量值的结构。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
##  <a name="getviewportext"></a>CDC::GetViewportExt  
 检索 x-和 y-区的设备上下文的视区。  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>返回值  
 X-和 y 的范围 （以设备为单位） 为`CSize`对象。  
  
##  <a name="getviewportorg"></a>CDC::GetViewportOrg  
 检索与设备上下文关联的视区原点 x 和 y 坐标。  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>返回值  
 （在设备坐标中） 作为的视区原点`CPoint`对象。  
  
##  <a name="getwindow"></a>CDC::GetWindow  
 返回与显示设备上下文关联的窗口。  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>返回值  
 指向`CWnd`对象成功; 否则为如果**NULL**。  
  
### <a name="remarks"></a>备注  
 这是一个高级的函数。 例如，此成员函数可能返回视图窗口打印时或在打印预览中。 它始终返回与输出关联的窗口。 使用给定的 DC 的输出函数绘制到此窗口。  
  
##  <a name="getwindowext"></a>CDC::GetWindowExt  
 检索 x-和 y-区的设备上下文与关联的窗口。  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>返回值  
 X-和 y-中的范围 （逻辑单位） 为`CSize`对象。  
  
##  <a name="getwindoworg"></a>CDC::GetWindowOrg  
 检索的源设备上下文与关联的窗口的 x 和 y 坐标。  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>返回值  
 （以逻辑坐标表示） 窗口中，根据原点`CPoint`对象。  
  
##  <a name="getworldtransform"></a>CDC::GetWorldTransform  
 检索页面空间转换到的当前世界空间。  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>参数  
 `rXform`  
 引用[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)接收页面空间转换到的当前世界空间的结构。  
  
### <a name="return-value"></a>返回值  
 如果成功返回非零值。  
  
 失败，则返回 0。  
  
 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 此方法会包装 Windows GDI 函数[GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953)。  
  
##  <a name="gradientfill"></a>CDC::GradientFill  
 调用此成员函数以矩形和三角形结构填充到另一侧顺利淡出的颜色。  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>参数  
 *pVertices*  
 指向数组的指针[TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142)结构，因为每个定义三角形的顶点。  
  
 *nVertices*  
 顶点的数目。  
  
 `pMesh`  
 数组[GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959)三角形模式或数组中的结构[GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958)矩形模式中的结构。  
  
 *nMeshElements*  
 中的元素 （三角形或矩形） 数目`pMesh`。  
  
 `dwMode`  
 指定渐变填充模式。 有关可能的值的列表，请参阅[GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>返回值  
 **TRUE**如果成功，否则为**FALSE**。  
  
### <a name="remarks"></a>备注  
 有关详细信息，请参阅`GradientFill`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="graystring"></a>Cdc:: graystring  
 绘制灰显的内存位图中写入文本、 变暗位图，，然后将位图复制到显示的给定位置 （灰色） 文本。  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>参数  
 `pBrush`  
 标识要用于变暗 （灰） 的画笔。  
  
 `lpfnOutput`  
 指定将绘制的字符串的应用程序提供的回调函数的过程实例地址。 有关详细信息，请参阅 Windows 说明**OutputFunc** [回调函数](../../mfc/reference/callback-function-for-cdc-graystring.md)。 如果此参数为**NULL**，系统将使用 Windows`TextOut`函数要绘制的字符串，和`lpData`被假定为指向要输出的字符字符串的长指针。  
  
 `lpData`  
 指定要传递给输出函数的数据的较远指针。 如果`lpfnOutput`是**NULL**，`lpData`必须是指向要输出的字符串的长指针。  
  
 `nCount`  
 指定要输出字符的数。 如果此参数为 0，`GrayString`计算字符串的长度 (假定`lpData`是指向字符串的指针)。 如果`nCount`为-1 并且指向函数`lpfnOutput`返回 0 时，图像时显示，但未变暗。  
  
 *x*  
 指定包含字符串的矩形的起始位置的逻辑 x 坐标。  
  
 *y*  
 指定包含字符串的矩形的起始位置的逻辑 y 坐标。  
  
 `nWidth`  
 指定包含字符串的矩形的宽度 （以逻辑单位）。 如果`nWidth`为 0，`GrayString`计算的宽度的区域中，假定`lpData`是指向字符串的指针。  
  
 `nHeight`  
 指定包含字符串的矩形的高度 （以逻辑单位）。 如果`nHeight`为 0，`GrayString`计算区的高度假设`lpData`是指向字符串的指针。  
  
### <a name="return-value"></a>返回值  
 如果绘制出字符串，则为非 0 或者，如果任一 0`TextOut`函数或应用程序提供的输出函数返回 0，或如果没有内存不足，无法创建变暗的内存位图。  
  
### <a name="remarks"></a>备注  
 该函数的模糊的文本而不考虑所选的画笔和背景。 `GrayString`成员函数使用当前选定的字体。 `MM_TEXT`使用此函数之前，必须选择映射模式。  
  
 应用程序可以在支持纯灰颜色情况下调用的设备上绘制为灰色 （显示为灰色） 字符串`GrayString`成员函数。 系统颜色**COLOR_GRAYTEXT**为用于绘制无效的文本的实线灰色系统颜色。 应用程序可以调用**GetSysColor** Windows 函数可检索的颜色值**COLOR_GRAYTEXT**。 如果颜色是 0 （黑色） 以外，应用程序可以调用`SetTextColor`成员函数以设置为颜色值的文本颜色，然后直接绘制的字符串。 如果检索到的颜色为黑色，应用程序必须调用`GrayString`变暗 （灰色） 文本。  
  
 如果`lpfnOutput`是**NULL**，GDI 使用 Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133)函数，和`lpData`被假定为要输出的字符的较远指针。 如果要将输出的字符不能由处理`TextOut`成员函数 （例如，字符串将存储为位图），应用程序必须提供其自己的输出函数。  
  
 另请注意所有回调函数必须都捕获返回到 Windows，因为不能跨回调边界引发异常之前的 Microsoft 基础异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。  
  
 回调函数传递给`GrayString`必须使用`__stdcall`调用约定，并且必须使用导出`__declspec`。  
  
 框架在处于预览模式时，调用`GrayString`成员函数将转换为`TextOut`不调用调用和回调函数。  
  
##  <a name="himetrictodp"></a>CDC::HIMETRICtoDP  
 使用此函数在转换**HIMETRIC**从 OLE 为像素的大小。  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 如果设备上下文对象的映射模式是`MM_LOENGLISH`， `MM_HIENGLISH`，`MM_LOMETRIC`或`MM_HIMETRIC`，则转换基于中物理英寸的像素数。 如果映射模式是其他非约束模式之一 (例如， `MM_TEXT`)，则转换基于在逻辑英寸像素数。  
  
##  <a name="himetrictolp"></a>CDC::HIMETRICtoLP  
 调用此函数可将转换**HIMETRIC**给逻辑单元的单位。  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 使用此函数，当您获取**HIMETRIC**从 OLE 并且想要将它们转换为应用程序的自然映射模式的大小。  
  
 转换通过第一个转换来实现**HIMETRIC**到像素为单位，然后将这些单元转换为使用的设备上下文的当前映射单元的逻辑单元的单位。 请注意的设备的窗口和视区的范围将影响结果。  
  
##  <a name="intersectcliprect"></a>CDC::IntersectClipRect  
 通过为当前区域与由指定的矩形的交集创建新的剪辑区域`x1`， `y1`， `x2`，和`y2`。  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定的矩形的左上角中的逻辑 x 坐标。  
  
 `y1`  
 指定的矩形的左上角中的逻辑 y 坐标。  
  
 `x2`  
 指定矩形右下角中的逻辑 x 坐标。  
  
 `y2`  
 指定矩形右下角中的逻辑 y 坐标。  
  
 `lpRect`  
 指定的矩形。 你可以传递`CRect`对象或指向的指针`RECT`结构为此参数。  
  
### <a name="return-value"></a>返回值  
 新的剪辑区域的类型。 它可以是以下值之一︰  
  
- **COMPLEXREGION**新剪辑区域有重叠的边框。  
  
- **错误**设备上下文无效。  
  
- **NULLREGION**新剪辑区域为空。  
  
- **SIMPLEREGION**新剪辑区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 GDI 剪裁以适合新边界的所有后续输出。 宽度和高度不能超过 32,767。  
  
##  <a name="invertrect"></a>CDC::InvertRect  
 反转给定矩形的内容。  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向`RECT`包含矩形的逻辑坐标反转。 你还可以传递`CRect`为此参数的对象。  
  
### <a name="remarks"></a>备注  
 数据倒排是逻辑不操作和翻转的每个像素的位。 单色显示中，在该函数白色做白色像素黑色和黑色像素。 颜色显示，反转取决于如何显示生成的颜色。 调用`InvertRect`两次同一矩形将显示还原到其以前的颜色。  
  
 如果在该矩形为空，就不绘制任何内容。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>CDC::InvertRgn  
 反转中由指定的区域的颜色`pRgn`。  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>参数  
 `pRgn`  
 标识要反转的区域。 逻辑单元中指定了区域的坐标。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 单色显示中，在该函数白色做白色像素黑色和黑色像素。 颜色显示，反转取决于如何显示生成的颜色。  
  
##  <a name="isprinting"></a>CDC::IsPrinting  
 确定是否正在使用的设备上下文进行打印。  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>返回值  
 非零如果`CDC`对象是一台打印机 DC; 否则为 0。  
  
##  <a name="lineto"></a>CDC::LineTo  
 从当前位置到，但不是包括、 由指定的点绘制一条线*x*和*y* (或`point`)。  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定行的终结点的逻辑 x 坐标。  
  
 *y*  
 指定行的终结点的逻辑 y 坐标。  
  
 `point`  
 指定行的终结点。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该线绘制; 则为非 0否则为 0。  
  
### <a name="remarks"></a>备注  
 与所选的钢笔绘制线条。 当前的位置设置为*x*， *y*或`point`。  
  
### <a name="example"></a>示例  
  请参阅示例[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="lptodp"></a>CDC::LPtoDP  
 将设备单位转换为逻辑单元。  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向的点数组。 数组中的每个点都[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)对象。  
  
 `nCount`  
 数组中的点的数目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)结构或[CRect](../../atl-mfc-shared/reference/crect-class.md)对象。 此参数用于常见的情况下映射到设备单位矩形从逻辑。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)结构或[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。  
  
### <a name="remarks"></a>备注  
 函数映射的每个点的坐标或维度的大小，从 GDI 的逻辑坐标系统到设备坐标系统。 转换取决于当前的映射模式和来源的设置和设备的窗口和视区的区。  
  
 点 x 和 y 坐标是在-32768 到 32767 的范围中的 2 字节有符号的整数。 在映射模式会导致值大于这些限制的情况下，系统将值设置为-32,768 和 32,767，分别。  
  
##  <a name="lptohimetric"></a>CDC::LPtoHIMETRIC  
 调用此函数可将转换到逻辑单元**HIMETRIC**单位。  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpSize`  
 指向**大小**结构或`CSize`对象。  
  
### <a name="remarks"></a>备注  
 使用此函数，当你向**HIMETRIC**给 OLE，将从你的应用程序的自然映射模式转换的大小。 请注意的设备的窗口和视区的范围将影响结果。  
  
 转换完成通过第一个逻辑单元将转换使用的设备上下文的当前映射单元，然后将转换到这些设备像素为单位来**HIMETRIC**单位。  
  
##  <a name="m_hattribdc"></a>CDC::m_hAttribDC  
 此特性设备上下文`CDC`对象。  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>备注  
 默认情况下，此设备上下文是等于`m_hDC`。 一般情况下，`CDC`请求信息从设备上下文的 GDI 调用定向到`m_hAttribDC`。 请参阅[CDC](../../mfc/reference/cdc-class.md)类有关的详细信息使用这些两个设备上下文中的说明。  
  
##  <a name="m_hdc"></a>CDC::m_hDC  
 此输出设备上下文`CDC`对象。  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>备注  
 默认情况下，`m_hDC`等同于`m_hAttribDC`，其他设备上下文由包装`CDC`。 一般情况下， `CDC` GDI 创建输出的调用会转到`m_hDC`设备上下文。 可以初始化`m_hDC`和`m_hAttribDC`为指向不同的设备。 请参阅[CDC](../../mfc/reference/cdc-class.md)类有关的详细信息使用这些两个设备上下文中的说明。  
  
##  <a name="maskblt"></a>CDC::MaskBlt  
 将使用给定的掩码和光栅操作的源和目标位图颜色数据合并。  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定目标矩形的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定目标矩形的左上角中的逻辑 y 坐标。  
  
 `nWidth`  
 指定逻辑单位，目标矩形和源位图的宽度。  
  
 `nHeight`  
 指定逻辑单位，目标矩形和源位图的高度。  
  
 `pSrcDC`  
 标识设备上下文是要复制位图。 它必须为零*dwRop*参数指定不包含源的光栅操作。  
  
 `xSrc`  
 指定了源位图的左上角中的逻辑 x 坐标。  
  
 `ySrc`  
 指定了源位图的左上角中的逻辑 y 坐标。  
  
 `maskBitmap`  
 标识单色掩码位图与源设备上下文中的颜色位图结合使用。  
  
 `xMask`  
 指定由指定的掩码位图的水平像素偏移量`maskBitmap`参数。  
  
 `yMask`  
 指定由指定的掩码位图的像素垂直偏移量`maskBitmap`参数。  
  
 *dwRop*  
 指定前景色和背景三元光栅操作代码，该函数用于控制的源和目标数据的组合。 后台光栅操作代码存储在此值; 该值的高位字的高位字节前景光栅操作代码存储在此值; 该值的高位字的低位字节此值的低位字被忽略，并且应为零。 宏**MAKEROP4**创建此类组合的前景色和背景光栅操作代码。 请参阅前景色和背景此函数的上下文中讨论的备注的部分。 请参阅`BitBlt`有关的常见光栅操作代码的列表的成员函数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 值为 1 中指定的掩码`maskBitmap`指示指定前景光栅操作代码*dwRop*应该应用于该位置。 值为 0 掩码中指示指定后台光栅操作代码*dwRop*应该应用于该位置。 光栅操作需要一个源，如果掩码矩形必须包含源矩形。 如果不存在，则函数将会失败。 光栅操作不需要源，如果掩码矩形必须包含目标矩形。 如果不存在，则函数将会失败。  
  
 如果旋转或切变转换为有效源设备上下文调用此函数时，，出现错误。 但是，允许其他类型的转换。  
  
 如果源、 模式和目标位图的颜色格式不同，此函数将转换模式或源格式，或是两者，以匹配目标格式。 如果掩码位图不是一个单色位图，就会出错。 当记录增强型图元文件时，发生错误 （和该函数返回 0） 如果源设备上下文标识增强型图元文件设备上下文。 并非所有设备都支持`MaskBlt`。 应用程序应调用`GetDeviceCaps`确定设备是否支持此函数。 如果不提供任何掩码位图，则此函数的行为完全相同`BitBlt`，使用前景光栅操作代码。 像素中的偏移量掩码位图映射到的点 (0，0) 中的源设备上下文位图。 这可用于在其中掩码位图包含一组掩码; 的情况下应用程序可以轻松地将应用其中任何一个掩码平面闪任务通过调整像素偏移量和矩形大小发送到`MaskBlt`。  
  
##  <a name="modifyworldtransform"></a>CDC::ModifyWorldTransform  
 更改的世界转换的设备上下文，使用指定的模式。  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>参数  
 `rXform`  
 引用[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)用于修改给定的设备上下文的世界转换的结构。  
  
 `iMode`  
 指定如何转换数据修改的当前世界转换。 此参数可以采用的值的列表，请参阅[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
### <a name="return-value"></a>返回值  
 如果成功返回非零值。  
  
 失败，则返回 0。  
  
 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 此方法会包装 Windows GDI 函数[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
##  <a name="moveto"></a>CDC::MoveTo  
 将当前的位置移动到由指定的点*x*和*y* (或通过`point`)。  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定新位置中的逻辑 x 坐标。  
  
 *y*  
 指定新位置中的逻辑 y 坐标。  
  
 `point`  
 指定新位置。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 作为前一个位置 x 和 y 坐标`CPoint`对象。  
  
### <a name="example"></a>示例  
  请参阅示例[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="offsetcliprgn"></a>CDC::OffsetClipRgn  
 按指定的偏移量移动设备上下文的剪辑区域。  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定要向左移动或向右的逻辑单元数。  
  
 *y*  
 指定要向上或向下移动逻辑单元数。  
  
 `size`  
 指定的偏移量。  
  
### <a name="return-value"></a>返回值  
 新区域的类型。 它可以是以下值之一︰  
  
- **COMPLEXREGION**剪辑区域有重叠的边框。  
  
- **错误**设备上下文无效。  
  
- **NULLREGION**剪辑区域为空。  
  
- **SIMPLEREGION**剪辑区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 该函数将移动区域*x*沿 x 轴单位和*y*沿 y 轴的单元。  
  
##  <a name="offsetviewportorg"></a>CDC::OffsetViewportOrg  
 修改的坐标，相对于当前的视区原点坐标视区原点。  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>参数  
 `nWidth`  
 指定要将添加到当前原点的 x 坐标的设备单元数。  
  
 `nHeight`  
 指定要将添加到当前原点的 y 坐标的设备单元数。  
  
### <a name="return-value"></a>返回值  
 上一个视区原点 （以设备坐标表示） 为`CPoint`对象。  
  
##  <a name="offsetwindoworg"></a>CDC::OffsetWindowOrg  
 修改的相对于当前窗口原点坐标窗口原点的坐标。  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>参数  
 `nWidth`  
 指定要将添加到当前原点的 x 坐标逻辑单元数。  
  
 `nHeight`  
 指定要添加到当前原点的 y 坐标的逻辑单元数。  
  
### <a name="return-value"></a>返回值  
 以前窗口原点 （以逻辑坐标表示） 为`CPoint`对象。  
  
##  <a name="operator_hdc"></a>CDC::operator HDC  
 使用此运算符将检索的设备上下文句柄`CDC`对象。  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果成功，设备上下文对象; 的句柄否则为**NULL**。  
  
### <a name="remarks"></a>备注  
 句柄可用于直接调用 Windows Api。  
  
##  <a name="paintrgn"></a>CDC::PaintRgn  
 填充由指定的区域`pRgn`使用当前的画笔。  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>参数  
 `pRgn`  
 标识要填充的区域。 逻辑单元中指定了给定区域的坐标。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
##  <a name="patblt"></a>CDC::PatBlt  
 创建在设备上的位模式。  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定要接收模式的矩形的左上角中的逻辑 x 坐标。  
  
 *y*  
 指定要接收模式的矩形的左上角中的逻辑 y 坐标。  
  
 `nWidth`  
 指定要接收模式的矩形的宽度 （以逻辑单位）。  
  
 `nHeight`  
 指定要接收模式的矩形的高度 （以逻辑单位）。  
  
 *dwRop*  
 指定的光栅操作代码。 光栅操作代码 (ROPs) 定义 GDI 如何合并涉及当前画笔、 可能的源位图和目标位图的输出操作中的颜色。 此参数可以是以下值之一︰  
  
- **PATCOPY**副本模式与目标位图。  
  
- **PATINVERT**合并目标位图与模式使用布尔 XOR 运算符。  
  
- **DSTINVERT** -反转目标位图。  
  
- **BLACKNESS** -使所有输出变黑。  
  
- **WHITENESS** -使所有输出空白。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 模式是选择的画笔和已在设备上的模式的组合。 通过指定的光栅操作代码*dwRop*定义如何模式的组合在一起。 列出针对此函数的光栅操作是完整 256 的三元光栅操作代码; 的受限子网具体而言，不能使用引用源的光栅操作代码。  
  
 并非所有的设备上下文支持`PatBlt`函数。 若要确定是否支持设备上下文`PatBlt`，调用`GetDeviceCaps`成员函数时**RASTERCAPS**索引并检查返回值以查找**RC_BITBLT**标志。  
  
##  <a name="pie"></a>CDC::Pie  
 通过绘制椭圆弧行加入其 center 和两个终结点来绘制饼形 wedge。  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 x 坐标。  
  
 `y1`  
 指定 （在逻辑单位） 的边界矩形的左上角的 y 坐标。  
  
 `x2`  
 指定 （在逻辑单位） 的边界矩形右下角的 x 坐标。  
  
 `y2`  
 指定 （在逻辑单位） 的边界矩形右下角的 y 坐标。  
  
 *x3*  
 指定 （在逻辑单元） 弧线的起始点的 x 坐标。 此时没有要将其完全置于圆弧。  
  
 `y3`  
 指定 （在逻辑单元） 弧线的起始点的 y 坐标。 此时没有要将其完全置于圆弧。  
  
 `x4`  
 指定弧的终结点 （在逻辑单位） 的 x 坐标。 此时没有要将其完全置于圆弧。  
  
 `y4`  
 指定弧的终结点 （在逻辑单位） 的 y 坐标。 此时没有要将其完全置于圆弧。  
  
 `lpRect`  
 指定的绑定矩形。 你可以传递`CRect`对象或指向的指针`RECT`结构为此参数。  
  
 `ptStart`  
 指定弧线的起始点。 此时没有要将其完全置于圆弧。 你可以传递[点](../../mfc/reference/point-structure1.md)结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
 `ptEnd`  
 指定弧的终结点。 此时没有要将其完全置于圆弧。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 圆弧的中心是由指定的边界矩形的中心`x1`， `y1`， `x2`，和`y2`(或通过`lpRect`)。 通过指定的起始和结束弧的点*x3*， `y3`， `x4`，和`y4`(或通过`ptStart`和`ptEnd`)。  
  
 以逆时针方向移动所选笔绘制弧。 到弧线的中心，从每个终结点绘制两个其他线。 用当前画笔填充饼形区域。 如果*x3*等于`x4`和`y3`等于`y4`，结果是与从椭圆的中心点到单个行的椭圆 ( *x3*， `y3`) 或 ( `x4`， `y4`)。  
  
 此函数所绘制图最多扩展，但不包括右侧和底部坐标。 这意味着图的高度是`y2`  -  `y1`图形的宽度为`x2`  -  `x1`。 宽度和边界的矩形的高度必须大于 2 个单位和小于 32,767 单位。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>CDC::PlayMetaFile  
 上的设备上下文中播放指定的图元文件的内容。  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>参数  
 *hMF*  
 标识要播放的图元文件。  
  
 *hEnhMetaFile*  
 标识增强型图元文件。  
  
 `lpBounds`  
 指向`RECT`结构或`CRect`对象，其中包含用来显示该图片的边框的坐标。 逻辑单元中指定坐标。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 图元文件就可以播放任意次数。  
  
 第二个版本`PlayMetaFile`显示存储在给定的增强型格式图元文件中的图片。 在应用程序调用的第二个版本`PlayMetaFile`，Windows 图片框中使用增强型图元文件标头映射到指向矩形图`lpBounds`参数。 (此图中可能剪切或通过之前调用的输出设备中设置的世界变换旋转`PlayMetaFile`。)图中包括的矩形的边缘点。 可以通过在播放增强型图元文件之前，在输出设备中定义的剪辑区域剪切增强型图元文件图片。  
  
 如果增强型图元文件包含可选的调色板，应用程序可以通过调用第二个版本之前设置调色板输出设备上实现一致的颜色`PlayMetaFile`。 若要检索可选调色板，使用**GetEnhMetaFilePaletteEntries** Windows 函数。 通过调用第二个版本，可以在新创建增强型图元文件中嵌入增强型图元文件`PlayMetaFile`和的新播放到设备上下文的源增强型图元文件增强型图元文件。  
  
 此函数将保留输出设备上下文的状态。 此函数会删除任何对象创建，但不是在增强型图元文件中删除。 若要停止此功能，应用程序可以调用**CancelDC**从另一个线程来终止操作的 Windows 函数。 在这种情况下，该函数返回零。  
  
##  <a name="plgblt"></a>CDC::PlgBlt  
 执行颜色数据的位的位块传输的源设备上下文中指定的矩形从到在给定的设备上下文中指定的平行四边形。  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>参数  
 `lpPoint`  
 指向标识目标平行四边形的三个角的逻辑空间中的三个点的数组。 源矩形的左上角映射到此数组、 此数组中的第二个点的右上角和左下角到第三个点中的第一个点。 源矩形右下角映射到在平行四边形中隐式的第四个点。  
  
 `pSrcDC`  
 标识源设备上下文。  
  
 `xSrc`  
 指定逻辑单位，源矩形的左上角的 x 坐标。  
  
 `ySrc`  
 指定逻辑单位，源矩形的左上角的 y 坐标。  
  
 `nWidth`  
 指定逻辑单位，源矩形的宽度。  
  
 `nHeight`  
 指定逻辑单位，源矩形的高度。  
  
 `maskBitmap`  
 标识用于屏蔽源矩形的颜色可选单色位图。  
  
 `xMask`  
 指定的单色位图左上角的 x 坐标。  
  
 `yMask`  
 指定的单色位图左上角的 y 坐标。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 如果给定的位掩码句柄标识有效的单色位图，该函数将使用此位图需要掩码的位从源矩形的颜色数据。  
  
 平行四边形 (D) 的第四个顶点针对定义通过将前三个点 （A、 B 和 C） 向量，并计算 D = B + C-a。  
  
 如果存在位掩码，值为 1 掩码中指示源像素颜色应复制到目标。 值为 0 掩码中指示的目标像素颜色是无法更改。  
  
 如果掩码矩形小于源和目标矩形，该函数将复制的掩码模式。  
  
 缩放、 平移和反射转换可以用在源设备上下文;但是，旋转和切变转换不是。 如果掩码位图不是一个单色位图，就会出错。 目标设备上下文的拉伸模式用于确定如何拉伸或压缩像素，如果这是必需的。 当记录增强型图元文件时，如果源设备上下文标识增强型图元文件设备上下文，则会发生错误。  
  
 目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。 如果源转换包括旋转或切变，则返回错误。 如果目标和源矩形不具有相同的颜色格式，`PlgBlt`将转换源矩形以匹配目标矩形。 并非所有设备都支持`PlgBlt`。 有关详细信息，请参阅说明**RC_BITBLT**中的光栅功能`CDC::GetDeviceCaps`成员函数。  
  
 如果源和目标设备上下文表示不兼容的设备，`PlgBlt`返回错误。  
  
##  <a name="polybezier"></a>CDC::PolyBezier  
 绘制一个或多个 Bzier 样条。  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)包含终结点和控制点 spline(s) 的数据结构。  
  
 `nCount`  
 指定的数中的点`lpPoints`数组。 此值必须是一个三倍以上样条要绘制的数，由于每个 Bzier 样条需要两个控点和终结点，以及初始样条需要其他的起始点。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此函数使用的终结点和指定的控制点绘制三次方 Bzier 样条`lpPoints`参数。 第一个样条是绘制从第一个点到四个点为控制点使用第二个和第三个点。 序列中的每个后续样条需要完全三个点︰ 以前样条终结点用作起始点、 序列中的下两个点是控点和第三个是终结点。  
  
 当前的位置，既不使用也不由更新`PolyBezier`函数。 不填充图。 此函数通过使用当前的钢笔绘制线条。  
  
##  <a name="polybezierto"></a>CDC::PolyBezierTo  
 绘制一个或多个 Bzier 样条。  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)点包含的终结点和控件的数据结构。  
  
 `nCount`  
 指定的数中的点`lpPoints`数组。 此值必须要绘制的样条数的三次，因为每个 Bzier 样条需要两个控点和终结点。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此函数通过使用由指定的控件点绘制三次方 Bzier 样条`lpPoints`参数。 第一个样条是绘制从当前位置到第三个点为控制点使用前两个点。 每个后续样条，该函数需要完全三个点，并使用以前样条终结点的起始点作为下一步。 `PolyBezierTo`当前位置移到最后一个 Bzier 样条曲线的结束点。 不填充图。 此函数通过使用当前的钢笔绘制线条。  
  
### <a name="example"></a>示例  
  请参阅示例[cdc:: beginpath](#beginpath)。  
  
##  <a name="polydraw"></a>CDC::PolyDraw  
 绘制一套直线线段和 Bzier 样条。  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)包含每个终结点的数据结构行段和终结点和控制每个 Bzier 样条曲线的点。  
  
 `lpTypes`  
 指向数组，它指定每个中点的方式`lpPoints`使用数组。 值可以是以下项之一︰  
  
- **PT_MOVETO**指定此点启动不连续的图。 此时将成为新的当前位置。  
  
- **PT_LINETO**指定行是要从当前位置绘制到目前为止，随后将成为新的当前位置。  
  
- **PT_BEZIERTO**指定此点是控点或结束点的 Bzier 样条。  
  
 **PT_BEZIERTO**始终出现在的三个组中的类型。 当前的位置定义 Bzier 样条的起始点。 前两个**PT_BEZIERTO**了点，控点，并且第三个**PT_BEZIERTO**点是结束点。 结束点将成为新的当前位置。 如果不存在三个连续**PT_BEZIERTO**点、 错误结果。  
  
     A **PT_LINETO**或**PT_BEZIERTO**类型可以结合使用按位运算符以下常量或以指示相应的点是一个数字和图中的最后一个点已关闭︰  
  
- **PT_CLOSEFIGURE**图自动关闭后的指定**PT_LINETO**或**PT_BEZIERTO**键入完成此点。 到最新从此点绘制一条线**PT_MOVETO**或`MoveTo`点。  
  
     此标志结合**PT_LINETO**类型为行，或与**PT_BEZIERTO**的结束点的 Bzier 样条中，通过使用按位类型`OR`运算符。 当前的位置设置为的结束行的结束点。  
  
 `nCount`  
 指定的中点总数`lpPoints`，数组中的字节数相同`lpTypes`数组。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此函数可用于绘制代替对连续调用的非连续数字`CDC::MoveTo`， `CDC::LineTo`，和`CDC::PolyBezierTo`成员函数。 使用当前的钢笔绘制直线和曲线样条和未填充数字。 如果没有通过调用启动活动路径`CDC::BeginPath`成员函数，`PolyDraw`将添加到路径。 中包含的点`lpPoints`数组并在`lpTypes`指示每个点是否属于`CDC::MoveTo`、 `CDC::LineTo`，或**CDC::BezierTo**操作。 还有可能以关闭图形。 此函数将更新当前的位置。  
  
### <a name="example"></a>示例  
  请参阅示例[cdc:: beginpath](#beginpath)。  
  
##  <a name="polygon"></a>CDC::Polygon  
 绘制多边形包含两个或多个点 （顶点） 线路连接，使用当前的钢笔。  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组指定多边形的顶点的点。 数组中的每个点都**点**结构或`CPoint`对象。  
  
 `nCount`  
 指定数组中的顶点数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 系统多边形将自动关闭，如有必要，通过从最后一个顶点绘制线条，与第一个。  
  
 可以检索或设置通过使用当前的多边形填充模式`GetPolyFillMode`和`SetPolyFillMode`成员函数。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>CDC::Polyline  
 绘制直线线段连接由指定的点的一组`lpPoints`。  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的**点**结构或`CPoint`要连接的对象。  
  
 `nCount`  
 数组中指定的点的数量。 此值必须至少为 2。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 从通过使用当前的钢笔的后续点的第一个点绘制连线。 与不同`LineTo`成员函数，`Polyline`函数既不使用也不更新当前位置。  
  
 有关详细信息，请参阅[折线](http://msdn.microsoft.com/library/windows/desktop/dd162815)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="polylineto"></a>CDC::PolylineTo  
 绘制一个或多个直线。  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的[点](../../mfc/reference/point-structure1.md)包含行的顶点的数据结构。  
  
 `nCount`  
 数组中指定的点的数量。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 绘制一条线是从当前位置到由指定的第一个点`lpPoints`通过使用当前的钢笔的参数。 为每个其他行，则该函数绘制从以前的行的结束点到由指定的下一步点`lpPoints`。 `PolylineTo`将当前的位置移动到的最后一行的结束点。 如果此函数所绘制的直线线段构成闭合的图形，该图不填充。  
  
##  <a name="polypolygon"></a>CDC::PolyPolygon  
 创建两个或多个使用当前的多边形填充模式填充的多边形。  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向数组的**点**结构或`CPoint`定义的多边形的顶点的对象。  
  
 `lpPolyCounts`  
 指向整数的数组，其中每个中的多边形之一指定点的数目`lpPoints`数组。  
  
 `nCount`  
 中的条目数`lpPolyCounts`数组。 此数字指定多边形要绘制的数。 此值必须至少为 2。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 多边形可能是连续的或重叠。  
  
 每个对的调用中指定的多边形`PolyPolygon`函数必须关闭。 与多边形由不同**多边形**成员函数，创建的多边形`PolyPolygon`不会自动关闭。  
  
 该函数将创建两个或多个多边形。 若要创建单个多边形，应用程序应使用**多边形**成员函数。  
  
 可以检索或设置通过使用当前的多边形填充模式`GetPolyFillMode`和`SetPolyFillMode`成员函数。  
  
##  <a name="polypolyline"></a>CDC::PolyPolyline  
 绘制多个序列的连接的直线线段。  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>参数  
 `lpPoints`  
 指向包含折线的顶点的结构的数组。 折线的连续指定。  
  
 `lpPolyPoints`  
 指向数组的变量指定的中点数`lpPoints`相应多边形的数组。 每个条目必须大于或等于 2。  
  
 `nCount`  
 指定内计数的总数`lpPolyPoints`数组。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 通过使用当前的钢笔绘制的直线线段。 不填充格式由的段的图。 当前的位置不使用也不更新此函数。  
  
##  <a name="ptvisible"></a>CDC::PtVisible  
 确定给定的点是否在设备上下文的剪辑区域内。  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定点的逻辑 x 坐标。  
  
 *y*  
 指定点的逻辑 y 坐标。  
  
 `point`  
 指定要检查以逻辑坐标表示的点。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果指定的点内的剪辑区域; 则为非 0否则为 0。  
  
##  <a name="queryabort"></a>CDC::QueryAbort  
 调用安装中止函数[SetAbortProc](#setabortproc)成员用于打印的应用程序和查询是否应终止打印的功能。  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>返回值  
 如果应继续打印或如果没有中止过程，返回的值不为零。 如果应终止打印作业，则为 0。 Abort 函数提供返回值。  
  
##  <a name="realizepalette"></a>CDC::RealizePalette  
 将映射到系统调色板条目从当前逻辑调色板。  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>返回值  
 指示逻辑调色板中的项数了映射到系统调色板中的不同项。 这表示此函数将重新映射，以适应系统调色板中的更改，因为上次实现逻辑调色板的条目数。  
  
### <a name="remarks"></a>备注  
 逻辑调色板充当了缓冲区之间颜色密集型应用程序和系统，允许应用程序使用许多根据需要而不会影响其自己的颜色显示颜色或与其他 windows 显示的颜色。  
  
 当窗口具有输入的焦点并调用`RealizePalette`，Windows 可确保该窗口将显示所有请求的颜色，最多同时在屏幕上可用的最大数目。 Windows 还将显示在窗口的调色板中未找到通过将它们与可用颜色匹配的颜色。  
  
 此外，Windows 匹配请求的可用颜色到尽可能真实地调用函数的非活动窗口的颜色。 这将显著减少不必要的更改，在非活动窗口中显示的颜色。  
  
##  <a name="rectangle"></a>CDC::Rectangle  
 绘制矩形使用当前的钢笔。  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定 （在逻辑单位） 的矩形的左上角的 x 坐标。  
  
 `y1`  
 指定 （在逻辑单位） 的矩形的左上角的 y 坐标。  
  
 `x2`  
 指定 （在逻辑单位） 的矩形右下角的 x 坐标。  
  
 `y2`  
 指定 （在逻辑单位） 的矩形右下角的 y 坐标。  
  
 `lpRect`  
 逻辑单元中指定的矩形。 你可以传递`CRect`对象或指向的指针`RECT`结构为此参数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 使用当前画笔填充的矩形的内部。  
  
 矩形达，扩展，但不包括右侧和底部坐标。 这意味着矩形的高度是`y2`  -  `y1`和矩形的宽度是`x2`  -  `x1`。 宽度和矩形的高度必须大于 2 个单位和小于 32,767 单位。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>CDC::RectVisible  
 确定是否显示上下文的剪辑区域内位于给定任何的矩形部分。  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>参数  
 `lpRect`  
 指向`RECT`结构或`CRect`对象，其中包含指定的矩形的逻辑坐标。  
  
### <a name="return-value"></a>返回值  
 如果给定任何的矩形部分之内的剪辑区域; 则为非 0否则为 0。  
  
##  <a name="releaseattribdc"></a>CDC::ReleaseAttribDC  
 调用此成员函数可设置`m_hAttribDC`到**NULL**。  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>备注  
 这不会导致**分离**发生。 仅输出设备上下文附加到`CDC`对象，并且它仅可以分离。  
  
##  <a name="releaseoutputdc"></a>CDC::ReleaseOutputDC  
 调用此成员函数可设置`m_hDC`成员**NULL**。  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>备注  
 输出设备上下文附加到时，不能调用此成员函数`CDC`对象。 使用**分离**成员函数可分离输出设备上下文。  
  
##  <a name="resetdc"></a>CDC::ResetDC  
 调用此成员函数以更新由包装的设备上下文`CDC`对象。  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>参数  
 *lpDevMode*  
 指向 Windows`DEVMODE`结构。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 从指定在 Windows 中的信息更新的设备上下文`DEVMODE`结构。 此成员函数仅重置特性设备上下文。  
  
 应用程序通常会使用`ResetDC`成员函数时窗口处理`WM_DEVMODECHANGE`消息。 此成员函数还可用于打印文档时更改纸张方向或纸箱。  
  
 此成员函数不能用于更改驱动程序名称、 设备名称，或输出端口。 当用户更改端口连接或设备名称时，必须删除原始的设备上下文，并使用新的信息创建新的设备上下文。  
  
 在调用此成员函数之前，必须确保已选入设备上下文的所有对象 （而非常用对象） 具有出所都选。  
  
##  <a name="restoredc"></a>CDC::RestoreDC  
 还原到以前的状态由标识设备上下文`nSavedDC`。  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>参数  
 `nSavedDC`  
 指定要还原的设备上下文。 它可以是先前的返回值`SaveDC`函数调用。 如果`nSavedDC`为-1，最近保存还原设备上下文。  
  
### <a name="return-value"></a>返回值  
 如果已还原指定的上下文;，零否则为 0。  
  
### <a name="remarks"></a>备注  
 `RestoreDC`将设备上下文的弹出从创建到以前的调用堆栈的状态信息还原`SaveDC`成员函数。  
  
 堆栈可以包含多个设备上下文的状态信息。 如果通过指定上下文`nSavedDC`不在堆栈上，顶部`RestoreDC`删除指定的设备上下文之间的所有状态信息`nSavedDC`和堆栈的顶部。 已删除的信息将丢失。  
  
##  <a name="roundrect"></a>CDC::RoundRect  
 使用当前的钢笔的圆角绘制的矩形。  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>参数  
 `x1`  
 指定 （在逻辑单位） 的矩形的左上角的 x 坐标。  
  
 `y1`  
 指定 （在逻辑单位） 的矩形的左上角的 y 坐标。  
  
 `x2`  
 指定 （在逻辑单位） 的矩形右下角的 x 坐标。  
  
 `y2`  
 指定 （在逻辑单位） 的矩形右下角的 y 坐标。  
  
 *x3*  
 指定用于绘制圆的角 （以逻辑单位） 的椭圆的宽度。  
  
 `y3`  
 指定用于绘制圆的角 （以逻辑单位） 的椭圆的高度。  
  
 `lpRect`  
 逻辑单元中指定的绑定矩形。 你可以传递`CRect`对象或指向的指针`RECT`结构为此参数。  
  
 `point`  
 X 坐标`point`指定的宽度 （以逻辑单位） 绘制圆的角的椭圆。 Y 坐标`point`指定要绘制圆的角 （以逻辑单位） 的椭圆的高度。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 使用当前画笔填充的矩形的内部。  
  
 此函数绘制的图最多扩展，但不包括右侧和底部坐标。 这意味着图的高度是`y2`  -  `y1`图形的宽度为`x2`  -  `x1`。 高度和边界的矩形的宽度必须大于 2 个单位和小于 32,767 单位。  
  
### <a name="example"></a>示例  
 [!code-cpp[NVC_MFCDocView # 40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>CDC::SaveDC  
 将通过复制状态信息 （如剪辑区域、 所选的对象和映射模式） 的设备上下文的当前状态保存到由 Windows 维护上下文堆栈中。  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>返回值  
 一个整数，它标识的已保存的设备上下文。 如果发生错误，则为 0。 该返回值可以用于通过调用还原的设备上下文`RestoreDC`。  
  
### <a name="remarks"></a>备注  
 更高版本可以通过使用还原的已保存的设备上下文`RestoreDC`。  
  
 `SaveDC`可以是任意次数用于保存任意数量的设备上下文状态。  
  
##  <a name="scaleviewportext"></a>CDC::ScaleViewportExt  
 修改视区范围相对于当前值。  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>参数  
 `xNum`  
 指定用来乘当前 x 程度量。  
  
 `xDenom`  
 指定被除数的值相乘当前 x 范围内的结果量`xNum`参数。  
  
 `yNum`  
 指定用来乘当前 y 程度量。  
  
 `yDenom`  
 指定被除数的值相乘当前 y 范围内的结果量`yNum`参数。  
  
### <a name="return-value"></a>返回值  
 上一个视区范围 （以设备为单位） 为`CSize`对象。  
  
### <a name="remarks"></a>备注  
 公式编写，如下所示︰  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 当前范围内乘以给定分子，然后除以给定分母来计算新的视区范围。  
  
##  <a name="scalewindowext"></a>CDC::ScaleWindowExt  
 修改范围相对于当前值，该窗口。  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>参数  
 `xNum`  
 指定用来乘当前 x 程度量。  
  
 `xDenom`  
 指定被除数的值相乘当前 x 范围内的结果量`xNum`参数。  
  
 `yNum`  
 指定用来乘当前 y 程度量。  
  
 `yDenom`  
 指定被除数的值相乘当前 y 范围内的结果量`yNum`参数。  
  
### <a name="return-value"></a>返回值  
 上一个窗口中的范围 （逻辑单位） 为`CSize`对象。  
  
### <a name="remarks"></a>备注  
 公式编写，如下所示︰  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 当前范围内乘以给定分子，然后除以给定分母来计算新的窗口范围。  
  
##  <a name="scrolldc"></a>CDC::ScrollDC  
 水平和垂直滚动的矩形的位数。  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>参数  
 `dx`  
 指定水平滚动单元的数。  
  
 *dy*  
 指定垂直滚动单位的数。  
  
 `lpRectScroll`  
 指向`RECT`结构或`CRect`包含滚动矩形的坐标的对象。  
  
 `lpRectClip`  
 指向`RECT`结构或`CRect`对象，其中包含的剪辑矩形的坐标。 当此矩形小于一个指向的原始`lpRectScroll`，滚动仅发生在较小的矩形。  
  
 `pRgnUpdate`  
 标识由滚动过程发现的区域。 `ScrollDC`函数定义此区域; 它不一定是一个矩形。  
  
 `lpRectUpdate`  
 指向`RECT`结构或`CRect`接收限定滚动更新区域的矩形的坐标的对象。 这是需要重新绘制的最大矩形区域。 中的结构或对象在函数返回时的值是在客户端坐标中，而不考虑给定的设备上下文的映射模式。  
  
### <a name="return-value"></a>返回值  
 如果在执行滚动; 则为非 0否则为 0。  
  
### <a name="remarks"></a>备注  
 如果`lpRectUpdate`是**NULL**，Windows 不会计算更新矩形。 如果这两个`pRgnUpdate`和`lpRectUpdate`是**NULL**，Windows 不会计算更新区域。 如果`pRgnUpdate`不**NULL**，Windows 假定它包含滚动进程由发现的区域的有效指针 (由定义`ScrollDC`成员函数)。 在中返回的更新区域`lpRectUpdate`可以传递给`CWnd::InvalidateRgn`必要情况。  
  
 应用程序应使用`ScrollWindow`类的成员函数`CWnd`时需滚动窗口的整个客户端区域。 否则，它应使用`ScrollDC`。  
  
##  <a name="selectclippath"></a>CDC::SelectClipPath  
 选择作为设备上下文，使用指定的模式来组合与任何现有的剪辑区域的新区域的剪辑区域的当前路径。  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>参数  
 `nMode`  
 指定的方法使用的路径。 允许以下值︰  
  
- **RGN_AND**新的剪辑区域包括为当前剪辑区域与当前的路径 （重叠区域） 的交集。  
  
- **RGN_COPY**新的剪辑区域为当前路径。  
  
- **RGN_DIFF**新的剪辑区域包括的区域的当前剪辑区域，以及那些当前路径中排除。  
  
- **RGN_OR**新的剪辑区域包括的为当前剪辑区域与当前路径的并集 （组合区域）。  
  
- **RGN_XOR**新的剪辑区域包括联合为当前剪辑区域与当前路径中，但不会重叠区域。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 标识的设备上下文必须包含已关闭的路径。  
  
##  <a name="selectcliprgn"></a>CDC::SelectClipRgn  
 选择作为设备上下文的当前剪辑区域的给定的区域。  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>参数  
 `pRgn`  
 标识要选择的区域。  
  
-   此函数，如果此值的第一个版本**NULL**，整个工作区被选定，并且对输出进行仍剪裁到窗口。  
  
-   对于此函数的第二个版本，可以是此句柄**NULL**仅当**RGN_COPY**指定模式。  
  
 `nMode`  
 指定要执行的操作。 它必须是以下值之一︰  
  
- **RGN_AND**新的剪辑区域将合并当前的剪辑区域与由标识区域的重叠区域`pRgn`。  
  
- **RGN_COPY**新的剪辑区域是由标识的区域的副本`pRgn`。 这是的功能等同于的第一个版本`SelectClipRgn`。 如果通过标识区域`pRgn`是**NULL**，新的剪辑区域将成为默认剪辑区域 （null 区域）。  
  
- **RGN_DIFF**新的剪辑区域将合并具有从由标识的区域中排除这些区域当前剪辑区域的区域`pRgn`。  
  
- **RGN_OR**新的剪辑区域将为当前剪辑区域和由标识的区域合并`pRgn`。  
  
- **RGN_XOR**新的剪辑区域将为当前剪辑区域和由标识的区域合并`pRgn`但不包括任何重叠区域。  
  
### <a name="return-value"></a>返回值  
 区域的类型。 它可以是任何以下值︰  
  
- **COMPLEXREGION**新剪辑区域有重叠的边框。  
  
- **错误**设备上下文或区域无效。  
  
- **NULLREGION**新剪辑区域为空。  
  
- **SIMPLEREGION**新剪辑区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 使用仅所选区域的副本。 可以为任意数目的其他设备上下文中，选择区域本身或可以删除它。  
  
 此函数假设对以设备为单位指定给定区域的坐标。 某些打印机设备支持的文本输出的分辨率更高版本比图形输出以便保留 express 文本度量值所需的精度。 这些设备报告设备单位，分辨率越高，也就是说，文本单位。 然后，这些设备将缩放图形的坐标，以便多个报告设备单位映射到只有 1 图形单元。 始终应调用`SelectClipRgn`函数使用文本单位。  
  
 必须获取 GDI 中的图形对象的缩放的应用程序可以使用**GETSCALINGFACTOR**打印机转义符，以确定缩放系数。 此缩放因子会影响剪辑。 如果区域用于剪辑图形，GDI 将坐标除以的缩放因子。 如果该区域用于剪辑文本，GDI 使未缩放调整。 缩放因子为 1 会导致要除以 2; 的坐标一个比例因子为 2 会导致要除以 4; 的坐标等等。  
  
##  <a name="selectobject"></a>Cdc:: selectobject  
 选择到设备上下文对象。  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>参数  
 *pPen*  
 指向的指针[CPen](../../mfc/reference/cpen-class.md)要选择的对象。  
  
 `pBrush`  
 指向的指针[CBrush](../../mfc/reference/cbrush-class.md)要选择的对象。  
  
 `pFont`  
 指向的指针[CFont](../../mfc/reference/cfont-class.md)要选择的对象。  
  
 `pBitmap`  
 指向的指针[CBitmap](../../mfc/reference/cbitmap-class.md)要选择的对象。  
  
 `pRgn`  
 指向的指针[CRgn](../../mfc/reference/crgn-class.md)要选择的对象。  
  
 `pObject`  
 指向的指针[CGdiObject](../../mfc/reference/cgdiobject-class.md)要选择的对象。  
  
### <a name="return-value"></a>返回值  
 指向要替换的对象的指针。 这是一个派生自的类的对象的指针`CGdiObject`，如`CPen`，取决于使用哪一版本的函数。 返回值是**NULL**如果没有错误。 此函数可能返回指针的临时对象。 此临时对象的一个 Windows 消息处理期间才有效。 有关详细信息，请参阅`CGdiObject::FromHandle`。  
  
 使用区域参数的成员函数的版本执行相同的任务`SelectClipRgn`成员函数。 其返回值可以是以下任一项︰  
  
- **COMPLEXREGION**新剪辑区域有重叠的边框。  
  
- **错误**设备上下文或区域无效。  
  
- **NULLREGION**新剪辑区域为空。  
  
- **SIMPLEREGION**新剪辑区域具有不重叠的边框。  
  
### <a name="remarks"></a>备注  
 类`CDC`提供五个版本专用于特定类型的 GDI 对象，包括钢笔、 画笔、 字体、 位图和区域。 新选择的对象将替换同一类型的上一个对象。 例如，如果`pObject`常规版本的`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)对象，该函数将当前的钢笔替换由指定的笔`pObject`。  
  
 应用程序可以选择位图到内存设备上下文仅和到只有一个内存设备上下文一次。 位图的格式必须是单色或与设备上下文中; 兼容如果不是，`SelectObject`返回错误。  
  
 对于 Windows 3.1 及更高版本，`SelectObject`函数是否使用了它在图元文件中不返回相同的值。 在以前版本的 Windows，`SelectObject`返回非零值表示成功和失败的 0，在图元文件中使用的时间。  
  
##  <a name="selectpalette"></a>CDC::SelectPalette  
 选择指定的逻辑调色板`pPalette`作为设备上下文的所选的调色板对象。  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>参数  
 `pPalette`  
 标识要选择的逻辑调色板。 该调色板必须已经与创建`CPalette`成员函数[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)。  
  
 `bForceBackground`  
 指定是否强制逻辑调色板要背景调色板。 如果`bForceBackground`为非零值，为所选的调色板始终背景调色板，而不考虑窗口是否具有输入的焦点。 如果`bForceBackground`为 0 和设备上下文附加到窗口，逻辑调色板窗口具有输入的焦点时前景调色板。  
  
### <a name="return-value"></a>返回值  
 指向的指针`CPalette`对象标识逻辑调色板替换为指定调色板`pPalette`。 它是**NULL**如果没有错误。  
  
### <a name="remarks"></a>备注  
 新调色板将成为用于通过 GDI 的设备上下文中显示的控件颜色的调色板对象，并替换以前的调色板。  
  
 应用程序可以选择的逻辑调色板到多个设备上下文。 但是，对逻辑调色板的更改会影响为其选择的所有设备上下文。 如果应用程序到多个设备上下文选择调色板，设备上下文必须都属于同一个物理设备。  
  
##  <a name="selectstockobject"></a>CDC::SelectStockObject  
 选择[CGdiObject](../../mfc/reference/cgdiobject-class.md)对应一个预定义的常用钢笔、 画笔或字体的对象。  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>参数  
 `nIndex`  
 指定所需的常用对象的种类。 它可以是以下值之一︰  
  
- **BLACK_BRUSH**实心画笔。  
  
- **DKGRAY_BRUSH**暗灰色的画笔。  
  
- **GRAY_BRUSH**灰色画笔。  
  
- **HOLLOW_BRUSH**空心画笔。  
  
- **LTGRAY_BRUSH**浅灰色的画笔。  
  
- **NULL_BRUSH** Null 画笔。  
  
- **WHITE_BRUSH**白色画笔。  
  
- **BLACK_PEN**黑色钢笔。  
  
- **NULL_PEN** Null 钢笔。  
  
- **WHITE_PEN**白色画笔。  
  
- **ANSI_FIXED_FONT** ANSI 固定的系统字体。  
  
- **ANSI_VAR_FONT** ANSI 变量系统字体。  
  
- **DEVICE_DEFAULT_FONT**依赖于设备的字体。  
  
- **OEM_FIXED_FONT** OEM 依赖于固定字体。  
  
- **SYSTEM_FONT**系统字体。 默认情况下，Windows 使用系统字体绘制菜单、 对话框控件和其他文本。 它是最好的但是，不依赖于 SYSTEM_FONT 获取由对话框和窗口使用的字体。 请改用`SystemParametersInfo`与要检索的当前字体的 SPI_GETNONCLIENTMETRICS 参数的函数。 `SystemParametersInfo`考虑到当前的主题，并提供的标题、 菜单和消息对话框字体信息。  
  
- **SYSTEM_FIXED_FONT**在版本 3.0 之前在 Windows 中使用的固定宽度系统字体。 此对象是可用于与早期版本的 Windows 兼容性。  
  
- **DEFAULT_PALETTE**默认颜色调色板。 该调色板包含系统调色板中的 20 静态颜色。  
  
### <a name="return-value"></a>返回值  
 指向的指针`CGdiObject`如果该函数成功，已替换的对象。 指向的实际对象是[CPen](../../mfc/reference/cpen-class.md)， [CBrush](../../mfc/reference/cbrush-class.md)，或[CFont](../../mfc/reference/cfont-class.md)对象。 如果调用失败，返回值是**NULL**。  
  
##  <a name="setabortproc"></a>Cdc:: setabortproc  
 安装打印作业的中止过程。  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>参数  
 `lpfn`  
 指向要作为中止程序安装的中止函数的指针。 有关详细信息的回调函数，请参阅[cdc:: setabortproc 的回调函数](../../mfc/reference/callback-function-for-cdc-setabortproc.md)。  
  
### <a name="return-value"></a>返回值  
 指定的结果`SetAbortProc`函数。 以下值中的某些属性是比其他，更有可能发生，但所有都是可行。  
  
- **SP_ERROR**常规错误。  
  
- **SP_OUTOFDISK**没有足够的磁盘空间是当前适用于后台处理，并在无更多空间将变为可用。  
  
- **SP_OUTOFMEMORY**没有足够的内存是适用于后台处理。  
  
- **SP_USERABORT**用户结束通过打印管理器作业。  
  
### <a name="remarks"></a>备注  
 如果应用程序是允许在后台处理期间取消打印作业，打印作业开始使用之前，它必须设置中止函数[StartDoc](#startdoc)成员函数。 打印管理器允许应用程序取消打印作业或处理的磁盘空间不足条件的后台处理过程中调用中止函数。 如果设置中止函数，打印作业将失败，如果没有足够的磁盘空间用于后台打印。  
  
 请注意 Microsoft Visual c + + 的功能简化传递给回调函数的创建`SetAbortProc`。 地址传递给`EnumObjects`成员函数是指向与导出的函数的指针**__declspec （dllexport)**与`__stdcall`调用约定。  
  
 您还不需要导出中的函数名称**导出**应用程序的模块定义文件中的语句。 你可以改用**导出**函数修饰符，如  
  
 **BOOL 回调导出**AFunction ( **HDC**， `int` **);**  
  
 若要使编译器发出导出的正确导出记录由不带别名名称。 这适用于大多数需求。 对于某些特殊的情况下，例如导出的函数的序号比较还是别名导出，你仍需要使用**导出**模块定义文件中的语句。  
  
 回调注册接口现在是类型安全的 （您必须在函数指针指向正确的一种特定的回调的函数中传递的）。  
  
 另请注意所有回调函数必须都捕获返回到 Windows，因为不能跨回调边界引发异常之前的 Microsoft 基础异常。 有关异常的详细信息，请参阅文章[异常](../../mfc/exception-handling-in-mfc.md)。  
  
##  <a name="setarcdirection"></a>CDC::SetArcDirection  
 设置要用于弧线和矩形函数的绘制方向。  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>参数  
 *nArcDirection*  
 指定新的圆弧方向。 此参数可以是以下值︰  
  
- **AD_COUNTERCLOCKWISE**逆时针旋转绘制的图形。  
  
- **AD_CLOCKWISE**沿顺时针方向绘制的图形。  
  
### <a name="return-value"></a>返回值  
 如果成功，则，指定旧弧线方向否则为 0。  
  
### <a name="remarks"></a>备注  
 按逆时针方向的默认方向。 `SetArcDirection`函数指定在其中以下函数绘图的方向︰  
  
|Arc|饼图|  
|---------|---------|  
|`ArcTo`|**矩形**|  
|`Chord`|`RoundRect`|  
|**椭圆**||  
  
##  <a name="setattribdc"></a>CDC::SetAttribDC  
 调用此函数可设置特性设备上下文， `m_hAttribDC`。  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>参数  
 `hDC`  
 Windows 设备上下文。  
  
### <a name="remarks"></a>备注  
 此成员函数不会附加到的设备上下文`CDC`对象。 仅输出设备上下文附加到`CDC`对象。  
  
##  <a name="setbkcolor"></a>CDC::SetBkColor  
 将当前的背景色设置为指定的颜色。  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 `crColor`  
 指定新的背景色。  
  
### <a name="return-value"></a>返回值  
 以前的背景色为 RGB 颜色值。 如果出错，则返回值将为 0x80000000。  
  
### <a name="remarks"></a>备注  
 如果后台模式下是**不透明**，系统使用的背景色填充样式的行中的空白、 阴影的画笔中行和中字符单元格的背景之间的间隙。 转换颜色和单色设备上下文之间的位图时，系统还会使用的背景色。  
  
 如果设备不能显示指定的颜色，系统将设置为最接近的物理颜色的背景色。  
  
##  <a name="setbkmode"></a>CDC::SetBkMode  
 设置后台模式。  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>参数  
 *nBkMode*  
 指定要设置的模式。 此参数可以是以下值︰  
  
- **不透明**之前的文本，阴影画笔，当前的背景色填充背景或钢笔绘制。 这是默认背景模式。  
  
- **透明**后台在绘制之前不会更改。  
  
### <a name="return-value"></a>返回值  
 以前的背景模式。  
  
### <a name="remarks"></a>备注  
 后台模式下定义系统是否在绘制文本、 阴影的画笔或不是一条实线任何笔样式之前删除现有的绘图图面上的背景色。  
  
### <a name="example"></a>示例  
  请参阅示例[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="setboundsrect"></a>CDC::SetBoundsRect  
 控制指定的设备上下文的边界矩形信息的累计。  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>参数  
 `lpRectBounds`  
 指向`RECT`结构或`CRect`用于设置边框的对象。 矩形尺寸的单位以逻辑坐标表示。 此参数可以为**NULL**。  
  
 `flags`  
 指定如何新添加的矩形将结合累积的矩形。 此参数可以是以下值的组合︰  
  
- **DCB_ACCUMULATE**添加由指定的矩形`lpRectBounds`到 （使用矩形联合操作） 的绑定矩形。  
  
- **DCB_DISABLE**关闭边界累积。  
  
- **DCB_ENABLE**开启边界累积。 （边界累积的默认设置为禁用）。  
  
### <a name="return-value"></a>返回值  
 边界矩形，如果该函数成功当前状态。 如`flags`，返回值可以是组合**DCB_**值︰  
  
- **DCB_ACCUMULATE**的边框不为空。 此值将始终设置。  
  
- **DCB_DISABLE**边界累积处于关闭状态。  
  
- **DCB_ENABLE**边界累积亮起。  
  
### <a name="remarks"></a>备注  
 Windows 可以维护所有绘制操作的边框。 可以查询此矩形，并将其重置应用程序。 绘制边界可用于使位图缓存失效。  
  
##  <a name="setbrushorg"></a>CDC::SetBrushOrg  
 指定的 GDI 会将分配给应用程序选择到设备上下文的下一步画笔的来源。  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的 x 坐标 （以设备为单位） 的新的原点。 此值必须在范围 0-7。  
  
 *y*  
 指定的 y 坐标 （以设备为单位） 的新的原点。 此值必须在范围 0-7。  
  
 `point`  
 指定新的原点 x 和 y 坐标。 每个值必须在范围 0-7。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 以前以设备为单位的画笔的原点。  
  
### <a name="remarks"></a>备注  
 默认值协调画笔原点是否 （0，0）。 若要更改的源的画笔，调用`UnrealizeObject`函数`CBrush`对象，请调用`SetBrushOrg`，然后调用`SelectObject`成员函数以选入设备上下文的画笔。  
  
 不要使用`SetBrushOrg`与 stock`CBrush`对象。  
  
##  <a name="setcoloradjustment"></a>CDC::SetColorAdjustment  
 设置使用指定的值的设备上下文的颜色调整值。  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>参数  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)包含颜色调整值的数据结构。  
  
### <a name="return-value"></a>返回值  
 如果成功，则不为 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 颜色调整值用于调整调用了源位图的输入的颜色`CDC::StretchBlt`成员函数时**半色调**模式设置。  
  
##  <a name="setdcbrushcolor"></a>CDC::SetDCBrushColor  
 将当前设备上下文 (DC) 画笔的颜色设置为指定的颜色值。  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 `crColor`  
 指定新的画笔颜色。  
  
### <a name="return-value"></a>返回值  
 如果函数成功，返回的值指定为以前的 DC 画笔颜色`COLORREF`值。  
  
 如果函数失败，返回值是`CLR_INVALID`。  
  
### <a name="remarks"></a>备注  
 此方法模拟该函数的功能[SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setdcpencolor"></a>CDC::SetDCPenColor  
 将当前的设备上下文 (DC) 钢笔颜色设置为指定的颜色值。  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 `crColor`  
 指定新的钢笔颜色。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此成员函数使用 Win32 函数[SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setgraphicsmode"></a>CDC::SetGraphicsMode  
 设置指定的设备上下文的图形模式。  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>参数  
 `iMode`  
 指定的图形模式。 此参数可以采用的值的列表，请参阅[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
### <a name="return-value"></a>返回值  
 如果成功返回旧的图形模式。  
  
 失败，则返回 0。 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 此方法会包装 Windows GDI 函数[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
##  <a name="setlayout"></a>CDC::SetLayout  
 调用此成员函数可将文本和图形设备上下文的布局更改为权保留，如阿拉伯语和希伯莱语的区域性的标准布局。  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>参数  
 `dwLayout`  
 设备上下文布局和位图控制标志。 它可以是以下值的组合。  
  
|值|含义|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|禁用对调用任何反射[cdc:: bitblt](#bitblt)和[CDC::StretchBlt](#stretchblt)。|  
|LAYOUT_RTL|设置默认水平布局为从右向左。|  
|LAYOUT_LTR|设置要从左到右的默认布局。|  
  
### <a name="return-value"></a>返回值  
 如果成功，以前的设备上下文的布局。  
  
 如果不成功， **GDI_ERROR**。 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 通常情况下，你不应该调用**SetLayout**窗口。 相反，通过设置来控制在窗口中的右到左布局[扩展窗口样式](../../mfc/reference/extended-window-styles.md)如**WS_EX_RTLREADING**。 设备上下文，如打印机或图元文件，不会继承此布局。 从右到左布局是调用设置的设备上下文的唯一办法**SetLayout**。  
  
 如果调用**SetLayout (LAYOUT_RTL** )， **SetLayout**会自动更改到的映射模式`MM_ISOTROPIC`。 因此，后续调用[GetMapMode](#getmapmode)将返回**MM_ISOTROPIC**而不是`MM_TEXT`。  
  
 在某些情况下，如与许多位图，你可能想要保留从左到右的布局。 在这些情况下，通过调用呈现图像`BitBlt`或`StretchBlt`，然后设置的位图控制标志`dwLayout`到**LAYOUT_BITMAPORIENTATIONPRESERVED**。  
  
 后更改与布局**LAYOUT_RTL**标记，通常指定权限的标志或左进行了互换。 为了避免混淆，你可能想要定义的标准标志的备用名称。 建议的备用标志名称的列表，请参阅[SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setmapmode"></a>CDC::SetMapMode  
 设置的映射模式。  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>参数  
 `nMapMode`  
 指定新的映射模式。 它可以是以下值之一︰  
  
- `MM_ANISOTROPIC`与任意缩放后的轴，逻辑单元将转换为任意单元。 映射模式设置为`MM_ANISOTROPIC`不会更改当前的窗口或视区设置。 若要更改单位，方向和缩放，调用[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成员函数。  
  
- `MM_HIENGLISH`每个逻辑单元会转换为 0.001 英寸。 正 x 是向右;正 y 是最多。  
  
- `MM_HIMETRIC`每个逻辑单元会转换为 0.01 毫米。 正 x 是向右;正 y 是最多。  
  
- `MM_ISOTROPIC`逻辑单元都使用同样缩放轴; 转换为任意单位也就是说，沿 x 轴 1 个单位等于 1 个单位沿 y 轴。 使用`SetWindowExt`和`SetViewportExt`成员函数以指定所需的单位和轴的方向。 GDI 根据需要进行调整以确保 x 和 y 单位保持相同的大小。  
  
- `MM_LOENGLISH`每个逻辑单元会转换为 0.01 英寸。 正 x 是向右;正 y 是最多。  
  
- `MM_LOMETRIC`每个逻辑单元会转换为 0.1 毫米。 正 x 是向右;正 y 是最多。  
  
- `MM_TEXT`每个逻辑单元将转换为 1 台设备像素。 正 x 是向右;正 y 已关闭。  
  
- `MM_TWIPS`每个逻辑单元会转换为 1/20 的点。 （由于点 1/72 英寸，缇是 1/1440年英寸。）正 x 是向右;正 y 是最多。  
  
### <a name="return-value"></a>返回值  
 以前的映射模式。  
  
### <a name="remarks"></a>备注  
 映射模式定义用于将逻辑单元转换为设备单位; 的度量的单位它还定义设备的 x 轴和 y 轴的方向。 GDI 使用映射模式将逻辑坐标转换为相应的设备坐标。 `MM_TEXT`模式允许应用程序能够以设备像素为单位，其中 1 个单位等于 1 个像素。 像素的物理大小而异设备到设备。  
  
 `MM_HIENGLISH`， `MM_HIMETRIC`， `MM_LOENGLISH`， `MM_LOMETRIC`，和`MM_TWIPS`模式可用于应用程序必须在以物理方式有意义的单元 （如英寸或毫米等） 中进行绘制。 `MM_ISOTROPIC`模式可确保纵横比为 1:1，这在很重要保留图像的确切形态时很有用。 `MM_ANISOTROPIC`模式允许 x 坐标和 y 坐标，以便独立调整。  
  
> [!NOTE]
>  如果调用[SetLayout](#setlayout)更改为从右向左的布局的 DC （设备上下文） **SetLayout**会自动更改到的映射模式`MM_ISOTROPIC`。  
  
### <a name="example"></a>示例  
  请参阅示例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setmapperflags"></a>CDC::SetMapperFlags  
 更改字体映射器转换到物理字体的逻辑字体时，所用的方法。  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>参数  
 `dwFlag`  
 指定是否字体映射器会尝试匹配字体的方面高度和宽度到设备。 当此值是**ASPECT_FILTERING**、 映射器选择唯一的字体其 x 方面和与指定的设备，y 方面完全相同。  
  
### <a name="return-value"></a>返回值  
 以前的字体映射器标志值。  
  
### <a name="remarks"></a>备注  
 应用程序可以使用`SetMapperFlags`导致字体映射程序来尝试选择仅与指定的设备的纵横比完全匹配的物理字体。  
  
 使用仅光栅字体的应用程序可以使用`SetMapperFlags`函数，以确保选定字体映射器的字体具吸引力，也在指定的设备上可读。 通常使用可扩展 (TrueType) 字体的应用程序不使用`SetMapperFlags`。  
  
 如果没有物理字体具有匹配的逻辑字体中的规范纵横比，GDI 选择新的长宽比，并选择与此新的纵横比匹配的字体。  
  
##  <a name="setmiterlimit"></a>CDC::SetMiterLimit  
 设置用于设备上下文的斜接联接的长度的限制。  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>参数  
 *fMiterLimit*  
 指定设备上下文的新斜接限制。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 斜接长度被指从联接的内侧的行墙的交集上的外部联接的行墙的交集的距离。 斜接限制为的线条宽度对斜接长度最大允许的比率。 默认斜接限制为 10.0。  
  
##  <a name="setoutputdc"></a>CDC::SetOutputDC  
 调用此成员函数可将输出设备上下文中，设置`m_hDC`。  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>参数  
 `hDC`  
 Windows 设备上下文。  
  
### <a name="remarks"></a>备注  
 此成员函数只有时设备上下文未附加到调用`CDC`对象。 此成员函数设置`m_hDC`但不会附加到的设备上下文`CDC`对象。  
  
##  <a name="setpixel"></a>CDC::SetPixel  
 设置为指定的颜色最接近指定的点处的像素`crColor`。  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定要设置的点的逻辑 x 坐标。  
  
 *y*  
 指定要设置的点的逻辑 y 坐标。  
  
 `crColor`  
 A **COLORREF** RGB 值，该值指定用来绘制点的颜色。 请参阅[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有关此值的说明。  
  
 `point`  
 指定逻辑 x 坐标和 y 坐标要设置的点。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 实际绘制点的颜色 RGB 值。 此值可以不同于指定的`crColor`如果使用该颜色的近似值。 如果函数失败 （如果该点则剪切区域外部），则返回值为-1。  
  
### <a name="remarks"></a>备注  
 点必须在的剪辑区域中。 如果点不在的剪辑区域，该函数将没有任何影响。  
  
 不是所有的设备都支持 `SetPixel` 函数。 若要确定设备是否支持`SetPixel`，调用`GetDeviceCaps`成员函数时**RASTERCAPS**索引并检查返回值以查找**RC_BITBLT**标志。  
  
##  <a name="setpixelv"></a>CDC::SetPixelV  
 到指定的颜色最接近的指定坐标处设置像素。  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的 x 坐标，逻辑单位，要设置的点。  
  
 *y*  
 指定逻辑单位，要设置的点的 y 坐标。  
  
 `crColor`  
 指定要用于绘制点的颜色。  
  
 `point`  
 指定逻辑 x 坐标和 y 坐标要设置的点。 你可以传递[点](../../mfc/reference/point-structure1.md)数据结构或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 点必须在的剪辑区域和设备面的可见部分。 并非所有设备都支持的成员函数。 有关详细信息，请参阅**RC_BITBLT**中的功能`CDC::GetDeviceCaps`成员函数。 `SetPixelV`比快`SetPixel`因为它不需要返回实际绘制的点的颜色值。  
  
##  <a name="setpolyfillmode"></a>CDC::SetPolyFillMode  
 设置在多边形填充模式。  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>参数  
 `nPolyFillMode`  
 指定新的填充模式。 此值可能是**备用**或**绕**。 在 Windows 中设置的默认模式是**备用**。  
  
### <a name="return-value"></a>返回值  
 如果成功，则以前填充模式否则为 0。  
  
### <a name="remarks"></a>备注  
 多边形填充模式时**备用**，系统填充每个扫描线上的奇数和偶数多边形边之间的区域。 也就是说，系统填充区域之间的第一个和第二个端、 之间的第三个和第四个端和等等。 默认值为此模式。  
  
 多边形填充模式时**绕**，系统将使用在其中绘制图来确定是否填充区域的方向。 在以顺时针方向或逆时针方向绘制多边形内的每个直线线段。 每当从封闭区域到图的外部绘制的虚线通过顺时针旋转直线段，则计数将会递增。 当行通过逆时针线段时，计数会减少。 计数不为零的曲线到达图外部时，会填充区域。  
  
##  <a name="setrop2"></a>CDC::SetROP2  
 设置的当前绘图模式。  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>参数  
 `nDrawMode`  
 指定新的绘制模式。 它可以是任何以下值︰  
  
- **R2_BLACK**像素始终为黑色。  
  
- **R2_WHITE**像素始终为白色。  
  
- **R2_NOP**像素保持不变。  
  
- **R2_NOT**像素是屏幕颜色的反向属性。  
  
- **R2_COPYPEN**像素是钢笔颜色。  
  
- **R2_NOTCOPYPEN**像素是的钢笔颜色的反向属性。  
  
- **R2_MERGEPENNOT**像素是屏幕颜色的反向和钢笔颜色的组合 (最终像素 = （不屏幕像素） 或笔)。  
  
- **R2_MASKPENNOT**像素是屏幕的反向和共有的钢笔颜色的组合 (最终像素 = （不屏幕像素） 和钢笔)。  
  
- **R2_MERGENOTPEN**像素是的钢笔颜色的反向属性和屏幕颜色的组合 (最终像素 = （不钢笔） 或屏幕像素)。  
  
- **R2_MASKNOTPEN**像素是的反向属性的笔和共有屏幕颜色的组合 (最终像素 = （不钢笔） 和屏幕像素)。  
  
- **R2_MERGEPEN**像素是钢笔颜色和屏幕颜色的组合 (最终像素 = 钢笔或屏幕像素)。  
  
- **R2_NOTMERGEPEN**像素是函数的反函数**R2_MERGEPEN**颜色 (最终像素 = 不 （笔或屏幕像素）)。  
  
- **R2_MASKPEN**像素是通用的笔和屏幕的颜色的组合 (最终像素 = 钢笔 AND 屏幕像素)。  
  
- **R2_NOTMASKPEN**像素是函数的反函数**R2_MASKPEN**颜色 (最终像素 = 不 （笔 AND 屏幕像素）)。  
  
- **R2_XORPEN**像素是颜色笔或在屏幕中，但不是在两者的组合 (最终像素 = 钢笔 XOR 屏幕像素)。  
  
- **R2_NOTXORPEN**像素是函数的反函数**R2_XORPEN**颜色 (最终像素 = 不 （钢笔 XOR 屏幕像素）)。  
  
### <a name="return-value"></a>返回值  
 以前的绘制模式。  
  
 它可以是任何中给定的值[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>备注  
 绘图模式指定如何显示图面上已颜色组合的钢笔颜色和填充的对象的内部。  
  
 绘图模式是仅适用于光栅设备;它不适用于向量设备。 绘图模式是二进制的光栅操作代码表示所有可能的布尔组合的两个变量，不使用二元运算符 AND、 OR 和 XOR （异或） 和一元运算。  
  
##  <a name="setstretchbltmode"></a>CDC::SetStretchBltMode  
 设置的位图拉伸模式`StretchBlt`成员函数。  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>参数  
 *nStretchMode*  
 指定的拉伸模式。 它可以是任何以下值︰  
  
|值|描述|  
|-----------|-----------------|  
|**BLACKONWHITE**|执行布尔 AND 运算使用的已清除的和现有的像素的颜色值。 如果位图是单色位图，此模式会保留代价白色像素是黑色像素。|  
|**COLORONCOLOR**|删除像素。 此模式下不尝试保留其信息的情况下删除所有消除了的行的像素为单位。|  
|**半色调**|将源矩形的像素映射到目标矩形中的像素的块。 通过目标块的像素为单位的平均颜色总数接近于源像素的颜色。|  
||设置后**半色调**拉伸模式下，应用程序必须调用 Win32 函数[SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967)设置的画笔的原点。 如果它无法这样做，则会发生画笔不一致问题。|  
|**STRETCH_ANDSCANS**|**Windows 95/98**︰ 相同**BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95/98**︰ 相同**COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95/98**︰ 相同**半色调**。|  
|**STRETCH_ORSCANS**|**Windows 95/98**︰ 相同**WHITEONBLACK**|  
|**WHITEONBLACK**|执行使用的已清除的和现有的像素的颜色值的布尔值或操作。 如果位图是单色位图，此模式会保留代价是牺牲黑色像素的白色像素。|  
  
### <a name="return-value"></a>返回值  
 以前的拉伸模式。 它可以是**STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS**。  
  
### <a name="remarks"></a>备注  
 位图拉伸模式定义信息从通过函数压缩的位图的删除途径。  
  
 **BLACKONWHITE** ( **STRETCH_ANDSCANS**) 和**WHITEONBLACK** ( **STRETCH_ORSCANS**) 模式通常用于保留单色位图中的前景色像素。 **COLORONCOLOR** ( **STRETCH_DELETESCANS**) 模式通常用于保留颜色位图中的颜色。  
  
 **半色调**模式要求的源映像比其他三个模式的更多处理; 它比其他慢，但生成高质量映像。 另请注意， **SetBrushOrgEx**设置后，必须调用**半色调**模式下以避免画笔不一致问题。  
  
 其他的拉伸模式可能会有具体取决于设备驱动程序的功能。  
  
##  <a name="settextalign"></a>CDC::SetTextAlign  
 设置文本对齐方式标志。  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>参数  
 `nFlags`  
 指定文本对齐方式的标志。 标志指定一个点和一个矩形，它限定文本之间的关系。 点可以是当前的位置或指定的文本输出函数的坐标。 中的文本字符串的相邻字符单元格定义是限定文本的矩形。 `nFlags`参数可以为以下三个类别的一个或多个标志。 从每个类别中选择一个标志。 第一个类别会影响在 x 方向的文本对齐方式︰  
  
- **TA_CENTER**对齐水平居中的边框的点。  
  
- **TA_LEFT**对齐边界的矩形的左侧的点。 此为默认设置。  
  
- **TA_RIGHT**对齐的边框的右侧的点。  
  
 第二个类别会影响在 y 轴方向的文本对齐方式︰  
  
- **TA_BASELINE**对齐到基准线的所选字体的点。  
  
- **TA_BOTTOM**对齐底部的边框的点。  
  
- **TA_TOP**对齐边界的矩形的顶部的点。 此为默认设置。  
  
 第三个类别确定写入文本时是否更新当前的位置︰  
  
- **TA_NOUPDATECP**不会在每次调用的文本输出函数后更新当前位置。 此为默认设置。  
  
- **TA_UPDATECP**文本输出函数每次调用后更新当前的 x 位置。 新的位置是边框的在文本的右侧。 当设置此标志，对的调用中指定的坐标`TextOut`成员函数将被忽略。  
  
### <a name="return-value"></a>返回值  
 以前文本对齐方式的设置，如果成功。 低序位字节包含水平的设置，高序位字节包含垂直设置;否则为 0。  
  
### <a name="remarks"></a>备注  
 `TextOut`和`ExtTextOut`定位的显示或设备上的文本字符串时，成员函数将使用这些标志。 标志指定的特定点和一个矩形，它限定文本之间的关系。 此点的坐标作为参数传递给`TextOut`成员函数。 限定文本的矩形的相邻字符单元格中的文本字符串由构成。  
  
##  <a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra  
 设置 intercharacter 间距的大小。  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>参数  
 `nCharExtra`  
 指定的额外空间量 （以逻辑单位） 添加到每个字符。 如果不是当前的映射模式`MM_TEXT`，`nCharExtra`转换和舍入为最近的像素。  
  
### <a name="return-value"></a>返回值  
 以前的 intercharacter 间距大小。  
  
### <a name="remarks"></a>备注  
 GDI 将此间距添加到每个字符，包括分行符，当它的设备上下文中写入一行文本。 Intercharacter 间距量的默认值为 0。  
  
##  <a name="settextcolor"></a>CDC::SetTextColor  
 设置为指定的颜色的文本颜色。  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>参数  
 `crColor`  
 指定作为 RGB 颜色值的文本颜色。  
  
### <a name="return-value"></a>返回值  
 以前的文本颜色的 RGB 值。  
  
### <a name="remarks"></a>备注  
 将文本写入此设备上下文以及时之间的转换位图颜色和单色设备上下文时，系统将使用此文本颜色。  
  
 如果设备不能表示的指定的颜色，系统会将文本颜色设置为最接近的物理颜色。 指定的字符的背景色`SetBkColor`和`SetBkMode`成员函数。  
  
### <a name="example"></a>示例  
  请参阅示例[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="settextjustification"></a>CDC::SetTextJustification  
 将空间添加到字符串中的中断字符。  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>参数  
 `nBreakExtra`  
 指定要添加到的 （以逻辑单位） 的文本行的总额外空间。 如果不是当前的映射模式`MM_TEXT`，给定此参数的值转换为当前的映射模式，并舍入为最接近的设备单位。  
  
 *nBreakCount*  
 在行中指定中断字符的数。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则，一个否则为 0。  
  
### <a name="remarks"></a>备注  
 应用程序可以使用`GetTextMetrics`成员函数以检索字体的中断字符。  
  
 后`SetTextJustification`调用成员函数，对文本输出函数的调用 (如`TextOut`) 将分发中指定数目的中断字符平均指定额外的空间。 中断字符通常是空格字符 (ASCII 32)，但可能由某些其他字符作为字体。  
  
 成员函数`GetTextExtent`通常用于`SetTextJustification`。 `GetTextExtent`计算对齐前给定行的宽度。 应用程序可以确定空间量，以指定中`nBreakExtra`参数通过返回的值中减去`GetTextExtent`从后对齐方式的字符串的宽度。  
  
 `SetTextJustification`函数可以用于对齐一行，其中包含将在不同的字体中的多个运行。 在这种情况下，行必须段落创建通过对齐并单独编写每次运行。  
  
 因为舍入误差在对齐期间可以发生，系统将保持一个正在运行的错误术语，用于定义当前错误。 对齐一行，其中包含多个运行时`GetTextExtent`会自动使用它时计算的在下次运行程度此错误术语。 这样，要到新的运行 blend 错误的文本输出函数。  
  
 对齐每行后，必须清除该错误术语以防止它被合并到下一行。 可以通过调用清除术语`SetTextJustification`与`nBreakExtra`设置为 0。  
  
##  <a name="setviewportext"></a>CDC::SetViewportExt  
 设置 x-和 y-区的设备上下文的视区。  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>参数  
 `cx`  
 指定 （以设备为单位） 的视区的 x 范围。  
  
 `cy`  
 指定 （以设备为单位） 的视区的 y 范围。  
  
 `size`  
 指定 x-和 y 的范围 （以设备为单位） 的视区。  
  
### <a name="return-value"></a>返回值  
 为视区的前一扩展盘区[CSize](../../atl-mfc-shared/reference/csize-class.md)对象。 当发生错误，x 坐标和 y 坐标的返回`CSize`对象都设置为 0。  
  
### <a name="remarks"></a>备注  
 视区内，以及设备上下文窗口中，定义 GDI 如何映射到的实际设备坐标系统中的点的逻辑坐标系统中的点。 换而言之，他们会定义 GDI 如何将逻辑坐标转换到设备坐标。  
  
 设置了以下的映射模式，调用`SetWindowExt`和`SetViewportExt`将被忽略︰  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 当`MM_ISOTROPIC`模式设置、 应用程序必须调用`SetWindowExt`成员函数调用之前`SetViewportExt`。  
  
### <a name="example"></a>示例  
  请参阅示例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setviewportorg"></a>CDC::SetViewportOrg  
 设置设备上下文的视区原点。  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定的 x 坐标 （以设备为单位） 的视区原点。 值必须在设备坐标系统的范围内。  
  
 *y*  
 指定的 y 坐标 （以设备为单位） 的视区原点。 值必须在设备坐标系统的范围内。  
  
 `point`  
 指定的视区的来源。 值必须在设备坐标系统的范围内。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 以前 （在设备坐标中） 作为的视区原点`CPoint`对象。  
  
### <a name="remarks"></a>备注  
 视区内，以及设备上下文窗口中，定义 GDI 如何映射到的实际设备坐标系统中的点的逻辑坐标系统中的点。 换而言之，他们会定义 GDI 如何将逻辑坐标转换到设备坐标。  
  
 视区原点标记在设备坐标系统 GDI 映射的窗口来源，由指定的逻辑坐标系统中的点到点**SetWindowOrg**成员函数。 GDI 映射按照相同的过程映射到视区原点窗口原点所需的所有其他点。 例如，在窗口原点的点围绕圆圈，圆圈中的所有点都将在一个圆周解决在视区原点的点中。 同样，通过窗口原点的行中的所有点都将通过视区原点的行中。  
  
### <a name="example"></a>示例  
  请参阅示例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindowext"></a>CDC::SetWindowExt  
 设置 x-和 y-区的设备上下文与关联的窗口。  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>参数  
 `cx`  
 指定的 x 的范围 （以逻辑单位） 的窗口。  
  
 `cy`  
 指定的 y 的范围 （以逻辑单位） 的窗口。  
  
 `size`  
 指定 x-和 y-中的范围 （逻辑单位） 的窗口。  
  
### <a name="return-value"></a>返回值  
 以前的窗口 （以逻辑单位） 的范围`CSize`对象。 如果发生错误，x 坐标和 y 坐标的返回`CSize`对象都设置为 0。  
  
### <a name="remarks"></a>备注  
 窗口中的，设备上下文视区内，以及定义 GDI 如何映射到设备坐标系统中的点的逻辑坐标系统中的点。  
  
 设置了以下的映射模式，调用`SetWindowExt`和`SetViewportExt`函数将被忽略︰  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 当`MM_ISOTROPIC`模式设置、 应用程序必须调用`SetWindowExt`之前调用的成员函数`SetViewportExt`。  
  
### <a name="example"></a>示例  
  请参阅示例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindoworg"></a>CDC::SetWindowOrg  
 设置的设备上下文则窗口原点。  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定新的窗口原点的逻辑 x 坐标。  
  
 *y*  
 指定新的窗口原点的逻辑 y 坐标。  
  
 `point`  
 指定新的窗口原点的逻辑坐标。 你可以传递**点**结构或`CPoint`为此参数的对象。  
  
### <a name="return-value"></a>返回值  
 为窗口的上一个原点`CPoint`对象。  
  
### <a name="remarks"></a>备注  
 窗口中的，设备上下文视区内，以及定义 GDI 如何映射到设备坐标系统中的点的逻辑坐标系统中的点。  
  
 窗口原点标记从中 GDI 映射视区原点，通过指定设备坐标系统中的点的逻辑坐标系统中的点**SetWindowOrg**函数。 GDI 映射按照相同的过程映射到视区原点窗口原点所需的所有其他点。 例如，在窗口原点的点围绕圆圈，圆圈中的所有点都将在一个圆周解决在视区原点的点中。 同样，通过窗口原点的行中的所有点都将通过视区原点的行中。  
  
##  <a name="setworldtransform"></a>CDC::SetWorldTransform  
 设置全局空间和指定的设备上下文的页面空间之间的二维线性转换。 此转换可以用于缩放、 旋转、 倾斜对象，或转换图形输出。  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>参数  
 `rXform`  
 引用[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)包含转换数据的结构。  
  
### <a name="return-value"></a>返回值  
 如果成功返回非零值。  
  
 失败，则返回 0。  
  
 若要获得扩展的错误信息，调用[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>备注  
 此方法会包装 Windows GDI 函数[SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104)。  
  
##  <a name="startdoc"></a>CDC::StartDoc  
 通知正在启动新的打印作业的设备驱动程序，所有后续`StartPage`和`EndPage`调用应假脱机之前相同的作业下`EndDoc`调用时发生。  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>参数  
 *lpDocInfo*  
 指向[DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574)结构，它包含文档文件的名称和输出文件的名称。  
  
 *lpszDocName*  
 指向包含文档文件的名称的字符串的指针。  
  
### <a name="return-value"></a>返回值  
 如果函数成功，则返回值是大于零。 此值是文档的打印作业标识符。  
  
 如果函数失败，则返回的值小于或等于零。  
  
### <a name="remarks"></a>备注  
 这可确保不止一页的文档将不能与其他作业进行分布。  
  
 对于 Windows 版本 3.1 和更高版本，此函数将替换**STARTDOC**打印机转义。 使用此函数可确保与其他打印作业的用户不能交织文档包含多个页。  
  
 `StartDoc`不应在图元文件内使用。  
  
### <a name="example"></a>示例  
 此代码段获取默认打印机，打开打印作业，并会将输出包含"Hello，World ！"个页面 它。 由于打印的此代码的文本不扩展到打印机的逻辑单元，输出文本可能会在此类小写字母中，结果是不可读。 缩放函数，如 CDC `SetMapMode`， `SetViewportOrg`，和`SetWindowExt`，可用来修复的缩放。  
  
 [!code-cpp[NVC_MFCDocView # 41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>CDC::StartPage  
 调用此成员函数以准备要接收数据的打印机驱动程序。  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>返回值  
 大于或等于 0，如果该函数成功或如果发生错误的负值。  
  
### <a name="remarks"></a>备注  
 `StartPage`取代**NEWFRAME**和**BANDINFO**转义。  
  
 打印调用的序列的概述，请参阅[StartDoc](#startdoc)成员函数。  
  
 系统禁用`ResetDC`之间调用的成员函数`StartPage`和`EndPage`。  
  
### <a name="example"></a>示例  
  请参阅示例[CDC::StartDoc](#startdoc)。  
  
##  <a name="stretchblt"></a>CDC::StretchBlt  
 将位图从源矩形复制到目标矩形，必要时可拉伸或压缩位图以符合目标矩形的尺寸。  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定目标矩形左上角的 x 坐标（使用逻辑单位）。  
  
 *y*  
 指定目标矩形左上角的 y 坐标（使用逻辑单位）。  
  
 `nWidth`  
 指定目标矩形的宽度（使用逻辑单位）。  
  
 `nHeight`  
 指定目标矩形的高度（使用逻辑单位）。  
  
 `pSrcDC`  
 指定源设备上下文。  
  
 `xSrc`  
 指定源矩形左上角的 x 坐标（使用逻辑单位）。  
  
 `ySrc`  
 指定源矩形左上角的 y 坐标（使用逻辑单位）。  
  
 `nSrcWidth`  
 指定源矩形的宽度（使用逻辑单位）。  
  
 `nSrcHeight`  
 指定源矩形的高度（使用逻辑单位）。  
  
 *dwRop*  
 指定要执行的光栅操作。 光栅操作代码定义 GDI 如何合并涉及当前画笔、可能的源位图和目标位图的输出操作中的颜色。 该参数可能是下列值之一：  
  
- **BLACKNESS** -使所有输出变黑。  
  
- **DSTINVERT** -反转目标位图。  
  
- **MERGECOPY** -合并模式使用布尔 AND 运算符的源位图。  
  
- **MERGEPAINT** -合并反转的源位图与目标位图使用布尔 OR 运算符。  
  
- **NOTSRCCOPY**将反转的源位图复制到目标。  
  
- **NOTSRCERASE** -反转目标位图与源位图使用布尔 OR 运算符组合的结果。  
  
- **PATCOPY**将模式复制到目标位图。  
  
- **PATINVERT** -合并目标位图与模式，即使用布尔 XOR 运算符。  
  
- **PATPAINT** -合并反转的源位图与模式，即使用布尔 OR 运算符。 使用布尔 OR 运算符合并该操作的结果与目标位图。  
  
- **SRCAND** -合并使用布尔 AND 运算符的目标和源位图的像素。  
  
- **SRCCOPY**将源位图复制到目标位图。  
  
- **SRCERASE** -反转目标位图，并将结果组合与源位图使用布尔 AND 运算符。  
  
- **SRCINVERT** -合并使用布尔 XOR 运算符的目标和源位图的像素。  
  
- **SRCPAINT** -合并使用布尔 OR 运算符的目标和源位图的像素。  
  
- **WHITENESS** -使所有输出空白。  
  
### <a name="return-value"></a>返回值  
 如果绘制出位图，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 该函数使用目标设备上下文的拉伸模式（由 `SetStretchBltMode` 设置）确定如何拉伸或压缩位图。  
  
 `StretchBlt` 函数将 `pSrcDC` 给定的源设备中的位图移动到其成员函数即将被调用的设备上下文对象所表示的目标设备。 `xSrc`、`ySrc`、`nSrcWidth` 和 `nSrcHeight` 参数定义源矩形的左上角和尺寸。 *X*， *y*， `nWidth`，和`nHeight`参数提供的左上角和目标矩形的尺寸。 由指定的光栅操作*dwRop*定义源位图和 bits 已在目标设备上的进行组合的方式。  
  
 如果 `StretchBlt` 与 `nSrcWidth` 或 `nWidth` 与 `nSrcHeight` 参数的符号不同，则 `nHeight` 函数将创建位图的镜像。 如果 `nSrcWidth` 与 `nWidth` 符号不同，则该函数将沿 x 轴创建位图的镜像。 如果 `nSrcHeight` 与 `nHeight` 符号不同，则该函数将沿 y 轴创建位图的镜像。  
  
 `StretchBlt` 函数将在内存中拉伸或压缩源位图，然后将结果复制到目标。 如果一个模式将与该结果合并，则合并操作会等到拉伸的源位图复制到目标后执行。 如果使用画笔，则为在目标设备上下文中选择的画笔。 目标坐标将根据目标设备上下文进行转换；源坐标将根据源设备上下文进行转换。  
  
 如果目标位图、源位图和模式位图没有相同的颜色格式，`StretchBlt` 将转换源位图和模式位图，以与目标位图匹配。 在转换中将使用目标设备上下文的前景色和背景色。  
  
 如果 `StretchBlt` 必须将单色位图转换为彩色，则会将白色位 (1) 设置为背景色，黑色位 (0) 设置为前景色。 若要将彩色位图转换为单色，它会将与背景色匹配的像素设置为白色 (1)，其他所有像素设置为黑色 (0)。 在转换中将使用彩色设备上下文的前景色和背景色。  
  
 不是所有的设备都支持 `StretchBlt` 函数。 若要确定设备是否支持`StretchBlt`，调用`GetDeviceCaps`成员函数时**RASTERCAPS**索引并检查返回值以查找**RC_STRETCHBLT**标志。  
  
##  <a name="strokeandfillpath"></a>CDC::StrokeAndFillPath  
 关闭任何开放的路径中的图形、 通过使用当前的钢笔，描边轮廓的路径和通过使用当前画笔填充其内部。  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 设备上下文必须包含已关闭的路径。 `StrokeAndFillPath`成员函数具有相同的效果关闭在路径中，所有开放的图形和描边，只不过填充的区域不重叠绘制的区域即使单独，填充路径笔宽。  
  
##  <a name="strokepath"></a>CDC::StrokePath  
 通过使用当前的钢笔呈现指定的路径。  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 设备上下文必须包含已关闭的路径。  
  
##  <a name="tabbedtextout"></a>CDC::TabbedTextOut  
 调用此成员函数以编写中将选项卡扩展到指定的制表位位置数组中的值的指定位置的字符字符串。  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定字符串的起始点的逻辑 x 坐标。  
  
 *y*  
 指定字符串的起始点的逻辑 y 坐标。  
  
 `lpszString`  
 指向要绘制的字符串。 可以将任一指针传递给字符的数组或[CString](../../atl-mfc-shared/reference/cstringt-class.md)为此参数的对象。  
  
 `nCount`  
 指定字符串中的字符数。 如果`nCount`为-1，计算长度。  
  
 `nTabPositions`  
 制表位位置的数组中指定的值的数目。  
  
 `lpnTabStopPositions`  
 指向数组，其中包含的制表位位置 （以逻辑单位）。 必须按升序排列; 排序的制表位最小 x 值应为数组中的第一个项目。  
  
 `nTabOrigin`  
 指定从其选项卡展开 （以逻辑单位） 的起始位置的 x 坐标。  
  
 `str`  
 A`CString`对象，其中包含指定的字符。  
  
### <a name="return-value"></a>返回值  
 尺寸 （以逻辑单位） 字符串作为`CSize`对象。  
  
### <a name="remarks"></a>备注  
 文本编写当前选定的字体。 如果`nTabPositions`为 0 和`lpnTabStopPositions`是**NULL**，选项卡扩展到八倍的平均字符宽度。  
  
 如果`nTabPositions`为 1，选项卡中的第一个值指定的距离用分隔停止`lpnTabStopPositions`数组。 如果`lpnTabStopPositions`数组包含多个值，为每个值在数组中，最多指定的数设置制表位`nTabPositions`。 `nTabOrigin`参数允许应用程序调用`TabbedTextOut`几次为单个行的函数。 使用组件时应用程序如果不止一次调用该函数`nTabOrigin`设置相同的值为每个时间，该函数将扩展相对于指定位置的所有选项卡`nTabOrigin`。  
  
 默认情况下，函数不使用或更新当前位置。 如果应用程序需要更新当前的位置，在它调用该函数时，应用程序可以调用[SetTextAlign](#settextalign)成员函数时`nFlags`设置为**TA_UPDATECP**。 当设置此标志时，Windows 将忽略*x*和*y*对后续调用的参数`TabbedTextOut`，改为使用当前的位置。  
  
##  <a name="textout"></a>CDC::TextOut  
 使用当前选定的字体在指定位置写入字符串。  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>参数  
 *x*  
 指定文本起点的逻辑 x 坐标。  
  
 *y*  
 指定文本起点的逻辑 y 坐标。  
  
 `lpszString`  
 指向要绘制的字符串。  
  
 `nCount`  
 指定字符串中的字符数。  
  
 `str`  
 包含要绘制的字符的 `CString` 对象。  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 字符原点位于字符单元格的左上角。 默认情况下，函数不使用或更新当前位置。  
  
 如果应用程序需要更新当前位置，当它调用`TextOut`，应用程序可以调用`SetTextAlign`成员函数时`nFlags`设置为**TA_UPDATECP**。 当设置此标志时，Windows 将忽略*x*和*y*对后续调用的参数`TextOut`，改为使用当前的位置。  
  
### <a name="example"></a>示例  
  请参阅示例[cdc:: beginpath](#beginpath)。  
  
##  <a name="transparentblt"></a>CDC::TransparentBlt  
 调用此成员函数以传输到目标设备上下文从指定的源设备上下文中，对应于像素组成的矩形的颜色数据位块。  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>参数  
 `xDest`  
 指定逻辑单位，目标矩形的左上角的 x 坐标。  
  
 `yDest`  
 指定逻辑单位，目标矩形的左上角的 y 坐标。  
  
 `nDestWidth`  
 指定的宽度，以逻辑单元，目标矩形。  
  
 `nDestHeight`  
 指定逻辑单位，目标矩形的高度。  
  
 `pSrcDC`  
 指向源设备上下文的指针。  
  
 `xSrc`  
 指定逻辑单位，源矩形的 x 坐标。  
  
 `ySrc`  
 指定的 y 坐标，逻辑单位，源矩形。  
  
 `nSrcWidth`  
 指定逻辑单位，源矩形的宽度。  
  
 `nSrcHeight`  
 指定逻辑单位，源矩形的高度。  
  
 `clrTransparent`  
 中要被视为透明的源位图的 RGB 颜色。  
  
### <a name="return-value"></a>返回值  
 **TRUE**如果成功，否则为**FALSE**。  
  
### <a name="remarks"></a>备注  
 `TransparentBlt`允许对透明度;代表 RGB 颜色，即由`clrTransparent`呈现透明的传输。  
  
 有关详细信息，请参阅[TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="updatecolors"></a>CDC::UpdateColors  
 更新在客户端区域中的按像素基于系统调色板颜色通过匹配当前的设备上下文的工作区。  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>备注  
 使用已实现的逻辑调色板非活动窗口可能调用`UpdateColors`作为系统调色板发生更改时重绘其工作区的替代方法。  
  
 有关使用调色板的详细信息，请参阅[UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `UpdateColors`成员函数通常比重绘区域的更快地更新的工作区。 但是，因为函数执行之前系统调色板更改基于每个像素的颜色的颜色转换，每次调用此函数会导致某些颜色准确性丢失。  
  
##  <a name="widenpath"></a>CDC::WidenPath  
 将当前路径重新定义为将如果路径已描边使用实际选入设备上下文的钢笔绘制区域。  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>返回值  
 如果该函数成功，则为非 0；否则为 0。  
  
### <a name="remarks"></a>备注  
 此函数是仅当当前的钢笔为几何钢笔由第二个版本的创建成功`CreatePen`成员函数，或如果使用的第一个版本创建钢笔`CreatePen`和宽度，都采用大于 1 设备单位。 设备上下文必须包含已关闭的路径。 在路径中的任何 Bzier 曲线将转换为直线估算扩大的曲线的序列。 在这种情况下，没有 Bzier 曲线保持后的路径`WidenPath`调用。  
  
## <a name="see-also"></a>另请参阅  
 [CObject 类](../../mfc/reference/cobject-class.md)   
 [层次结构图](../../mfc/hierarchy-chart.md)   
 [CPaintDC 类](../../mfc/reference/cpaintdc-class.md)   
 [CWindowDC 类](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC 类](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC 类](../../mfc/reference/cmetafiledc-class.md)

