---
title: ARM64 ABI 约定概述
ms.date: 07/11/2018
ms.openlocfilehash: c5c928dcb77729f5b79433d3be1b552664a0d211
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/31/2018
ms.locfileid: "50599779"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 约定概述

基本的 ABI 为 Windows 编译时和运行在 64 位模式下 （ARMv8 或更高版本的体系结构），在多数情况下，为 ARM 处理器上遵循 ARM 的标准 AArch64 EABI。 本文重点介绍的一些关键的假设和从 EABI 中记录了哪些更改。 32 位 ABI 有关的信息，请参阅[概述的 ARM ABI 约定](overview-of-arm-abi-conventions.md)。 有关标准 ARM EABI 的详细信息，请参阅[应用程序二进制接口 (ABI) 的 ARM 体系结构](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html)（外部链接）。

## <a name="definitions"></a>定义

随着 64 位支持，ARM 定义多个词：

- **AArch32** – 旧的 32 位指令集体系结构 (ISA) 由 ARM，包括 Thumb 模式下执行。
- **AArch64** – 新的 64 位指令集体系结构 (ISA) 由 ARM 定义。
- **ARMv7** –"第 7 个代"的规范 ARM 硬件，只包括对 AArch32 的支持。 这是 ARM 的 Windows 的第一个版本支持的 ARM 硬件的版本。
- **ARMv8** –"第 8 个代"的规范包括支持 AArch32 和 AArch64 的 ARM 硬件。

除了这些定义，在 Windows 中我们使用这些术语：

- **ARM** – 指的是 32 位 ARM 体系结构 (AArch32)。 这有时称为 WoA (在 ARM 上 Windows)。
- **ARM32** – 相同 ARM，上述; 为清楚起见本文档中使用。
- **ARM64** – 指的是 64 位 ARM 体系结构 (AArch64)。 WoA64 没有此类的内容。

最后，如果为数据类型的引用，引用 ARM 中的以下定义：

- **短矢量**– 这是直接在 SIMD 可表示的数据类型，即 8 或 16 字节积累的元素，其大小 （8 或 16 个字节） 对齐其中的每个元素可以是 1、 2、 4 或 8 个字节的矢量
- **HFA （同构浮点聚合）** – 这是使用 2-4 完全相同的浮点型成员 （浮点数或双精度型值） 的数据类型
- **HVA （同构的短矢量聚合）** – 这是与 2-4 相同短矢量成员的数据类型

## <a name="base-requirements"></a>基本要求

上 ARMv8 运行或在任何时候都更高版本的体系结构，前提是 Windows 的 ARM64 版本。 同时浮点和 NEON 支持都假定为会在硬件中提供。

尽管 AArch32 应用程序的完全支持 ARMv8 规范允许，但目前没有计划支持 ARM64 版本的 Windows （即，没有计划 WOW64） 上运行现有 ARM32 应用程序。 这要取决于重新评估以后，但它是当前的工作假设。

ARMv8 规范 AArch32 和 AArch64 介绍新的可选加密和 CRC 帮助程序操作码。 支持这些是当前可选的但建议这样做。 希望充分利用这些操作代码的代码应执行的运行时检查其存在。

## <a name="endianness"></a>字节排序方式

作为与 ARM32 版本的 Windows，ARM64 Windows 上执行在 little-endian 模式下。 切换字节排序方式很难实现，而内核模式下支持 AArch64，在不是更轻松地强制执行。

## <a name="alignment"></a>对齐方式

在 ARM64 上运行的 Windows 使 CPU 硬件来以透明方式处理未对齐的访问。 从 AArch32 提高了，这种支持现在还适用于所有整数访问 （包括多个单词访问） 以及浮点访问。

但是，对未缓存 （设备） 内存访问仍必须始终对齐。 这意味着，如果没有代码可以调用时读取/写入未对齐的数据从非缓存的内存，则必须播放该文件用于操作安全，并确保所有访问都对齐。

## <a name="integer-registers"></a>整数寄存器

AArch64 体系结构支持 32 整数寄存器，总结如下：

|寄存器|是否易失？|角色|
|-|-|-|
x0|易失的|参数/从头开始注册 1、 结果寄存器
x1 x7|易失的|参数/从头开始注册 2-8
x8 x15|易失的|临时寄存器
x16 x17|易失的|内部过程调用临时寄存器
x18|非易失性的|平台注册： 在内核模式下，指向 KPCR 当前处理器;在用户模式下，指向 TEB
x19 x28|非易失性的|临时寄存器
x29/fp|非易失性的|帧指针
x30/lr|非易失性的|链接寄存器

作为完整的 64 位值 （通过 x0 x30) 或 32 位值 （通过 w0 w30)，可以访问每个注册。 32 位操作零扩展其结果最多 64 位。

请参阅使用参数寄存器中传递部分了解详细信息的参数。

请注意，与 AArch32，在电脑和 SP 不是索引的寄存器，因此受限的可能访问它们的方式。 此外请注意，没有任何 x31 注册 （即出于特殊目的使用编码）。

ETW 和其他服务使用的与加快堆栈审核的兼容性需要使用帧指针 (x29)。 它必须指向上一个 {x29，x 30} 对在堆栈上的。

## <a name="floating-pointsimd-registers"></a>浮点 point/SIMD 寄存器

AArch64 体系结构还支持 32 point 浮点/SIMD 寄存器，总结如下：

寄存器|是否易失？|角色
|-|-|-|
v0|易失的|参数/从头开始注册 1、 结果寄存器
v1 v7|易失的|参数/从头开始注册 2-8
v8 v15|非易失性的|Scratch 寄存器 （请注意，仅的低 64 位均为非易失性）
v16 v31|易失的|临时寄存器

每个注册可能会作为一个完整 128 位值 （通过 v0 v31 或 q0 q31） 作为 64 位值 （通过 d0-d31) 作为 32 位值 （通过 s0-s31) 作为 16 位值 （通过 h0-h31)，或作为 8 位值 （通过 b0 b31) 访问。 访问小于 128 位访问仅低位的完整的 128 位寄存器，并将剩余的位保留不变，除非另行指定。 （请注意，这是明显不同于 AArch32，其中的较小的寄存器已打包在较大的寄存器之上）。

除了数据寄存器，浮点控制寄存器 (FPCR) 中各种的位域上有某些要求：

Bits|含义|是否易失？|角色
|-|-|-|-|
26|AHP|非易失性|备选半精度控制
25|DN|非易失性|默认 NaN 模式控制
24|FZ|非易失性的|清零模式控制
23-22|RMode|非易失性的|舍入模式控制
15,12 8|IDE/IXE 等|非易失性|异常捕获启用位，必须始终为 0

## <a name="system-registers"></a>系统寄存器

如 AArch32，AArch64 规范提供了三个系统控制"的线程 ID"寄存器是使用/分配，如下所示：

寄存器|角色
|-|-|
TPIDR_EL0|保留
TPIDRRO_EL0|包含当前处理器的 CPU 数
TPIDR_EL1|指向当前处理器的 KPCR 结构

## <a name="floating-point-exceptions"></a>浮点异常

为 IEEE 浮点异常的支持取决于您在 AArch64 的系统上。 有关处理器有硬件浮点异常的变体，Windows 内核以无提示方式将捕获的异常和隐式禁用 FPCR 寄存器中。 这是为了确保在处理器变量之间的规范化的行为 （否则，代码开发的平台上不支持异常可能会发现本身支持的平台上运行时执行意外的异常）。

## <a name="parameter-passing"></a>参数传递

对于非可变参数函数，Windows ABI 将遵循由 ARM 传递的参数所指定的规则。 这些规则是直接从过程调用标准摘录 AArch64 体系结构：

### <a name="stage-a--initialization"></a>阶段 A-初始化

自变量处理开始之前，一次执行此阶段。

1. 下一步常规用途注册数 (NGRN) 设置为零。

1. 下一步单指令多数据和浮点注册数 (NSRN) 设置为零。

1. 下一个堆叠自变量地址 (NSAA) 设置为当前的堆栈指针值 (SP)。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>阶段 B-预填充和扩展的参数

对于每个自变量列表中应用以下列表中的第一个匹配规则。 如果使用此参数以未修改形式没有规则匹配。

1. 其大小不能由调用方和被调用方静态确定的复合类型的参数类型时，将参数复制到内存和自变量替换为指向该副本的指针。 （C/c + + 中不存在此类类型，但它们存在于其他语言或语言扩展中）。

1. 如果自变量类型是 HFA 或有关 HVA，则使用此参数未修改。

1. 大于 16 个字节的复合类型的参数类型时，参数复制到由调用方分配的内存，并指向该副本的指针替换为参数。

1. 如果参数类型为复合类型然后自变量的大小舍入为最接近的 8 个字节的倍数。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>阶段 C-自变量分配给寄存器和堆栈

对于列表中的每个参数在分配参数之前依次应用以下规则。 如果自变量分配给寄存器在寄存器中的任何未使用的位具有未指定的值。 自变量分配到堆栈槽时任何未使用的填充字节具有未指定的值。

1. 如果参数为半-，单、 双精度或四核精度浮点或短向量类型和 NSRN 则小于 8，自变量分配到寄存器 v [NSRN] 的最低有效位。 NSRN 就会递增 1。 现在已分配参数。

1. 如果参数为 HFA 或有关 HVA 并且有足够的未分配的 SIMD 和浮点寄存器 （NSRN + 数成员 ≤ 8），然后该参数已分配给单指令多数据和浮点寄存器 （与每个成员的 HFA 或 HVA 一个寄存器）。 NSRN 加使用的寄存器的数量。 现在已分配参数。

1. 如果参数为 HFA 或有关 HVA NSRN 设置为 8，和自变量的大小向上舍入到最接近的 8 个字节的倍数。

1. 如果参数为 HFA HVA 四精度浮点或短向量类型则 NSAA 舍入到较大的 8 或参数的类型的自然对齐方式。

1. 如果参数为半或单精度浮点类型，则会将自变量的大小设置为 8 个字节。 效果如同自变量具有已复制到 64 位寄存器的最低有效位和使用未指定值填充剩余的位。

1. 如果参数为 HFA，有关 HVA 后, 半部分-，单、 双-或四精度浮点或短矢量类型，然后自变量将复制到内存中的调整后的 nsaa 处。 NSAA 按自变量的大小递增。 现在已分配参数。

1. 如果参数为整型或指针类型，自变量的大小将为小于或等于 8 个字节且 NGRN 为小于 8，自变量复制到 x [NGRN] 中的最低有效位。 NGRN 就会递增 1。 现在已分配参数。

1. 如果自变量具有 16 的对齐方式然后 NGRN 舍入为下一个偶数。

1. 如果参数是一种整型类型、 自变量的大小等于 16 和 NGRN 为不超过 7，将参数复制到 x [NGRN] x [NGRN + 1]。 x [NGRN] 应包含较低寻址的双字的自变量的内存表示形式。 NGRN 加两个。 现在已分配参数。

1. 如果参数为复合类型和双字自变量的大小不超过 8 减去 NGRN，则自变量复制到连续的通用寄存器，x [NGRN] 处开始。 像具有已加载到从双字对齐地址与相应序列的 LDR 指令从内存加载连续寄存器 （寄存器的任何未使用部分的内容是未指定寄存器传递的参数通过此标准）。 NGRN 加使用的寄存器的数量。 现在已分配参数。

1. NGRN 设置为 8。

1. NSAA 向上舍入到较大的 8 或参数的类型的自然对齐方式...

1. 如果参数为复合类型则会将参数复制到内存中的调整后的 nsaa 处。 NSAA 按自变量的大小递增。 现在已分配参数。

1. 如果自变量的大小小于 8 个字节到 8 个字节设置自变量的大小。 其效果是像参数已复制到 64 位寄存器的最低有效位和使用未指定值填充剩余的位。

1. 自变量复制到内存中的调整后的 nsaa 处。 NSAA 按自变量的大小递增。 现在已分配参数。

### <a name="addendum-variadic-functions"></a>附录： 可变参数函数

采用可变数量的参数的函数的处理方式不同于更高版本，按如下所示：

1. 所有复合字符将被视为相似;HFAs hva 的任何特殊处理。

1. 不使用单指令多数据和浮点寄存器。

实际上，这相当于以下规则 C.12–C.15 分配虚部堆栈，其中第一个 64 个字节的堆栈被加载到 x0-x7，通常情况下放置任何剩余的 stack 参数的参数。

## <a name="return-values"></a>返回值

X0 中返回整数值。 浮点值 s0/d0/v0 根据形式返回。

返回按值不能通过寄存器传递的对于调用方应保留足够的大小和对齐方式为保存结果的内存块。 内存块的地址应该传递作为附加参数到 x8 POD 类型，或在 x0 （或如果 $这传入 x0 x1） 中的函数的非 POD 类型。 被调用方可能会在子例程 （不存在也 x0 必须不要求被调用方保留 x8 中, 存储的值而非 POD，此缓冲区的地址返回由被调用方） 的执行期间修改任意点处的结果内存块。

## <a name="stack"></a>堆栈

以下利 ARM ABI，堆栈必须保持为 16 字节对齐在所有时间。 AArch64 包含生成错误时执行的 SP 相对负载或应用商店和 SP 不是 16 字节对齐的堆栈对齐的硬件功能。 在任何时候启用此功能在运行 Windows。

分配 4k 或多个值得堆栈的函数必须确保按顺序访问的最后一页之前每个页时，从而确保没有代码可以"跳过"Windows 用于展开堆栈的受保护页。 通常这是通过`__chkstk`帮助器，具有将按 16 个 in x8 划分的总堆栈分配的自定义调用约定。

## <a name="red-zone"></a>红色区域

立即在当前的堆栈指针下方的 16 字节区域是保留供分析和动态修补方案。 这允许小心地生成的代码要插入它存储在 2 个寄存器 [sp，# 16] 并临时将其用于任意目的。 Windows 内核保证如果异常或中断执行，在用户和内核模式下不会覆盖这些 16 个字节。

## <a name="kernel-stack"></a>内核堆栈

在 Windows 中的默认内核模式堆栈是六页 (24 k)。 在内核模式下应特别小心于带大堆栈缓冲区的函数。 适时中断无法提供很少的空余空间，并创建堆栈应急 bugcheck。

## <a name="stack-walking"></a>堆栈审核

Windows 中的代码编译的启用帧指针 ([/Oy-](../build/reference/oy-frame-pointer-omission.md)) 以实现快速审核堆栈。 此结论就是 x29 (fp) 通常指向链是 {fp，lr} 中的下一个链接对，该值指示在前一个帧上堆栈和寄信人地址的指针。 鼓励第三方代码，以便改进分析和跟踪也启用帧指针。

## <a name="exception-unwinding"></a>异常展开

在处理异常时展开被辅助通过使用展开代码。 展开代码是一系列字节存储在可执行文件的.xdata 部分以抽象方式描述序言和尾声的操作，以便可以在准备备份到撤消函数序言的效果调用方的堆栈帧。 展开代码的详细信息，请参阅[ARM64 异常处理](arm64-exception-handling.md)。

ARM EABI 还指定了利用展开代码的异常展开模式。 但是，规范介绍不足以在 Windows，必须处理序言或尾声中间的一个函数的 PC 的情况下展开。

动态生成的代码应通过的动态函数表所述`RtlAddFunctionTable`以及关联函数，以便生成的代码可以参与异常处理。

## <a name="cycle-counter"></a>时钟周期计数器

支持循环所需的所有 ARMv8 Cpu 计数器寄存器。 这是 Windows 配置为可读的任何级别的异常 （包括用户模式） 的 64 位寄存器。 它可以通过特殊 PMCCNTR_EL0 访问程序集代码中使用 MSR 操作码的注册或`_ReadStatusReg`C/c + + 代码中内部函数。

请注意，此处时钟周期计数器真循环计数器，不时钟，并因此计数频率会因处理器的频率。 如果您认为您必须知道的时钟周期计数器的频率，您不应使用循环计数器。 相反，你想要测量时钟时间，应使用`QueryPerformanceCounter`。

## <a name="see-also"></a>请参阅

[Visual C++ ARM 迁移的常见问题](../build/common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 异常处理](../build/arm64-exception-handling.md)
