---
title: ARM64 ABI 约定概述
ms.date: 03/27/2019
ms.openlocfilehash: 07d58bbd64795235ad63a7b26b6f18fcffdcd1d2
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303266"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 约定概述

用于 Windows 的基本应用程序二进制接口（ABI）在64位模式（ARMv8 或更高版本体系结构）中编译和运行时，在大多数情况下都遵循 ARM 的标准 AArch64 EABI。 本文重点介绍了 EABI 中所述的一些主要假设和更改。 有关32位 ABI 的信息，请参阅[ARM abi 约定概述](overview-of-arm-abi-conventions.md)。 有关标准 ARM EABI 的详细信息，请参阅[ARM 体系结构的应用程序二进制接口（ABI）](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) （外部链接）。

## <a name="definitions"></a>定义

由于引入了64位支持，ARM 定义了若干术语：

- **AArch32** – ARM 定义的旧式32位指令集体系结构（ISA），包括 Thumb 模式执行。
- **AArch64** – ARM 定义的新64位指令集体系结构（ISA）。
- **ARMv7** – "第7代" ARM 硬件的规范，只包括对 AArch32 的支持。 此版本的 ARM 硬件是支持 ARM 的第一个版本 Windows。
- **ARMv8** – "8 代" ARM 硬件的规范，其中包括对 AArch32 和 AArch64 的支持。

Windows 也使用以下术语：

- **ARM** –是指32位 ARM 体系结构（AArch32），有时称为 WOA （ARM 上的 Windows）。
- **ARM32** –与 ARM 相同;为清楚起见，在此文档中使用。
- **ARM64** –是指64位 ARM 体系结构（AArch64）。 没有 WoA64。

最后，引用数据类型时，将引用 ARM 中的以下定义：

- **Short 向量**–一种数据类型，可直接在 SIMD 中表示，即8字节的向量或16字节的元素。 它与大小（8字节或16字节）对齐，其中每个元素可以为1、2、4或8字节。
- **HFA （同类浮点聚合）** –一种数据类型，具有2到4个相同的浮点成员（浮动或双精度型）。
- **HVA （同类简短矢量聚合）** -一种数据类型，具有2到4个相同的短矢量成员。

## <a name="base-requirements"></a>基本要求

Windows 当然的 ARM64 版本始终在 ARMv8 或更高版本的体系结构上运行。 假设在硬件中存在浮点和霓虹灯式支持。

ARMv8 规范描述了 AArch32 和 AArch64 的新可选加密和 CRC 帮助程序操作码。 对它们的支持当前是可选的，但建议这样做。 若要利用这些操作码，应用程序应该首先对其存在进行运行时检查。

## <a name="endianness"></a>字节排序方式

与 Windows 的 ARM32 版本一样，在 ARM64 Windows 上以小字节序模式执行。 如果未在 AArch64 中支持内核模式，则切换 endian 是很难实现的，因此更易于强制执行。

## <a name="alignment"></a>对齐

在 ARM64 上运行的 Windows 使得 CPU 硬件可以透明地处理未对齐的访问。 从 AArch32 的改进，这一支持现在也适用于所有整数访问（包括多单词访问）和浮点访问。

但是，对非缓存（设备）内存的访问仍必须始终对齐。 如果代码可能在未缓存的内存中读取或写入未对齐的数据，则必须确保对齐所有访问。

局部变量的默认布局对齐方式：

| 大小(字节) | 对齐方式（字节） |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3、4 | 4 |
| > 4 | 8 |

全局和静态静态的默认布局对齐方式：

| 大小(字节) | 对齐方式（字节） |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| > = 64 | 16 |

## <a name="integer-registers"></a>整数寄存器

AArch64 体系结构支持32整数寄存器：

| 注册 | 是否易失？ | 角色 |
| - | - | - |
| x0 | Volatile | 参数/暂存注册1，结果注册 |
| x1-x7 | Volatile | 参数/暂存注册2-8 |
| x8-x15 | Volatile | 暂存寄存器 |
| x16-x17 | Volatile | 过程内调用暂存注册 |
| x18 | 非易失性的 | 平台注册：在内核模式下，指向当前处理器的 KPCR;在用户模式下，指向 TEB |
| x19-x28 | 非易失性的 | 暂存寄存器 |
| x29/fp | 非易失性的 | 帧指针 |
| x30/lr | 非易失性的 | 链接寄存器 |

可以将每个寄存器作为完整64位值（通过 x0-x30）或32位值（通过 w0-w30）进行访问。 32位操作将结果扩大到64位。

有关参数寄存器使用的详细信息，请参阅参数传递部分。

与 AArch32 不同，程序计数器（PC）和堆栈指针（SP）不是索引的寄存器。 它们的访问方式受到限制。 另请注意，没有 x31 注册。 该编码用于特殊目的。

与 ETW 和其他服务使用的快速堆栈遍历兼容需要帧指针（x29）。 它必须指向堆栈上的前 {x29，x30} 配对。

## <a name="floating-pointsimd-registers"></a>浮点/SIMD 寄存器

AArch64 体系结构还支持32浮点/SIMD 寄存器，如下所示：

| 注册 | 是否易失？ | 角色 |
| - | - | - |
| v0 | Volatile | 参数/暂存注册1，结果注册 |
| v1-v7 | Volatile | 参数/暂存寄存器2-8 |
| v8-v15 | 非易失性的 | 暂存寄存器（仅低64位为非易失性） |
| v16-v31 | Volatile | 暂存寄存器 |

每个注册都可以作为完整的128位值（通过 v0-v31 或 q0-q31）进行访问。 它可作为64位值（通过 d31）进行访问，作为32位值（通过 s31）、16位值（通过 h0-h31）或作为8位值（通过 b0-b31）进行访问。 小于128位的访问仅访问完整128位寄存器的下限。 除非另有指定，否则它们保持不变。 （AArch64 与 AArch32 不同，其中较小寄存器在较大寄存器的顶层打包。）

浮点控制寄存器（FPCR）对其中的各种位域具有特定要求：

| Bits | 含义 | 是否易失？ | 角色 |
| - | - | - | - |
| 26 | AHP | 非易失性 | 备用半角控件。 |
| 25 | DN | 非易失性 | 默认 NaN 模式控件。 |
| 24 | FZ | 非易失性的 | 刷新到零模式控件。 |
| 23-22 | RMode | 非易失性的 | 舍入模式控件。 |
| 15,12-8 | IDE/IXE/等 | 非易失性 | 异常陷阱启用位，必须始终为0。 |

## <a name="system-registers"></a>系统寄存器

与 AArch32 一样，AArch64 规范提供三个系统控制的 "线程 ID" 寄存器：

| 注册 | 角色 |
| - | - |
| TPIDR_EL0 | 保留。 |
| TPIDRRO_EL0 | 包含当前处理器的 CPU 号。 |
| TPIDR_EL1 | 指向当前处理器的 KPCR 结构。 |

## <a name="floating-point-exceptions"></a>浮点异常

在 AArch64 系统上，对 IEEE 浮点异常的支持是可选的。 对于具有硬件浮点异常的处理器变体，Windows 内核会悄悄地捕获异常并在 FPCR 注册中隐式禁用它们。 此陷阱可确保跨处理器变体的标准行为。 否则，在支持的平台上运行时，不支持异常的平台上开发的代码可能会遇到意外异常。

## <a name="parameter-passing"></a>参数传递

对于非可变参数函数，Windows ABI 遵循 ARM 指定的用于参数传递的规则。 这些规则直接从 AArch64 体系结构的过程调用标准中摘录内容：

### <a name="stage-a--initialization"></a>阶段 A –初始化

此阶段只是一次完成，然后处理自变量。

1. 下一个通用寄存器号（NGRN）设置为零。

1. 下一个 SIMD 和浮点寄存器号（NSRN）设置为零。

1. 下一个堆积参数地址（NSAA）设置为当前堆栈指针值（SP）。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>阶段 B –自变量的预填充和扩展

对于列表中的每个参数，应用以下列表中的第一个匹配规则。 如果没有匹配的规则，则使用未修改的参数。

1. 如果参数类型为其大小不能由调用方和被调用方静态确定的复合类型，则将参数复制到内存中，并将参数替换为指向副本的指针。 （C/C++中没有此类类型，但它们存在于其他语言或语言扩展中）。

1. 如果参数类型为 HFA 或 HVA，则使用未修改的参数。

1. 如果参数类型为大于16个字节的复合类型，则该参数将被复制到由调用方分配的内存中，并且该参数将替换为指向副本的指针。

1. 如果参数类型为复合类型，则将参数的大小向上舍入到最接近的8个字节。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>阶段 C-将参数分配给寄存器和堆栈

对于列表中的每个自变量，将依次应用以下规则，直到分配自变量。 将自变量分配给寄存器时，寄存器中任何未使用的位都有未指定的值。 如果将自变量分配给堆栈槽，则任何未使用的填充字节都具有未指定的值。

1. 如果参数为半、单精度、双精度或四精度浮点数或短矢量类型，并且 NSRN 小于8，则会将参数分配给寄存器 v\[NSRN] 的最小有效位。 NSRN 递增1。 自变量现在已分配。

1. 如果参数是 HFA 或 HVA，且有足够的未分配 SIMD 和浮点寄存器（NSRN + 成员≤8），则会将参数分配给 SIMD 和浮点寄存器，每个 HFA 或 HVA 成员一个寄存器。 NSRN 按所用寄存器的数量递增。 自变量现在已分配。

1. 如果参数是 HFA 或 HVA，则 NSRN 设置为8，并且参数的大小向上舍入到最接近的8个字节。

1. 如果参数是 HFA、HVA、四精度浮点或小矢量类型，则将 NSAA 向上舍入为较大的8，或参数类型的自然对齐。

1. 如果参数为半精度或单精度浮点类型，则将参数的大小设置为8个字节。 其效果就好像该参数已复制到64位寄存器的最小有效位，并且剩余的位用未指定的值填充。

1. 如果参数是 HFA、HVA、半精度、单精度、双精度或四精度浮点数或小矢量类型，则将参数复制到已调整的 NSAA 上的内存。 NSAA 按参数的大小递增。 自变量现在已分配。

1. 如果参数为整型或指针类型，则参数的大小小于或等于8个字节，并且 NGRN 小于8，则将参数复制到 x\[NGRN] 中的最小有效位。 NGRN 递增1。 自变量现在已分配。

1. 如果参数的对齐方式为16，则将 NGRN 向上舍入到下一个偶数。

1. 如果自变量是整型类型，则该参数的大小等于16，并且 NGRN 小于7，参数将复制到 x\[NGRN] 和 x\[NGRN + 1]。 x\[NGRN] 应包含参数的内存表示形式的较低字符。 NGRN 递增2。 自变量现在已分配。

1. 如果该参数是一个复合类型，并且该参数的双字中的大小不超过8个减号 NGRN，则该参数将被复制到连续的通用寄存器中，从 x\[NGRN] 开始。 参数的传递方式与双字对齐地址的加载到寄存器中的参数相同，并具有一系列从内存中加载连续寄存器的适当的 LDR 指令。 此标准不指定寄存器的任何未使用部分的内容。 NGRN 按所用寄存器的数量递增。 自变量现在已分配。

1. NGRN 设置为8。

1. NSAA 向上舍入为较大的8，或自变量类型的自然对齐。

1. 如果该参数是一个复合类型，则该参数将复制到调整后的 NSAA 中的内存。 NSAA 按参数的大小递增。 自变量现在已分配。

1. 如果参数的大小小于8个字节，则将参数的大小设置为8个字节。 其效果就好像将自变量复制到64位寄存器的最小有效位，并且剩余的位用未指定的值填充。

1. 自变量将复制到调整后的 NSAA 中的内存。 NSAA 按参数的大小递增。 自变量现在已分配。

### <a name="addendum-variadic-functions"></a>附录：可变参数函数

采用可变数量的参数的函数的处理方式不同于以上，如下所示：

1. 所有复合都视为相同;没有对 HFAs 或 Hva 的特殊处理。

1. 不使用 SIMD 和浮点寄存器。

实际上，它与下面的规则 C. 12-C （）相同，可将自变量分配给虚部堆栈，其中，堆栈的前64字节将加载到 x 7 中，并且所有剩余的堆栈参数将正常放置。

## <a name="return-values"></a>返回值

在 x0 中返回整数值。

在适当的情况下，将在 s0、d0 或 v0 中返回浮点值。

HFA 和 HVA 值将根据需要返回到 s0-s3、d0-d3 或 v0。

通过值返回的类型的处理方式取决于它们是否具有某些属性。 具有所有这些属性的类型，

- 它们是由 c + + 14 标准定义*聚合*的，也就是说，它们没有用户提供的构造函数，没有私有或受保护的非静态数据成员，没有基类，也没有虚函数，
- 它们具有普通的复制赋值运算符，
- 它们具有普通析构函数，

使用以下返回样式：

- 小于或等于8字节的类型在 x0 中返回。
- 小于或等于16字节的类型在 x0 和 x1 中返回，其中的 x0 包含低序位8字节。
- 对于大于16个字节的类型，调用方应保留具有足够大小和对齐方式的内存块来保存结果。 内存块的地址应作为附加参数传递到 x8 中的函数。 调用方可能会在执行子例程的任何时间点修改结果内存块。 被调用方不需要保留存储在 x8 中的值。

所有其他类型均使用此约定：

- 调用方应保留足够大小的内存块并调整其大小以容纳结果。 内存块的地址应作为额外的参数传递给 x0 中的函数，如果 $this 传入 x0，则为 x1。 调用方可能会在执行子例程的任何时间点修改结果内存块。 被调用方返回了 x0 中内存块的地址。

## <a name="stack"></a>堆栈

在 ARM 后面的 ABI 后面，堆栈必须始终保持16字节的对齐状态。 AArch64 包含一项硬件功能，该功能可在 SP 不是16个字节且已完成 SP 相关的加载或存储时生成堆栈对齐错误。 Windows 运行时始终启用此功能。

分配4k 或更多的堆栈的函数必须确保最终页面之前的每页都按顺序排列。 此操作可确保任何代码都不能 "leap" Windows 用于展开堆栈的防护页。 通常，接触由 `__chkstk` 帮助器来完成，该 helper 具有一个自定义调用约定，该约定将总堆栈分配除以16（在 x15 中）。

## <a name="red-zone"></a>红色区域

当前堆栈指针下方的16字节区域保留供分析和动态修补方案使用。 此区域允许在 [sp，#-16] 上插入存储两个寄存器的精心生成的代码，并暂时将其用于任意目的。 Windows 内核保证在用户和内核模式下发生异常或中断时，不会覆盖这些16个字节。

## <a name="kernel-stack"></a>内核堆栈

Windows 中的默认内核模式堆栈是六个页面（24k）。 请特别注意内核模式下具有大型堆栈缓冲区的函数。 错误计时中断可能会产生较少的空间，并创建堆栈死机 bug 检查。

## <a name="stack-walking"></a>堆栈遍历

Windows 中的代码在启用了帧指针的情况（[/Oy-](reference/oy-frame-pointer-omission.md)）中进行编译，以实现快速堆栈遍历。 通常，x29 （fp）指向链中的下一个链接，该链接为 {fp，lr} 对，指示指向堆栈上上一帧的指针和返回地址。 还建议使用第三方代码启用帧指针，以允许改进分析和跟踪。

## <a name="exception-unwinding"></a>异常展开

异常处理期间的展开通过使用展开代码进行。 展开代码是存储在可执行文件的 xdata 节中的字节序列。 它们以抽象的方式描述了序言和尾声的操作，以便可以撤消函数序言的效果，以便为备份到调用方的堆栈帧做好准备。 有关展开代码的详细信息，请参阅[ARM64 exception 处理](arm64-exception-handling.md)。

ARM EABI 还指定了使用展开代码的异常展开模型。 但是，在 Windows 中进行展开时所提供的规范不足，因为它必须处理 PC 处于函数序言或尾声中间的情况。

动态生成的代码应通过 `RtlAddFunctionTable` 和关联的函数在动态函数表中进行描述，以便生成的代码可以参与异常处理。

## <a name="cycle-counter"></a>循环计数器

所有 ARMv8 Cpu 都需要支持循环计数器寄存器，这是一个64位寄存器，Windows 可将其配置为可在任何异常级别读取，包括用户模式。 可以通过特殊 PMCCNTR_EL0 register，使用程序集代码中的 MSR 操作码或 C/C++ code 中的 `_ReadStatusReg` 内部，来访问它。

此处的循环计数器为 true 循环计数器，而不是时钟时钟。 计数频率将因处理器频率而异。 如果你认为必须知道周期计数器的频率，则不应使用周期计数器。 相反，你需要衡量时钟时间，你应该使用 `QueryPerformanceCounter`。

## <a name="see-also"></a>另请参阅

[Visual C++ ARM 迁移的常见问题](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 异常处理](arm64-exception-handling.md)
